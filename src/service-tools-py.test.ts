import { assertEquals } from "https://deno.land/std@0.208.0/assert/mod.ts";
import { router } from "./service.ts";
console.log(String(router)[0]); // so that {router} get loaded

const body = {
    "language": "python",
    "prompt": "\nnnFrom a youtube URL, get the video transcipt, and then write a haiku about with the LLMProcessor\n",
    "feedback": "",
    "tool_type": "shinkai",
    "tool_headers": "\nasync def shinkai_typescript_unsafe_processor(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for executing Node.js code. This is unsafe and should be used with extreme caution.\n\n    Args:\n        input: Dict[str, Any]:\n            package: str (required) - The package.json contents\n            code: str (required) - The TypeScript code to execute\n            parameters: Dict[str, Any] (required) - Parameters to pass to the code\n            config: Dict[str, Any] (required) - Configuration for the code execution\n\n    Returns:\n        Dict[str, Any]: {\n            stdout: str \n        }\n    \"\"\"\n    pass\nasync def shinkai_llm_map_reduce_processor(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for applying a prompt over a long text (longer than the context window of the LLM) using an AI LLM. \nThis can be used to process complex requests, text analysis, text matching, text generation, and any other AI LLM task. over long texts.\n\n    Args:\n        input: Dict[str, Any]:\n            prompt: str (required) - The prompt to apply over the data\n            data: str (required) - The data to process\n            tools: List[Any] (optional) - List of tools names or tool router keys to be used with the prompt\n\n    Returns:\n        Dict[str, Any]: {\n            response: str \n        }\n    \"\"\"\n    pass\nasync def shinkai_llm_prompt_processor(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for processing any prompt using an AI LLM. \nAnalyzing the input prompt and returning a string with the result of the prompt.\nThis can be used to process complex requests, text analysis, text matching, text generation, and any other AI LLM task.\n\n    Args:\n        input: Dict[str, Any]:\n            tools: List[Any] (optional) - List of tools names or tool router keys to be used with the prompt\n            prompt: str (required) - The prompt to process\n            format: str (required) - Response type. The only valid option is 'text'\n\n    Returns:\n        Dict[str, Any]: {\n            message: str \n        }\n    \"\"\"\n    pass\nasync def shinkai_sqlite_query_executor(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for executing a single SQL query on a specified database file. \nIf this tool is used, you need to create if not exists the tables used other queries.\nTable creation should always use 'CREATE TABLE IF NOT EXISTS'.\n\n-- Example table creation:\nCREATE TABLE IF NOT EXISTS table_name (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    field_1 TEXT NOT NULL,\n    field_2 DATETIME DEFAULT CURRENT_TIMESTAMP,\n    field_3 INTEGER,\n    field_4 TEXT\n);\n\n-- Example insert:\nINSERT INTO table_name (field_1, field_3, field_4) \n    VALUES ('value_1', 3, 'value_4')\n    ON CONFLICT(id) DO UPDATE SET field_1 = 'value_1', field_3 = 3, field_4 = 'value_4';\n;\n\n-- Example read:\nSELECT * FROM table_name WHERE field_2 > datetime('now', '-1 day');\nSELECT field_1, field_3 FROM table_name WHERE field_3 > 100 ORDER BY field_2 DESC LIMIT 10;\n\n    Args:\n        input: Dict[str, Any]:\n            params: List[Any] (optional) - The parameters to pass to the query\n            query: str (required) - The SQL query to execute\n\n    Returns:\n        Dict[str, Any]: {\n            result: Any \n            rowCount: float \n            rowsAffected: float \n            type: str \n        }\n    \"\"\"\n    pass\nasync def shinkai_process_embeddings(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for processing embeddings within a job scope. \nThis tool processes resources and generates embeddings using a specified mapping function.\n\nExample usage:\n- Provide a custom mapping function to transform resource content.\n- Process resources in chunks to optimize performance.\n- Collect and join processed embeddings for further analysis.\n\n    Args:\n        input: Dict[str, Any]:\n            map_function: str (optional) - The map function to use\n            prompt: str (required) - The prompt to use\n\n    Returns:\n        Dict[str, Any]: {\n            result: str \n            rowCount: float \n            rowsAffected: float \n            type: str \n        }\n    \"\"\"\n    pass\nasync def shinkai_tool_config_updater(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for updating the configuration of a tool. \nThis tool allows you to update config fields of a tool by providing the tool_router_key and config key-value pairs.\n\nExample usage:\n{\n    \"tool_router_key\": \"local:::deno_toolkit:::my_tool\",\n    \"config\": {\n            \"api_key\": \"some-api-key\",\n            \"api_secret\": \"some-api-secret\"\n    }\n}\n\n    Args:\n        input: Dict[str, Any]:\n            tool_router_key: str (required) - The tool_router_key of the tool to update\n            config: Dict[str, Any] (required) - Configuration key-value pairs to update\n\n    Returns:\n        Dict[str, Any]: {\n            message: str \n            success: bool \n        }\n    \"\"\"\n    pass\nasync def coinbase_balance_getter(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for getting the balance of a Coinbase wallet after restoring it\n\n    Args:\n        input: Dict[str, Any]:\n            walletId: str (optional) - Optional wallet ID to get balance for a specific wallet\n\n    Returns:\n        Dict[str, Any]: {\n            balances: Dict[str, Any] - Map of token symbols to their respective balances\n            message: str - Status message about the balance retrieval operation\n        }\n    \"\"\"\n    pass\nasync def x_twitter_post(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Function to post a tweet to Twitter.\n\n    Args:\n        input: Dict[str, Any]:\n            text: str (optional) - Message to post\n            imagePath: str (optional) - Path to the image to post\n\n    Returns:\n        Dict[str, Any]: {\n            data: str - The data returned by the Twitter API\n        }\n    \"\"\"\n    pass\nasync def math_expression_evaluator(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Parses and evaluates mathematical expressions. It’s a safer and more math-oriented alternative to using JavaScript’s eval function for mathematical expressions.\n\n    Args:\n        input: Dict[str, Any]:\n            expression: str (required) - The mathematical expression to evaluate (e.g., '2 + 2 * 3')\n\n    Returns:\n        Dict[str, Any]: {\n            result: str - The evaluated result of the mathematical expression\n        }\n    \"\"\"\n    pass\nasync def duck_duck_go_search(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Searches the DuckDuckGo search engine. Example result: [{\"title\": \"IMDb Top 250 Movies\", \"description\": \"Find out which <b>movies</b> are rated as the <b>best</b> <b>of</b> <b>all</b> <b>time</b> by IMDb users. See the list of 250 titles sorted by ranking, genre, year, and rating, and learn how the list is determined.\", \"url\": \"https://www.imdb.com/chart/top/\"}]\n\n    Args:\n        input: Dict[str, Any]:\n            message: str (required) - The search query to send to DuckDuckGo\n\n    Returns:\n        Dict[str, Any]: {\n            message: str - The search results from DuckDuckGo in JSON format, containing title, description, and URL for each result\n            puppeteer: bool - Whether the search was performed using Puppeteer\n        }\n    \"\"\"\n    pass\nasync def memory_management(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Handles memory storage and retrieval using a SQLite database.\n\n    Args:\n        input: Dict[str, Any]:\n            general_prompt: str (optional) - The general prompt for generating memories\n            specific_prompt: str (optional) - The specific prompt for generating memories\n            data: str (optional) - The data to process for memory management, if not provided, the tool will return existing memories\n            key: str (optional) - The key for specific memory retrieval\n\n    Returns:\n        Dict[str, Any]: {\n            generalMemory: str - The updated general memory\n            specificMemory: str - The updated specific memory\n        }\n    \"\"\"\n    pass\nasync def write_file_contents(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Writes the text contents of a file to the given path.\n\n    Args:\n        input: Dict[str, Any]:\n            content: str (required) - The content to write to the file.\n            path: str (required) - The path of the file to write to.\n\n    Returns:\n        Dict[str, Any]: {\n            message: str - The message returned from the operation.\n        }\n    \"\"\"\n    pass\nasync def email_answerer(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Generates responses to emails based on a given context and memory, and logs answered emails in a database.\n\n    Args:\n        input: Dict[str, Any]:\n            to_date: str (optional) - The ending date for fetching emails in DD-Mon-YYYY format\n            from_date: str (optional) - The starting date for fetching emails in DD-Mon-YYYY format\n\n    Returns:\n        Dict[str, Any]: {\n            login_status: str - The status of the email login\n            mail_ids: List[str] - The list of generated unique mail IDs\n            skipped: List[str] - List of email IDs that were skipped\n            table_created: bool - Indicates if the email logging table was created\n        }\n    \"\"\"\n    pass\nasync def meme_generator(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Generates a meme image based on a joke by selecting a template and splitting the joke into appropriate parts.\n\n    Args:\n        input: Dict[str, Any]:\n            joke: str (required) - The joke to create the meme from\n\n    Returns:\n        Dict[str, Any]: {\n            memeUrl: str - The URL of the generated meme image\n        }\n    \"\"\"\n    pass\nasync def coinbase_wallet_creator(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for creating a Coinbase wallet\n\n    Args:\n        input: Dict[str, Any]:\n\n    Returns:\n        Dict[str, Any]: {\n            address: str \n            seed: str \n            walletId: str \n        }\n    \"\"\"\n    pass\nasync def perplexity(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Searches the internet using Perplexity\n\n    Args:\n        input: Dict[str, Any]:\n            query: str (required) - The search query to send to Perplexity\n\n    Returns:\n        Dict[str, Any]: {\n            response: str - The search results and analysis from Perplexity\n        }\n    \"\"\"\n    pass\nasync def update_file_with_prompt(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Applies a prompt to the file contents.\n\n    Args:\n        input: Dict[str, Any]:\n            prompt: str (required) - The prompt to apply to the file contents.\n            path: str (required) - The path of the file to update.\n\n    Returns:\n        Dict[str, Any]: {\n            message: str - The message returned from the tool.\n            new_file_content: str - The path of the file that was updated.\n        }\n    \"\"\"\n    pass\nasync def youtube_transcript_summarizer(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Fetches the transcript of a YouTube video and generates a formatted summary using an LLM.\n\n    Args:\n        input: Dict[str, Any]:\n            lang: str (optional) - The language for the transcript (optional)\n            url: str (required) - The URL of the YouTube video\n\n    Returns:\n        Dict[str, Any]: {\n            summary: str - The generated summary of the video\n        }\n    \"\"\"\n    pass\nasync def smart_search_engine(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"This function takes a question as input and returns a comprehensive answer, along with the sources and statements used to generate the answer.\n\n    Args:\n        input: Dict[str, Any]:\n            question: str (required) - The question to answer\n\n    Returns:\n        Dict[str, Any]: {\n            response: str - The generated answer\n            sources: List[Dict[str, Any]] - The sources used to generate the answer\n            statements: List[Dict[str, Any]] - The statements extracted from the sources\n        }\n    \"\"\"\n    pass\nasync def email_fetcher(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Fetches emails from an IMAP server and returns their subject, date, sender, and text content.\n\n    Args:\n        input: Dict[str, Any]:\n            to_date: str (optional) - The end date for the email search (optional)\n            from_date: str (optional) - The start date for the email search (optional)\n\n    Returns:\n        Dict[str, Any]: {\n            emails: List[Dict[str, Any]] - A list of email objects\n            login_status: str - Indicates if login was successful or not\n        }\n    \"\"\"\n    pass\nasync def x_twitter_search(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Fetch from X/Twitter API to perform various search and retrieval operations.\n\n    Args:\n        input: Dict[str, Any]:\n            tweetId: str (optional) - The ID of the tweet to retrieve\n            username: str (optional) - The username for retrieving user posts\n            searchQuery: str (optional) - The search query for fetching tweets\n            command: str (required) - The exact command to execute: 'search-top' | 'search-suggestions' | 'search-latest' | 'get-user-posts' | 'get-post-by-id'\n\n    Returns:\n        Dict[str, Any]: {\n            data: Dict[str, Any] - The data returned from the Twitter API\n        }\n    \"\"\"\n    pass\nasync def read_file_contents(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Reads the text contents of a file from the given path.\n\n    Args:\n        input: Dict[str, Any]:\n            path: str (required) - The path of the file to read.\n\n    Returns:\n        Dict[str, Any]: {\n            content: str - The content of the file.\n        }\n    \"\"\"\n    pass\nasync def coinbase_my_address_getter(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for getting the default address of a Coinbase wallet\n\n    Args:\n        input: Dict[str, Any]:\n            walletId: str (optional) - The ID of the Coinbase wallet to get the address from\n\n    Returns:\n        Dict[str, Any]: {\n            address: str - The Ethereum address of the Coinbase wallet\n        }\n    \"\"\"\n    pass\nasync def coinbase_transaction_sender(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for restoring a Coinbase wallet and sending a transaction\n\n    Args:\n        input: Dict[str, Any]:\n            assetId: str (required) - The ID of the asset/token to send\n            recipient_address: str (required) - The destination address for the transaction\n            amount: str (required) - The amount of tokens to send\n\n    Returns:\n        Dict[str, Any]: {\n            status: str - The status of the transaction (e.g., 'success', 'pending', 'failed')\n            transactionHash: str - The hash of the completed transaction\n            transactionLink: str - A link to view the transaction on a block explorer\n        }\n    \"\"\"\n    pass\nasync def coinbase_transactions_getter(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for getting the transactions of a Coinbase wallet after restoring it\n\n    Args:\n        input: Dict[str, Any]:\n\n    Returns:\n        Dict[str, Any]: {\n            columnsCount: float \n            rowsCount: float \n            tableCsv: str \n        }\n    \"\"\"\n    pass\nasync def send_email(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Sends an email using SMTP.\n\n    Args:\n        input: Dict[str, Any]:\n            recipient_email: str (required) - The recipient's email address\n            subject: str (required) - The email subject\n            body: str (required) - The email body\n\n    Returns:\n        Dict[str, Any]: {\n            message: str - A message indicating the result of the operation\n            status: str - The status of the email sending operation ('success' or 'failed')\n        }\n    \"\"\"\n    pass\nasync def download_pages(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Downloads a URL and converts its HTML content to Markdown\n\n    Args:\n        input: Dict[str, Any]:\n            url: str (required) - A URL of a web page to download\n\n    Returns:\n        Dict[str, Any]: {\n            markdown: str - The Markdown content converted from the web page\n        }\n    \"\"\"\n    pass\nasync def coinbase_faucet_caller(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for calling a faucet on Coinbase\n\n    Args:\n        input: Dict[str, Any]:\n\n    Returns:\n        Dict[str, Any]: {\n            data: str \n        }\n    \"\"\"\n    pass\nasync def google_search(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"This function takes a question as input and returns a comprehensive answer, along with the sources and statements used to generate the answer.\n\n    Args:\n        input: Dict[str, Any]:\n            query: str (required) - The search query to look up\n\n    Returns:\n        Dict[str, Any]: {\n            query: str \n            results: List[Dict[str, Any]] \n        }\n    \"\"\"\n    pass\nasync def perplexity_api(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Searches the web using Perplexity API (limited)\n\n    Args:\n        input: Dict[str, Any]:\n            query: str (required) - The search query to send to Perplexity API\n\n    Returns:\n        Dict[str, Any]: {\n            response: str - The search results and analysis from Perplexity API\n        }\n    \"\"\"\n    pass\nasync def my_cool_shinkai_and_cursor_tool(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Flip a coin with n sides using true randomness from random.org. Supports custom side names and various meta-usage patterns.\n\n    Args:\n        input: Dict[str, Any]:\n            sides: float (optional) - Number of sides (default: 3)\n            sideNames: List[Any] (optional) - Optional custom names for sides (must match number of sides)\n\n    Returns:\n        Dict[str, Any]: {\n            error: str - Error message if the flip failed\n            result: str - The result of the coin flip\n        }\n    \"\"\"\n    pass\nasync def the_best_download_pages(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Downloads a URL and converts its HTML content to Markdown\n\n    Args:\n        input: Dict[str, Any]:\n\n    Returns:\n        Dict[str, Any]: {\n            markdown: str - The Markdown content converted from the web page\n        }\n    \"\"\"\n    pass\nasync def coinbase_balance_getter_20250305_123114(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Tool for getting the balance of a Coinbase wallet after restoring it\n\n    Args:\n        input: Dict[str, Any]:\n            walletId: str (optional) - Optional wallet ID to get balance for a specific wallet\n\n    Returns:\n        Dict[str, Any]: {\n            balances: Dict[str, Any] - Map of token symbols to their respective balances\n            message: str - Status message about the balance retrieval operation\n        }\n    \"\"\"\n    pass\nasync def placeholder_functionality_for_test2(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"A placeholder function for test2 that logs a message to the console.\n\n    Args:\n        input: Dict[str, Any]:\n\n    Returns:\n        Dict[str, Any]: {\n            address: str - The address of the wallet\n            seedPhrase: List[str] - The seed phrase associated with the wallet\n        }\n    \"\"\"\n    pass\nasync def file_creator(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Creates a test file in the home directory.\n\n    Args:\n        input: Dict[str, Any]:\n            action: str (required) - The action to perform, such as 'fetchPoolData'.\n            tokenAddress: str (required) - The address of the token for which to fetch pool data.\n\n    Returns:\n        Dict[str, Any]: {\n            error: str - An error message if an error occurs.\n            poolData: Dict[str, Any] \n        }\n    \"\"\"\n    pass\nasync def hello_world_printer(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"A simple tool that prints 'Hello, world!' to the console.\n\n    Args:\n        input: Dict[str, Any]:\n\n    Returns:\n        Dict[str, Any]: {\n        }\n    \"\"\"\n    pass\nasync def range_generator(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Generates a range of integers between two given numbers.\n\n    Args:\n        input: Dict[str, Any]:\n            a: float (required) - The start of the range (inclusive).\n            b: float (required) - The end of the range (inclusive).\n\n    Returns:\n        Dict[str, Any]: {\n            error: str - Error message if inputs are invalid.\n            result: List[float] - The generated range of numbers.\n        }\n    \"\"\"\n    pass\nasync def calculate_sum(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Calculates the sum of two numbers using the arithmetic series formula.\n\n    Args:\n        input: Dict[str, Any]:\n            a: float (required) - The first number\n            b: float (required) - The second number\n\n    Returns:\n        Dict[str, Any]: {\n            result: float - The result of the sum\n        }\n    \"\"\"\n    pass\nasync def sum_calculator(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Calculates the sum of two numbers provided as inputs.\n\n    Args:\n        input: Dict[str, Any]:\n            a: Any (required) - The first number to sum\n            b: Any (required) - The second number to sum\n\n    Returns:\n        Dict[str, Any]: {\n            error: str - Error message in case of invalid input\n            result: float - The sum of a and b\n        }\n    \"\"\"\n    pass\nasync def shinkai_llm_processor(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Processes input through either TypeScript execution or LLM prompt processing.\n\n    Args:\n        input: Dict[str, Any]:\n            input: str (required) - The input string to be processed\n            config: Dict[str, Any] (optional) - Configuration object for the processing\n\n    Returns:\n        Dict[str, Any]: {\n            result: str - The result of the processing\n        }\n    \"\"\"\n    pass\nasync def command_processor(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Processes a command using CorrectProcessor and returns the result or an error message.\n\n    Args:\n        input: Dict[str, Any]:\n            command: str (required) - The command to be processed\n\n    Returns:\n        Dict[str, Any]: {\n            error: str - An error message, if applicable\n            result: str - The result of the command processing\n        }\n    \"\"\"\n    pass\nasync def run_command_processor(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"A server-side function to handle various types of input commands and return structured output.\n\n    Args:\n        input: Dict[str, Any]:\n            command: str (required) - The command to be executed\n\n    Returns:\n        Dict[str, Any]: {\n            message: str - The result message of the command execution\n            status: str - The status of the command execution\n        }\n    \"\"\"\n    pass\nasync def hello_file_creator(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Creates a file with the message 'hello world' in the user's home directory.\n\n    Args:\n        input: Dict[str, Any]:\n            tokenB: str (required) - The second token in the arbitrage opportunity\n            tokenA: str (required) - The first token in the arbitrage opportunity\n            tokenC: str (required) - The third token in the arbitrage opportunity\n\n    Returns:\n        Dict[str, Any]: {\n            opportunities: List[Dict[str, Any]] - A list of found arbitrage opportunities\n        }\n    \"\"\"\n    pass\nasync def sum_numbers(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Function to sum two numbers and return the result.\n\n    Args:\n        input: Dict[str, Any]:\n            a: float (required) - First number to sum\n            b: float (required) - Second number to sum\n\n    Returns:\n        Dict[str, Any]: {\n            result: float - The result of the summation\n        }\n    \"\"\"\n    pass\nasync def you_tube_transcript_summarizer(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Fetches and summarizes YouTube video transcripts.\n\n    Args:\n        input: Dict[str, Any]:\n            url: str (required) - The URL of the YouTube video\n\n    Returns:\n        Dict[str, Any]: {\n            summary: str - The summarized transcript of the video\n        }\n    \"\"\"\n    pass\nasync def download_web_page(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Downloads a web page and returns the HTML content or an error message.\n\n    Args:\n        input: Dict[str, Any]:\n            url: str (required) - The URL of the web page to download\n\n    Returns:\n        Dict[str, Any]: {\n            errorMessage: str - An error message if the download fails\n            htmlContent: str - The HTML content of the downloaded web page\n        }\n    \"\"\"\n    pass\nasync def command_processor_runner(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Runs a command asynchronously and processes the result.\n\n    Args:\n        input: Dict[str, Any]:\n            command: str (required) - The command to be executed.\n\n    Returns:\n        Dict[str, Any]: {\n            message: str - The message returned from the command execution.\n            status: str - The status of the command execution.\n        }\n    \"\"\"\n    pass\nasync def command_handler(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Handles command execution and returns the status and message.\n\n    Args:\n        input: Dict[str, Any]:\n            command: str (required) - The command to execute\n\n    Returns:\n        Dict[str, Any]: {\n            message: str - Response message from the command\n            status: str - Execution status\n        }\n    \"\"\"\n    pass\nasync def command_runner(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Executes a command and returns the status and message of execution.\n\n    Args:\n        input: Dict[str, Any]:\n            command: str (required) - The command to be executed\n\n    Returns:\n        Dict[str, Any]: {\n            message: str - Message regarding the command execution\n            status: str - Status of the command execution\n        }\n    \"\"\"\n    pass\nasync def network_error_handler(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Handles network errors by logging and managing requests that encounter unexpected EOF issues.\n\n    Args:\n        input: Dict[str, Any]:\n            url: str (required) - The URL to connect to\n            timeout: float (optional) - Timeout duration for the connection\n\n    Returns:\n        Dict[str, Any]: {\n            errorMessage: str - Details of the network error if occurred\n            success: bool - Indicates if the connection was successful\n        }\n    \"\"\"\n    pass\nasync def fn_name(input: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"<description>\n\n    Args:\n        input: Dict[str, Any]:\n\n    Returns:\n        Dict[str, Any]: {\n        }\n    \"\"\"\n    pass\n\n\n#\n# <tool_key_path_to_function_name>\n# local:::__official_shinkai:::shinkai_typescript_unsafe_processor shinkai_typescript_unsafe_processor\n# local:::__official_shinkai:::shinkai_llm_map_reduce_processor shinkai_llm_map_reduce_processor\n# local:::__official_shinkai:::shinkai_llm_prompt_processor shinkai_llm_prompt_processor\n# local:::__official_shinkai:::shinkai_sqlite_query_executor shinkai_sqlite_query_executor\n# local:::__official_shinkai:::shinkai_process_embeddings shinkai_process_embeddings\n# local:::__official_shinkai:::shinkai_tool_config_updater shinkai_tool_config_updater\n# local:::__official_shinkai:::coinbase_balance_getter coinbase_balance_getter\n# local:::__official_shinkai:::x_twitter_post x_twitter_post\n# local:::__official_shinkai:::math_expression_evaluator math_expression_evaluator\n# local:::__official_shinkai:::duckduckgo_search duck_duck_go_search\n# local:::__official_shinkai:::memory_management memory_management\n# local:::__official_shinkai:::write_file_contents write_file_contents\n# local:::__official_shinkai:::email_answerer email_answerer\n# local:::__official_shinkai:::meme_generator meme_generator\n# local:::__official_shinkai:::coinbase_wallet_creator coinbase_wallet_creator\n# local:::__official_shinkai:::perplexity perplexity\n# local:::__official_shinkai:::update_file_with_prompt update_file_with_prompt\n# local:::__official_shinkai:::youtube_transcript_summarizer youtube_transcript_summarizer\n# local:::__official_shinkai:::smart_search_engine smart_search_engine\n# local:::__official_shinkai:::email_fetcher email_fetcher\n# local:::__official_shinkai:::x_twitter_search x_twitter_search\n# local:::__official_shinkai:::read_file_contents read_file_contents\n# local:::__official_shinkai:::coinbase_my_address_getter coinbase_my_address_getter\n# local:::__official_shinkai:::coinbase_transaction_sender coinbase_transaction_sender\n# local:::__official_shinkai:::coinbase_transactions_getter coinbase_transactions_getter\n# local:::__official_shinkai:::send_email send_email\n# local:::__official_shinkai:::download_pages download_pages\n# local:::__official_shinkai:::coinbase_faucet_caller coinbase_faucet_caller\n# local:::__official_shinkai:::google_search google_search\n# local:::__official_shinkai:::perplexity_api perplexity_api\n# local:::__localhost_sep_shinkai:::my_cool_shinkai_and_cursor_tool my_cool_shinkai_and_cursor_tool\n# local:::__localhost_sep_shinkai:::the_best_download_pages the_best_download_pages\n# local:::__localhost_sep_shinkai:::coinbase_balance_getter_20250305_123114 coinbase_balance_getter_20250305_123114\n# local:::__localhost_sep_shinkai:::placeholder_functionality_for_test2 placeholder_functionality_for_test2\n# local:::__localhost_sep_shinkai:::file_creator file_creator\n# local:::__localhost_sep_shinkai:::hello_world_printer hello_world_printer\n# local:::__localhost_sep_shinkai:::range_generator range_generator\n# local:::__localhost_sep_shinkai:::calculate_sum calculate_sum\n# local:::__localhost_sep_shinkai:::sum_calculator sum_calculator\n# local:::__localhost_sep_shinkai:::shinkai_llm_processor shinkai_llm_processor\n# local:::__localhost_sep_shinkai:::command_processor command_processor\n# local:::__localhost_sep_shinkai:::run_command_processor run_command_processor\n# local:::__localhost_sep_shinkai:::hello_file_creator hello_file_creator\n# local:::__localhost_sep_shinkai:::sum_numbers sum_numbers\n# local:::__localhost_sep_shinkai:::youtube_transcript_summarizer you_tube_transcript_summarizer\n# local:::__localhost_sep_shinkai:::download_web_page download_web_page\n# local:::__localhost_sep_shinkai:::command_processor_runner command_processor_runner\n# local:::__localhost_sep_shinkai:::command_handler command_handler\n# local:::__localhost_sep_shinkai:::command_runner command_runner\n# local:::__localhost_sep_shinkai:::network_error_handler network_error_handler\n# local:::__localhost_sep_shinkai:::_name_ fn_name\n# </tool_key_path_to_function_name>\n#\n\n",
    "x_shinkai_request_uuid": "replace-me",
    "skipfeedback": "false"
}

Deno.test("POST /generate should return 200 with valid parameters", async () => {

    const baseUrl = `http://localhost:8080`;
    const uuid = new Date().getTime().toString() + '-' + Math.random().toString(36).substring(2, 15);
    {
        let response1 = await fetch(`${baseUrl}/generate`, {
            method: "POST",
            headers: {
                "accept": "text/event-stream",
                "Content-Type": "application/json",
            },
            body: JSON.stringify(
                {
                    ...body,
                    x_shinkai_request_uuid: 'test-py-' + uuid,
                }),
        });
        assertEquals(response1.status, 200, 'response1.status');

        let reader1 = response1.body?.getReader();
        let decoder1 = new TextDecoder();
        let part1 = '';
        while (true) {
            const data = await reader1?.read();
            const partialResult = decoder1.decode(data?.value);
            console.log(partialResult);
            part1 += partialResult;
            if (data?.done) break;
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        reader1 = undefined as any;
        decoder1 = undefined as any;
        response1 = undefined as any;
        assertEquals(part1.includes('event: request-feedback'), true, 'part1.includes(request-feedback)');
    }

    let code = '';
    {
        let response2 = await fetch(`${baseUrl}/generate`, {
            method: "POST",
            headers: {
                "accept": "text/event-stream",
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                language: "python",
                prompt: "ok",
                tool_type: "shinkai",
                skipfeedback: "false",
                x_shinkai_request_uuid: 'test-py-' + uuid,
                feedback: ""
            }),
        });

        let reader2 = response2.body?.getReader();
        let decoder2 = new TextDecoder();
        let part2 = '';
        while (true) {
            const data = await reader2?.read();
            const partialResult = decoder2.decode(data?.value);
            console.log(partialResult);
            part2 += partialResult;
            if (data?.done) break;
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        reader2 = undefined as any;
        decoder2 = undefined as any;
        response2 = undefined as any;
        assertEquals(part2.includes('event: code'), true, 'part2.includes(code)');

        code = part2.split('event: code')[1].split('\n')[1].replace(/^data: /, '');
        assertEquals(code.includes('async def run'), true, 'code.includes(async def run)');
    }

    {
        let response3 = await fetch(`${baseUrl}/metadata`, {
            method: "POST",
            headers: {
                "accept": "text/event-stream",
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                language: "typescript",
                code,
                x_shinkai_request_uuid: 'test-metadata-' + uuid,
            }),
        });

        let reader3 = response3.body?.getReader();
        let decoder3 = new TextDecoder();
        let part3 = '';
        while (true) {
            const data = await reader3?.read();
            const partialResult = decoder3.decode(data?.value);
            console.log(partialResult);
            part3 += partialResult;
            if (data?.done) break;
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        reader3 = undefined as any;
        decoder3 = undefined as any;
        response3 = undefined as any;
        assertEquals(part3.includes('event: metadata'), true, 'part3.includes(metadata)');

    }

});
