import { assertEquals } from "https://deno.land/std@0.208.0/assert/mod.ts";
import { router } from "./service.ts";
console.log(String(router)[0]); // so that {router} get loaded

const body = {
    "language": "typescript",
    "prompt": "\nnFrom a youtube URL, get the video transcipt, and then write a haiku about with the LLMProcessor\n",
    "feedback": "",
    "tool_type": "shinkai",
    "tool_headers": "\n/**\n * Tool for executing Node.js code. This is unsafe and should be used with extreme caution.\n * @param input - {\n *   code: string - The TypeScript code to execute\n *   config: object - Configuration for the code execution\n *   package: string - The package.json contents\n *   parameters: object - Parameters to pass to the code\n *\n * @returns {\n *   stdout: string;\n * }\n */\nexport async function shinkaiTypescriptUnsafeProcessor(input: {package: string, config: object, code: string, parameters: object}): Promise<{\n    stdout: string;\n}>;\n\n/**\n * Tool for applying a prompt over a long text (longer than the context window of the LLM) using an AI LLM. \nThis can be used to process complex requests, text analysis, text matching, text generation, and any other AI LLM task. over long texts.\n * @param input - {\n *   data: string - The data to process\n *   prompt: string - The prompt to apply over the data\n *   tools?: string[] - List of tools names or tool router keys to be used with the prompt\n *\n * @returns {\n *   response: string;\n * }\n */\nexport async function shinkaiLlmMapReduceProcessor(input: {data: string, prompt: string, tools?: any[]}): Promise<{\n    response: string;\n}>;\n\n/**\n * Tool for processing any prompt using an AI LLM. \nAnalyzing the input prompt and returning a string with the result of the prompt.\nThis can be used to process complex requests, text analysis, text matching, text generation, and any other AI LLM task.\n * @param input - {\n *   format: string - Response type. The only valid option is 'text'\n *   prompt: string - The prompt to process\n *   tools?: string[] - List of tools names or tool router keys to be used with the prompt\n *\n * @returns {\n *   message: string;\n * }\n */\nexport async function shinkaiLlmPromptProcessor(input: {prompt: string, tools?: any[], format: string}): Promise<{\n    message: string;\n}>;\n\n/**\n * Tool for executing a single SQL query on a specified database file. \nIf this tool is used, you need to create if not exists the tables used other queries.\nTable creation should always use 'CREATE TABLE IF NOT EXISTS'.\n\n-- Example table creation:\nCREATE TABLE IF NOT EXISTS table_name (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    field_1 TEXT NOT NULL,\n    field_2 DATETIME DEFAULT CURRENT_TIMESTAMP,\n    field_3 INTEGER,\n    field_4 TEXT\n);\n\n-- Example insert:\nINSERT INTO table_name (field_1, field_3, field_4) \n    VALUES ('value_1', 3, 'value_4')\n    ON CONFLICT(id) DO UPDATE SET field_1 = 'value_1', field_3 = 3, field_4 = 'value_4';\n;\n\n-- Example read:\nSELECT * FROM table_name WHERE field_2 > datetime('now', '-1 day');\nSELECT field_1, field_3 FROM table_name WHERE field_3 > 100 ORDER BY field_2 DESC LIMIT 10;\n * @param input - {\n *   params?: any[] - The parameters to pass to the query\n *   query: string - The SQL query to execute\n *\n * @returns {\n *   result: any;\n *   rowCount: number;\n *   rowsAffected: number;\n *   type: string;\n * }\n */\nexport async function shinkaiSqliteQueryExecutor(input: {query: string, params?: any[]}): Promise<{\n    result: any;\n    rowCount: number;\n    rowsAffected: number;\n    type: string;\n}>;\n\n/**\n * Tool for processing embeddings within a job scope. \nThis tool processes resources and generates embeddings using a specified mapping function.\n\nExample usage:\n- Provide a custom mapping function to transform resource content.\n- Process resources in chunks to optimize performance.\n- Collect and join processed embeddings for further analysis.\n * @param input - {\n *   map_function?: string - The map function to use\n *   prompt: string - The prompt to use\n *\n * @returns {\n *   result: string;\n *   rowCount: number;\n *   rowsAffected: number;\n *   type: string;\n * }\n */\nexport async function shinkaiProcessEmbeddings(input: {prompt: string, map_function?: string}): Promise<{\n    result: string;\n    rowCount: number;\n    rowsAffected: number;\n    type: string;\n}>;\n\n/**\n * Tool for updating the configuration of a tool. \nThis tool allows you to update config fields of a tool by providing the tool_router_key and config key-value pairs.\n\nExample usage:\n{\n    \"tool_router_key\": \"local:::deno_toolkit:::my_tool\",\n    \"config\": {\n            \"api_key\": \"some-api-key\",\n            \"api_secret\": \"some-api-secret\"\n    }\n}\n * @param input - {\n *   config: object - Configuration key-value pairs to update\n *   tool_router_key: string - The tool_router_key of the tool to update\n *\n * @returns {\n *   message: string;\n *   success: boolean;\n * }\n */\nexport async function shinkaiToolConfigUpdater(input: {config: object, tool_router_key: string}): Promise<{\n    message: string;\n    success: boolean;\n}>;\n\n/**\n * Tool for getting the balance of a Coinbase wallet after restoring it\n * @param input - {\n *   walletId?: string - Optional wallet ID to get balance for a specific wallet\n *\n * @returns {\n *   balances: object;\n *   message: string;\n * }\n */\nexport async function coinbaseBalanceGetter(input: {walletId?: string}): Promise<{\n    balances: object;\n    message: string;\n}>;\n\n/**\n * Function to post a tweet to Twitter.\n * @param input - {\n *   imagePath?: string - Path to the image to post\n *   text?: string - Message to post\n *\n * @returns {\n *   data: string;\n * }\n */\nexport async function xTwitterPost(input: {text?: string, imagePath?: string}): Promise<{\n    data: string;\n}>;\n\n/**\n * Parses and evaluates mathematical expressions. It’s a safer and more math-oriented alternative to using JavaScript’s eval function for mathematical expressions.\n * @param input - {\n *   expression: string - The mathematical expression to evaluate (e.g., '2 + 2 * 3')\n *\n * @returns {\n *   result: string;\n * }\n */\nexport async function mathExpressionEvaluator(input: {expression: string}): Promise<{\n    result: string;\n}>;\n\n/**\n * Searches the DuckDuckGo search engine. Example result: [{\"title\": \"IMDb Top 250 Movies\", \"description\": \"Find out which <b>movies</b> are rated as the <b>best</b> <b>of</b> <b>all</b> <b>time</b> by IMDb users. See the list of 250 titles sorted by ranking, genre, year, and rating, and learn how the list is determined.\", \"url\": \"https://www.imdb.com/chart/top/\"}]\n * @param input - {\n *   message: string - The search query to send to DuckDuckGo\n *\n * @returns {\n *   message: string;\n *   puppeteer: boolean;\n * }\n */\nexport async function duckduckgoSearch(input: {message: string}): Promise<{\n    message: string;\n    puppeteer: boolean;\n}>;\n\n/**\n * Handles memory storage and retrieval using a SQLite database.\n * @param input - {\n *   data?: string - The data to process for memory management, if not provided, the tool will return existing memories\n *   general_prompt?: string - The general prompt for generating memories\n *   key?: string - The key for specific memory retrieval\n *   specific_prompt?: string - The specific prompt for generating memories\n *\n * @returns {\n *   generalMemory: string;\n *   specificMemory: string;\n * }\n */\nexport async function memoryManagement(input: {general_prompt?: string, data?: string, key?: string, specific_prompt?: string}): Promise<{\n    generalMemory: string;\n    specificMemory: string;\n}>;\n/**\n * Query the SQL database for results from memoryManagement\n * \n * Available SQL Tables:\n * memory_table\n * CREATE TABLE IF NOT EXISTS memory_table (id INTEGER PRIMARY KEY AUTOINCREMENT, date DATETIME DEFAULT CURRENT_TIMESTAMP, key TEXT, memory TEXT)\n *\n * Example / Reference SQL Queries:\n * Get general memory\n * SELECT id, key, memory FROM memory_table WHERE key IS NULL\n\n * Get specific memory\n * SELECT id, key, memory FROM memory_table WHERE key = ?\n\n * Update memory\n * UPDATE memory_table SET memory = ? WHERE id = ?\n\n * \n* @param query - SQL query to execute\n* @param params - Optional array of parameters for the query\n* @returns Query results\n*/\n\nasync function query_memoryManagement(query: string, params?: any[]);\n/**\n * Writes the text contents of a file to the given path.\n * @param input - {\n *   content: string - The content to write to the file.\n *   path: string - The path of the file to write to.\n *\n * @returns {\n *   message: string;\n * }\n */\nexport async function writeFileContents(input: {content: string, path: string}): Promise<{\n    message: string;\n}>;\n\n/**\n * Generates responses to emails based on a given context and memory, and logs answered emails in a database.\n * @param input - {\n *   from_date?: string - The starting date for fetching emails in DD-Mon-YYYY format\n *   to_date?: string - The ending date for fetching emails in DD-Mon-YYYY format\n *\n * @returns {\n *   login_status: string;\n *   mail_ids: string[];\n *   skipped: string[];\n *   table_created: boolean;\n * }\n */\nexport async function emailAnswerer(input: {to_date?: string, from_date?: string}): Promise<{\n    login_status: string;\n    mail_ids: string[];\n    skipped: string[];\n    table_created: boolean;\n}>;\n/**\n * Query the SQL database for results from emailAnswerer\n * \n * Available SQL Tables:\n * answered_emails\n * CREATE TABLE IF NOT EXISTS answered_emails (email_unique_id TEXT UNIQUE PRIMARY KEY, subject TEXT NOT NULL, email TEXT NOT NULL, response TEXT NOT NULL, received_date DATETIME NOT NULL, response_date DATETIME DEFAULT CURRENT_TIMESTAMP)\n *\n * Example / Reference SQL Queries:\n * Get answered emails\n * SELECT * FROM answered_emails\n\n * Get email by unique ID\n * SELECT * FROM answered_emails WHERE email_unique_id = :emailUniqueId\n\n * Insert new email\n * INSERT INTO answered_emails (email_unique_id, subject, email, response, received_date) VALUES (:emailUniqueId, :subject, :email, :response, :receivedDate)\n\n * \n* @param query - SQL query to execute\n* @param params - Optional array of parameters for the query\n* @returns Query results\n*/\n\nasync function query_emailAnswerer(query: string, params?: any[]);\n/**\n * Generates a meme image based on a joke by selecting a template and splitting the joke into appropriate parts.\n * @param input - {\n *   joke: string - The joke to create the meme from\n *\n * @returns {\n *   memeUrl: string;\n * }\n */\nexport async function memeGenerator(input: {joke: string}): Promise<{\n    memeUrl: string;\n}>;\n\n/**\n * Tool for creating a Coinbase wallet\n * @param input - {\n *\n * @returns {\n *   address: string;\n *   seed: string;\n *   walletId: string;\n * }\n */\nexport async function coinbaseWalletCreator(input: {}): Promise<{\n    address: string;\n    seed: string;\n    walletId: string;\n}>;\n\n/**\n * Searches the internet using Perplexity\n * @param input - {\n *   query: string - The search query to send to Perplexity\n *\n * @returns {\n *   response: string;\n * }\n */\nexport async function perplexity(input: {query: string}): Promise<{\n    response: string;\n}>;\n\n/**\n * Applies a prompt to the file contents.\n * @param input - {\n *   path: string - The path of the file to update.\n *   prompt: string - The prompt to apply to the file contents.\n *\n * @returns {\n *   message: string;\n *   new_file_content: string;\n * }\n */\nexport async function updateFileWithPrompt(input: {path: string, prompt: string}): Promise<{\n    message: string;\n    new_file_content: string;\n}>;\n\n/**\n * Fetches the transcript of a YouTube video and generates a formatted summary using an LLM.\n * @param input - {\n *   lang?: string - The language for the transcript (optional)\n *   url: string - The URL of the YouTube video\n *\n * @returns {\n *   summary: string;\n * }\n */\nexport async function youtubeTranscriptSummarizer(input: {url: string, lang?: string}): Promise<{\n    summary: string;\n}>;\n\n/**\n * This function takes a question as input and returns a comprehensive answer, along with the sources and statements used to generate the answer.\n * @param input - {\n *   question: string - The question to answer\n *\n * @returns {\n *   response: string;\n *   sources: object[];\n *   statements: object[];\n * }\n */\nexport async function smartSearchEngine(input: {question: string}): Promise<{\n    response: string;\n    sources: object[];\n    statements: object[];\n}>;\n\n/**\n * Fetches emails from an IMAP server and returns their subject, date, sender, and text content.\n * @param input - {\n *   from_date?: string - The start date for the email search (optional)\n *   to_date?: string - The end date for the email search (optional)\n *\n * @returns {\n *   emails: object[];\n *   login_status: string;\n * }\n */\nexport async function emailFetcher(input: {to_date?: string, from_date?: string}): Promise<{\n    emails: object[];\n    login_status: string;\n}>;\n\n/**\n * Fetch from X/Twitter API to perform various search and retrieval operations.\n * @param input - {\n *   command: string - The exact command to execute: 'search-top' | 'search-suggestions' | 'search-latest' | 'get-user-posts' | 'get-post-by-id'\n *   searchQuery?: string - The search query for fetching tweets\n *   tweetId?: string - The ID of the tweet to retrieve\n *   username?: string - The username for retrieving user posts\n *\n * @returns {\n *   data: object;\n * }\n */\nexport async function xTwitterSearch(input: {username?: string, tweetId?: string, searchQuery?: string, command: string}): Promise<{\n    data: object;\n}>;\n\n/**\n * Reads the text contents of a file from the given path.\n * @param input - {\n *   path: string - The path of the file to read.\n *\n * @returns {\n *   content: string;\n * }\n */\nexport async function readFileContents(input: {path: string}): Promise<{\n    content: string;\n}>;\n\n/**\n * Tool for getting the default address of a Coinbase wallet\n * @param input - {\n *   walletId?: string - The ID of the Coinbase wallet to get the address from\n *\n * @returns {\n *   address: string;\n * }\n */\nexport async function coinbaseMyAddressGetter(input: {walletId?: string}): Promise<{\n    address: string;\n}>;\n\n/**\n * Tool for restoring a Coinbase wallet and sending a transaction\n * @param input - {\n *   amount: string - The amount of tokens to send\n *   assetId: string - The ID of the asset/token to send\n *   recipient_address: string - The destination address for the transaction\n *\n * @returns {\n *   status: string;\n *   transactionHash: string;\n *   transactionLink: string;\n * }\n */\nexport async function coinbaseTransactionSender(input: {assetId: string, amount: string, recipient_address: string}): Promise<{\n    status: string;\n    transactionHash: string;\n    transactionLink: string;\n}>;\n\n/**\n * Tool for getting the transactions of a Coinbase wallet after restoring it\n * @param input - {\n *\n * @returns {\n *   columnsCount: number;\n *   rowsCount: number;\n *   tableCsv: string;\n * }\n */\nexport async function coinbaseTransactionsGetter(input: {}): Promise<{\n    columnsCount: number;\n    rowsCount: number;\n    tableCsv: string;\n}>;\n\n/**\n * Sends an email using SMTP.\n * @param input - {\n *   body: string - The email body\n *   recipient_email: string - The recipient's email address\n *   subject: string - The email subject\n *\n * @returns {\n *   message: string;\n *   status: string;\n * }\n */\nexport async function sendEmail(input: {recipient_email: string, subject: string, body: string}): Promise<{\n    message: string;\n    status: string;\n}>;\n\n/**\n * Downloads a URL and converts its HTML content to Markdown\n * @param input - {\n *   url: string - A URL of a web page to download\n *\n * @returns {\n *   markdown: string;\n * }\n */\nexport async function downloadPages(input: {url: string}): Promise<{\n    markdown: string;\n}>;\n\n/**\n * Tool for calling a faucet on Coinbase\n * @param input - {\n *\n * @returns {\n *   data: string;\n * }\n */\nexport async function coinbaseFaucetCaller(input: {}): Promise<{\n    data: string;\n}>;\n\n/**\n * This function takes a question as input and returns a comprehensive answer, along with the sources and statements used to generate the answer.\n * @param input - {\n *   query: string - The search query to look up\n *\n * @returns {\n *   query: string;\n *   results: object[];\n * }\n */\nexport async function googleSearch(input: {query: string}): Promise<{\n    query: string;\n    results: object[];\n}>;\n\n/**\n * Searches the web using Perplexity API (limited)\n * @param input - {\n *   query: string - The search query to send to Perplexity API\n *\n * @returns {\n *   response: string;\n * }\n */\nexport async function perplexityApi(input: {query: string}): Promise<{\n    response: string;\n}>;\n\n/**\n * Flip a coin with n sides using true randomness from random.org. Supports custom side names and various meta-usage patterns.\n * @param input - {\n *   sideNames?: string[] - Optional custom names for sides (must match number of sides)\n *   sides?: number - Number of sides (default: 3)\n *\n * @returns {\n *   error: string;\n *   result: string;\n * }\n */\nexport async function myCoolShinkaiAndCursorTool(input: {sideNames?: any[], sides?: number}): Promise<{\n    error: string;\n    result: string;\n}>;\n\n/**\n * Downloads a URL and converts its HTML content to Markdown\n * @param input - {\n *\n * @returns {\n *   markdown: string;\n * }\n */\nexport async function theBestDownloadPages(input: {}): Promise<{\n    markdown: string;\n}>;\n\n/**\n * Tool for getting the balance of a Coinbase wallet after restoring it\n * @param input - {\n *   walletId?: string - Optional wallet ID to get balance for a specific wallet\n *\n * @returns {\n *   balances: object;\n *   message: string;\n * }\n */\nexport async function coinbaseBalanceGetter20250305123114(input: {walletId?: string}): Promise<{\n    balances: object;\n    message: string;\n}>;\n\n/**\n * A placeholder function for test2 that logs a message to the console.\n * @param input - {\n *\n * @returns {\n *   address: string;\n *   seedPhrase: string[];\n * }\n */\nexport async function placeholderFunctionalityForTest2(input: {}): Promise<{\n    address: string;\n    seedPhrase: string[];\n}>;\n\n/**\n * Creates a test file in the home directory.\n * @param input - {\n *   action: string - The action to perform, such as 'fetchPoolData'.\n *   tokenAddress: string - The address of the token for which to fetch pool data.\n *\n * @returns {\n *   error: string;\n *   poolData: object;\n * }\n */\nexport async function fileCreator(input: {tokenAddress: string, action: string}): Promise<{\n    error: string;\n    poolData: object;\n}>;\n\n/**\n * A simple tool that prints 'Hello, world!' to the console.\n * @param input - {\n *\n * @returns {\n * }\n */\nexport async function helloWorldPrinter(input: {}): Promise<{\n}>;\n\n/**\n * Generates a range of integers between two given numbers.\n * @param input - {\n *   a: number - The start of the range (inclusive).\n *   b: number - The end of the range (inclusive).\n *\n * @returns {\n *   error: string;\n *   result: number[];\n * }\n */\nexport async function rangeGenerator(input: {a: number, b: number}): Promise<{\n    error: string;\n    result: number[];\n}>;\n\n/**\n * Calculates the sum of two numbers using the arithmetic series formula.\n * @param input - {\n *   a: number - The first number\n *   b: number - The second number\n *\n * @returns {\n *   result: number;\n * }\n */\nexport async function calculateSum(input: {a: number, b: number}): Promise<{\n    result: number;\n}>;\n\n/**\n * Calculates the sum of two numbers provided as inputs.\n * @param input - {\n *   a: any - The first number to sum\n *   b: any - The second number to sum\n *\n * @returns {\n *   error: string;\n *   result: number;\n * }\n */\nexport async function sumCalculator(input: {a: any, b: any}): Promise<{\n    error: string;\n    result: number;\n}>;\n\n/**\n * Processes input through either TypeScript execution or LLM prompt processing.\n * @param input - {\n *   config?: object - Configuration object for the processing\n *   input: string - The input string to be processed\n *\n * @returns {\n *   result: string;\n * }\n */\nexport async function shinkaiLlmProcessor(input: {input: string, config?: object}): Promise<{\n    result: string;\n}>;\n\n/**\n * Processes a command using CorrectProcessor and returns the result or an error message.\n * @param input - {\n *   command: string - The command to be processed\n *\n * @returns {\n *   error: string;\n *   result: string;\n * }\n */\nexport async function commandProcessor(input: {command: string}): Promise<{\n    error: string;\n    result: string;\n}>;\n\n/**\n * A server-side function to handle various types of input commands and return structured output.\n * @param input - {\n *   command: string - The command to be executed\n *\n * @returns {\n *   message: string;\n *   status: string;\n * }\n */\nexport async function runCommandProcessor(input: {command: string}): Promise<{\n    message: string;\n    status: string;\n}>;\n\n/**\n * Creates a file with the message 'hello world' in the user's home directory.\n * @param input - {\n *   tokenA: string - The first token in the arbitrage opportunity\n *   tokenB: string - The second token in the arbitrage opportunity\n *   tokenC: string - The third token in the arbitrage opportunity\n *\n * @returns {\n *   opportunities: object[];\n * }\n */\nexport async function helloFileCreator(input: {tokenB: string, tokenA: string, tokenC: string}): Promise<{\n    opportunities: object[];\n}>;\n\n/**\n * Function to sum two numbers and return the result.\n * @param input - {\n *   a: number - First number to sum\n *   b: number - Second number to sum\n *\n * @returns {\n *   result: number;\n * }\n */\nexport async function sumNumbers(input: {b: number, a: number}): Promise<{\n    result: number;\n}>;\n\n/**\n * Downloads a web page and returns the HTML content or an error message.\n * @param input - {\n *   url: string - The URL of the web page to download\n *\n * @returns {\n *   errorMessage: string;\n *   htmlContent: string;\n * }\n */\nexport async function downloadWebPage(input: {url: string}): Promise<{\n    errorMessage: string;\n    htmlContent: string;\n}>;\n\n/**\n * Runs a command asynchronously and processes the result.\n * @param input - {\n *   command: string - The command to be executed.\n *\n * @returns {\n *   message: string;\n *   status: string;\n * }\n */\nexport async function commandProcessorRunner(input: {command: string}): Promise<{\n    message: string;\n    status: string;\n}>;\n\n/**\n * Handles command execution and returns the status and message.\n * @param input - {\n *   command: string - The command to execute\n *\n * @returns {\n *   message: string;\n *   status: string;\n * }\n */\nexport async function commandHandler(input: {command: string}): Promise<{\n    message: string;\n    status: string;\n}>;\n\n/**\n * Executes a command and returns the status and message of execution.\n * @param input - {\n *   command: string - The command to be executed\n *\n * @returns {\n *   message: string;\n *   status: string;\n * }\n */\nexport async function commandRunner(input: {command: string}): Promise<{\n    message: string;\n    status: string;\n}>;\n\n/**\n * Handles network errors by logging and managing requests that encounter unexpected EOF issues.\n * @param input - {\n *   timeout?: number - Timeout duration for the connection\n *   url: string - The URL to connect to\n *\n * @returns {\n *   errorMessage: string;\n *   success: boolean;\n * }\n */\nexport async function networkErrorHandler(input: {url: string, timeout?: number}): Promise<{\n    errorMessage: string;\n    success: boolean;\n}>;\n\n/**\n * <description>\n * @param input - {\n *\n * @returns {\n * }\n */\nexport async function fnName(input: {}): Promise<{\n}>;\n\n\n\n//\n// <tool_key_path_to_function_name>\n// local:::__official_shinkai:::shinkai_typescript_unsafe_processor shinkaiTypescriptUnsafeProcessor\n// local:::__official_shinkai:::shinkai_llm_map_reduce_processor shinkaiLlmMapReduceProcessor\n// local:::__official_shinkai:::shinkai_llm_prompt_processor shinkaiLlmPromptProcessor\n// local:::__official_shinkai:::shinkai_sqlite_query_executor shinkaiSqliteQueryExecutor\n// local:::__official_shinkai:::shinkai_process_embeddings shinkaiProcessEmbeddings\n// local:::__official_shinkai:::shinkai_tool_config_updater shinkaiToolConfigUpdater\n// local:::__official_shinkai:::coinbase_balance_getter coinbaseBalanceGetter\n// local:::__official_shinkai:::x_twitter_post xTwitterPost\n// local:::__official_shinkai:::math_expression_evaluator mathExpressionEvaluator\n// local:::__official_shinkai:::duckduckgo_search duckduckgoSearch\n// local:::__official_shinkai:::memory_management memoryManagement\n// local:::__official_shinkai:::write_file_contents writeFileContents\n// local:::__official_shinkai:::email_answerer emailAnswerer\n// local:::__official_shinkai:::meme_generator memeGenerator\n// local:::__official_shinkai:::coinbase_wallet_creator coinbaseWalletCreator\n// local:::__official_shinkai:::perplexity perplexity\n// local:::__official_shinkai:::update_file_with_prompt updateFileWithPrompt\n// local:::__official_shinkai:::youtube_transcript_summarizer youtubeTranscriptSummarizer\n// local:::__official_shinkai:::smart_search_engine smartSearchEngine\n// local:::__official_shinkai:::email_fetcher emailFetcher\n// local:::__official_shinkai:::x_twitter_search xTwitterSearch\n// local:::__official_shinkai:::read_file_contents readFileContents\n// local:::__official_shinkai:::coinbase_my_address_getter coinbaseMyAddressGetter\n// local:::__official_shinkai:::coinbase_transaction_sender coinbaseTransactionSender\n// local:::__official_shinkai:::coinbase_transactions_getter coinbaseTransactionsGetter\n// local:::__official_shinkai:::send_email sendEmail\n// local:::__official_shinkai:::download_pages downloadPages\n// local:::__official_shinkai:::coinbase_faucet_caller coinbaseFaucetCaller\n// local:::__official_shinkai:::google_search googleSearch\n// local:::__official_shinkai:::perplexity_api perplexityApi\n// local:::__localhost_sep_shinkai:::my_cool_shinkai_and_cursor_tool myCoolShinkaiAndCursorTool\n// local:::__localhost_sep_shinkai:::the_best_download_pages theBestDownloadPages\n// local:::__localhost_sep_shinkai:::coinbase_balance_getter_20250305_123114 coinbaseBalanceGetter20250305123114\n// local:::__localhost_sep_shinkai:::placeholder_functionality_for_test2 placeholderFunctionalityForTest2\n// local:::__localhost_sep_shinkai:::file_creator fileCreator\n// local:::__localhost_sep_shinkai:::hello_world_printer helloWorldPrinter\n// local:::__localhost_sep_shinkai:::range_generator rangeGenerator\n// local:::__localhost_sep_shinkai:::calculate_sum calculateSum\n// local:::__localhost_sep_shinkai:::sum_calculator sumCalculator\n// local:::__localhost_sep_shinkai:::shinkai_llm_processor shinkaiLlmProcessor\n// local:::__localhost_sep_shinkai:::command_processor commandProcessor\n// local:::__localhost_sep_shinkai:::run_command_processor runCommandProcessor\n// local:::__localhost_sep_shinkai:::hello_file_creator helloFileCreator\n// local:::__localhost_sep_shinkai:::sum_numbers sumNumbers\n// local:::__localhost_sep_shinkai:::download_web_page downloadWebPage\n// local:::__localhost_sep_shinkai:::command_processor_runner commandProcessorRunner\n// local:::__localhost_sep_shinkai:::command_handler commandHandler\n// local:::__localhost_sep_shinkai:::command_runner commandRunner\n// local:::__localhost_sep_shinkai:::network_error_handler networkErrorHandler\n// local:::__localhost_sep_shinkai:::_name_ fnName\n// </tool_key_path_to_function_name>\n//\n\n",
    "x_shinkai_request_uuid": "replace-me",
    "skipfeedback": "false"
}

Deno.test("POST /generate should return 200 with valid parameters", async () => {

    const baseUrl = `http://localhost:8080`;
    const uuid = new Date().getTime().toString() + '-' + Math.random().toString(36).substring(2, 15);
    {
        let response1 = await fetch(`${baseUrl}/generate`, {
            method: "POST",
            headers: {
                "accept": "text/event-stream",
                "Content-Type": "application/json",
            },
            body: JSON.stringify(
                {
                    ...body,
                    x_shinkai_request_uuid: 'test-ts-' + uuid,
                }),
        });
        assertEquals(response1.status, 200, 'response1.status');

        let reader1 = response1.body?.getReader();
        let decoder1 = new TextDecoder();
        let part1 = '';
        while (true) {
            const data = await reader1?.read();
            const partialResult = decoder1.decode(data?.value);
            console.log(partialResult);
            part1 += partialResult;
            if (data?.done) break;
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        reader1 = undefined as any;
        decoder1 = undefined as any;
        response1 = undefined as any;
        assertEquals(part1.includes('event: request-feedback'), true, 'part1.includes(request-feedback)');
    }

    let code = '';
    {
        let response2 = await fetch(`${baseUrl}/generate`, {
            method: "POST",
            headers: {
                "accept": "text/event-stream",
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                language: "typescript",
                prompt: "ok",
                tool_type: "shinkai",
                skipfeedback: "false",
                x_shinkai_request_uuid: 'test-ts-' + uuid,
                feedback: ""
            }),
        });

        let reader2 = response2.body?.getReader();
        let decoder2 = new TextDecoder();
        let part2 = '';
        while (true) {
            const data = await reader2?.read();
            const partialResult = decoder2.decode(data?.value);
            console.log(partialResult);
            part2 += partialResult;
            if (data?.done) break;
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        reader2 = undefined as any;
        decoder2 = undefined as any;
        response2 = undefined as any;
        assertEquals(part2.includes('event: code'), true, 'part2.includes(code)');

        code = part2.split('event: code')[1].split('\n')[1].replace(/^data: /, '');
        assertEquals(code.includes('export async function run'), true, 'code.includes(export async function run)');
    }

    {
        let response3 = await fetch(`${baseUrl}/metadata`, {
            method: "POST",
            headers: {
                "accept": "text/event-stream",
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                language: "typescript",
                code,
                x_shinkai_request_uuid: 'test-metadata-' + uuid,
            }),
        });

        let reader3 = response3.body?.getReader();
        let decoder3 = new TextDecoder();
        let part3 = '';
        while (true) {
            const data = await reader3?.read();
            const partialResult = decoder3.decode(data?.value);
            console.log(partialResult);
            part3 += partialResult;
            if (data?.done) break;
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        reader3 = undefined as any;
        decoder3 = undefined as any;
        response3 = undefined as any;
        assertEquals(part3.includes('event: metadata'), true, 'part3.includes(metadata)');

    }

});
