{"success":true,"status":"completed","completed":1,"total":1,"creditsUsed":1,"expiresAt":"2025-03-05T20:50:37.000Z","data":[{"markdown":"[Skip to main content](https://redux.js.org/usage/usage-with-typescript#docusaurus_skipToContent_fallback)\n\n[![Redux.dev - a new course by Mark Erikson + ui.dev - Learn more](https://redux.js.org/img/course-callout-wide.svg)](https://redux.dev/)\n\nOn this page\n\nUsage with TypeScript\n=====================\n\nWhat You'll Learn\n\n*   Standard patterns for setting up a Redux app with TypeScript\n*   Techniques for correctly typing portions of Redux logic\n\nPrerequisites\n\n*   Understanding of [TypeScript syntax and terms](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)\n    \n*   Familiarity with TypeScript concepts like [generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)\n     and [utility types](https://www.typescriptlang.org/docs/handbook/utility-types.html)\n    \n*   Knowledge of [React Hooks](https://reactjs.org/docs/hooks-intro.html)\n    \n\nOverview[​](https://redux.js.org/usage/usage-with-typescript#overview \"Direct link to heading\")\n\n------------------------------------------------------------------------------------------------\n\n**TypeScript** is a typed superset of JavaScript that provides compile-time checking of source code. When used with Redux, TypeScript can help provide:\n\n1.  Type safety for reducers, state and action creators, and UI components\n2.  Easy refactoring of typed code\n3.  A superior developer experience in a team environment\n\n[**We strongly recommend using TypeScript in Redux applications**](https://redux.js.org/style-guide/#use-static-typing)\n. However, like all tools, TypeScript has tradeoffs. It adds complexity in terms of writing additional code, understanding TS syntax, and building the application. At the same time, it provides value by catching errors earlier in development, enabling safer and more efficient refactoring, and acting as documentation for existing source code.\n\nWe believe that **[pragmatic use of TypeScript](https://blog.isquaredsoftware.com/2019/11/blogged-answers-learning-and-using-typescript/#pragmatism-is-vital)\n provides more than enough value and benefit to justify the added overhead**, especially in larger codebases, but you should take time to **evaluate the tradeoffs and decide whether it's worth using TS in your own application**.\n\nThere are multiple possible approaches to type checking Redux code. **This page shows our standard recommended patterns for using Redux and TypeScript together**, and is not an exhaustive guide. Following these patterns should result in a good TS usage experience, with **the best tradeoffs between type safety and amount of type declarations you have to add to your codebase**.\n\nStandard Redux Toolkit Project Setup with TypeScript[​](https://redux.js.org/usage/usage-with-typescript#standard-redux-toolkit-project-setup-with-typescript \"Direct link to heading\")\n\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWe assume that a typical Redux project is using Redux Toolkit and React Redux together.\n\n[Redux Toolkit](https://redux-toolkit.js.org/)\n (RTK) is the standard approach for writing modern Redux logic. RTK is already written in TypeScript, and its API is designed to provide a good experience for TypeScript usage.\n\n[React Redux](https://react-redux.js.org/)\n has its type definitions in a separate [`@types/react-redux` typedefs package](https://npm.im/@types/react-redux)\n on NPM. In addition to typing the library functions, the types also export some helpers to make it easier to write typesafe interfaces between your Redux store and your React components.\n\nAs of React Redux v7.2.3, the `react-redux` package has a dependency on `@types/react-redux`, so the type definitions will be automatically installed with the library. Otherwise, you'll need to manually install them yourself (typically `npm install @types/react-redux` ).\n\nThe [Redux+TS template for Create-React-App](https://github.com/reduxjs/cra-template-redux-typescript)\n comes with a working example of these patterns already configured.\n\n### Define Root State and Dispatch Types[​](https://redux.js.org/usage/usage-with-typescript#define-root-state-and-dispatch-types \"Direct link to heading\")\n\nUsing [configureStore](https://redux-toolkit.js.org/api/configureStore)\n should not need any additional typings. You will, however, want to extract the `RootState` type and the `Dispatch` type so that they can be referenced as needed. Inferring these types from the store itself means that they correctly update as you add more state slices or modify middleware settings.\n\nSince those are types, it's safe to export them directly from your store setup file such as `app/store.ts` and import them directly into other files.\n\napp/store.ts\n\n    import { configureStore } from '@reduxjs/toolkit'// ...export const store = configureStore({  reducer: {    posts: postsReducer,    comments: commentsReducer,    users: usersReducer  }})// Get the type of our store variableexport type AppStore = typeof store// Infer the `RootState` and `AppDispatch` types from the store itselfexport type RootState = ReturnType<AppStore['getState']>// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}export type AppDispatch = AppStore['dispatch']\n\n### Define Typed Hooks[​](https://redux.js.org/usage/usage-with-typescript#define-typed-hooks \"Direct link to heading\")\n\nWhile it's possible to import the `RootState` and `AppDispatch` types into each component, it's better to **create pre-typed versions of the `useDispatch` and `useSelector` hooks for usage in your application**. This is important for a couple reasons:\n\n*   For `useSelector`, it saves you the need to type `(state: RootState)` every time\n*   For `useDispatch`, the default `Dispatch` type does not know about thunks or other middleware. In order to correctly dispatch thunks, you need to use the specific customized `AppDispatch` type from the store that includes the thunk middleware types, and use that with `useDispatch`. Adding a pre-typed `useDispatch` hook keeps you from forgetting to import `AppDispatch` where it's needed.\n\nSince these are actual variables, not types, it's important to define them in a separate file such as `app/hooks.ts`, not the store setup file. This allows you to import them into any component file that needs to use the hooks, and avoids potential circular import dependency issues.\n\n#### `.withTypes()`[​](https://redux.js.org/usage/usage-with-typescript#withtypes \"Direct link to heading\")\n\nPreviously, the approach for \"pre-typing\" hooks with your app setting was a little varied. The result would look something like the snippet below:\n\napp/hooks.ts\n\n    import type { TypedUseSelectorHook } from 'react-redux'import { useDispatch, useSelector, useStore } from 'react-redux'import type { AppDispatch, AppStore, RootState } from './store'// Use throughout your app instead of plain `useDispatch` and `useSelector`export const useAppDispatch: () => AppDispatch = useDispatchexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelectorexport const useAppStore: () => AppStore = useStore\n\nReact Redux v9.1.0 adds a new `.withTypes` method to each of these hooks, analogous to the [`.withTypes`](https://redux-toolkit.js.org/usage/usage-with-typescript#defining-a-pre-typed-createasyncthunk)\n method found on Redux Toolkit's `createAsyncThunk`.\n\nThe setup now becomes:\n\napp/hooks.ts\n\n    import { useDispatch, useSelector, useStore } from 'react-redux'import type { AppDispatch, AppStore, RootState } from './store'// Use throughout your app instead of plain `useDispatch` and `useSelector`export const useAppDispatch = useDispatch.withTypes<AppDispatch>()export const useAppSelector = useSelector.withTypes<RootState>()export const useAppStore = useStore.withTypes<AppStore>()\n\nApplication Usage[​](https://redux.js.org/usage/usage-with-typescript#application-usage \"Direct link to heading\")\n\n------------------------------------------------------------------------------------------------------------------\n\n### Define Slice State and Action Types[​](https://redux.js.org/usage/usage-with-typescript#define-slice-state-and-action-types \"Direct link to heading\")\n\nEach slice file should define a type for its initial state value, so that `createSlice` can correctly infer the type of `state` in each case reducer.\n\nAll generated actions should be defined using the `PayloadAction<T>` type from Redux Toolkit, which takes the type of the `action.payload` field as its generic argument.\n\nYou can safely import the `RootState` type from the store file here. It's a circular import, but the TypeScript compiler can correctly handle that for types. This may be needed for use cases like writing selector functions.\n\nfeatures/counter/counterSlice.ts\n\n    import { createSlice, PayloadAction } from '@reduxjs/toolkit'import type { RootState } from '../../app/store'// Define a type for the slice stateinterface CounterState {  value: number}// Define the initial state using that typeconst initialState: CounterState = {  value: 0}export const counterSlice = createSlice({  name: 'counter',  // `createSlice` will infer the state type from the `initialState` argument  initialState,  reducers: {    increment: state => {      state.value += 1    },    decrement: state => {      state.value -= 1    },    // Use the PayloadAction type to declare the contents of `action.payload`    incrementByAmount: (state, action: PayloadAction<number>) => {      state.value += action.payload    }  }})export const { increment, decrement, incrementByAmount } = counterSlice.actions// Other code such as selectors can use the imported `RootState` typeexport const selectCount = (state: RootState) => state.counter.valueexport default counterSlice.reducer\n\nThe generated action creators will be correctly typed to accept a `payload` argument based on the `PayloadAction<T>` type you provided for the reducer. For example, `incrementByAmount` requires a `number` as its argument.\n\nIn some cases, [TypeScript may unnecessarily tighten the type of the initial state](https://github.com/reduxjs/redux-toolkit/pull/827)\n. If that happens, you can work around it by casting the initial state using `as`, instead of declaring the type of the variable:\n\n    // Workaround: cast state instead of declaring variable typeconst initialState = {  value: 0} as CounterState\n\n### Use Typed Hooks in Components[​](https://redux.js.org/usage/usage-with-typescript#use-typed-hooks-in-components \"Direct link to heading\")\n\nIn component files, import the pre-typed hooks instead of the standard hooks from React Redux.\n\nfeatures/counter/Counter.tsx\n\n    import React, { useState } from 'react'import { useAppSelector, useAppDispatch } from 'app/hooks'import { decrement, increment } from './counterSlice'export function Counter() {  // The `state` arg is correctly typed as `RootState` already  const count = useAppSelector(state => state.counter.value)  const dispatch = useAppDispatch()  // omit rendering logic}\n\nWarn about wrong imports\n\nESLint can help your team import the right hooks easily. The [typescript-eslint/no-restricted-imports](https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-restricted-imports.md)\n rule can show a warning when the wrong import is used accidentally.\n\nYou could add this to your ESLint config as an example:\n\n    \"no-restricted-imports\": \"off\",\"@typescript-eslint/no-restricted-imports\": [  \"warn\",  {    \"name\": \"react-redux\",    \"importNames\": [\"useSelector\", \"useDispatch\"],    \"message\": \"Use typed hooks `useAppDispatch` and `useAppSelector` instead.\"  }],\n\nTyping Additional Redux Logic[​](https://redux.js.org/usage/usage-with-typescript#typing-additional-redux-logic \"Direct link to heading\")\n\n------------------------------------------------------------------------------------------------------------------------------------------\n\n### Type Checking Reducers[​](https://redux.js.org/usage/usage-with-typescript#type-checking-reducers \"Direct link to heading\")\n\n[Reducers](https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers)\n are pure functions that receive the current `state` and incoming `action` as arguments, and return a new state.\n\nIf you are using Redux Toolkit's `createSlice`, you should rarely need to specifically type a reducer separately. If you do actually write a standalone reducer, it's typically sufficient to declare the type of the `initialState` value, and type the `action` as `UnknownAction`:\n\n    import { UnknownAction } from 'redux'interface CounterState {  value: number}const initialState: CounterState = {  value: 0}export default function counterReducer(  state = initialState,  action: UnknownAction) {  // logic here}\n\nHowever, the Redux core does export a `Reducer<State, Action>` type you can use as well.\n\n### Type Checking Middleware[​](https://redux.js.org/usage/usage-with-typescript#type-checking-middleware \"Direct link to heading\")\n\n[Middleware](https://redux.js.org/tutorials/fundamentals/part-4-store#middleware)\n are an extension mechanism for the Redux store. Middleware are composed into a pipeline that wrap the store's `dispatch` method, and have access to the store's `dispatch` and `getState` methods.\n\nThe Redux core exports a `Middleware` type that can be used to correctly type a middleware function:\n\n    export interface Middleware<  DispatchExt = {}, // optional override return behavior of `dispatch`  S = any, // type of the Redux store state  D extends Dispatch = Dispatch // type of the dispatch method>\n\nA custom middleware should use the `Middleware` type, and pass the generic args for `S` (state) and `D` (dispatch) if needed:\n\n    import { Middleware } from 'redux'import { RootState } from '../store'export const exampleMiddleware: Middleware<  {}, // Most middleware do not modify the dispatch return value  RootState> = storeApi => next => action => {  const state = storeApi.getState() // correctly typed as RootState}\n\ncaution\n\nIf you are using `typescript-eslint`, the `@typescript-eslint/ban-types` rule might report an error if you use `{}` for the dispatch value. The recommended changes it makes are incorrect and will break your Redux store types, you should disable the rule for this line and keep using `{}`.\n\nThe dispatch generic should likely only be needed if you are dispatching additional thunks within the middleware.\n\nIn cases where `type RootState = ReturnType<typeof store.getState>` is used, a [circular type reference between the middleware and store definitions](https://github.com/reduxjs/redux/issues/4267)\n can be avoided by switching the type definition of `RootState` to:\n\n    const rootReducer = combineReducers({ ... });type RootState = ReturnType<typeof rootReducer>;\n\nSwitching the type definition of `RootState` with Redux Toolkit example:\n\n    // instead of defining the reducers in the reducer field of configureStore, combine them here:const rootReducer = combineReducers({ counter: counterReducer })// then set rootReducer as the reducer object of configureStoreconst store = configureStore({  reducer: rootReducer,  middleware: getDefaultMiddleware =>    getDefaultMiddleware().concat(yourMiddleware)})type RootState = ReturnType<typeof rootReducer>\n\n### Type Checking Redux Thunks[​](https://redux.js.org/usage/usage-with-typescript#type-checking-redux-thunks \"Direct link to heading\")\n\n[Redux Thunk](https://github.com/reduxjs/redux-thunk)\n is the standard middleware for writing sync and async logic that interacts with the Redux store. A thunk function receives `dispatch` and `getState` as its parameters. Redux Thunk has a built in `ThunkAction` type which we can use to define types for those arguments:\n\n    export type ThunkAction<  R, // Return type of the thunk function  S, // state type used by getState  E, // any \"extra argument\" injected into the thunk  A extends Action // known types of actions that can be dispatched> = (dispatch: ThunkDispatch<S, E, A>, getState: () => S, extraArgument: E) => R\n\nYou will typically want to provide the `R` (return type) and `S` (state) generic arguments. Unfortunately, TS does not allow only providing _some_ generic arguments, so the usual values for the other arguments are `unknown` for `E` and `UnknownAction` for `A`:\n\n    import { UnknownAction } from 'redux'import { sendMessage } from './store/chat/actions'import { RootState } from './store'import { ThunkAction } from 'redux-thunk'export const thunkSendMessage =  (message: string): ThunkAction<void, RootState, unknown, UnknownAction> =>  async dispatch => {    const asyncResp = await exampleAPI()    dispatch(      sendMessage({        message,        user: asyncResp,        timestamp: new Date().getTime()      })    )  }function exampleAPI() {  return Promise.resolve('Async Chat Bot')}\n\nTo reduce repetition, you might want to define a reusable `AppThunk` type once, in your store file, and then use that type whenever you write a thunk:\n\n    export type AppThunk<ReturnType = void> = ThunkAction<  ReturnType,  RootState,  unknown,  UnknownAction>\n\nNote that this assumes that there is no meaningful return value from the thunk. If your thunk returns a promise and you want to [use the returned promise after dispatching the thunk](https://redux.js.org/tutorials/essentials/part-5-async-logic#checking-thunk-results-in-components)\n, you'd want to use this as `AppThunk<Promise<SomeReturnType>>`.\n\ncaution\n\nDon't forget that **the default `useDispatch` hook does not know about thunks**, and so dispatching a thunk will cause a type error. Be sure to [use an updated form of `Dispatch` in your components that recognizes thunks as an acceptable type to dispatch](https://redux.js.org/usage/usage-with-typescript#define-root-state-and-dispatch-types)\n.\n\nUsage with React Redux[​](https://redux.js.org/usage/usage-with-typescript#usage-with-react-redux \"Direct link to heading\")\n\n----------------------------------------------------------------------------------------------------------------------------\n\nWhile [React Redux](https://react-redux.js.org/)\n is a separate library from Redux itself, it is commonly used with React.\n\nFor a complete guide on how to correctly use React Redux with TypeScript, see **[the \"Static Typing\" page in the React Redux docs](https://react-redux.js.org/using-react-redux/static-typing)\n**. This section will highlight the standard patterns.\n\nIf you are using TypeScript, the React Redux types are maintained separately in DefinitelyTyped, but included as a dependency of the react-redux package, so they should be installed automatically. If you still need to install them manually, run:\n\n    npm install @types/react-redux\n\n### Typing the `useSelector` hook[​](https://redux.js.org/usage/usage-with-typescript#typing-the-useselector-hook \"Direct link to heading\")\n\nDeclare the type of the `state` parameter in the selector function, and the return type of `useSelector` will be inferred to match the return type of the selector:\n\n    interface RootState {  isOn: boolean}// TS infers type: (state: RootState) => booleanconst selectIsOn = (state: RootState) => state.isOn// TS infers `isOn` is booleanconst isOn = useSelector(selectIsOn)\n\nThis can also be done inline as well:\n\n    const isOn = useSelector((state: RootState) => state.isOn)\n\nHowever, prefer creating a pre-typed `useAppSelector` hook with the correct type of `state` built-in instead.\n\n### Typing the `useDispatch` hook[​](https://redux.js.org/usage/usage-with-typescript#typing-the-usedispatch-hook \"Direct link to heading\")\n\nBy default, the return value of `useDispatch` is the standard `Dispatch` type defined by the Redux core types, so no declarations are needed:\n\n    const dispatch = useDispatch()\n\nHowever, prefer creating a pre-typed `useAppDispatch` hook with the correct type of `Dispatch` built-in instead.\n\n### Typing the `connect` higher order component[​](https://redux.js.org/usage/usage-with-typescript#typing-the-connect-higher-order-component \"Direct link to heading\")\n\nIf you are still using `connect`, you should use the `ConnectedProps<T>` type exported by `@types/react-redux^7.1.2` to infer the types of the props from `connect` automatically. This requires splitting the `connect(mapState, mapDispatch)(MyComponent)` call into two parts:\n\n    import { connect, ConnectedProps } from 'react-redux'interface RootState {  isOn: boolean}const mapState = (state: RootState) => ({  isOn: state.isOn})const mapDispatch = {  toggleOn: () => ({ type: 'TOGGLE_IS_ON' })}const connector = connect(mapState, mapDispatch)// The inferred type will look like:// {isOn: boolean, toggleOn: () => void}type PropsFromRedux = ConnectedProps<typeof connector>type Props = PropsFromRedux & {  backgroundColor: string}const MyComponent = (props: Props) => (  <div style={{ backgroundColor: props.backgroundColor }}>    <button onClick={props.toggleOn}>      Toggle is {props.isOn ? 'ON' : 'OFF'}    </button>  </div>)export default connector(MyComponent)\n\nUsage with Redux Toolkit[​](https://redux.js.org/usage/usage-with-typescript#usage-with-redux-toolkit \"Direct link to heading\")\n\n--------------------------------------------------------------------------------------------------------------------------------\n\nThe [Standard Redux Toolkit Project Setup with TypeScript](https://redux.js.org/usage/usage-with-typescript#standard-redux-toolkit-project-setup-with-typescript)\n section already covered the normal usage patterns for `configureStore` and `createSlice`, and the [Redux Toolkit \"Usage with TypeScript\" page](https://redux-toolkit.js.org/usage/usage-with-typescript)\n covers all of the RTK APIs in detail.\n\nHere are some additional typing patterns you will commonly see when using RTK.\n\n### Typing `configureStore`[​](https://redux.js.org/usage/usage-with-typescript#typing-configurestore \"Direct link to heading\")\n\n`configureStore` infers the type of the state value from the provided root reducer function, so no specific type declarations should be needed.\n\nIf you want to add additional middleware to the store, be sure to use the specialized `.concat()` and `.prepend()` methods included in the array returned by `getDefaultMiddleware()`, as those will correctly preserve the types of the middleware you're adding. (Using plain JS array spreads often loses those types.)\n\n    const store = configureStore({  reducer: rootReducer,  middleware: getDefaultMiddleware =>    getDefaultMiddleware()      .prepend(        // correctly typed middlewares can just be used        additionalMiddleware,        // you can also type middlewares manually        untypedMiddleware as Middleware<          (action: Action<'specialAction'>) => number,          RootState        >      )      // prepend and concat calls can be chained      .concat(logger)})\n\n### Matching Actions[​](https://redux.js.org/usage/usage-with-typescript#matching-actions \"Direct link to heading\")\n\nRTK-generated action creators have a `match` method that acts as a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)\n. Calling `someActionCreator.match(action)` will do a string comparison against the `action.type` string, and if used as a condition, narrow the type of `action` down to be the correct TS type:\n\n    const increment = createAction<number>('increment')function test(action: Action) {  if (increment.match(action)) {    // action.payload inferred correctly here    const num = 5 + action.payload  }}\n\nThis is particularly useful when checking for action types in Redux middleware, such as custom middleware, `redux-observable`, and RxJS's `filter` method.\n\n### Typing `createSlice`[​](https://redux.js.org/usage/usage-with-typescript#typing-createslice \"Direct link to heading\")\n\n#### Defining Separate Case Reducers[​](https://redux.js.org/usage/usage-with-typescript#defining-separate-case-reducers \"Direct link to heading\")\n\nIf you have too many case reducers and defining them inline would be messy, or you want to reuse case reducers across slices, you can also define them outside the `createSlice` call and type them as `CaseReducer`:\n\n    type State = numberconst increment: CaseReducer<State, PayloadAction<number>> = (state, action) =>  state + action.payloadcreateSlice({  name: 'test',  initialState: 0,  reducers: {    increment  }})\n\n#### Typing `extraReducers`[​](https://redux.js.org/usage/usage-with-typescript#typing-extrareducers \"Direct link to heading\")\n\nIf you are adding an `extraReducers` field in `createSlice`, be sure to use the \"builder callback\" form, as the \"plain object\" form cannot infer action types correctly. Passing an RTK-generated action creator to `builder.addCase()` will correctly infer the type of the `action`:\n\n    const usersSlice = createSlice({  name: 'users',  initialState,  reducers: {    // fill in primary logic here  },  extraReducers: builder => {    builder.addCase(fetchUserById.pending, (state, action) => {      // both `state` and `action` are now correctly typed      // based on the slice state and the `pending` action creator    })  }})\n\n#### Typing `prepare` Callbacks[​](https://redux.js.org/usage/usage-with-typescript#typing-prepare-callbacks \"Direct link to heading\")\n\nIf you want to add a `meta` or `error` property to your action, or customize the `payload` of your action, you have to use the `prepare` notation for defining the case reducer. Using this notation with TypeScript looks like:\n\n    const blogSlice = createSlice({  name: 'blogData',  initialState,  reducers: {    receivedAll: {      reducer(        state,        action: PayloadAction<Page[], string, { currentPage: number }>      ) {        state.all = action.payload        state.meta = action.meta      },      prepare(payload: Page[], currentPage: number) {        return { payload, meta: { currentPage } }      }    }  }})\n\n#### Fixing Circular Types in Exported Slices[​](https://redux.js.org/usage/usage-with-typescript#fixing-circular-types-in-exported-slices \"Direct link to heading\")\n\nFinally, on rare occasions you might need to export the slice reducer with a specific type in order to break a circular type dependency problem. This might look like:\n\n    export default counterSlice.reducer as Reducer<Counter>\n\n### Typing `createAsyncThunk`[​](https://redux.js.org/usage/usage-with-typescript#typing-createasyncthunk \"Direct link to heading\")\n\nFor basic usage, the only type you need to provide for `createAsyncThunk` is the type of the single argument for your payload creation callback. You should also ensure that the return value of the callback is typed correctly:\n\n    const fetchUserById = createAsyncThunk(  'users/fetchById',  // Declare the type your function argument here:  async (userId: number) => {    const response = await fetch(`https://reqres.in/api/users/${userId}`)    // Inferred return type: Promise<MyData>    return (await response.json()) as MyData  })// the parameter of `fetchUserById` is automatically inferred to `number` here// and dispatching the resulting thunkAction will return a Promise of a correctly// typed \"fulfilled\" or \"rejected\" action.const lastReturnedAction = await store.dispatch(fetchUserById(3))\n\nIf you need to modify the types of the `thunkApi` parameter, such as supplying the type of the `state` returned by `getState()`, you must supply the first two generic arguments for return type and payload argument, plus whichever \"thunkApi argument fields\" are relevant in an object:\n\n    const fetchUserById = createAsyncThunk<  // Return type of the payload creator  MyData,  // First argument to the payload creator  number,  {    // Optional fields for defining thunkApi field types    dispatch: AppDispatch    state: State    extra: {      jwt: string    }  }>('users/fetchById', async (userId, thunkApi) => {  const response = await fetch(`https://reqres.in/api/users/${userId}`, {    headers: {      Authorization: `Bearer ${thunkApi.extra.jwt}`    }  })  return (await response.json()) as MyData})\n\n### Typing `createEntityAdapter`[​](https://redux.js.org/usage/usage-with-typescript#typing-createentityadapter \"Direct link to heading\")\n\nUsage of `createEntityAdapter` with Typescript varies based on whether your entities are normalized by an `id` property, or whether a custom `selectId` is needed.\n\nIf your entities are normalized by an `id` property, `createEntityAdapter` only requires you to specify the entity type as the single generic argument. For example:\n\n    interface Book {  id: number  title: string}// no selectId needed here, as the entity has an `id` property we can default toconst booksAdapter = createEntityAdapter<Book>({  sortComparer: (a, b) => a.title.localeCompare(b.title)})const booksSlice = createSlice({  name: 'books',  // The type of the state is inferred here  initialState: booksAdapter.getInitialState(),  reducers: {    bookAdded: booksAdapter.addOne,    booksReceived(state, action: PayloadAction<{ books: Book[] }>) {      booksAdapter.setAll(state, action.payload.books)    }  }})\n\nOn the other hand, if the entity needs to be normalized by a different property, we instead recommend passing a custom `selectId` function and annotating there. This allows proper inference of the ID's type, instead of having to provide it manually.\n\n    interface Book {  bookId: number  title: string  // ...}const booksAdapter = createEntityAdapter({  selectId: (book: Book) => book.bookId,  sortComparer: (a, b) => a.title.localeCompare(b.title)})const booksSlice = createSlice({  name: 'books',  // The type of the state is inferred here  initialState: booksAdapter.getInitialState(),  reducers: {    bookAdded: booksAdapter.addOne,    booksReceived(state, action: PayloadAction<{ books: Book[] }>) {      booksAdapter.setAll(state, action.payload.books)    }  }})\n\nAdditional Recommendations[​](https://redux.js.org/usage/usage-with-typescript#additional-recommendations \"Direct link to heading\")\n\n------------------------------------------------------------------------------------------------------------------------------------\n\n### Use the React Redux Hooks API[​](https://redux.js.org/usage/usage-with-typescript#use-the-react-redux-hooks-api \"Direct link to heading\")\n\n**We recommend using the React Redux hooks API as the default approach**. The hooks API is much simpler to use with TypeScript, as `useSelector` is a simple hook that takes a selector function, and the return type is easily inferred from the type of the `state` argument.\n\nWhile `connect` still works fine, and _can_ be typed, it's much more difficult to type correctly.\n\n### Avoid Action Type Unions[​](https://redux.js.org/usage/usage-with-typescript#avoid-action-type-unions \"Direct link to heading\")\n\n**We specifically recommend _against_ trying to create unions of action types**, as it provides no real benefit and actually misleads the compiler in some ways. See RTK maintainer Lenz Weber's post [Do Not Create Union Types with Redux Action Types](https://phryneas.de/redux-typescript-no-discriminating-union)\n for an explanation of why this is a problem.\n\nIn addition, if you're using `createSlice`, you already know that all actions defined by that slice are being handled correctly.\n\nResources[​](https://redux.js.org/usage/usage-with-typescript#resources \"Direct link to heading\")\n\n--------------------------------------------------------------------------------------------------\n\nFor further information, see these additional resources:\n\n*   Redux library documentation:\n    *   [React Redux docs: Static Typing](https://react-redux.js.org/using-react-redux/static-typing)\n        : Examples of how to use the React Redux APIs with TypeScript\n    *   [Redux Toolkit docs: Usage with TypeScript](https://redux-toolkit.js.org/usage/usage-with-typescript)\n        : Examples of how to use the Redux Toolkit APIs with TypeScript\n*   React + Redux + TypeScript guides:\n    *   [React+TypeScript Cheatsheet](https://github.com/typescript-cheatsheets/react-typescript-cheatsheet)\n        : a comprehensive guide to using React with TypeScript\n    *   [React + Redux in TypeScript Guide](https://github.com/piotrwitek/react-redux-typescript-guide)\n        : extensive information on patterns for using React and Redux with TypeScript\n        *   _Note: while this guide has some useful info, many of the patterns it shows go against our recommended practices shown in this page, such as using action type unions. We link this out of completeness_\n*   Other articles:\n    *   [Do Not Create Union Types with Redux Action Types](https://phryneas.de/redux-typescript-no-discriminating-union)\n        \n    *   [Redux with Code-Splitting and Type Checking](https://www.matthewgerstman.com/tech/redux-code-split-typecheck/)\n        \n\n*   [Overview](https://redux.js.org/usage/usage-with-typescript#overview)\n    \n*   [Standard Redux Toolkit Project Setup with TypeScript](https://redux.js.org/usage/usage-with-typescript#standard-redux-toolkit-project-setup-with-typescript)\n    *   [Define Root State and Dispatch Types](https://redux.js.org/usage/usage-with-typescript#define-root-state-and-dispatch-types)\n        \n    *   [Define Typed Hooks](https://redux.js.org/usage/usage-with-typescript#define-typed-hooks)\n        *   [`.withTypes()`](https://redux.js.org/usage/usage-with-typescript#withtypes)\n            \n*   [Application Usage](https://redux.js.org/usage/usage-with-typescript#application-usage)\n    *   [Define Slice State and Action Types](https://redux.js.org/usage/usage-with-typescript#define-slice-state-and-action-types)\n        \n    *   [Use Typed Hooks in Components](https://redux.js.org/usage/usage-with-typescript#use-typed-hooks-in-components)\n        \n*   [Typing Additional Redux Logic](https://redux.js.org/usage/usage-with-typescript#typing-additional-redux-logic)\n    *   [Type Checking Reducers](https://redux.js.org/usage/usage-with-typescript#type-checking-reducers)\n        \n    *   [Type Checking Middleware](https://redux.js.org/usage/usage-with-typescript#type-checking-middleware)\n        \n    *   [Type Checking Redux Thunks](https://redux.js.org/usage/usage-with-typescript#type-checking-redux-thunks)\n        \n*   [Usage with React Redux](https://redux.js.org/usage/usage-with-typescript#usage-with-react-redux)\n    *   [Typing the `useSelector` hook](https://redux.js.org/usage/usage-with-typescript#typing-the-useselector-hook)\n        \n    *   [Typing the `useDispatch` hook](https://redux.js.org/usage/usage-with-typescript#typing-the-usedispatch-hook)\n        \n    *   [Typing the `connect` higher order component](https://redux.js.org/usage/usage-with-typescript#typing-the-connect-higher-order-component)\n        \n*   [Usage with Redux Toolkit](https://redux.js.org/usage/usage-with-typescript#usage-with-redux-toolkit)\n    *   [Typing `configureStore`](https://redux.js.org/usage/usage-with-typescript#typing-configurestore)\n        \n    *   [Matching Actions](https://redux.js.org/usage/usage-with-typescript#matching-actions)\n        \n    *   [Typing `createSlice`](https://redux.js.org/usage/usage-with-typescript#typing-createslice)\n        *   [Defining Separate Case Reducers](https://redux.js.org/usage/usage-with-typescript#defining-separate-case-reducers)\n            \n        *   [Typing `extraReducers`](https://redux.js.org/usage/usage-with-typescript#typing-extrareducers)\n            \n        *   [Typing `prepare` Callbacks](https://redux.js.org/usage/usage-with-typescript#typing-prepare-callbacks)\n            \n        *   [Fixing Circular Types in Exported Slices](https://redux.js.org/usage/usage-with-typescript#fixing-circular-types-in-exported-slices)\n            \n    *   [Typing `createAsyncThunk`](https://redux.js.org/usage/usage-with-typescript#typing-createasyncthunk)\n        \n    *   [Typing `createEntityAdapter`](https://redux.js.org/usage/usage-with-typescript#typing-createentityadapter)\n        \n*   [Additional Recommendations](https://redux.js.org/usage/usage-with-typescript#additional-recommendations)\n    *   [Use the React Redux Hooks API](https://redux.js.org/usage/usage-with-typescript#use-the-react-redux-hooks-api)\n        \n    *   [Avoid Action Type Unions](https://redux.js.org/usage/usage-with-typescript#avoid-action-type-unions)\n        \n*   [Resources](https://redux.js.org/usage/usage-with-typescript#resources)","metadata":{"og:description":"- Standard patterns for setting up a Redux app with TypeScript","ogDescription":"- Standard patterns for setting up a Redux app with TypeScript","docsearch:docusaurus_tag":"docs-default-current","title":"Usage With TypeScript | Redux","docusaurus_tag":"docs-default-current","favicon":"https://redux.js.org/img/favicon/favicon.ico","docsearch:language":"en","twitter:image":"https://redux.js.org/img/redux-logo-landscape.png","twitter:card":"summary","ogTitle":"Usage With TypeScript | Redux","ogImage":"https://redux.js.org/img/redux-logo-landscape.png","docsearch:version":"current","og:title":"Usage With TypeScript | Redux","generator":"Docusaurus v2.2.0","language":"en","og:url":"https://redux.js.org/usage/usage-with-typescript","docusaurus_locale":"en","viewport":"width=device-width, initial-scale=1.0","ogUrl":"https://redux.js.org/usage/usage-with-typescript","og:image":"https://redux.js.org/img/redux-logo-landscape.png","description":"- Standard patterns for setting up a Redux app with TypeScript","docusaurus_version":"current","scrapeId":"851a3ccc-1c2e-4725-9464-dbcca861a6c5","sourceURL":"https://redux.js.org/usage/usage-with-typescript","url":"https://redux.js.org/usage/usage-with-typescript","statusCode":200}}]}