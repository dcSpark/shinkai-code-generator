{"success":true,"status":"completed","completed":2,"total":2,"creditsUsed":2,"expiresAt":"2025-03-05T20:53:59.000Z","data":[{"markdown":"*   [Docs](https://beautiful-soup-4.readthedocs.io/en/latest/#)\n     »\n*   Beautiful Soup Documentation\n*   [View page source](https://beautiful-soup-4.readthedocs.io/en/latest/_sources/index.rst.txt)\n    \n\n* * *\n\nBeautiful Soup Documentation[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#beautiful-soup-documentation \"Permalink to this headline\")\n\n==============================================================================================================================================\n\n![\"The Fish-Footman began by producing from under his arm a great letter, nearly as large as himself.\"](https://beautiful-soup-4.readthedocs.io/en/latest/_images/6.1.jpg)\n\n[Beautiful Soup](http://www.crummy.com/software/BeautifulSoup/)\n is a Python library for pulling data out of HTML and XML files. It works with your favorite parser to provide idiomatic ways of navigating, searching, and modifying the parse tree. It commonly saves programmers hours or days of work.\n\nThese instructions illustrate all major features of Beautiful Soup 4, with examples. I show you what the library is good for, how it works, how to use it, how to make it do what you want, and what to do when it violates your expectations.\n\nThis document covers Beautiful Soup version 4.8.1. The examples in this documentation should work the same way in Python 2.7 and Python 3.2.\n\nYou might be looking for the documentation for [Beautiful Soup 3](http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html)\n. If so, you should know that Beautiful Soup 3 is no longer being developed and that support for it will be dropped on or after December 31, 2020. If you want to learn about the differences between Beautiful Soup 3 and Beautiful Soup 4, see [Porting code to BS4](https://beautiful-soup-4.readthedocs.io/en/latest/#porting-code-to-bs4)\n.\n\nThis documentation has been translated into other languages by Beautiful Soup users:\n\n*   [这篇文档当然还有中文版.](https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/)\n    \n*   このページは日本語で利用できます([外部リンク](http://kondou.com/BS4/)\n    )\n*   [이 문서는 한국어 번역도 가능합니다.](https://www.crummy.com/software/BeautifulSoup/bs4/doc.ko/)\n    \n*   [Este documento também está disponível em Português do Brasil.](https://www.crummy.com/software/BeautifulSoup/bs4/doc.ptbr/)\n    \n\nGetting help[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#getting-help \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------\n\nIf you have questions about Beautiful Soup, or run into problems, [send mail to the discussion group](https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup)\n. If your problem involves parsing an HTML document, be sure to mention [what the diagnose() function says](https://beautiful-soup-4.readthedocs.io/en/latest/#diagnose)\n about that document.\n\nQuick Start[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#quick-start \"Permalink to this headline\")\n\n============================================================================================================\n\nHere’s an HTML document I’ll be using as an example throughout this document. It’s part of a story from Alice in Wonderland:\n\nhtml\\_doc \\= \"\"\"\n<html><head><title>The Dormouse's story</title></head>\n<body>\n<p class=\"title\"><b>The Dormouse's story</b></p>\n\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie</a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n\n<p class=\"story\">...</p>\n\"\"\"\n\nRunning the “three sisters” document through Beautiful Soup gives us a `BeautifulSoup` object, which represents the document as a nested data structure:\n\nfrom bs4 import BeautifulSoup\nsoup \\= BeautifulSoup(html\\_doc, 'html.parser')\n\nprint(soup.prettify())\n\\# <html>\n\\#  <head>\n\\#   <title>\n\\#    The Dormouse's story\n\\#   </title>\n\\#  </head>\n\\#  <body>\n\\#   <p class=\"title\">\n\\#    <b>\n\\#     The Dormouse's story\n\\#    </b>\n\\#   </p>\n\\#   <p class=\"story\">\n\\#    Once upon a time there were three little sisters; and their names were\n\\#    <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">\n\\#     Elsie\n\\#    </a>\n\\#    ,\n\\#    <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">\n\\#     Lacie\n\\#    </a>\n\\#    and\n\\#    <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link2\">\n\\#     Tillie\n\\#    </a>\n\\#    ; and they lived at the bottom of a well.\n\\#   </p>\n\\#   <p class=\"story\">\n\\#    ...\n\\#   </p>\n\\#  </body>\n\\# </html>\n\nHere are some simple ways to navigate that data structure:\n\nsoup.title\n\\# <title>The Dormouse's story</title>\n\nsoup.title.name\n\\# u'title'\n\nsoup.title.string\n\\# u'The Dormouse's story'\n\nsoup.title.parent.name\n\\# u'head'\n\nsoup.p\n\\# <p class=\"title\"><b>The Dormouse's story</b></p>\n\nsoup.p\\['class'\\]\n\\# u'title'\n\nsoup.a\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\n\nsoup.find\\_all('a')\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nsoup.find(id\\=\"link3\")\n\\# <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\n\nOne common task is extracting all the URLs found within a page’s <a> tags:\n\nfor link in soup.find\\_all('a'):\n    print(link.get('href'))\n\\# http://example.com/elsie\n\\# http://example.com/lacie\n\\# http://example.com/tillie\n\nAnother common task is extracting all the text from a page:\n\nprint(soup.get\\_text())\n\\# The Dormouse's story\n#\n\\# The Dormouse's story\n#\n\\# Once upon a time there were three little sisters; and their names were\n\\# Elsie,\n\\# Lacie and\n\\# Tillie;\n\\# and they lived at the bottom of a well.\n#\n\\# ...\n\nDoes this look like what you need? If so, read on.\n\nInstalling Beautiful Soup[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#installing-beautiful-soup \"Permalink to this headline\")\n\n========================================================================================================================================\n\nIf you’re using a recent version of Debian or Ubuntu Linux, you can install Beautiful Soup with the system package manager:\n\n$ apt-get install python-bs4 (for Python 2)\n\n$ apt-get install python3-bs4 (for Python 3)\n\nBeautiful Soup 4 is published through PyPi, so if you can’t install it with the system packager, you can install it with `easy_install` or `pip`. The package name is `beautifulsoup4`, and the same package works on Python 2 and Python 3. Make sure you use the right version of `pip` or `easy_install` for your Python version (these may be named `pip3` and `easy_install3` respectively if you’re using Python 3).\n\n$ easy\\_install beautifulsoup4\n\n$ pip install beautifulsoup4\n\n(The `BeautifulSoup` package is probably not what you want. That’s the previous major release, [Beautiful Soup 3](http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html)\n. Lots of software uses BS3, so it’s still available, but if you’re writing new code you should install `beautifulsoup4`.)\n\nIf you don’t have `easy_install` or `pip` installed, you can [download the Beautiful Soup 4 source tarball](http://www.crummy.com/software/BeautifulSoup/download/4.x/)\n and install it with `setup.py`.\n\n$ python setup.py install\n\nIf all else fails, the license for Beautiful Soup allows you to package the entire library with your application. You can download the tarball, copy its `bs4` directory into your application’s codebase, and use Beautiful Soup without installing it at all.\n\nI use Python 2.7 and Python 3.2 to develop Beautiful Soup, but it should work with other recent versions.\n\nProblems after installation[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#problems-after-installation \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------------------------------------\n\nBeautiful Soup is packaged as Python 2 code. When you install it for use with Python 3, it’s automatically converted to Python 3 code. If you don’t install the package, the code won’t be converted. There have also been reports on Windows machines of the wrong version being installed.\n\nIf you get the `ImportError` “No module named HTMLParser”, your problem is that you’re running the Python 2 version of the code under Python 3.\n\nIf you get the `ImportError` “No module named html.parser”, your problem is that you’re running the Python 3 version of the code under Python 2.\n\nIn both cases, your best bet is to completely remove the Beautiful Soup installation from your system (including any directory created when you unzipped the tarball) and try the installation again.\n\nIf you get the `SyntaxError` “Invalid syntax” on the line `ROOT_TAG_NAME = u'[document]'`, you need to convert the Python 2 code to Python 3. You can do this either by installing the package:\n\n$ python3 setup.py install\n\nor by manually running Python’s `2to3` conversion script on the `bs4` directory:\n\n$ 2to3-3.2 -w bs4\n\nInstalling a parser[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#installing-a-parser \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------------\n\nBeautiful Soup supports the HTML parser included in Python’s standard library, but it also supports a number of third-party Python parsers. One is the [lxml parser](http://lxml.de/)\n. Depending on your setup, you might install lxml with one of these commands:\n\n$ apt-get install python-lxml\n\n$ easy\\_install lxml\n\n$ pip install lxml\n\nAnother alternative is the pure-Python [html5lib parser](http://code.google.com/p/html5lib/)\n, which parses HTML the way a web browser does. Depending on your setup, you might install html5lib with one of these commands:\n\n$ apt-get install python-html5lib\n\n$ easy\\_install html5lib\n\n$ pip install html5lib\n\nThis table summarizes the advantages and disadvantages of each parser library:\n\n|     |     |     |     |\n| --- | --- | --- | --- |   \n| Parser | Typical usage | Advantages | Disadvantages |\n| Python’s html.parser | `BeautifulSoup(markup, \"html.parser\")` | *   Batteries included<br>*   Decent speed<br>*   Lenient (As of Python 2.7.3 and 3.2.) | *   Not as fast as lxml, less lenient than html5lib. |\n| lxml’s HTML parser | `BeautifulSoup(markup, \"lxml\")` | *   Very fast<br>*   Lenient | *   External C dependency |\n| lxml’s XML parser | `BeautifulSoup(markup, \"lxml-xml\")` `BeautifulSoup(markup, \"xml\")` | *   Very fast<br>*   The only currently supported XML parser | *   External C dependency |\n| html5lib | `BeautifulSoup(markup, \"html5lib\")` | *   Extremely lenient<br>*   Parses pages the same way a web browser does<br>*   Creates valid HTML5 | *   Very slow<br>*   External Python dependency |\n\nIf you can, I recommend you install and use lxml for speed. If you’re using a version of Python 2 earlier than 2.7.3, or a version of Python 3 earlier than 3.2.2, it’s essential that you install lxml or html5lib–Python’s built-in HTML parser is just not very good in older versions.\n\nNote that if a document is invalid, different parsers will generate different Beautiful Soup trees for it. See [Differences between parsers](https://beautiful-soup-4.readthedocs.io/en/latest/#differences-between-parsers)\n for details.\n\nMaking the soup[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#making-the-soup \"Permalink to this headline\")\n\n====================================================================================================================\n\nTo parse a document, pass it into the `BeautifulSoup` constructor. You can pass in a string or an open filehandle:\n\nfrom bs4 import BeautifulSoup\n\nwith open(\"index.html\") as fp:\n    soup \\= BeautifulSoup(fp)\n\nsoup \\= BeautifulSoup(\"<html>data</html>\")\n\nFirst, the document is converted to Unicode, and HTML entities are converted to Unicode characters:\n\nBeautifulSoup(\"Sacr&eacute; bleu!\")\n<html><head></head><body>Sacré bleu!</body></html>\n\nBeautiful Soup then parses the document using the best available parser. It will use an HTML parser unless you specifically tell it to use an XML parser. (See [Parsing XML](https://beautiful-soup-4.readthedocs.io/en/latest/#id17)\n.)\n\nKinds of objects[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#kinds-of-objects \"Permalink to this headline\")\n\n======================================================================================================================\n\nBeautiful Soup transforms a complex HTML document into a complex tree of Python objects. But you’ll only ever have to deal with about four kinds of objects: `Tag`, `NavigableString`, `BeautifulSoup`, and `Comment`.\n\n`Tag`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#tag \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------\n\nA `Tag` object corresponds to an XML or HTML tag in the original document:\n\nsoup \\= BeautifulSoup('<b class=\"boldest\">Extremely bold</b>')\ntag \\= soup.b\ntype(tag)\n\\# <class 'bs4.element.Tag'>\n\nTags have a lot of attributes and methods, and I’ll cover most of them in [Navigating the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#navigating-the-tree)\n and [Searching the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-the-tree)\n. For now, the most important features of a tag are its name and attributes.\n\n### Name[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#name \"Permalink to this headline\")\n\nEvery tag has a name, accessible as `.name`:\n\ntag.name\n\\# u'b'\n\nIf you change a tag’s name, the change will be reflected in any HTML markup generated by Beautiful Soup:\n\ntag.name \\= \"blockquote\"\ntag\n\\# <blockquote class=\"boldest\">Extremely bold</blockquote>\n\n### Attributes[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#attributes \"Permalink to this headline\")\n\nA tag may have any number of attributes. The tag `<b id=\"boldest\">` has an attribute “id” whose value is “boldest”. You can access a tag’s attributes by treating the tag like a dictionary:\n\ntag\\['id'\\]\n\\# u'boldest'\n\nYou can access that dictionary directly as `.attrs`:\n\ntag.attrs\n\\# {u'id': 'boldest'}\n\nYou can add, remove, and modify a tag’s attributes. Again, this is done by treating the tag as a dictionary:\n\ntag\\['id'\\] \\= 'verybold'\ntag\\['another-attribute'\\] \\= 1\ntag\n\\# <b another-attribute=\"1\" id=\"verybold\"></b>\n\ndel tag\\['id'\\]\ndel tag\\['another-attribute'\\]\ntag\n\\# <b></b>\n\ntag\\['id'\\]\n\\# KeyError: 'id'\nprint(tag.get('id'))\n\\# None\n\n#### Multi-valued attributes[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#multi-valued-attributes \"Permalink to this headline\")\n\nHTML 4 defines a few attributes that can have multiple values. HTML 5 removes a couple of them, but defines a few more. The most common multi-valued attribute is `class` (that is, a tag can have more than one CSS class). Others include `rel`, `rev`, `accept-charset`, `headers`, and `accesskey`. Beautiful Soup presents the value(s) of a multi-valued attribute as a list:\n\ncss\\_soup \\= BeautifulSoup('<p class=\"body\"></p>')\ncss\\_soup.p\\['class'\\]\n\\# \\[\"body\"\\]\n\ncss\\_soup \\= BeautifulSoup('<p class=\"body strikeout\"></p>')\ncss\\_soup.p\\['class'\\]\n\\# \\[\"body\", \"strikeout\"\\]\n\nIf an attribute looks like it has more than one value, but it’s not a multi-valued attribute as defined by any version of the HTML standard, Beautiful Soup will leave the attribute alone:\n\nid\\_soup \\= BeautifulSoup('<p id=\"my id\"></p>')\nid\\_soup.p\\['id'\\]\n\\# 'my id'\n\nWhen you turn a tag back into a string, multiple attribute values are consolidated:\n\nrel\\_soup \\= BeautifulSoup('<p>Back to the <a rel=\"index\">homepage</a></p>')\nrel\\_soup.a\\['rel'\\]\n\\# \\['index'\\]\nrel\\_soup.a\\['rel'\\] \\= \\['index', 'contents'\\]\nprint(rel\\_soup.p)\n\\# <p>Back to the <a rel=\"index contents\">homepage</a></p>\n\nYou can disable this by passing `multi_valued_attributes=None` as a keyword argument into the `BeautifulSoup` constructor:\n\nno\\_list\\_soup \\= BeautifulSoup('<p class=\"body strikeout\"></p>', 'html', multi\\_valued\\_attributes\\=None)\nno\\_list\\_soup.p\\['class'\\]\n\\# u'body strikeout'\n\nYou can use `` `get_attribute_list `` to get a value that’s always a list, whether or not it’s a multi-valued atribute:\n\nid\\_soup.p.get\\_attribute\\_list('id')\n\\# \\[\"my id\"\\]\n\nIf you parse a document as XML, there are no multi-valued attributes:\n\nxml\\_soup \\= BeautifulSoup('<p class=\"body strikeout\"></p>', 'xml')\nxml\\_soup.p\\['class'\\]\n\\# u'body strikeout'\n\nAgain, you can configure this using the `multi_valued_attributes` argument:\n\nclass\\_is\\_multi\\= { '\\*' : 'class'}\nxml\\_soup \\= BeautifulSoup('<p class=\"body strikeout\"></p>', 'xml', multi\\_valued\\_attributes\\=class\\_is\\_multi)\nxml\\_soup.p\\['class'\\]\n\\# \\[u'body', u'strikeout'\\]\n\nYou probably won’t need to do this, but if you do, use the defaults as a guide. They implement the rules described in the HTML specification:\n\nfrom bs4.builder import builder\\_registry\nbuilder\\_registry.lookup('html').DEFAULT\\_CDATA\\_LIST\\_ATTRIBUTES\n\n`NavigableString`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#navigablestring \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------\n\nA string corresponds to a bit of text within a tag. Beautiful Soup uses the `NavigableString` class to contain these bits of text:\n\ntag.string\n\\# u'Extremely bold'\ntype(tag.string)\n\\# <class 'bs4.element.NavigableString'>\n\nA `NavigableString` is just like a Python Unicode string, except that it also supports some of the features described in [Navigating the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#navigating-the-tree)\n and [Searching the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-the-tree)\n. You can convert a `NavigableString` to a Unicode string with `unicode()`:\n\nunicode\\_string \\= unicode(tag.string)\nunicode\\_string\n\\# u'Extremely bold'\ntype(unicode\\_string)\n\\# <type 'unicode'>\n\nYou can’t edit a string in place, but you can replace one string with another, using [replace\\_with()](https://beautiful-soup-4.readthedocs.io/en/latest/#replace-with)\n:\n\ntag.string.replace\\_with(\"No longer bold\")\ntag\n\\# <blockquote>No longer bold</blockquote>\n\n`NavigableString` supports most of the features described in [Navigating the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#navigating-the-tree)\n and [Searching the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-the-tree)\n, but not all of them. In particular, since a string can’t contain anything (the way a tag may contain a string or another tag), strings don’t support the `.contents` or `.string` attributes, or the `find()` method.\n\nIf you want to use a `NavigableString` outside of Beautiful Soup, you should call `unicode()` on it to turn it into a normal Python Unicode string. If you don’t, your string will carry around a reference to the entire Beautiful Soup parse tree, even when you’re done using Beautiful Soup. This is a big waste of memory.\n\n`BeautifulSoup`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#beautifulsoup \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------------------\n\nThe `BeautifulSoup` object represents the parsed document as a whole. For most purposes, you can treat it as a [Tag](https://beautiful-soup-4.readthedocs.io/en/latest/#tag)\n object. This means it supports most of the methods described in [Navigating the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#navigating-the-tree)\n and [Searching the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-the-tree)\n.\n\nYou can also pass a `BeautifulSoup` object into one of the methods defined in [Modifying the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#modifying-the-tree)\n, just as you would a [Tag](https://beautiful-soup-4.readthedocs.io/en/latest/#tag)\n. This lets you do things like combine two parsed documents:\n\ndoc \\= BeautifulSoup(\"<document><content/>INSERT FOOTER HERE</document\", \"xml\")\nfooter \\= BeautifulSoup(\"<footer>Here's the footer</footer>\", \"xml\")\ndoc.find(text\\=\"INSERT FOOTER HERE\").replace\\_with(footer)\n\\# u'INSERT FOOTER HERE'\nprint(doc)\n\\# <?xml version=\"1.0\" encoding=\"utf-8\"?>\n\\# <document><content/><footer>Here's the footer</footer></document>\n\nSince the `BeautifulSoup` object doesn’t correspond to an actual HTML or XML tag, it has no name and no attributes. But sometimes it’s useful to look at its `.name`, so it’s been given the special `.name` “\\[document\\]”:\n\nsoup.name\n\\# u'\\[document\\]'\n\nComments and other special strings[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#comments-and-other-special-strings \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n`Tag`, `NavigableString`, and `BeautifulSoup` cover almost everything you’ll see in an HTML or XML file, but there are a few leftover bits. The only one you’ll probably ever need to worry about is the comment:\n\nmarkup \\= \"<b><!--Hey, buddy. Want to buy a used parser?--></b>\"\nsoup \\= BeautifulSoup(markup)\ncomment \\= soup.b.string\ntype(comment)\n\\# <class 'bs4.element.Comment'>\n\nThe `Comment` object is just a special type of `NavigableString`:\n\ncomment\n\\# u'Hey, buddy. Want to buy a used parser'\n\nBut when it appears as part of an HTML document, a `Comment` is displayed with special formatting:\n\nprint(soup.b.prettify())\n\\# <b>\n\\#  <!--Hey, buddy. Want to buy a used parser?-->\n\\# </b>\n\nBeautiful Soup defines classes for anything else that might show up in an XML document: `CData`, `ProcessingInstruction`, `Declaration`, and `Doctype`. Just like `Comment`, these classes are subclasses of `NavigableString` that add something extra to the string. Here’s an example that replaces the comment with a CDATA block:\n\nfrom bs4 import CData\ncdata \\= CData(\"A CDATA block\")\ncomment.replace\\_with(cdata)\n\nprint(soup.b.prettify())\n\\# <b>\n\\#  <!\\[CDATA\\[A CDATA block\\]\\]>\n\\# </b>\n\nNavigating the tree[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#navigating-the-tree \"Permalink to this headline\")\n\n============================================================================================================================\n\nHere’s the “Three sisters” HTML document again:\n\nhtml\\_doc \\= \"\"\"\n<html><head><title>The Dormouse's story</title></head>\n<body>\n<p class=\"title\"><b>The Dormouse's story</b></p>\n\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie</a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n\n<p class=\"story\">...</p>\n\"\"\"\n\nfrom bs4 import BeautifulSoup\nsoup \\= BeautifulSoup(html\\_doc, 'html.parser')\n\nI’ll use this as an example to show you how to move from one part of a document to another.\n\nGoing down[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#going-down \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------\n\nTags may contain strings and other tags. These elements are the tag’s children. Beautiful Soup provides a lot of different attributes for navigating and iterating over a tag’s children.\n\nNote that Beautiful Soup strings don’t support any of these attributes, because a string can’t have children.\n\n### Navigating using tag names[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#navigating-using-tag-names \"Permalink to this headline\")\n\nThe simplest way to navigate the parse tree is to say the name of the tag you want. If you want the <head> tag, just say `soup.head`:\n\nsoup.head\n\\# <head><title>The Dormouse's story</title></head>\n\nsoup.title\n\\# <title>The Dormouse's story</title>\n\nYou can do use this trick again and again to zoom in on a certain part of the parse tree. This code gets the first <b> tag beneath the <body> tag:\n\nsoup.body.b\n\\# <b>The Dormouse's story</b>\n\nUsing a tag name as an attribute will give you only the first tag by that name:\n\nsoup.a\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\n\nIf you need to get all the <a> tags, or anything more complicated than the first tag with a certain name, you’ll need to use one of the methods described in [Searching the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-the-tree)\n, such as find\\_all():\n\nsoup.find\\_all('a')\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\n### `.contents` and `.children`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#contents-and-children \"Permalink to this headline\")\n\nA tag’s children are available in a list called `.contents`:\n\nhead\\_tag \\= soup.head\nhead\\_tag\n\\# <head><title>The Dormouse's story</title></head>\n\nhead\\_tag.contents\n\\[<title\\>The Dormouse's story</title>\\]\n\ntitle\\_tag \\= head\\_tag.contents\\[0\\]\ntitle\\_tag\n\\# <title>The Dormouse's story</title>\ntitle\\_tag.contents\n\\# \\[u'The Dormouse's story'\\]\n\nThe `BeautifulSoup` object itself has children. In this case, the <html> tag is the child of the `BeautifulSoup` object.:\n\nlen(soup.contents)\n\\# 1\nsoup.contents\\[0\\].name\n\\# u'html'\n\nA string does not have `.contents`, because it can’t contain anything:\n\ntext \\= title\\_tag.contents\\[0\\]\ntext.contents\n\\# AttributeError: 'NavigableString' object has no attribute 'contents'\n\nInstead of getting them as a list, you can iterate over a tag’s children using the `.children` generator:\n\nfor child in title\\_tag.children:\n    print(child)\n\\# The Dormouse's story\n\n### `.descendants`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#descendants \"Permalink to this headline\")\n\nThe `.contents` and `.children` attributes only consider a tag’s direct children. For instance, the <head> tag has a single direct child–the <title> tag:\n\nhead\\_tag.contents\n\\# \\[<title>The Dormouse's story</title>\\]\n\nBut the <title> tag itself has a child: the string “The Dormouse’s story”. There’s a sense in which that string is also a child of the <head> tag. The `.descendants` attribute lets you iterate over all of a tag’s children, recursively: its direct children, the children of its direct children, and so on:\n\nfor child in head\\_tag.descendants:\n    print(child)\n\\# <title>The Dormouse's story</title>\n\\# The Dormouse's story\n\nThe <head> tag has only one child, but it has two descendants: the <title> tag and the <title> tag’s child. The `BeautifulSoup` object only has one direct child (the <html> tag), but it has a whole lot of descendants:\n\nlen(list(soup.children))\n\\# 1\nlen(list(soup.descendants))\n\\# 25\n\n### `.string`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#string \"Permalink to this headline\")\n\nIf a tag has only one child, and that child is a `NavigableString`, the child is made available as `.string`:\n\ntitle\\_tag.string\n\\# u'The Dormouse's story'\n\nIf a tag’s only child is another tag, and that tag has a `.string`, then the parent tag is considered to have the same `.string` as its child:\n\nhead\\_tag.contents\n\\# \\[<title>The Dormouse's story</title>\\]\n\nhead\\_tag.string\n\\# u'The Dormouse's story'\n\nIf a tag contains more than one thing, then it’s not clear what `.string` should refer to, so `.string` is defined to be `None`:\n\nprint(soup.html.string)\n\\# None\n\n### `.strings` and `stripped_strings`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#strings-and-stripped-strings \"Permalink to this headline\")\n\nIf there’s more than one thing inside a tag, you can still look at just the strings. Use the `.strings` generator:\n\nfor string in soup.strings:\n    print(repr(string))\n\\# u\"The Dormouse's story\"\n\\# u'\\\\n\\\\n'\n\\# u\"The Dormouse's story\"\n\\# u'\\\\n\\\\n'\n\\# u'Once upon a time there were three little sisters; and their names were\\\\n'\n\\# u'Elsie'\n\\# u',\\\\n'\n\\# u'Lacie'\n\\# u' and\\\\n'\n\\# u'Tillie'\n\\# u';\\\\nand they lived at the bottom of a well.'\n\\# u'\\\\n\\\\n'\n\\# u'...'\n\\# u'\\\\n'\n\nThese strings tend to have a lot of extra whitespace, which you can remove by using the `.stripped_strings` generator instead:\n\nfor string in soup.stripped\\_strings:\n    print(repr(string))\n\\# u\"The Dormouse's story\"\n\\# u\"The Dormouse's story\"\n\\# u'Once upon a time there were three little sisters; and their names were'\n\\# u'Elsie'\n\\# u','\n\\# u'Lacie'\n\\# u'and'\n\\# u'Tillie'\n\\# u';\\\\nand they lived at the bottom of a well.'\n\\# u'...'\n\nHere, strings consisting entirely of whitespace are ignored, and whitespace at the beginning and end of strings is removed.\n\nGoing up[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#going-up \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------\n\nContinuing the “family tree” analogy, every tag and every string has a parent: the tag that contains it.\n\n### `.parent`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#parent \"Permalink to this headline\")\n\nYou can access an element’s parent with the `.parent` attribute. In the example “three sisters” document, the <head> tag is the parent of the <title> tag:\n\ntitle\\_tag \\= soup.title\ntitle\\_tag\n\\# <title>The Dormouse's story</title>\ntitle\\_tag.parent\n\\# <head><title>The Dormouse's story</title></head>\n\nThe title string itself has a parent: the <title> tag that contains it:\n\ntitle\\_tag.string.parent\n\\# <title>The Dormouse's story</title>\n\nThe parent of a top-level tag like <html> is the `BeautifulSoup` object itself:\n\nhtml\\_tag \\= soup.html\ntype(html\\_tag.parent)\n\\# <class 'bs4.BeautifulSoup'>\n\nAnd the `.parent` of a `BeautifulSoup` object is defined as None:\n\nprint(soup.parent)\n\\# None\n\n### `.parents`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#parents \"Permalink to this headline\")\n\nYou can iterate over all of an element’s parents with `.parents`. This example uses `.parents` to travel from an <a> tag buried deep within the document, to the very top of the document:\n\nlink \\= soup.a\nlink\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\nfor parent in link.parents:\n    if parent is None:\n        print(parent)\n    else:\n        print(parent.name)\n\\# p\n\\# body\n\\# html\n\\# \\[document\\]\n\\# None\n\nGoing sideways[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#going-sideways \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------------------\n\nConsider a simple document like this:\n\nsibling\\_soup \\= BeautifulSoup(\"<a><b>text1</b><c>text2</c></b></a>\")\nprint(sibling\\_soup.prettify())\n\\# <html>\n\\#  <body>\n\\#   <a>\n\\#    <b>\n\\#     text1\n\\#    </b>\n\\#    <c>\n\\#     text2\n\\#    </c>\n\\#   </a>\n\\#  </body>\n\\# </html>\n\nThe <b> tag and the <c> tag are at the same level: they’re both direct children of the same tag. We call them siblings. When a document is pretty-printed, siblings show up at the same indentation level. You can also use this relationship in the code you write.\n\n### `.next_sibling` and `.previous_sibling`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#next-sibling-and-previous-sibling \"Permalink to this headline\")\n\nYou can use `.next_sibling` and `.previous_sibling` to navigate between page elements that are on the same level of the parse tree:\n\nsibling\\_soup.b.next\\_sibling\n\\# <c>text2</c>\n\nsibling\\_soup.c.previous\\_sibling\n\\# <b>text1</b>\n\nThe <b> tag has a `.next_sibling`, but no `.previous_sibling`, because there’s nothing before the <b> tag on the same level of the tree. For the same reason, the <c> tag has a `.previous_sibling` but no `.next_sibling`:\n\nprint(sibling\\_soup.b.previous\\_sibling)\n\\# None\nprint(sibling\\_soup.c.next\\_sibling)\n\\# None\n\nThe strings “text1” and “text2” are not siblings, because they don’t have the same parent:\n\nsibling\\_soup.b.string\n\\# u'text1'\n\nprint(sibling\\_soup.b.string.next\\_sibling)\n\\# None\n\nIn real documents, the `.next_sibling` or `.previous_sibling` of a tag will usually be a string containing whitespace. Going back to the “three sisters” document:\n\n<a href\\=\"http://example.com/elsie\" class\\=\"sister\" id\\=\"link1\"\\>Elsie</a\\>\n<a href\\=\"http://example.com/lacie\" class\\=\"sister\" id\\=\"link2\"\\>Lacie</a\\>\n<a href\\=\"http://example.com/tillie\" class\\=\"sister\" id\\=\"link3\"\\>Tillie</a\\>\n\nYou might think that the `.next_sibling` of the first <a> tag would be the second <a> tag. But actually, it’s a string: the comma and newline that separate the first <a> tag from the second:\n\nlink \\= soup.a\nlink\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\n\nlink.next\\_sibling\n\\# u',\\\\n'\n\nThe second <a> tag is actually the `.next_sibling` of the comma:\n\nlink.next\\_sibling.next\\_sibling\n\\# <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\n\n### `.next_siblings` and `.previous_siblings`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#next-siblings-and-previous-siblings \"Permalink to this headline\")\n\nYou can iterate over a tag’s siblings with `.next_siblings` or `.previous_siblings`:\n\nfor sibling in soup.a.next\\_siblings:\n    print(repr(sibling))\n\\# u',\\\\n'\n\\# <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\n\\# u' and\\\\n'\n\\# <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\n\\# u'; and they lived at the bottom of a well.'\n\\# None\n\nfor sibling in soup.find(id\\=\"link3\").previous\\_siblings:\n    print(repr(sibling))\n\\# ' and\\\\n'\n\\# <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\n\\# u',\\\\n'\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\n\\# u'Once upon a time there were three little sisters; and their names were\\\\n'\n\\# None\n\nGoing back and forth[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#going-back-and-forth \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------------------------------\n\nTake a look at the beginning of the “three sisters” document:\n\n<html\\><head\\><title\\>The Dormouse's story</title></head>\n<p class\\=\"title\"\\><b\\>The Dormouse's story</b></p>\n\nAn HTML parser takes this string of characters and turns it into a series of events: “open an <html> tag”, “open a <head> tag”, “open a <title> tag”, “add a string”, “close the <title> tag”, “open a <p> tag”, and so on. Beautiful Soup offers tools for reconstructing the initial parse of the document.\n\n### `.next_element` and `.previous_element`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#next-element-and-previous-element \"Permalink to this headline\")\n\nThe `.next_element` attribute of a string or tag points to whatever was parsed immediately afterwards. It might be the same as `.next_sibling`, but it’s usually drastically different.\n\nHere’s the final <a> tag in the “three sisters” document. Its `.next_sibling` is a string: the conclusion of the sentence that was interrupted by the start of the <a> tag.:\n\nlast\\_a\\_tag \\= soup.find(\"a\", id\\=\"link3\")\nlast\\_a\\_tag\n\\# <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\n\nlast\\_a\\_tag.next\\_sibling\n\\# '; and they lived at the bottom of a well.'\n\nBut the `.next_element` of that <a> tag, the thing that was parsed immediately after the <a> tag, is not the rest of that sentence: it’s the word “Tillie”:\n\nlast\\_a\\_tag.next\\_element\n\\# u'Tillie'\n\nThat’s because in the original markup, the word “Tillie” appeared before that semicolon. The parser encountered an <a> tag, then the word “Tillie”, then the closing </a> tag, then the semicolon and rest of the sentence. The semicolon is on the same level as the <a> tag, but the word “Tillie” was encountered first.\n\nThe `.previous_element` attribute is the exact opposite of `.next_element`. It points to whatever element was parsed immediately before this one:\n\nlast\\_a\\_tag.previous\\_element\n\\# u' and\\\\n'\nlast\\_a\\_tag.previous\\_element.next\\_element\n\\# <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\n\n### `.next_elements` and `.previous_elements`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#next-elements-and-previous-elements \"Permalink to this headline\")\n\nYou should get the idea by now. You can use these iterators to move forward or backward in the document as it was parsed:\n\nfor element in last\\_a\\_tag.next\\_elements:\n    print(repr(element))\n\\# u'Tillie'\n\\# u';\\\\nand they lived at the bottom of a well.'\n\\# u'\\\\n\\\\n'\n\\# <p class=\"story\">...</p>\n\\# u'...'\n\\# u'\\\\n'\n\\# None\n\nSearching the tree[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-the-tree \"Permalink to this headline\")\n\n==========================================================================================================================\n\nBeautiful Soup defines a lot of methods for searching the parse tree, but they’re all very similar. I’m going to spend a lot of time explaining the two most popular methods: `find()` and `find_all()`. The other methods take almost exactly the same arguments, so I’ll just cover them briefly.\n\nOnce again, I’ll be using the “three sisters” document as an example:\n\nhtml\\_doc \\= \"\"\"\n<html><head><title>The Dormouse's story</title></head>\n<body>\n<p class=\"title\"><b>The Dormouse's story</b></p>\n\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie</a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n\n<p class=\"story\">...</p>\n\"\"\"\n\nfrom bs4 import BeautifulSoup\nsoup \\= BeautifulSoup(html\\_doc, 'html.parser')\n\nBy passing in a filter to an argument like `find_all()`, you can zoom in on the parts of the document you’re interested in.\n\nKinds of filters[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#kinds-of-filters \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------\n\nBefore talking in detail about `find_all()` and similar methods, I want to show examples of different filters you can pass into these methods. These filters show up again and again, throughout the search API. You can use them to filter based on a tag’s name, on its attributes, on the text of a string, or on some combination of these.\n\n### A string[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#a-string \"Permalink to this headline\")\n\nThe simplest filter is a string. Pass a string to a search method and Beautiful Soup will perform a match against that exact string. This code finds all the <b> tags in the document:\n\nsoup.find\\_all('b')\n\\# \\[<b>The Dormouse's story</b>\\]\n\nIf you pass in a byte string, Beautiful Soup will assume the string is encoded as UTF-8. You can avoid this by passing in a Unicode string instead.\n\n### A regular expression[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#a-regular-expression \"Permalink to this headline\")\n\nIf you pass in a regular expression object, Beautiful Soup will filter against that regular expression using its `search()` method. This code finds all the tags whose names start with the letter “b”; in this case, the <body> tag and the <b> tag:\n\nimport re\nfor tag in soup.find\\_all(re.compile(\"^b\")):\n    print(tag.name)\n\\# body\n\\# b\n\nThis code finds all the tags whose names contain the letter ‘t’:\n\nfor tag in soup.find\\_all(re.compile(\"t\")):\n    print(tag.name)\n\\# html\n\\# title\n\n### A list[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#a-list \"Permalink to this headline\")\n\nIf you pass in a list, Beautiful Soup will allow a string match against any item in that list. This code finds all the <a> tags and all the <b> tags:\n\nsoup.find\\_all(\\[\"a\", \"b\"\\])\n\\# \\[<b>The Dormouse's story</b>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\n### `True`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#true \"Permalink to this headline\")\n\nThe value `True` matches everything it can. This code finds all the tags in the document, but none of the text strings:\n\nfor tag in soup.find\\_all(True):\n    print(tag.name)\n\\# html\n\\# head\n\\# title\n\\# body\n\\# p\n\\# b\n\\# p\n\\# a\n\\# a\n\\# a\n\\# p\n\n### A function[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#a-function \"Permalink to this headline\")\n\nIf none of the other matches work for you, define a function that takes an element as its only argument. The function should return `True` if the argument matches, and `False` otherwise.\n\nHere’s a function that returns `True` if a tag defines the “class” attribute but doesn’t define the “id” attribute:\n\ndef has\\_class\\_but\\_no\\_id(tag):\n    return tag.has\\_attr('class') and not tag.has\\_attr('id')\n\nPass this function into `find_all()` and you’ll pick up all the <p> tags:\n\nsoup.find\\_all(has\\_class\\_but\\_no\\_id)\n\\# \\[<p class=\"title\"><b>The Dormouse's story</b></p>,\\\n\\#  <p class=\"story\">Once upon a time there were...</p>,\\\n\\#  <p class=\"story\">...</p>\\]\n\nThis function only picks up the <p> tags. It doesn’t pick up the <a> tags, because those tags define both “class” and “id”. It doesn’t pick up tags like <html> and <title>, because those tags don’t define “class”.\n\nIf you pass in a function to filter on a specific attribute like `href`, the argument passed into the function will be the attribute value, not the whole tag. Here’s a function that finds all `a` tags whose `href` attribute _does not_ match a regular expression:\n\ndef not\\_lacie(href):\n    return href and not re.compile(\"lacie\").search(href)\nsoup.find\\_all(href\\=not\\_lacie)\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nThe function can be as complicated as you need it to be. Here’s a function that returns `True` if a tag is surrounded by string objects:\n\nfrom bs4 import NavigableString\ndef surrounded\\_by\\_strings(tag):\n    return (isinstance(tag.next\\_element, NavigableString)\n            and isinstance(tag.previous\\_element, NavigableString))\n\nfor tag in soup.find\\_all(surrounded\\_by\\_strings):\n    print tag.name\n\\# p\n\\# a\n\\# a\n\\# a\n\\# p\n\nNow we’re ready to look at the search methods in detail.\n\n`find_all()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#find-all \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------\n\nSignature: find\\_all([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [recursive](https://beautiful-soup-4.readthedocs.io/en/latest/#recursive)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [limit](https://beautiful-soup-4.readthedocs.io/en/latest/#limit)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nThe `find_all()` method looks through a tag’s descendants and retrieves all descendants that match your filters. I gave several examples in [Kinds of filters](https://beautiful-soup-4.readthedocs.io/en/latest/#kinds-of-filters)\n, but here are a few more:\n\nsoup.find\\_all(\"title\")\n\\# \\[<title>The Dormouse's story</title>\\]\n\nsoup.find\\_all(\"p\", \"title\")\n\\# \\[<p class=\"title\"><b>The Dormouse's story</b></p>\\]\n\nsoup.find\\_all(\"a\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nsoup.find\\_all(id\\=\"link2\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\\]\n\nimport re\nsoup.find(string\\=re.compile(\"sisters\"))\n\\# u'Once upon a time there were three little sisters; and their names were\\\\n'\n\nSome of these should look familiar, but others are new. What does it mean to pass in a value for `string`, or `id`? Why does `find_all(\"p\", \"title\")` find a <p> tag with the CSS class “title”? Let’s look at the arguments to `find_all()`.\n\n### The `name` argument[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#the-name-argument \"Permalink to this headline\")\n\nPass in a value for `name` and you’ll tell Beautiful Soup to only consider tags with certain names. Text strings will be ignored, as will tags whose names that don’t match.\n\nThis is the simplest usage:\n\nsoup.find\\_all(\"title\")\n\\# \\[<title>The Dormouse's story</title>\\]\n\nRecall from [Kinds of filters](https://beautiful-soup-4.readthedocs.io/en/latest/#kinds-of-filters)\n that the value to `name` can be [a string](https://beautiful-soup-4.readthedocs.io/en/latest/#a-string)\n, [a regular expression](https://beautiful-soup-4.readthedocs.io/en/latest/#a-regular-expression)\n, [a list](https://beautiful-soup-4.readthedocs.io/en/latest/#a-list)\n, [a function](https://beautiful-soup-4.readthedocs.io/en/latest/#a-function)\n, or [the value True](https://beautiful-soup-4.readthedocs.io/en/latest/#the-value-true)\n.\n\n### The keyword arguments[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#the-keyword-arguments \"Permalink to this headline\")\n\nAny argument that’s not recognized will be turned into a filter on one of a tag’s attributes. If you pass in a value for an argument called `id`, Beautiful Soup will filter against each tag’s ‘id’ attribute:\n\nsoup.find\\_all(id\\='link2')\n\\# \\[<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\\]\n\nIf you pass in a value for `href`, Beautiful Soup will filter against each tag’s ‘href’ attribute:\n\nsoup.find\\_all(href\\=re.compile(\"elsie\"))\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\\]\n\nYou can filter an attribute based on [a string](https://beautiful-soup-4.readthedocs.io/en/latest/#a-string)\n, [a regular expression](https://beautiful-soup-4.readthedocs.io/en/latest/#a-regular-expression)\n, [a list](https://beautiful-soup-4.readthedocs.io/en/latest/#a-list)\n, [a function](https://beautiful-soup-4.readthedocs.io/en/latest/#a-function)\n, or [the value True](https://beautiful-soup-4.readthedocs.io/en/latest/#the-value-true)\n.\n\nThis code finds all tags whose `id` attribute has a value, regardless of what the value is:\n\nsoup.find\\_all(id\\=True)\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nYou can filter multiple attributes at once by passing in more than one keyword argument:\n\nsoup.find\\_all(href\\=re.compile(\"elsie\"), id\\='link1')\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">three</a>\\]\n\nSome attributes, like the data-\\* attributes in HTML 5, have names that can’t be used as the names of keyword arguments:\n\ndata\\_soup \\= BeautifulSoup('<div data-foo=\"value\">foo!</div>')\ndata\\_soup.find\\_all(data\\-foo\\=\"value\")\n\\# SyntaxError: keyword can't be an expression\n\nYou can use these attributes in searches by putting them into a dictionary and passing the dictionary into `find_all()` as the `attrs` argument:\n\ndata\\_soup.find\\_all(attrs\\={\"data-foo\": \"value\"})\n\\# \\[<div data-foo=\"value\">foo!</div>\\]\n\nYou can’t use a keyword argument to search for HTML’s ‘name’ element, because Beautiful Soup uses the `name` argument to contain the name of the tag itself. Instead, you can give a value to ‘name’ in the `attrs` argument:\n\nname\\_soup \\= BeautifulSoup('<input name=\"email\"/>')\nname\\_soup.find\\_all(name\\=\"email\")\n\\# \\[\\]\nname\\_soup.find\\_all(attrs\\={\"name\": \"email\"})\n\\# \\[<input name=\"email\"/>\\]\n\n### Searching by CSS class[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-by-css-class \"Permalink to this headline\")\n\nIt’s very useful to search for a tag that has a certain CSS class, but the name of the CSS attribute, “class”, is a reserved word in Python. Using `class` as a keyword argument will give you a syntax error. As of Beautiful Soup 4.1.2, you can search by CSS class using the keyword argument `class_`:\n\nsoup.find\\_all(\"a\", class\\_\\=\"sister\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nAs with any keyword argument, you can pass `class_` a string, a regular expression, a function, or `True`:\n\nsoup.find\\_all(class\\_\\=re.compile(\"itl\"))\n\\# \\[<p class=\"title\"><b>The Dormouse's story</b></p>\\]\n\ndef has\\_six\\_characters(css\\_class):\n    return css\\_class is not None and len(css\\_class) \\== 6\n\nsoup.find\\_all(class\\_\\=has\\_six\\_characters)\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\n[Remember](https://beautiful-soup-4.readthedocs.io/en/latest/#multivalue)\n that a single tag can have multiple values for its “class” attribute. When you search for a tag that matches a certain CSS class, you’re matching against any of its CSS classes:\n\ncss\\_soup \\= BeautifulSoup('<p class=\"body strikeout\"></p>')\ncss\\_soup.find\\_all(\"p\", class\\_\\=\"strikeout\")\n\\# \\[<p class=\"body strikeout\"></p>\\]\n\ncss\\_soup.find\\_all(\"p\", class\\_\\=\"body\")\n\\# \\[<p class=\"body strikeout\"></p>\\]\n\nYou can also search for the exact string value of the `class` attribute:\n\ncss\\_soup.find\\_all(\"p\", class\\_\\=\"body strikeout\")\n\\# \\[<p class=\"body strikeout\"></p>\\]\n\nBut searching for variants of the string value won’t work:\n\ncss\\_soup.find\\_all(\"p\", class\\_\\=\"strikeout body\")\n\\# \\[\\]\n\nIf you want to search for tags that match two or more CSS classes, you should use a CSS selector:\n\ncss\\_soup.select(\"p.strikeout.body\")\n\\# \\[<p class=\"body strikeout\"></p>\\]\n\nIn older versions of Beautiful Soup, which don’t have the `class_` shortcut, you can use the `attrs` trick mentioned above. Create a dictionary whose value for “class” is the string (or regular expression, or whatever) you want to search for:\n\nsoup.find\\_all(\"a\", attrs\\={\"class\": \"sister\"})\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\n### The `string` argument[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#the-string-argument \"Permalink to this headline\")\n\nWith `string` you can search for strings instead of tags. As with `name` and the keyword arguments, you can pass in [a string](https://beautiful-soup-4.readthedocs.io/en/latest/#a-string)\n, [a regular expression](https://beautiful-soup-4.readthedocs.io/en/latest/#a-regular-expression)\n, [a list](https://beautiful-soup-4.readthedocs.io/en/latest/#a-list)\n, [a function](https://beautiful-soup-4.readthedocs.io/en/latest/#a-function)\n, or [the value True](https://beautiful-soup-4.readthedocs.io/en/latest/#the-value-true)\n. Here are some examples:\n\nsoup.find\\_all(string\\=\"Elsie\")\n\\# \\[u'Elsie'\\]\n\nsoup.find\\_all(string\\=\\[\"Tillie\", \"Elsie\", \"Lacie\"\\])\n\\# \\[u'Elsie', u'Lacie', u'Tillie'\\]\n\nsoup.find\\_all(string\\=re.compile(\"Dormouse\"))\n\\[u\"The Dormouse's story\", u\"The Dormouse's story\"\\]\n\ndef is\\_the\\_only\\_string\\_within\\_a\\_tag(s):\n    \"\"\"Return True if this string is the only child of its parent tag.\"\"\"\n    return (s \\== s.parent.string)\n\nsoup.find\\_all(string\\=is\\_the\\_only\\_string\\_within\\_a\\_tag)\n\\# \\[u\"The Dormouse's story\", u\"The Dormouse's story\", u'Elsie', u'Lacie', u'Tillie', u'...'\\]\n\nAlthough `string` is for finding strings, you can combine it with arguments that find tags: Beautiful Soup will find all tags whose `.string` matches your value for `string`. This code finds the <a> tags whose `.string` is “Elsie”:\n\nsoup.find\\_all(\"a\", string\\=\"Elsie\")\n\\# \\[<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie</a>\\]\n\nThe `string` argument is new in Beautiful Soup 4.4.0. In earlier versions it was called `text`:\n\nsoup.find\\_all(\"a\", text\\=\"Elsie\")\n\\# \\[<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie</a>\\]\n\n### The `limit` argument[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#the-limit-argument \"Permalink to this headline\")\n\n`find_all()` returns all the tags and strings that match your filters. This can take a while if the document is large. If you don’t need all the results, you can pass in a number for `limit`. This works just like the LIMIT keyword in SQL. It tells Beautiful Soup to stop gathering results after it’s found a certain number.\n\nThere are three links in the “three sisters” document, but this code only finds the first two:\n\nsoup.find\\_all(\"a\", limit\\=2)\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\\]\n\n### The `recursive` argument[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#the-recursive-argument \"Permalink to this headline\")\n\nIf you call `mytag.find_all()`, Beautiful Soup will examine all the descendants of `mytag`: its children, its children’s children, and so on. If you only want Beautiful Soup to consider direct children, you can pass in `recursive=False`. See the difference here:\n\nsoup.html.find\\_all(\"title\")\n\\# \\[<title>The Dormouse's story</title>\\]\n\nsoup.html.find\\_all(\"title\", recursive\\=False)\n\\# \\[\\]\n\nHere’s that part of the document:\n\n<html\\>\n <head\\>\n  <title\\>\n   The Dormouse's story\n  </title\\>\n </head\\>\n...\n\nThe <title> tag is beneath the <html> tag, but it’s not directly beneath the <html> tag: the <head> tag is in the way. Beautiful Soup finds the <title> tag when it’s allowed to look at all descendants of the <html> tag, but when `recursive=False` restricts it to the <html> tag’s immediate children, it finds nothing.\n\nBeautiful Soup offers a lot of tree-searching methods (covered below), and they mostly take the same arguments as `find_all()`: `name`, `attrs`, `string`, `limit`, and the keyword arguments. But the `recursive` argument is different: `find_all()` and `find()` are the only methods that support it. Passing `recursive=False` into a method like `find_parents()` wouldn’t be very useful.\n\nCalling a tag is like calling `find_all()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#calling-a-tag-is-like-calling-find-all \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBecause `find_all()` is the most popular method in the Beautiful Soup search API, you can use a shortcut for it. If you treat the `BeautifulSoup` object or a `Tag` object as though it were a function, then it’s the same as calling `find_all()` on that object. These two lines of code are equivalent:\n\nsoup.find\\_all(\"a\")\nsoup(\"a\")\n\nThese two lines are also equivalent:\n\nsoup.title.find\\_all(string\\=True)\nsoup.title(string\\=True)\n\n`find()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#find \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------\n\nSignature: find([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [recursive](https://beautiful-soup-4.readthedocs.io/en/latest/#recursive)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nThe `find_all()` method scans the entire document looking for results, but sometimes you only want to find one result. If you know a document only has one <body> tag, it’s a waste of time to scan the entire document looking for more. Rather than passing in `limit=1` every time you call `find_all`, you can use the `find()` method. These two lines of code are nearly equivalent:\n\nsoup.find\\_all('title', limit\\=1)\n\\# \\[<title>The Dormouse's story</title>\\]\n\nsoup.find('title')\n\\# <title>The Dormouse's story</title>\n\nThe only difference is that `find_all()` returns a list containing the single result, and `find()` just returns the result.\n\nIf `find_all()` can’t find anything, it returns an empty list. If `find()` can’t find anything, it returns `None`:\n\nprint(soup.find(\"nosuchtag\"))\n\\# None\n\nRemember the `soup.head.title` trick from [Navigating using tag names](https://beautiful-soup-4.readthedocs.io/en/latest/#navigating-using-tag-names)\n? That trick works by repeatedly calling `find()`:\n\nsoup.head.title\n\\# <title>The Dormouse's story</title>\n\nsoup.find(\"head\").find(\"title\")\n\\# <title>The Dormouse's story</title>\n\n`find_parents()` and `find_parent()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#find-parents-and-find-parent \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nSignature: find\\_parents([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [limit](https://beautiful-soup-4.readthedocs.io/en/latest/#limit)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nSignature: find\\_parent([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nI spent a lot of time above covering `find_all()` and `find()`. The Beautiful Soup API defines ten other methods for searching the tree, but don’t be afraid. Five of these methods are basically the same as `find_all()`, and the other five are basically the same as `find()`. The only differences are in what parts of the tree they search.\n\nFirst let’s consider `find_parents()` and `find_parent()`. Remember that `find_all()` and `find()` work their way down the tree, looking at tag’s descendants. These methods do the opposite: they work their way up the tree, looking at a tag’s (or a string’s) parents. Let’s try them out, starting from a string buried deep in the “three daughters” document:\n\na\\_string \\= soup.find(string\\=\"Lacie\")\na\\_string\n\\# u'Lacie'\n\na\\_string.find\\_parents(\"a\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\\]\n\na\\_string.find\\_parent(\"p\")\n\\# <p class=\"story\">Once upon a time there were three little sisters; and their names were\n\\#  <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a> and\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>;\n\\#  and they lived at the bottom of a well.</p>\n\na\\_string.find\\_parents(\"p\", class\\=\"title\")\n\\# \\[\\]\n\nOne of the three <a> tags is the direct parent of the string in question, so our search finds it. One of the three <p> tags is an indirect parent of the string, and our search finds that as well. There’s a <p> tag with the CSS class “title” somewhere in the document, but it’s not one of this string’s parents, so we can’t find it with `find_parents()`.\n\nYou may have made the connection between `find_parent()` and `find_parents()`, and the [.parent](https://beautiful-soup-4.readthedocs.io/en/latest/#parent)\n and [.parents](https://beautiful-soup-4.readthedocs.io/en/latest/#parents)\n attributes mentioned earlier. The connection is very strong. These search methods actually use `.parents` to iterate over all the parents, and check each one against the provided filter to see if it matches.\n\n`find_next_siblings()` and `find_next_sibling()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#find-next-siblings-and-find-next-sibling \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nSignature: find\\_next\\_siblings([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [limit](https://beautiful-soup-4.readthedocs.io/en/latest/#limit)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nSignature: find\\_next\\_sibling([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nThese methods use [.next\\_siblings](https://beautiful-soup-4.readthedocs.io/en/latest/#sibling-generators)\n to iterate over the rest of an element’s siblings in the tree. The `find_next_siblings()` method returns all the siblings that match, and `find_next_sibling()` only returns the first one:\n\nfirst\\_link \\= soup.a\nfirst\\_link\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\n\nfirst\\_link.find\\_next\\_siblings(\"a\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nfirst\\_story\\_paragraph \\= soup.find(\"p\", \"story\")\nfirst\\_story\\_paragraph.find\\_next\\_sibling(\"p\")\n\\# <p class=\"story\">...</p>\n\n`find_previous_siblings()` and `find_previous_sibling()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#find-previous-siblings-and-find-previous-sibling \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nSignature: find\\_previous\\_siblings([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [limit](https://beautiful-soup-4.readthedocs.io/en/latest/#limit)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nSignature: find\\_previous\\_sibling([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nThese methods use [.previous\\_siblings](https://beautiful-soup-4.readthedocs.io/en/latest/#sibling-generators)\n to iterate over an element’s siblings that precede it in the tree. The `find_previous_siblings()` method returns all the siblings that match, and `find_previous_sibling()` only returns the first one:\n\nlast\\_link \\= soup.find(\"a\", id\\=\"link3\")\nlast\\_link\n\\# <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\n\nlast\\_link.find\\_previous\\_siblings(\"a\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\\]\n\nfirst\\_story\\_paragraph \\= soup.find(\"p\", \"story\")\nfirst\\_story\\_paragraph.find\\_previous\\_sibling(\"p\")\n\\# <p class=\"title\"><b>The Dormouse's story</b></p>\n\n`find_all_next()` and `find_next()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#find-all-next-and-find-next \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------------------------------------\n\nSignature: find\\_all\\_next([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [limit](https://beautiful-soup-4.readthedocs.io/en/latest/#limit)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nSignature: find\\_next([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nThese methods use [.next\\_elements](https://beautiful-soup-4.readthedocs.io/en/latest/#element-generators)\n to iterate over whatever tags and strings that come after it in the document. The `find_all_next()` method returns all matches, and `find_next()` only returns the first match:\n\nfirst\\_link \\= soup.a\nfirst\\_link\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\n\nfirst\\_link.find\\_all\\_next(string\\=True)\n\\# \\[u'Elsie', u',\\\\n', u'Lacie', u' and\\\\n', u'Tillie',\\\n\\#  u';\\\\nand they lived at the bottom of a well.', u'\\\\n\\\\n', u'...', u'\\\\n'\\]\n\nfirst\\_link.find\\_next(\"p\")\n\\# <p class=\"story\">...</p>\n\nIn the first example, the string “Elsie” showed up, even though it was contained within the <a> tag we started from. In the second example, the last <p> tag in the document showed up, even though it’s not in the same part of the tree as the <a> tag we started from. For these methods, all that matters is that an element match the filter, and show up later in the document than the starting element.\n\n`find_all_previous()` and `find_previous()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#find-all-previous-and-find-previous \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nSignature: find\\_all\\_previous([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [limit](https://beautiful-soup-4.readthedocs.io/en/latest/#limit)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nSignature: find\\_previous([name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n)\n\nThese methods use [.previous\\_elements](https://beautiful-soup-4.readthedocs.io/en/latest/#element-generators)\n to iterate over the tags and strings that came before it in the document. The `find_all_previous()` method returns all matches, and `find_previous()` only returns the first match:\n\nfirst\\_link \\= soup.a\nfirst\\_link\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\n\nfirst\\_link.find\\_all\\_previous(\"p\")\n\\# \\[<p class=\"story\">Once upon a time there were three little sisters; ...</p>,\\\n\\#  <p class=\"title\"><b>The Dormouse's story</b></p>\\]\n\nfirst\\_link.find\\_previous(\"title\")\n\\# <title>The Dormouse's story</title>\n\nThe call to `find_all_previous(\"p\")` found the first paragraph in the document (the one with class=”title”), but it also finds the second paragraph, the <p> tag that contains the <a> tag we started with. This shouldn’t be too surprising: we’re looking at all the tags that show up earlier in the document than the one we started with. A <p> tag that contains an <a> tag must have shown up before the <a> tag it contains.\n\nCSS selectors[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#css-selectors \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------\n\nAs of version 4.7.0, Beautiful Soup supports most CSS4 selectors via the [SoupSieve](https://facelessuser.github.io/soupsieve/)\n project. If you installed Beautiful Soup through `pip`, SoupSieve was installed at the same time, so you don’t have to do anything extra.\n\n`BeautifulSoup` has a `.select()` method which uses SoupSieve to run a CSS selector against a parsed document and return all the matching elements. `Tag` has a similar method which runs a CSS selector against the contents of a single tag.\n\n(Earlier versions of Beautiful Soup also have the `.select()` method, but only the most commonly-used CSS selectors are supported.)\n\nThe SoupSieve [documentation](https://facelessuser.github.io/soupsieve/)\n lists all the currently supported CSS selectors, but here are some of the basics:\n\nYou can find tags:\n\nsoup.select(\"title\")\n\\# \\[<title>The Dormouse's story</title>\\]\n\nsoup.select(\"p:nth-of-type(3)\")\n\\# \\[<p class=\"story\">...</p>\\]\n\nFind tags beneath other tags:\n\nsoup.select(\"body a\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\"  id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nsoup.select(\"html head title\")\n\\# \\[<title>The Dormouse's story</title>\\]\n\nFind tags directly beneath other tags:\n\nsoup.select(\"head > title\")\n\\# \\[<title>The Dormouse's story</title>\\]\n\nsoup.select(\"p > a\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\"  id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nsoup.select(\"p > a:nth-of-type(2)\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\\]\n\nsoup.select(\"p > #link1\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\\]\n\nsoup.select(\"body > a\")\n\\# \\[\\]\n\nFind the siblings of tags:\n\nsoup.select(\"#link1 ~ .sister\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\"  id=\"link3\">Tillie</a>\\]\n\nsoup.select(\"#link1 + .sister\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\\]\n\nFind tags by CSS class:\n\nsoup.select(\".sister\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nsoup.select(\"\\[class~=sister\\]\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nFind tags by ID:\n\nsoup.select(\"#link1\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\\]\n\nsoup.select(\"a#link2\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\\]\n\nFind tags that match any selector from a list of selectors:\n\nsoup.select(\"#link1,#link2\")\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>\\]\n\nTest for the existence of an attribute:\n\nsoup.select('a\\[href\\]')\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nFind tags by attribute value:\n\nsoup.select('a\\[href=\"http://example.com/elsie\"\\]')\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\\]\n\nsoup.select('a\\[href^=\"http://example.com/\"\\]')\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>,\\\n\\#  <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nsoup.select('a\\[href$=\"tillie\"\\]')\n\\# \\[<a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\]\n\nsoup.select('a\\[href\\*=\".com/el\"\\]')\n\\# \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\\]\n\nThere’s also a method called `select_one()`, which finds only the first tag that matches a selector:\n\nsoup.select\\_one(\".sister\")\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>\n\nIf you’ve parsed XML that defines namespaces, you can use them in CSS selectors.:\n\nfrom bs4 import BeautifulSoup\nxml \\= \"\"\"<tag xmlns:ns1=\"http://namespace1/\" xmlns:ns2=\"http://namespace2/\">\n <ns1:child>I'm in namespace 1</ns1:child>\n <ns2:child>I'm in namespace 2</ns2:child>\n</tag> \"\"\"\nsoup \\= BeautifulSoup(xml, \"xml\")\n\nsoup.select(\"child\")\n\\# \\[<ns1:child>I'm in namespace 1</ns1:child>, <ns2:child>I'm in namespace 2</ns2:child>\\]\n\nsoup.select(\"ns1|child\", namespaces\\=namespaces)\n\\# \\[<ns1:child>I'm in namespace 1</ns1:child>\\]\n\nWhen handling a CSS selector that uses namespaces, Beautiful Soup uses the namespace abbreviations it found when parsing the document. You can override this by passing in your own dictionary of abbreviations:\n\nnamespaces \\= dict(first\\=\"http://namespace1/\", second\\=\"http://namespace2/\")\nsoup.select(\"second|child\", namespaces\\=namespaces)\n\\# \\[<ns1:child>I'm in namespace 2</ns1:child>\\]\n\nAll this CSS selector stuff is a convenience for people who already know the CSS selector syntax. You can do all of this with the Beautiful Soup API. And if CSS selectors are all you need, you should parse the document with lxml: it’s a lot faster. But this lets you combine CSS selectors with the Beautiful Soup API.\n\nModifying the tree[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#modifying-the-tree \"Permalink to this headline\")\n\n==========================================================================================================================\n\nBeautiful Soup’s main strength is in searching the parse tree, but you can also modify the tree and write your changes as a new HTML or XML document.\n\nChanging tag names and attributes[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#changing-tag-names-and-attributes \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\nI covered this earlier, in [Attributes](https://beautiful-soup-4.readthedocs.io/en/latest/#attributes)\n, but it bears repeating. You can rename a tag, change the values of its attributes, add new attributes, and delete attributes:\n\nsoup \\= BeautifulSoup('<b class=\"boldest\">Extremely bold</b>')\ntag \\= soup.b\n\ntag.name \\= \"blockquote\"\ntag\\['class'\\] \\= 'verybold'\ntag\\['id'\\] \\= 1\ntag\n\\# <blockquote class=\"verybold\" id=\"1\">Extremely bold</blockquote>\n\ndel tag\\['class'\\]\ndel tag\\['id'\\]\ntag\n\\# <blockquote>Extremely bold</blockquote>\n\nModifying `.string`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#modifying-string \"Permalink to this headline\")\n\n-------------------------------------------------------------------------------------------------------------------------\n\nIf you set a tag’s `.string` attribute to a new string, the tag’s contents are replaced with that string:\n\nmarkup \\= '<a href=\"http://example.com/\">I linked to <i>example.com</i></a>'\nsoup \\= BeautifulSoup(markup)\n\ntag \\= soup.a\ntag.string \\= \"New link text.\"\ntag\n\\# <a href=\"http://example.com/\">New link text.</a>\n\nBe careful: if the tag contained other tags, they and all their contents will be destroyed.\n\n`append()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#append \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------\n\nYou can add to a tag’s contents with `Tag.append()`. It works just like calling `.append()` on a Python list:\n\nsoup \\= BeautifulSoup(\"<a>Foo</a>\")\nsoup.a.append(\"Bar\")\n\nsoup\n\\# <html><head></head><body><a>FooBar</a></body></html>\nsoup.a.contents\n\\# \\[u'Foo', u'Bar'\\]\n\n`extend()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#extend \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------\n\nStarting in Beautiful Soup 4.7.0, `Tag` also supports a method called `.extend()`, which works just like calling `.extend()` on a Python list:\n\nsoup \\= BeautifulSoup(\"<a>Soup</a>\")\nsoup.a.extend(\\[\"'s\", \" \", \"on\"\\])\n\nsoup\n\\# <html><head></head><body><a>Soup's on</a></body></html>\nsoup.a.contents\n\\# \\[u'Soup', u''s', u' ', u'on'\\]\n\n`NavigableString()` and `.new_tag()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#navigablestring-and-new-tag \"Permalink to this headline\")\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\nIf you need to add a string to a document, no problem–you can pass a Python string in to `append()`, or you can call the `NavigableString` constructor:\n\nsoup \\= BeautifulSoup(\"<b></b>\")\ntag \\= soup.b\ntag.append(\"Hello\")\nnew\\_string \\= NavigableString(\" there\")\ntag.append(new\\_string)\ntag\n\\# <b>Hello there.</b>\ntag.contents\n\\# \\[u'Hello', u' there'\\]\n\nIf you want to create a comment or some other subclass of `NavigableString`, just call the constructor:\n\nfrom bs4 import Comment\nnew\\_comment \\= Comment(\"Nice to see you.\")\ntag.append(new\\_comment)\ntag\n\\# <b>Hello there<!--Nice to see you.--></b>\ntag.contents\n\\# \\[u'Hello', u' there', u'Nice to see you.'\\]\n\n(This is a new feature in Beautiful Soup 4.4.0.)\n\nWhat if you need to create a whole new tag? The best solution is to call the factory method `BeautifulSoup.new_tag()`:\n\nsoup \\= BeautifulSoup(\"<b></b>\")\noriginal\\_tag \\= soup.b\n\nnew\\_tag \\= soup.new\\_tag(\"a\", href\\=\"http://www.example.com\")\noriginal\\_tag.append(new\\_tag)\noriginal\\_tag\n\\# <b><a href=\"http://www.example.com\"></a></b>\n\nnew\\_tag.string \\= \"Link text.\"\noriginal\\_tag\n\\# <b><a href=\"http://www.example.com\">Link text.</a></b>\n\nOnly the first argument, the tag name, is required.\n\n`insert()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#insert \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------\n\n`Tag.insert()` is just like `Tag.append()`, except the new element doesn’t necessarily go at the end of its parent’s `.contents`. It’ll be inserted at whatever numeric position you say. It works just like `.insert()` on a Python list:\n\nmarkup \\= '<a href=\"http://example.com/\">I linked to <i>example.com</i></a>'\nsoup \\= BeautifulSoup(markup)\ntag \\= soup.a\n\ntag.insert(1, \"but did not endorse \")\ntag\n\\# <a href=\"http://example.com/\">I linked to but did not endorse <i>example.com</i></a>\ntag.contents\n\\# \\[u'I linked to ', u'but did not endorse', <i>example.com</i>\\]\n\n`insert_before()` and `insert_after()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#insert-before-and-insert-after \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThe `insert_before()` method inserts tags or strings immediately before something else in the parse tree:\n\nsoup \\= BeautifulSoup(\"<b>stop</b>\")\ntag \\= soup.new\\_tag(\"i\")\ntag.string \\= \"Don't\"\nsoup.b.string.insert\\_before(tag)\nsoup.b\n\\# <b><i>Don't</i>stop</b>\n\nThe `insert_after()` method inserts tags or strings immediately following something else in the parse tree:\n\ndiv \\= soup.new\\_tag('div')\ndiv.string \\= 'ever'\nsoup.b.i.insert\\_after(\" you \", div)\nsoup.b\n\\# <b><i>Don't</i> you <div>ever</div> stop</b>\nsoup.b.contents\n\\# \\[<i>Don't</i>, u' you', <div>ever</div>, u'stop'\\]\n\n`clear()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#clear \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------\n\n`Tag.clear()` removes the contents of a tag:\n\nmarkup \\= '<a href=\"http://example.com/\">I linked to <i>example.com</i></a>'\nsoup \\= BeautifulSoup(markup)\ntag \\= soup.a\n\ntag.clear()\ntag\n\\# <a href=\"http://example.com/\"></a>\n\n`extract()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#extract \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------\n\n`PageElement.extract()` removes a tag or string from the tree. It returns the tag or string that was extracted:\n\nmarkup \\= '<a href=\"http://example.com/\">I linked to <i>example.com</i></a>'\nsoup \\= BeautifulSoup(markup)\na\\_tag \\= soup.a\n\ni\\_tag \\= soup.i.extract()\n\na\\_tag\n\\# <a href=\"http://example.com/\">I linked to</a>\n\ni\\_tag\n\\# <i>example.com</i>\n\nprint(i\\_tag.parent)\nNone\n\nAt this point you effectively have two parse trees: one rooted at the `BeautifulSoup` object you used to parse the document, and one rooted at the tag that was extracted. You can go on to call `extract` on a child of the element you extracted:\n\nmy\\_string \\= i\\_tag.string.extract()\nmy\\_string\n\\# u'example.com'\n\nprint(my\\_string.parent)\n\\# None\ni\\_tag\n\\# <i></i>\n\n`decompose()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#decompose \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------------\n\n`Tag.decompose()` removes a tag from the tree, then completely destroys it and its contents:\n\nmarkup \\= '<a href=\"http://example.com/\">I linked to <i>example.com</i></a>'\nsoup \\= BeautifulSoup(markup)\na\\_tag \\= soup.a\n\nsoup.i.decompose()\n\na\\_tag\n\\# <a href=\"http://example.com/\">I linked to</a>\n\n`replace_with()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#replace-with \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------------------\n\n`PageElement.replace_with()` removes a tag or string from the tree, and replaces it with the tag or string of your choice:\n\nmarkup \\= '<a href=\"http://example.com/\">I linked to <i>example.com</i></a>'\nsoup \\= BeautifulSoup(markup)\na\\_tag \\= soup.a\n\nnew\\_tag \\= soup.new\\_tag(\"b\")\nnew\\_tag.string \\= \"example.net\"\na\\_tag.i.replace\\_with(new\\_tag)\n\na\\_tag\n\\# <a href=\"http://example.com/\">I linked to <b>example.net</b></a>\n\n`replace_with()` returns the tag or string that was replaced, so that you can examine it or add it back to another part of the tree.\n\n`wrap()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#wrap \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------\n\n`PageElement.wrap()` wraps an element in the tag you specify. It returns the new wrapper:\n\nsoup \\= BeautifulSoup(\"<p>I wish I was bold.</p>\")\nsoup.p.string.wrap(soup.new\\_tag(\"b\"))\n\\# <b>I wish I was bold.</b>\n\nsoup.p.wrap(soup.new\\_tag(\"div\")\n\\# <div><p><b>I wish I was bold.</b></p></div>\n\nThis method is new in Beautiful Soup 4.0.5.\n\n`unwrap()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#unwrap \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------\n\n`Tag.unwrap()` is the opposite of `wrap()`. It replaces a tag with whatever’s inside that tag. It’s good for stripping out markup:\n\nmarkup \\= '<a href=\"http://example.com/\">I linked to <i>example.com</i></a>'\nsoup \\= BeautifulSoup(markup)\na\\_tag \\= soup.a\n\na\\_tag.i.unwrap()\na\\_tag\n\\# <a href=\"http://example.com/\">I linked to example.com</a>\n\nLike `replace_with()`, `unwrap()` returns the tag that was replaced.\n\n`smooth()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#smooth \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------\n\nAfter calling a bunch of methods that modify the parse tree, you may end up with two or more `NavigableString` objects next to each other. Beautiful Soup doesn’t have any problems with this, but since it can’t happen in a freshly parsed document, you might not expect behavior like the following:\n\nsoup \\= BeautifulSoup(\"<p>A one</p>\")\nsoup.p.append(\", a two\")\n\nsoup.p.contents\n\\# \\[u'A one', u', a two'\\]\n\nprint(soup.p.encode())\n\\# <p>A one, a two</p>\n\nprint(soup.p.prettify())\n\\# <p>\n\\#  A one\n\\#  , a two\n\\# </p>\n\nYou can call `Tag.smooth()` to clean up the parse tree by consolidating adjacent strings:\n\nsoup.smooth()\n\nsoup.p.contents\n\\# \\[u'A one, a two'\\]\n\nprint(soup.p.prettify())\n\\# <p>\n\\#  A one, a two\n\\# </p>\n\nThe `smooth()` method is new in Beautiful Soup 4.8.0.\n\nOutput[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#output \"Permalink to this headline\")\n\n==================================================================================================\n\nPretty-printing[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#pretty-printing \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------------\n\nThe `prettify()` method will turn a Beautiful Soup parse tree into a nicely formatted Unicode string, with a separate line for each tag and each string:\n\nmarkup \\= '<a href=\"http://example.com/\">I linked to <i>example.com</i></a>'\nsoup \\= BeautifulSoup(markup)\nsoup.prettify()\n\\# '<html>\\\\n <head>\\\\n </head>\\\\n <body>\\\\n  <a href=\"http://example.com/\">\\\\n...'\n\nprint(soup.prettify())\n\\# <html>\n\\#  <head>\n\\#  </head>\n\\#  <body>\n\\#   <a href=\"http://example.com/\">\n\\#    I linked to\n\\#    <i>\n\\#     example.com\n\\#    </i>\n\\#   </a>\n\\#  </body>\n\\# </html>\n\nYou can call `prettify()` on the top-level `BeautifulSoup` object, or on any of its `Tag` objects:\n\nprint(soup.a.prettify())\n\\# <a href=\"http://example.com/\">\n\\#  I linked to\n\\#  <i>\n\\#   example.com\n\\#  </i>\n\\# </a>\n\nNon-pretty printing[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#non-pretty-printing \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------------\n\nIf you just want a string, with no fancy formatting, you can call `unicode()` or `str()` on a `BeautifulSoup` object, or a `Tag` within it:\n\nstr(soup)\n\\# '<html><head></head><body><a href=\"http://example.com/\">I linked to <i>example.com</i></a></body></html>'\n\nunicode(soup.a)\n\\# u'<a href=\"http://example.com/\">I linked to <i>example.com</i></a>'\n\nThe `str()` function returns a string encoded in UTF-8. See [Encodings](https://beautiful-soup-4.readthedocs.io/en/latest/#encodings)\n for other options.\n\nYou can also call `encode()` to get a bytestring, and `decode()` to get Unicode.\n\nOutput formatters[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#output-formatters \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------------------------\n\nIf you give Beautiful Soup a document that contains HTML entities like “&lquot;”, they’ll be converted to Unicode characters:\n\nsoup \\= BeautifulSoup(\"&ldquo;Dammit!&rdquo; he said.\")\nunicode(soup)\n\\# u'<html><head></head><body>\\\\u201cDammit!\\\\u201d he said.</body></html>'\n\nIf you then convert the document to a string, the Unicode characters will be encoded as UTF-8. You won’t get the HTML entities back:\n\nstr(soup)\n\\# '<html><head></head><body>\\\\xe2\\\\x80\\\\x9cDammit!\\\\xe2\\\\x80\\\\x9d he said.</body></html>'\n\nBy default, the only characters that are escaped upon output are bare ampersands and angle brackets. These get turned into “&amp;”, “&lt;”, and “&gt;”, so that Beautiful Soup doesn’t inadvertently generate invalid HTML or XML:\n\nsoup \\= BeautifulSoup(\"<p>The law firm of Dewey, Cheatem, & Howe</p>\")\nsoup.p\n\\# <p>The law firm of Dewey, Cheatem, &amp; Howe</p>\n\nsoup \\= BeautifulSoup('<a href=\"http://example.com/?foo=val1&bar=val2\">A link</a>')\nsoup.a\n\\# <a href=\"http://example.com/?foo=val1&amp;bar=val2\">A link</a>\n\nYou can change this behavior by providing a value for the `formatter` argument to `prettify()`, `encode()`, or `decode()`. Beautiful Soup recognizes five possible values for `formatter`.\n\nThe default is `formatter=\"minimal\"`. Strings will only be processed enough to ensure that Beautiful Soup generates valid HTML/XML:\n\nfrench \\= \"<p>Il a dit &lt;&lt;Sacr&eacute; bleu!&gt;&gt;</p>\"\nsoup \\= BeautifulSoup(french)\nprint(soup.prettify(formatter\\=\"minimal\"))\n\\# <html>\n\\#  <body>\n\\#   <p>\n\\#    Il a dit &lt;&lt;Sacré bleu!&gt;&gt;\n\\#   </p>\n\\#  </body>\n\\# </html>\n\nIf you pass in `formatter=\"html\"`, Beautiful Soup will convert Unicode characters to HTML entities whenever possible:\n\nprint(soup.prettify(formatter\\=\"html\"))\n\\# <html>\n\\#  <body>\n\\#   <p>\n\\#    Il a dit &lt;&lt;Sacr&eacute; bleu!&gt;&gt;\n\\#   </p>\n\\#  </body>\n\\# </html>\n\nIf you pass in `formatter=\"html5\"`, it’s the same as `formatter=\"html5\"`, but Beautiful Soup will omit the closing slash in HTML void tags like “br”:\n\nsoup \\= BeautifulSoup(\"<br>\")\n\nprint(soup.encode(formatter\\=\"html\"))\n\\# <html><body><br/></body></html>\n\nprint(soup.encode(formatter\\=\"html5\"))\n\\# <html><body><br></body></html>\n\nIf you pass in `formatter=None`, Beautiful Soup will not modify strings at all on output. This is the fastest option, but it may lead to Beautiful Soup generating invalid HTML/XML, as in these examples:\n\nprint(soup.prettify(formatter\\=None))\n\\# <html>\n\\#  <body>\n\\#   <p>\n\\#    Il a dit <<Sacré bleu!>>\n\\#   </p>\n\\#  </body>\n\\# </html>\n\nlink\\_soup \\= BeautifulSoup('<a href=\"http://example.com/?foo=val1&bar=val2\">A link</a>')\nprint(link\\_soup.a.encode(formatter\\=None))\n\\# <a href=\"http://example.com/?foo=val1&bar=val2\">A link</a>\n\nIf you need more sophisticated control over your output, you can use Beautiful Soup’s `Formatter` class. Here’s a formatter that converts strings to uppercase, whether they occur in a text node or in an attribute value:\n\nfrom bs4.formatter import HTMLFormatter\ndef uppercase(str):\n    return str.upper()\nformatter \\= HTMLFormatter(uppercase)\n\nprint(soup.prettify(formatter\\=formatter))\n\\# <html>\n\\#  <body>\n\\#   <p>\n\\#    IL A DIT <<SACRÉ BLEU!>>\n\\#   </p>\n\\#  </body>\n\\# </html>\n\nprint(link\\_soup.a.prettify(formatter\\=formatter))\n\\# <a href=\"HTTP://EXAMPLE.COM/?FOO=VAL1&BAR=VAL2\">\n\\#  A LINK\n\\# </a>\n\nSubclassing `HTMLFormatter` or `XMLFormatter` will give you even more control over the output. For example, Beautiful Soup sorts the attributes in every tag by default:\n\nattr\\_soup \\= BeautifulSoup(b'<p z=\"1\" m=\"2\" a=\"3\"></p>')\nprint(attr\\_soup.p.encode())\n\\# <p a=\"3\" m=\"2\" z=\"1\"></p>\n\nTo turn this off, you can subclass the `Formatter.attributes()` method, which controls which attributes are output and in what order. This implementation also filters out the attribute called “m” whenever it appears:\n\nclass UnsortedAttributes(HTMLFormatter):\n    def attributes(self, tag):\n        for k, v in tag.attrs.items():\n            if k \\== 'm':\n                continue\n            yield k, v\nprint(attr\\_soup.p.encode(formatter\\=UnsortedAttributes()))\n\\# <p z=\"1\" a=\"3\"></p>\n\nOne last caveat: if you create a `CData` object, the text inside that object is always presented exactly as it appears, with no formatting. Beautiful Soup will call your entity substitution function, just in case you’ve written a custom function that counts all the strings in the document or something, but it will ignore the return value:\n\nfrom bs4.element import CData\nsoup \\= BeautifulSoup(\"<a></a>\")\nsoup.a.string \\= CData(\"one < three\")\nprint(soup.a.prettify(formatter\\=\"xml\"))\n\\# <a>\n\\#  <!\\[CDATA\\[one < three\\]\\]>\n\\# </a>\n\n`get_text()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#get-text \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------\n\nIf you only want the text part of a document or tag, you can use the `get_text()` method. It returns all the text in a document or beneath a tag, as a single Unicode string:\n\nmarkup \\= '<a href=\"http://example.com/\">\\\\nI linked to <i>example.com</i>\\\\n</a>'\nsoup \\= BeautifulSoup(markup)\n\nsoup.get\\_text()\nu'\\\\nI linked to example.com\\\\n'\nsoup.i.get\\_text()\nu'example.com'\n\nYou can specify a string to be used to join the bits of text together:\n\n\\# soup.get\\_text(\"|\")\nu'\\\\nI linked to |example.com|\\\\n'\n\nYou can tell Beautiful Soup to strip whitespace from the beginning and end of each bit of text:\n\n\\# soup.get\\_text(\"|\", strip=True)\nu'I linked to|example.com'\n\nBut at that point you might want to use the [.stripped\\_strings](https://beautiful-soup-4.readthedocs.io/en/latest/#string-generators)\n generator instead, and process the text yourself:\n\n\\[text for text in soup.stripped\\_strings\\]\n\\# \\[u'I linked to', u'example.com'\\]\n\nSpecifying the parser to use[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#specifying-the-parser-to-use \"Permalink to this headline\")\n\n==============================================================================================================================================\n\nIf you just need to parse some HTML, you can dump the markup into the `BeautifulSoup` constructor, and it’ll probably be fine. Beautiful Soup will pick a parser for you and parse the data. But there are a few additional arguments you can pass in to the constructor to change which parser is used.\n\nThe first argument to the `BeautifulSoup` constructor is a string or an open filehandle–the markup you want parsed. The second argument is how you’d like the markup parsed.\n\nIf you don’t specify anything, you’ll get the best HTML parser that’s installed. Beautiful Soup ranks lxml’s parser as being the best, then html5lib’s, then Python’s built-in parser. You can override this by specifying one of the following:\n\n*   What type of markup you want to parse. Currently supported are “html”, “xml”, and “html5”.\n*   The name of the parser library you want to use. Currently supported options are “lxml”, “html5lib”, and “html.parser” (Python’s built-in HTML parser).\n\nThe section [Installing a parser](https://beautiful-soup-4.readthedocs.io/en/latest/#installing-a-parser)\n contrasts the supported parsers.\n\nIf you don’t have an appropriate parser installed, Beautiful Soup will ignore your request and pick a different parser. Right now, the only supported XML parser is lxml. If you don’t have lxml installed, asking for an XML parser won’t give you one, and asking for “lxml” won’t work either.\n\nDifferences between parsers[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#differences-between-parsers \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------------------------------------\n\nBeautiful Soup presents the same interface to a number of different parsers, but each parser is different. Different parsers will create different parse trees from the same document. The biggest differences are between the HTML parsers and the XML parsers. Here’s a short document, parsed as HTML:\n\nBeautifulSoup(\"<a><b /></a>\")\n\\# <html><head></head><body><a><b></b></a></body></html>\n\nSince an empty <b /> tag is not valid HTML, the parser turns it into a <b></b> tag pair.\n\nHere’s the same document parsed as XML (running this requires that you have lxml installed). Note that the empty <b /> tag is left alone, and that the document is given an XML declaration instead of being put into an <html> tag.:\n\nBeautifulSoup(\"<a><b /></a>\", \"xml\")\n\\# <?xml version=\"1.0\" encoding=\"utf-8\"?>\n\\# <a><b/></a>\n\nThere are also differences between HTML parsers. If you give Beautiful Soup a perfectly-formed HTML document, these differences won’t matter. One parser will be faster than another, but they’ll all give you a data structure that looks exactly like the original HTML document.\n\nBut if the document is not perfectly-formed, different parsers will give different results. Here’s a short, invalid document parsed using lxml’s HTML parser. Note that the dangling </p> tag is simply ignored:\n\nBeautifulSoup(\"<a></p>\", \"lxml\")\n\\# <html><body><a></a></body></html>\n\nHere’s the same document parsed using html5lib:\n\nBeautifulSoup(\"<a></p>\", \"html5lib\")\n\\# <html><head></head><body><a><p></p></a></body></html>\n\nInstead of ignoring the dangling </p> tag, html5lib pairs it with an opening <p> tag. This parser also adds an empty <head> tag to the document.\n\nHere’s the same document parsed with Python’s built-in HTML parser:\n\nBeautifulSoup(\"<a></p>\", \"html.parser\")\n\\# <a></a>\n\nLike html5lib, this parser ignores the closing </p> tag. Unlike html5lib, this parser makes no attempt to create a well-formed HTML document by adding a <body> tag. Unlike lxml, it doesn’t even bother to add an <html> tag.\n\nSince the document “<a></p>” is invalid, none of these techniques is the “correct” way to handle it. The html5lib parser uses techniques that are part of the HTML5 standard, so it has the best claim on being the “correct” way, but all three techniques are legitimate.\n\nDifferences between parsers can affect your script. If you’re planning on distributing your script to other people, or running it on multiple machines, you should specify a parser in the `BeautifulSoup` constructor. That will reduce the chances that your users parse a document differently from the way you parse it.\n\nEncodings[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#encodings \"Permalink to this headline\")\n\n========================================================================================================\n\nAny HTML or XML document is written in a specific encoding like ASCII or UTF-8. But when you load that document into Beautiful Soup, you’ll discover it’s been converted to Unicode:\n\nmarkup \\= \"<h1>Sacr\\\\xc3\\\\xa9 bleu!</h1>\"\nsoup \\= BeautifulSoup(markup)\nsoup.h1\n\\# <h1>Sacré bleu!</h1>\nsoup.h1.string\n\\# u'Sacr\\\\xe9 bleu!'\n\nIt’s not magic. (That sure would be nice.) Beautiful Soup uses a sub-library called [Unicode, Dammit](https://beautiful-soup-4.readthedocs.io/en/latest/#unicode-dammit)\n to detect a document’s encoding and convert it to Unicode. The autodetected encoding is available as the `.original_encoding` attribute of the `BeautifulSoup` object:\n\nsoup.original\\_encoding\n'utf-8'\n\nUnicode, Dammit guesses correctly most of the time, but sometimes it makes mistakes. Sometimes it guesses correctly, but only after a byte-by-byte search of the document that takes a very long time. If you happen to know a document’s encoding ahead of time, you can avoid mistakes and delays by passing it to the `BeautifulSoup` constructor as `from_encoding`.\n\nHere’s a document written in ISO-8859-8. The document is so short that Unicode, Dammit can’t get a lock on it, and misidentifies it as ISO-8859-7:\n\nmarkup \\= b\"<h1>\\\\xed\\\\xe5\\\\xec\\\\xf9</h1>\"\nsoup \\= BeautifulSoup(markup)\nsoup.h1\n<h1\\>νεμω</h1\\>\nsoup.original\\_encoding\n'ISO-8859-7'\n\nWe can fix this by passing in the correct `from_encoding`:\n\nsoup \\= BeautifulSoup(markup, from\\_encoding\\=\"iso-8859-8\")\nsoup.h1\n<h1\\>םולש</h1\\>\nsoup.original\\_encoding\n'iso8859-8'\n\nIf you don’t know what the correct encoding is, but you know that Unicode, Dammit is guessing wrong, you can pass the wrong guesses in as `exclude_encodings`:\n\nsoup \\= BeautifulSoup(markup, exclude\\_encodings\\=\\[\"ISO-8859-7\"\\])\nsoup.h1\n<h1\\>םולש</h1\\>\nsoup.original\\_encoding\n'WINDOWS-1255'\n\nWindows-1255 isn’t 100% correct, but that encoding is a compatible superset of ISO-8859-8, so it’s close enough. (`exclude_encodings` is a new feature in Beautiful Soup 4.4.0.)\n\nIn rare cases (usually when a UTF-8 document contains text written in a completely different encoding), the only way to get Unicode may be to replace some characters with the special Unicode character “REPLACEMENT CHARACTER” (U+FFFD, �). If Unicode, Dammit needs to do this, it will set the `.contains_replacement_characters` attribute to `True` on the `UnicodeDammit` or `BeautifulSoup` object. This lets you know that the Unicode representation is not an exact representation of the original–some data was lost. If a document contains �, but `.contains_replacement_characters` is `False`, you’ll know that the � was there originally (as it is in this paragraph) and doesn’t stand in for missing data.\n\nOutput encoding[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#output-encoding \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------------\n\nWhen you write out a document from Beautiful Soup, you get a UTF-8 document, even if the document wasn’t in UTF-8 to begin with. Here’s a document written in the Latin-1 encoding:\n\nmarkup \\= b'''\n <html>\n  <head>\n   <meta content=\"text/html; charset=ISO-Latin-1\" http-equiv=\"Content-type\" />\n  </head>\n  <body>\n   <p>Sacr\\\\xe9 bleu!</p>\n  </body>\n </html>\n'''\n\nsoup \\= BeautifulSoup(markup)\nprint(soup.prettify())\n\\# <html>\n\\#  <head>\n\\#   <meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-type\" />\n\\#  </head>\n\\#  <body>\n\\#   <p>\n\\#    Sacré bleu!\n\\#   </p>\n\\#  </body>\n\\# </html>\n\nNote that the <meta> tag has been rewritten to reflect the fact that the document is now in UTF-8.\n\nIf you don’t want UTF-8, you can pass an encoding into `prettify()`:\n\nprint(soup.prettify(\"latin-1\"))\n\\# <html>\n\\#  <head>\n\\#   <meta content=\"text/html; charset=latin-1\" http-equiv=\"Content-type\" />\n\\# ...\n\nYou can also call encode() on the `BeautifulSoup` object, or any element in the soup, just as if it were a Python string:\n\nsoup.p.encode(\"latin-1\")\n\\# '<p>Sacr\\\\xe9 bleu!</p>'\n\nsoup.p.encode(\"utf-8\")\n\\# '<p>Sacr\\\\xc3\\\\xa9 bleu!</p>'\n\nAny characters that can’t be represented in your chosen encoding will be converted into numeric XML entity references. Here’s a document that includes the Unicode character SNOWMAN:\n\nmarkup \\= u\"<b>\\\\N{SNOWMAN}</b>\"\nsnowman\\_soup \\= BeautifulSoup(markup)\ntag \\= snowman\\_soup.b\n\nThe SNOWMAN character can be part of a UTF-8 document (it looks like ☃), but there’s no representation for that character in ISO-Latin-1 or ASCII, so it’s converted into “&#9731” for those encodings:\n\nprint(tag.encode(\"utf-8\"))\n\\# <b>☃</b>\n\nprint tag.encode(\"latin-1\")\n\\# <b>&#9731;</b>\n\nprint tag.encode(\"ascii\")\n\\# <b>&#9731;</b>\n\nUnicode, Dammit[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#unicode-dammit \"Permalink to this headline\")\n\n-------------------------------------------------------------------------------------------------------------------\n\nYou can use Unicode, Dammit without using Beautiful Soup. It’s useful whenever you have data in an unknown encoding and you just want it to become Unicode:\n\nfrom bs4 import UnicodeDammit\ndammit \\= UnicodeDammit(\"Sacr\\\\xc3\\\\xa9 bleu!\")\nprint(dammit.unicode\\_markup)\n\\# Sacré bleu!\ndammit.original\\_encoding\n\\# 'utf-8'\n\nUnicode, Dammit’s guesses will get a lot more accurate if you install the `chardet` or `cchardet` Python libraries. The more data you give Unicode, Dammit, the more accurately it will guess. If you have your own suspicions as to what the encoding might be, you can pass them in as a list:\n\ndammit \\= UnicodeDammit(\"Sacr\\\\xe9 bleu!\", \\[\"latin-1\", \"iso-8859-1\"\\])\nprint(dammit.unicode\\_markup)\n\\# Sacré bleu!\ndammit.original\\_encoding\n\\# 'latin-1'\n\nUnicode, Dammit has two special features that Beautiful Soup doesn’t use.\n\n### Smart quotes[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#smart-quotes \"Permalink to this headline\")\n\nYou can use Unicode, Dammit to convert Microsoft smart quotes to HTML or XML entities:\n\nmarkup \\= b\"<p>I just \\\\x93love\\\\x94 Microsoft Word\\\\x92s smart quotes</p>\"\n\nUnicodeDammit(markup, \\[\"windows-1252\"\\], smart\\_quotes\\_to\\=\"html\").unicode\\_markup\n\\# u'<p>I just &ldquo;love&rdquo; Microsoft Word&rsquo;s smart quotes</p>'\n\nUnicodeDammit(markup, \\[\"windows-1252\"\\], smart\\_quotes\\_to\\=\"xml\").unicode\\_markup\n\\# u'<p>I just &#x201C;love&#x201D; Microsoft Word&#x2019;s smart quotes</p>'\n\nYou can also convert Microsoft smart quotes to ASCII quotes:\n\nUnicodeDammit(markup, \\[\"windows-1252\"\\], smart\\_quotes\\_to\\=\"ascii\").unicode\\_markup\n\\# u'<p>I just \"love\" Microsoft Word\\\\'s smart quotes</p>'\n\nHopefully you’ll find this feature useful, but Beautiful Soup doesn’t use it. Beautiful Soup prefers the default behavior, which is to convert Microsoft smart quotes to Unicode characters along with everything else:\n\nUnicodeDammit(markup, \\[\"windows-1252\"\\]).unicode\\_markup\n\\# u'<p>I just \\\\u201clove\\\\u201d Microsoft Word\\\\u2019s smart quotes</p>'\n\n### Inconsistent encodings[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#inconsistent-encodings \"Permalink to this headline\")\n\nSometimes a document is mostly in UTF-8, but contains Windows-1252 characters such as (again) Microsoft smart quotes. This can happen when a website includes data from multiple sources. You can use `UnicodeDammit.detwingle()` to turn such a document into pure UTF-8. Here’s a simple example:\n\nsnowmen \\= (u\"\\\\N{SNOWMAN}\" \\* 3)\nquote \\= (u\"\\\\N{LEFT DOUBLE QUOTATION MARK}I like snowmen!\\\\N{RIGHT DOUBLE QUOTATION MARK}\")\ndoc \\= snowmen.encode(\"utf8\") + quote.encode(\"windows\\_1252\")\n\nThis document is a mess. The snowmen are in UTF-8 and the quotes are in Windows-1252. You can display the snowmen or the quotes, but not both:\n\nprint(doc)\n\\# ☃☃☃�I like snowmen!�\n\nprint(doc.decode(\"windows-1252\"))\n\\# â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”\n\nDecoding the document as UTF-8 raises a `UnicodeDecodeError`, and decoding it as Windows-1252 gives you gibberish. Fortunately, `UnicodeDammit.detwingle()` will convert the string to pure UTF-8, allowing you to decode it to Unicode and display the snowmen and quote marks simultaneously:\n\nnew\\_doc \\= UnicodeDammit.detwingle(doc)\nprint(new\\_doc.decode(\"utf8\"))\n\\# ☃☃☃“I like snowmen!”\n\n`UnicodeDammit.detwingle()` only knows how to handle Windows-1252 embedded in UTF-8 (or vice versa, I suppose), but this is the most common case.\n\nNote that you must know to call `UnicodeDammit.detwingle()` on your data before passing it into `BeautifulSoup` or the `UnicodeDammit` constructor. Beautiful Soup assumes that a document has a single encoding, whatever it might be. If you pass it a document that contains both UTF-8 and Windows-1252, it’s likely to think the whole document is Windows-1252, and the document will come out looking like `â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”`.\n\n`UnicodeDammit.detwingle()` is new in Beautiful Soup 4.1.0.\n\nLine numbers[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#line-numbers \"Permalink to this headline\")\n\n==============================================================================================================\n\nThe ```html.parser` and ``html5lib``` parsers can keep track of where in the original document each Tag was found. You can access this information as `Tag.sourceline` (line number) and `Tag.sourcepos` (position of the start tag within a line):\n\nmarkup \\= \"<p\\\\n\\>Paragraph 1</p>\\\\n    <p>Paragraph 2</p>\"\nsoup \\= BeautifulSoup(markup, 'html.parser')\nfor tag in soup.find\\_all('p'):\n    print(tag.sourceline, tag.sourcepos, tag.string)\n\\# (1, 0, u'Paragraph 1')\n\\# (2, 3, u'Paragraph 2')\n\nNote that the two parsers mean slightly different things by `sourceline` and `sourcepos`. For html.parser, these numbers represent the position of the initial less-than sign. For html5lib, these numbers represent the position of the final greater-than sign:\n\nsoup \\= BeautifulSoup(markup, 'html5lib')\nfor tag in soup.find\\_all('p'):\n    print(tag.sourceline, tag.sourcepos, tag.string)\n\\# (2, 1, u'Paragraph 1')\n\\# (3, 7, u'Paragraph 2')\n\nYou can shut off this feature by passing ```store_line_numbers=False` into the ``BeautifulSoup``` constructor:\n\nmarkup \\= \"<p\\\\n\\>Paragraph 1</p>\\\\n    <p>Paragraph 2</p>\"\nsoup \\= BeautifulSoup(markup, 'html.parser', store\\_line\\_numbers\\=False)\nsoup.p.sourceline\n\\# None\n\nThis feature is new in 4.8.1, and the parsers based on lxml don’t support it.\n\nComparing objects for equality[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#comparing-objects-for-equality \"Permalink to this headline\")\n\n==================================================================================================================================================\n\nBeautiful Soup says that two `NavigableString` or `Tag` objects are equal when they represent the same HTML or XML markup. In this example, the two <b> tags are treated as equal, even though they live in different parts of the object tree, because they both look like “<b>pizza</b>”:\n\nmarkup \\= \"<p>I want <b>pizza</b> and more <b>pizza</b>!</p>\"\nsoup \\= BeautifulSoup(markup, 'html.parser')\nfirst\\_b, second\\_b \\= soup.find\\_all('b')\nprint first\\_b \\== second\\_b\n\\# True\n\nprint first\\_b.previous\\_element \\== second\\_b.previous\\_element\n\\# False\n\nIf you want to see whether two variables refer to exactly the same object, use is:\n\nprint first\\_b is second\\_b\n\\# False\n\nCopying Beautiful Soup objects[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#copying-beautiful-soup-objects \"Permalink to this headline\")\n\n==================================================================================================================================================\n\nYou can use `copy.copy()` to create a copy of any `Tag` or `NavigableString`:\n\nimport copy\np\\_copy \\= copy.copy(soup.p)\nprint p\\_copy\n\\# <p>I want <b>pizza</b> and more <b>pizza</b>!</p>\n\nThe copy is considered equal to the original, since it represents the same markup as the original, but it’s not the same object:\n\nprint soup.p \\== p\\_copy\n\\# True\n\nprint soup.p is p\\_copy\n\\# False\n\nThe only real difference is that the copy is completely detached from the original Beautiful Soup object tree, just as if `extract()` had been called on it:\n\nprint p\\_copy.parent\n\\# None\n\nThis is because two different `Tag` objects can’t occupy the same space at the same time.\n\nParsing only part of a document[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#parsing-only-part-of-a-document \"Permalink to this headline\")\n\n====================================================================================================================================================\n\nLet’s say you want to use Beautiful Soup look at a document’s <a> tags. It’s a waste of time and memory to parse the entire document and then go over it again looking for <a> tags. It would be much faster to ignore everything that wasn’t an <a> tag in the first place. The `SoupStrainer` class allows you to choose which parts of an incoming document are parsed. You just create a `SoupStrainer` and pass it in to the `BeautifulSoup` constructor as the `parse_only` argument.\n\n(Note that _this feature won’t work if you’re using the html5lib parser_. If you use html5lib, the whole document will be parsed, no matter what. This is because html5lib constantly rearranges the parse tree as it works, and if some part of the document didn’t actually make it into the parse tree, it’ll crash. To avoid confusion, in the examples below I’ll be forcing Beautiful Soup to use Python’s built-in parser.)\n\n`SoupStrainer`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#soupstrainer \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------\n\nThe `SoupStrainer` class takes the same arguments as a typical method from [Searching the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-the-tree)\n: [name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, [attrs](https://beautiful-soup-4.readthedocs.io/en/latest/#attrs)\n, [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n, and [\\*\\*kwargs](https://beautiful-soup-4.readthedocs.io/en/latest/#kwargs)\n. Here are three `SoupStrainer` objects:\n\nfrom bs4 import SoupStrainer\n\nonly\\_a\\_tags \\= SoupStrainer(\"a\")\n\nonly\\_tags\\_with\\_id\\_link2 \\= SoupStrainer(id\\=\"link2\")\n\ndef is\\_short\\_string(string):\n    return len(string) < 10\n\nonly\\_short\\_strings \\= SoupStrainer(string\\=is\\_short\\_string)\n\nI’m going to bring back the “three sisters” document one more time, and we’ll see what the document looks like when it’s parsed with these three `SoupStrainer` objects:\n\nhtml\\_doc \\= \"\"\"\n<html><head><title>The Dormouse's story</title></head>\n<body>\n<p class=\"title\"><b>The Dormouse's story</b></p>\n\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie</a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n\n<p class=\"story\">...</p>\n\"\"\"\n\nprint(BeautifulSoup(html\\_doc, \"html.parser\", parse\\_only\\=only\\_a\\_tags).prettify())\n\\# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">\n\\#  Elsie\n\\# </a>\n\\# <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">\n\\#  Lacie\n\\# </a>\n\\# <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">\n\\#  Tillie\n\\# </a>\n\nprint(BeautifulSoup(html\\_doc, \"html.parser\", parse\\_only\\=only\\_tags\\_with\\_id\\_link2).prettify())\n\\# <a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">\n\\#  Lacie\n\\# </a>\n\nprint(BeautifulSoup(html\\_doc, \"html.parser\", parse\\_only\\=only\\_short\\_strings).prettify())\n\\# Elsie\n\\# ,\n\\# Lacie\n\\# and\n\\# Tillie\n\\# ...\n#\n\nYou can also pass a `SoupStrainer` into any of the methods covered in [Searching the tree](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-the-tree)\n. This probably isn’t terribly useful, but I thought I’d mention it:\n\nsoup \\= BeautifulSoup(html\\_doc)\nsoup.find\\_all(only\\_short\\_strings)\n\\# \\[u'\\\\n\\\\n', u'\\\\n\\\\n', u'Elsie', u',\\\\n', u'Lacie', u' and\\\\n', u'Tillie',\\\n\\#  u'\\\\n\\\\n', u'...', u'\\\\n'\\]\n\nTroubleshooting[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#troubleshooting \"Permalink to this headline\")\n\n====================================================================================================================\n\n`diagnose()`[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#diagnose \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------\n\nIf you’re having trouble understanding what Beautiful Soup does to a document, pass the document into the `diagnose()` function. (New in Beautiful Soup 4.2.0.) Beautiful Soup will print out a report showing you how different parsers handle the document, and tell you if you’re missing a parser that Beautiful Soup could be using:\n\nfrom bs4.diagnose import diagnose\nwith open(\"bad.html\") as fp:\n    data \\= fp.read()\ndiagnose(data)\n\n\\# Diagnostic running on Beautiful Soup 4.2.0\n\\# Python version 2.7.3 (default, Aug  1 2012, 05:16:07)\n\\# I noticed that html5lib is not installed. Installing it may help.\n\\# Found lxml version 2.3.2.0\n#\n\\# Trying to parse your data with html.parser\n\\# Here's what html.parser did with the document:\n\\# ...\n\nJust looking at the output of diagnose() may show you how to solve the problem. Even if not, you can paste the output of `diagnose()` when asking for help.\n\nErrors when parsing a document[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#errors-when-parsing-a-document \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nThere are two different kinds of parse errors. There are crashes, where you feed a document to Beautiful Soup and it raises an exception, usually an `HTMLParser.HTMLParseError`. And there is unexpected behavior, where a Beautiful Soup parse tree looks a lot different than the document used to create it.\n\nAlmost none of these problems turn out to be problems with Beautiful Soup. This is not because Beautiful Soup is an amazingly well-written piece of software. It’s because Beautiful Soup doesn’t include any parsing code. Instead, it relies on external parsers. If one parser isn’t working on a certain document, the best solution is to try a different parser. See [Installing a parser](https://beautiful-soup-4.readthedocs.io/en/latest/#installing-a-parser)\n for details and a parser comparison.\n\nThe most common parse errors are `HTMLParser.HTMLParseError: malformed start tag` and `HTMLParser.HTMLParseError: bad end tag`. These are both generated by Python’s built-in HTML parser library, and the solution is to [install lxml or html5lib.](https://beautiful-soup-4.readthedocs.io/en/latest/#parser-installation)\n\nThe most common type of unexpected behavior is that you can’t find a tag that you know is in the document. You saw it going in, but `find_all()` returns `[]` or `find()` returns `None`. This is another common problem with Python’s built-in HTML parser, which sometimes skips tags it doesn’t understand. Again, the solution is to [install lxml or html5lib.](https://beautiful-soup-4.readthedocs.io/en/latest/#parser-installation)\n\nVersion mismatch problems[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#version-mismatch-problems \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------------------------\n\n*   `SyntaxError: Invalid syntax` (on the line `ROOT_TAG_NAME = u'[document]'`): Caused by running the Python 2 version of Beautiful Soup under Python 3, without converting the code.\n*   `ImportError: No module named HTMLParser` - Caused by running the Python 2 version of Beautiful Soup under Python 3.\n*   `ImportError: No module named html.parser` - Caused by running the Python 3 version of Beautiful Soup under Python 2.\n*   `ImportError: No module named BeautifulSoup` - Caused by running Beautiful Soup 3 code on a system that doesn’t have BS3 installed. Or, by writing Beautiful Soup 4 code without knowing that the package name has changed to `bs4`.\n*   `ImportError: No module named bs4` - Caused by running Beautiful Soup 4 code on a system that doesn’t have BS4 installed.\n\nParsing XML[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#parsing-xml \"Permalink to this headline\")\n\n------------------------------------------------------------------------------------------------------------\n\nBy default, Beautiful Soup parses documents as HTML. To parse a document as XML, pass in “xml” as the second argument to the `BeautifulSoup` constructor:\n\nsoup \\= BeautifulSoup(markup, \"xml\")\n\nYou’ll need to [have lxml installed](https://beautiful-soup-4.readthedocs.io/en/latest/#parser-installation)\n.\n\nOther parser problems[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#other-parser-problems \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------------------------\n\n*   If your script works on one computer but not another, or in one virtual environment but not another, or outside the virtual environment but not inside, it’s probably because the two environments have different parser libraries available. For example, you may have developed the script on a computer that has lxml installed, and then tried to run it on a computer that only has html5lib installed. See [Differences between parsers](https://beautiful-soup-4.readthedocs.io/en/latest/#differences-between-parsers)\n     for why this matters, and fix the problem by mentioning a specific parser library in the `BeautifulSoup` constructor.\n*   Because [HTML tags and attributes are case-insensitive](http://www.w3.org/TR/html5/syntax.html#syntax)\n    , all three HTML parsers convert tag and attribute names to lowercase. That is, the markup <TAG></TAG> is converted to <tag></tag>. If you want to preserve mixed-case or uppercase tags and attributes, you’ll need to [parse the document as XML.](https://beautiful-soup-4.readthedocs.io/en/latest/#parsing-xml)\n    \n\nMiscellaneous[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#miscellaneous \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------\n\n*   `UnicodeEncodeError: 'charmap' codec can't encode character u'\\xfoo' in position bar` (or just about any other `UnicodeEncodeError`) - This is not a problem with Beautiful Soup. This problem shows up in two main situations. First, when you try to print a Unicode character that your console doesn’t know how to display. (See [this page on the Python wiki](http://wiki.python.org/moin/PrintFails)\n     for help.) Second, when you’re writing to a file and you pass in a Unicode character that’s not supported by your default encoding. In this case, the simplest solution is to explicitly encode the Unicode string into UTF-8 with `u.encode(\"utf8\")`.\n*   `KeyError: [attr]` - Caused by accessing `tag['attr']` when the tag in question doesn’t define the `attr` attribute. The most common errors are `KeyError: 'href'` and `KeyError: 'class'`. Use `tag.get('attr')` if you’re not sure `attr` is defined, just as you would with a Python dictionary.\n*   `AttributeError: 'ResultSet' object has no attribute 'foo'` - This usually happens because you expected `find_all()` to return a single tag or string. But `find_all()` returns a \\_list\\_ of tags and strings–a `ResultSet` object. You need to iterate over the list and look at the `.foo` of each one. Or, if you really only want one result, you need to use `find()` instead of `find_all()`.\n*   `AttributeError: 'NoneType' object has no attribute 'foo'` - This usually happens because you called `find()` and then tried to access the .foo\\` attribute of the result. But in your case, `find()` didn’t find anything, so it returned `None`, instead of returning a tag or a string. You need to figure out why your `find()` call isn’t returning anything.\n\nImproving Performance[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#improving-performance \"Permalink to this headline\")\n\n--------------------------------------------------------------------------------------------------------------------------------\n\nBeautiful Soup will never be as fast as the parsers it sits on top of. If response time is critical, if you’re paying for computer time by the hour, or if there’s any other reason why computer time is more valuable than programmer time, you should forget about Beautiful Soup and work directly atop [lxml](http://lxml.de/)\n.\n\nThat said, there are things you can do to speed up Beautiful Soup. If you’re not using lxml as the underlying parser, my advice is to [start](https://beautiful-soup-4.readthedocs.io/en/latest/#parser-installation)\n. Beautiful Soup parses documents significantly faster using lxml than using html.parser or html5lib.\n\nYou can speed up encoding detection significantly by installing the [cchardet](http://pypi.python.org/pypi/cchardet/)\n library.\n\n[Parsing only part of a document](https://beautiful-soup-4.readthedocs.io/en/latest/#parsing-only-part-of-a-document)\n won’t save you much time parsing the document, but it can save a lot of memory, and it’ll make searching the document much faster.\n\nTranslating this documentation[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#translating-this-documentation \"Permalink to this headline\")\n\n==================================================================================================================================================\n\nNew translations of the Beautiful Soup documentation are greatly appreciated. Translations should be licensed under the MIT license, just like Beautiful Soup and its English documentation are.\n\nThere are two ways of getting your translation into the main code base and onto the Beautiful Soup website:\n\n1.  Create a branch of the Beautiful Soup repository, add your translation, and propose a merge with the main branch, the same as you would do with a proposed change to the source code.\n2.  Send a message to the Beautiful Soup discussion group with a link to your translation, or attach your translation to the message.\n\nUse the Chinese or Brazilian Portuguese translations as your model. In particular, please translate the source file `doc/source/index.rst`, rather than the HTML version of the documentation. This makes it possible to publish the documentation in a variety of formats, not just HTML.\n\nBeautiful Soup 3[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#id18 \"Permalink to this headline\")\n\n==========================================================================================================\n\nBeautiful Soup 3 is the previous release series, and is no longer being actively developed. It’s currently packaged with all major Linux distributions:\n\n$ apt-get install python-beautifulsoup\n\nIt’s also published through PyPi as `BeautifulSoup`.:\n\n$ easy\\_install BeautifulSoup\n\n$ pip install BeautifulSoup\n\nYou can also [download a tarball of Beautiful Soup 3.2.0](http://www.crummy.com/software/BeautifulSoup/bs3/download/3.x/BeautifulSoup-3.2.0.tar.gz)\n.\n\nIf you ran `easy_install beautifulsoup` or `easy_install BeautifulSoup`, but your code doesn’t work, you installed Beautiful Soup 3 by mistake. You need to run `easy_install beautifulsoup4`.\n\n[The documentation for Beautiful Soup 3 is archived online](http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html)\n.\n\nPorting code to BS4[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#porting-code-to-bs4 \"Permalink to this headline\")\n\n----------------------------------------------------------------------------------------------------------------------------\n\nMost code written against Beautiful Soup 3 will work against Beautiful Soup 4 with one simple change. All you should have to do is change the package name from `BeautifulSoup` to `bs4`. So this:\n\nfrom BeautifulSoup import BeautifulSoup\n\nbecomes this:\n\nfrom bs4 import BeautifulSoup\n\n*   If you get the `ImportError` “No module named BeautifulSoup”, your problem is that you’re trying to run Beautiful Soup 3 code, but you only have Beautiful Soup 4 installed.\n*   If you get the `ImportError` “No module named bs4”, your problem is that you’re trying to run Beautiful Soup 4 code, but you only have Beautiful Soup 3 installed.\n\nAlthough BS4 is mostly backwards-compatible with BS3, most of its methods have been deprecated and given new names for [PEP 8 compliance](http://www.python.org/dev/peps/pep-0008/)\n. There are numerous other renames and changes, and a few of them break backwards compatibility.\n\nHere’s what you’ll need to know to convert your BS3 code and habits to BS4:\n\n### You need a parser[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#you-need-a-parser \"Permalink to this headline\")\n\nBeautiful Soup 3 used Python’s `SGMLParser`, a module that was deprecated and removed in Python 3.0. Beautiful Soup 4 uses `html.parser` by default, but you can plug in lxml or html5lib and use that instead. See [Installing a parser](https://beautiful-soup-4.readthedocs.io/en/latest/#installing-a-parser)\n for a comparison.\n\nSince `html.parser` is not the same parser as `SGMLParser`, you may find that Beautiful Soup 4 gives you a different parse tree than Beautiful Soup 3 for the same markup. If you swap out `html.parser` for lxml or html5lib, you may find that the parse tree changes yet again. If this happens, you’ll need to update your scraping code to deal with the new tree.\n\n### Method names[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#method-names \"Permalink to this headline\")\n\n*   `renderContents` -> `encode_contents`\n*   `replaceWith` -> `replace_with`\n*   `replaceWithChildren` -> `unwrap`\n*   `findAll` -> `find_all`\n*   `findAllNext` -> `find_all_next`\n*   `findAllPrevious` -> `find_all_previous`\n*   `findNext` -> `find_next`\n*   `findNextSibling` -> `find_next_sibling`\n*   `findNextSiblings` -> `find_next_siblings`\n*   `findParent` -> `find_parent`\n*   `findParents` -> `find_parents`\n*   `findPrevious` -> `find_previous`\n*   `findPreviousSibling` -> `find_previous_sibling`\n*   `findPreviousSiblings` -> `find_previous_siblings`\n*   `getText` -> `get_text`\n*   `nextSibling` -> `next_sibling`\n*   `previousSibling` -> `previous_sibling`\n\nSome arguments to the Beautiful Soup constructor were renamed for the same reasons:\n\n*   `BeautifulSoup(parseOnlyThese=...)` -> `BeautifulSoup(parse_only=...)`\n*   `BeautifulSoup(fromEncoding=...)` -> `BeautifulSoup(from_encoding=...)`\n\nI renamed one method for compatibility with Python 3:\n\n*   `Tag.has_key()` -> `Tag.has_attr()`\n\nI renamed one attribute to use more accurate terminology:\n\n*   `Tag.isSelfClosing` -> `Tag.is_empty_element`\n\nI renamed three attributes to avoid using words that have special meaning to Python. Unlike the others, these changes are _not backwards compatible._ If you used these attributes in BS3, your code will break on BS4 until you change them.\n\n*   `UnicodeDammit.unicode` -> `UnicodeDammit.unicode_markup`\n*   `Tag.next` -> `Tag.next_element`\n*   `Tag.previous` -> `Tag.previous_element`\n\n### Generators[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#generators \"Permalink to this headline\")\n\nI gave the generators PEP 8-compliant names, and transformed them into properties:\n\n*   `childGenerator()` -> `children`\n*   `nextGenerator()` -> `next_elements`\n*   `nextSiblingGenerator()` -> `next_siblings`\n*   `previousGenerator()` -> `previous_elements`\n*   `previousSiblingGenerator()` -> `previous_siblings`\n*   `recursiveChildGenerator()` -> `descendants`\n*   `parentGenerator()` -> `parents`\n\nSo instead of this:\n\nfor parent in tag.parentGenerator():\n    ...\n\nYou can write this:\n\nfor parent in tag.parents:\n    ...\n\n(But the old code will still work.)\n\nSome of the generators used to yield `None` after they were done, and then stop. That was a bug. Now the generators just stop.\n\nThere are two new generators, [.strings and .stripped\\_strings](https://beautiful-soup-4.readthedocs.io/en/latest/#string-generators)\n. `.strings` yields NavigableString objects, and `.stripped_strings` yields Python strings that have had whitespace stripped.\n\n### XML[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#xml \"Permalink to this headline\")\n\nThere is no longer a `BeautifulStoneSoup` class for parsing XML. To parse XML you pass in “xml” as the second argument to the `BeautifulSoup` constructor. For the same reason, the `BeautifulSoup` constructor no longer recognizes the `isHTML` argument.\n\nBeautiful Soup’s handling of empty-element XML tags has been improved. Previously when you parsed XML you had to explicitly say which tags were considered empty-element tags. The `selfClosingTags` argument to the constructor is no longer recognized. Instead, Beautiful Soup considers any empty tag to be an empty-element tag. If you add a child to an empty-element tag, it stops being an empty-element tag.\n\n### Entities[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#entities \"Permalink to this headline\")\n\nAn incoming HTML or XML entity is always converted into the corresponding Unicode character. Beautiful Soup 3 had a number of overlapping ways of dealing with entities, which have been removed. The `BeautifulSoup` constructor no longer recognizes the `smartQuotesTo` or `convertEntities` arguments. ([Unicode, Dammit](https://beautiful-soup-4.readthedocs.io/en/latest/#unicode-dammit)\n still has `smart_quotes_to`, but its default is now to turn smart quotes into Unicode.) The constants `HTML_ENTITIES`, `XML_ENTITIES`, and `XHTML_ENTITIES` have been removed, since they configure a feature (transforming some but not all entities into Unicode characters) that no longer exists.\n\nIf you want to turn Unicode characters back into HTML entities on output, rather than turning them into UTF-8 characters, you need to use an [output formatter](https://beautiful-soup-4.readthedocs.io/en/latest/#output-formatters)\n.\n\n### Miscellaneous[¶](https://beautiful-soup-4.readthedocs.io/en/latest/#id19 \"Permalink to this headline\")\n\n[Tag.string](https://beautiful-soup-4.readthedocs.io/en/latest/#string)\n now operates recursively. If tag A contains a single tag B and nothing else, then A.string is the same as B.string. (Previously, it was None.)\n\n[Multi-valued attributes](https://beautiful-soup-4.readthedocs.io/en/latest/#multi-valued-attributes)\n like `class` have lists of strings as their values, not strings. This may affect the way you search by CSS class.\n\nIf you pass one of the `find*` methods both [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n and a tag-specific argument like [name](https://beautiful-soup-4.readthedocs.io/en/latest/#id11)\n, Beautiful Soup will search for tags that match your tag-specific criteria and whose [Tag.string](https://beautiful-soup-4.readthedocs.io/en/latest/#string)\n matches your value for [string](https://beautiful-soup-4.readthedocs.io/en/latest/#id12)\n. It will not find the strings themselves. Previously, Beautiful Soup ignored the tag-specific arguments and looked for strings.\n\nThe `BeautifulSoup` constructor no longer recognizes the markupMassage argument. It’s now the parser’s responsibility to handle markup correctly.\n\nThe rarely-used alternate parser classes like `ICantBelieveItsBeautifulSoup` and `BeautifulSOAP` have been removed. It’s now the parser’s decision how to handle ambiguous markup.\n\nThe `prettify()` method now returns a Unicode string, not a bytestring.","metadata":{"title":"Beautiful Soup Documentation — Beautiful Soup 4.4.0 documentation","readthedocs-project-slug":"beautiful-soup-4","language":"en","readthedocs-resolver-filename":"/","readthedocs-version-slug":"latest","readthedocs-http-status":"200","viewport":"width=device-width, initial-scale=1.0","scrapeId":"85a9e3cc-d917-484f-b77f-0c0a7fecf119","sourceURL":"https://beautiful-soup-4.readthedocs.io/en/latest/","url":"https://beautiful-soup-4.readthedocs.io/en/latest/","statusCode":200}},{"markdown":".. \\_documentation: Beautiful Soup Documentation ============================ .. image:: 6.1.jpg :align: right :alt: \"The Fish-Footman began by producing from under his arm a great letter, nearly as large as himself.\" \\`Beautiful Soup \\`\\_ is a Python library for pulling data out of HTML and XML files. It works with your favorite parser to provide idiomatic ways of navigating, searching, and modifying the parse tree. It commonly saves programmers hours or days of work. These instructions illustrate all major features of Beautiful Soup 4, with examples. I show you what the library is good for, how it works, how to use it, how to make it do what you want, and what to do when it violates your expectations. This document covers Beautiful Soup version 4.8.1. The examples in this documentation should work the same way in Python 2.7 and Python 3.2. You might be looking for the documentation for \\`Beautiful Soup 3 \\`\\_. If so, you should know that Beautiful Soup 3 is no longer being developed and that support for it will be dropped on or after December 31, 2020. If you want to learn about the differences between Beautiful Soup 3 and Beautiful Soup 4, see \\`Porting code to BS4\\`\\_. This documentation has been translated into other languages by Beautiful Soup users: \\* \\`è¿™ç¯‡æ–‡æ¡£å½“ç„¶è¿˜æœ‰ä¸­æ–‡ç‰ˆ. \\`\\_ \\* ã“ã®ãƒšãƒ¼ã‚¸ã¯æ—¥æœ¬èªžã§åˆ©ç”¨ã§ãã¾ã™(\\`å¤–éƒ¨ãƒªãƒ³ã‚¯ \\`\\_) \\* \\`ì´ ë¬¸ì„œëŠ” í•œêµ­ì–´ ë²ˆì—­ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤. \\`\\_ \\* \\`Este documento tambÃ©m estÃ¡ disponÃ­vel em PortuguÃªs do Brasil. \\`\\_ Getting help ------------ If you have questions about Beautiful Soup, or run into problems, \\`send mail to the discussion group \\`\\_. If your problem involves parsing an HTML document, be sure to mention :ref:\\`what the diagnose() function says \\` about that document. Quick Start =========== Here's an HTML document I'll be using as an example throughout this document. It's part of a story from \\`Alice in Wonderland\\`:: html\\_doc = \"\"\" The Dormouse's story\n\n**The Dormouse's story**\n\nOnce upon a time there were three little sisters; and their names were [Elsie](http://example.com/elsie)\n, [Lacie](http://example.com/lacie)\n and [Tillie](http://example.com/tillie)\n; and they lived at the bottom of a well.\n\n...\n\n\"\"\" Running the \"three sisters\" document through Beautiful Soup gives us a \\`\\`BeautifulSoup\\`\\` object, which represents the document as a nested data structure:: from bs4 import BeautifulSoup soup = BeautifulSoup(html\\_doc, 'html.parser') print(soup.prettify()) # # # \\# The Dormouse's story # \\# # #\n\n\\# **\\# The Dormouse's story #** #\n\n#\n\n\\# Once upon a time there were three little sisters; and their names were # [\\# Elsie #](http://example.com/elsie)\n \\# , # [\\# Lacie #](http://example.com/lacie)\n \\# and # [\\# Tillie #](http://example.com/tillie)\n \\# ; and they lived at the bottom of a well. #\n\n#\n\n\\# ... #\n\n\\# # Here are some simple ways to navigate that data structure:: soup.title # The Dormouse's story soup.title.name # u'title' soup.title.string # u'The Dormouse's story' soup.title.parent.name # u'head' soup.p #\n\n**The Dormouse's story**\n\nsoup.p\\['class'\\] # u'title' soup.a # [Elsie](http://example.com/elsie)\n soup.find\\_all('a') # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] soup.find(id=\"link3\") # [Tillie](http://example.com/tillie)\n One common task is extracting all the URLs found within a page's tags:: for link in soup.find\\_all('a'): print(link.get('href')) # http://example.com/elsie # http://example.com/lacie # http://example.com/tillie Another common task is extracting all the text from a page:: print(soup.get\\_text()) # The Dormouse's story # # The Dormouse's story # # Once upon a time there were three little sisters; and their names were # Elsie, # Lacie and # Tillie; # and they lived at the bottom of a well. # # ... Does this look like what you need? If so, read on. Installing Beautiful Soup ========================= If you're using a recent version of Debian or Ubuntu Linux, you can install Beautiful Soup with the system package manager: :kbd:\\`$ apt-get install python-bs4\\` (for Python 2) :kbd:\\`$ apt-get install python3-bs4\\` (for Python 3) Beautiful Soup 4 is published through PyPi, so if you can't install it with the system packager, you can install it with \\`\\`easy\\_install\\`\\` or \\`\\`pip\\`\\`. The package name is \\`\\`beautifulsoup4\\`\\`, and the same package works on Python 2 and Python 3. Make sure you use the right version of \\`\\`pip\\`\\` or \\`\\`easy\\_install\\`\\` for your Python version (these may be named \\`\\`pip3\\`\\` and \\`\\`easy\\_install3\\`\\` respectively if you're using Python 3). :kbd:\\`$ easy\\_install beautifulsoup4\\` :kbd:\\`$ pip install beautifulsoup4\\` (The \\`\\`BeautifulSoup\\`\\` package is probably \\`not\\` what you want. That's the previous major release, \\`Beautiful Soup 3\\`\\_. Lots of software uses BS3, so it's still available, but if you're writing new code you should install \\`\\`beautifulsoup4\\`\\`.) If you don't have \\`\\`easy\\_install\\`\\` or \\`\\`pip\\`\\` installed, you can \\`download the Beautiful Soup 4 source tarball \\`\\_ and install it with \\`\\`setup.py\\`\\`. :kbd:\\`$ python setup.py install\\` If all else fails, the license for Beautiful Soup allows you to package the entire library with your application. You can download the tarball, copy its \\`\\`bs4\\`\\` directory into your application's codebase, and use Beautiful Soup without installing it at all. I use Python 2.7 and Python 3.2 to develop Beautiful Soup, but it should work with other recent versions. Problems after installation --------------------------- Beautiful Soup is packaged as Python 2 code. When you install it for use with Python 3, it's automatically converted to Python 3 code. If you don't install the package, the code won't be converted. There have also been reports on Windows machines of the wrong version being installed. If you get the \\`\\`ImportError\\`\\` \"No module named HTMLParser\", your problem is that you're running the Python 2 version of the code under Python 3. If you get the \\`\\`ImportError\\`\\` \"No module named html.parser\", your problem is that you're running the Python 3 version of the code under Python 2. In both cases, your best bet is to completely remove the Beautiful Soup installation from your system (including any directory created when you unzipped the tarball) and try the installation again. If you get the \\`\\`SyntaxError\\`\\` \"Invalid syntax\" on the line \\`\\`ROOT\\_TAG\\_NAME = u'\\[document\\]'\\`\\`, you need to convert the Python 2 code to Python 3. You can do this either by installing the package: :kbd:\\`$ python3 setup.py install\\` or by manually running Python's \\`\\`2to3\\`\\` conversion script on the \\`\\`bs4\\`\\` directory: :kbd:\\`$ 2to3-3.2 -w bs4\\` .. \\_parser-installation: Installing a parser ------------------- Beautiful Soup supports the HTML parser included in Python's standard library, but it also supports a number of third-party Python parsers. One is the \\`lxml parser \\`\\_. Depending on your setup, you might install lxml with one of these commands: :kbd:\\`$ apt-get install python-lxml\\` :kbd:\\`$ easy\\_install lxml\\` :kbd:\\`$ pip install lxml\\` Another alternative is the pure-Python \\`html5lib parser \\`\\_, which parses HTML the way a web browser does. Depending on your setup, you might install html5lib with one of these commands: :kbd:\\`$ apt-get install python-html5lib\\` :kbd:\\`$ easy\\_install html5lib\\` :kbd:\\`$ pip install html5lib\\` This table summarizes the advantages and disadvantages of each parser library: +----------------------+--------------------------------------------+--------------------------------+--------------------------+ | Parser | Typical usage | Advantages | Disadvantages | +----------------------+--------------------------------------------+--------------------------------+--------------------------+ | Python's html.parser | \\`\\`BeautifulSoup(markup, \"html.parser\")\\`\\` | \\* Batteries included | \\* Not as fast as lxml, | | | | \\* Decent speed | less lenient than | | | | \\* Lenient (As of Python 2.7.3 | html5lib. | | | | and 3.2.) | | +----------------------+--------------------------------------------+--------------------------------+--------------------------+ | lxml's HTML parser | \\`\\`BeautifulSoup(markup, \"lxml\")\\`\\` | \\* Very fast | \\* External C dependency | | | | \\* Lenient | | +----------------------+--------------------------------------------+--------------------------------+--------------------------+ | lxml's XML parser | \\`\\`BeautifulSoup(markup, \"lxml-xml\")\\`\\` | \\* Very fast | \\* External C dependency | | | \\`\\`BeautifulSoup(markup, \"xml\")\\`\\` | \\* The only currently supported | | | | | XML parser | | +----------------------+--------------------------------------------+--------------------------------+--------------------------+ | html5lib | \\`\\`BeautifulSoup(markup, \"html5lib\")\\`\\` | \\* Extremely lenient | \\* Very slow | | | | \\* Parses pages the same way a | \\* External Python | | | | web browser does | dependency | | | | \\* Creates valid HTML5 | | +----------------------+--------------------------------------------+--------------------------------+--------------------------+ If you can, I recommend you install and use lxml for speed. If you're using a version of Python 2 earlier than 2.7.3, or a version of Python 3 earlier than 3.2.2, it's \\`essential\\` that you install lxml or html5lib--Python's built-in HTML parser is just not very good in older versions. Note that if a document is invalid, different parsers will generate different Beautiful Soup trees for it. See \\`Differences between parsers\\`\\_ for details. Making the soup =============== To parse a document, pass it into the \\`\\`BeautifulSoup\\`\\` constructor. You can pass in a string or an open filehandle:: from bs4 import BeautifulSoup with open(\"index.html\") as fp: soup = BeautifulSoup(fp) soup = BeautifulSoup(\"data\") First, the document is converted to Unicode, and HTML entities are converted to Unicode characters:: BeautifulSoup(\"Sacré bleu!\") SacrÃ© bleu! Beautiful Soup then parses the document using the best available parser. It will use an HTML parser unless you specifically tell it to use an XML parser. (See \\`Parsing XML\\`\\_.) Kinds of objects ================ Beautiful Soup transforms a complex HTML document into a complex tree of Python objects. But you'll only ever have to deal with about four \\`kinds\\` of objects: \\`\\`Tag\\`\\`, \\`\\`NavigableString\\`\\`, \\`\\`BeautifulSoup\\`\\`, and \\`\\`Comment\\`\\`. .. \\_Tag: \\`\\`Tag\\`\\` ------- A \\`\\`Tag\\`\\` object corresponds to an XML or HTML tag in the original document:: soup = BeautifulSoup('**Extremely bold**') tag = soup.b type(tag) # Tags have a lot of attributes and methods, and I'll cover most of them in \\`Navigating the tree\\`\\_ and \\`Searching the tree\\`\\_. For now, the most important features of a tag are its name and attributes. Name ^^^^ Every tag has a name, accessible as \\`\\`.name\\`\\`:: tag.name # u'b' If you change a tag's name, the change will be reflected in any HTML markup generated by Beautiful Soup:: tag.name = \"blockquote\" tag #\n\n> Extremely bold\n\nAttributes ^^^^^^^^^^ A tag may have any number of attributes. The tag \\`\\`**\\`\\` has an attribute \"id\" whose value is \"boldest\". You can access a tag's attributes by treating the tag like a dictionary:: tag\\['id'\\] # u'boldest' You can access that dictionary directly as \\`\\`.attrs\\`\\`:: tag.attrs # {u'id': 'boldest'} You can add, remove, and modify a tag's attributes. Again, this is done by treating the tag as a dictionary:: tag\\['id'\\] = 'verybold' tag\\['another-attribute'\\] = 1 tag # del tag\\['id'\\] del tag\\['another-attribute'\\] tag # tag\\['id'\\] # KeyError: 'id' print(tag.get('id')) # None .. \\_multivalue: Multi-valued attributes &&&&&&&&&&&&&&&&&&&&&&& HTML 4 defines a few attributes that can have multiple values. HTML 5 removes a couple of them, but defines a few more. The most common multi-valued attribute is \\`\\`class\\`\\` (that is, a tag can have more than one CSS class). Others include \\`\\`rel\\`\\`, \\`\\`rev\\`\\`, \\`\\`accept-charset\\`\\`, \\`\\`headers\\`\\`, and \\`\\`accesskey\\`\\`. Beautiful Soup presents the value(s) of a multi-valued attribute as a list:: css\\_soup = BeautifulSoup('\n\n') css\\_soup.p\\['class'\\] # \\[\"body\"\\] css\\_soup = BeautifulSoup('\n\n') css\\_soup.p\\['class'\\] # \\[\"body\", \"strikeout\"\\] If an attribute \\`looks\\` like it has more than one value, but it's not a multi-valued attribute as defined by any version of the HTML standard, Beautiful Soup will leave the attribute alone:: id\\_soup = BeautifulSoup('\n\n') id\\_soup.p\\['id'\\] # 'my id' When you turn a tag back into a string, multiple attribute values are consolidated:: rel\\_soup = BeautifulSoup('****\n\nBack to the homepage\n\n') rel\\_soup.a\\['rel'\\] # \\['index'\\] rel\\_soup.a\\['rel'\\] = \\['index', 'contents'\\] print(rel\\_soup.p) #\n\nBack to the homepage\n\nYou can disable this by passing \\`\\`multi\\_valued\\_attributes=None\\`\\` as a keyword argument into the \\`\\`BeautifulSoup\\`\\` constructor:: no\\_list\\_soup = BeautifulSoup('\n\n', 'html', multi\\_valued\\_attributes=None) no\\_list\\_soup.p\\['class'\\] # u'body strikeout' You can use \\`\\`\\`get\\_attribute\\_list\\`\\` to get a value that's always a list, whether or not it's a multi-valued atribute:: id\\_soup.p.get\\_attribute\\_list('id') # \\[\"my id\"\\] If you parse a document as XML, there are no multi-valued attributes:: xml\\_soup = BeautifulSoup('\n\n', 'xml') xml\\_soup.p\\['class'\\] # u'body strikeout' Again, you can configure this using the \\`\\`multi\\_valued\\_attributes\\`\\` argument:: class\\_is\\_multi= { '\\*' : 'class'} xml\\_soup = BeautifulSoup('\n\n', 'xml', multi\\_valued\\_attributes=class\\_is\\_multi) xml\\_soup.p\\['class'\\] # \\[u'body', u'strikeout'\\] You probably won't need to do this, but if you do, use the defaults as a guide. They implement the rules described in the HTML specification:: from bs4.builder import builder\\_registry builder\\_registry.lookup('html').DEFAULT\\_CDATA\\_LIST\\_ATTRIBUTES \\`\\`NavigableString\\`\\` ------------------- A string corresponds to a bit of text within a tag. Beautiful Soup uses the \\`\\`NavigableString\\`\\` class to contain these bits of text:: tag.string # u'Extremely bold' type(tag.string) # A \\`\\`NavigableString\\`\\` is just like a Python Unicode string, except that it also supports some of the features described in \\`Navigating the tree\\`\\_ and \\`Searching the tree\\`\\_. You can convert a \\`\\`NavigableString\\`\\` to a Unicode string with \\`\\`unicode()\\`\\`:: unicode\\_string = unicode(tag.string) unicode\\_string # u'Extremely bold' type(unicode\\_string) # You can't edit a string in place, but you can replace one string with another, using :ref:\\`replace\\_with()\\`:: tag.string.replace\\_with(\"No longer bold\") tag #\n\n> No longer bold\n\n\\`\\`NavigableString\\`\\` supports most of the features described in \\`Navigating the tree\\`\\_ and \\`Searching the tree\\`\\_, but not all of them. In particular, since a string can't contain anything (the way a tag may contain a string or another tag), strings don't support the \\`\\`.contents\\`\\` or \\`\\`.string\\`\\` attributes, or the \\`\\`find()\\`\\` method. If you want to use a \\`\\`NavigableString\\`\\` outside of Beautiful Soup, you should call \\`\\`unicode()\\`\\` on it to turn it into a normal Python Unicode string. If you don't, your string will carry around a reference to the entire Beautiful Soup parse tree, even when you're done using Beautiful Soup. This is a big waste of memory. \\`\\`BeautifulSoup\\`\\` ----------------- The \\`\\`BeautifulSoup\\`\\` object represents the parsed document as a whole. For most purposes, you can treat it as a :ref:\\`Tag\\` object. This means it supports most of the methods described in \\`Navigating the tree\\`\\_ and \\`Searching the tree\\`\\_. You can also pass a \\`\\`BeautifulSoup\\`\\` object into one of the methods defined in \\`Modifying the tree\\`\\_, just as you would a :ref:\\`Tag\\`. This lets you do things like combine two parsed documents:: doc = BeautifulSoup(\"INSERT FOOTER HEREHere's the footer\", \"xml\") doc.find(text=\"INSERT FOOTER HERE\").replace\\_with(footer) # u'INSERT FOOTER HERE' print(doc) # \\# Since the \\`\\`BeautifulSoup\\`\\` object doesn't correspond to an actual HTML or XML tag, it has no name and no attributes. But sometimes it's useful to look at its \\`\\`.name\\`\\`, so it's been given the special \\`\\`.name\\`\\` \"\\[document\\]\":: soup.name # u'\\[document\\]' Comments and other special strings ---------------------------------- \\`\\`Tag\\`\\`, \\`\\`NavigableString\\`\\`, and \\`\\`BeautifulSoup\\`\\` cover almost everything you'll see in an HTML or XML file, but there are a few leftover bits. The only one you'll probably ever need to worry about is the comment:: markup = \"\" soup = BeautifulSoup(markup) comment = soup.b.string type(comment) # The \\`\\`Comment\\`\\` object is just a special type of \\`\\`NavigableString\\`\\`:: comment # u'Hey, buddy. Want to buy a used parser' But when it appears as part of an HTML document, a \\`\\`Comment\\`\\` is displayed with special formatting:: print(soup.b.prettify()) # **\\# \\#** Beautiful Soup defines classes for anything else that might show up in an XML document: \\`\\`CData\\`\\`, \\`\\`ProcessingInstruction\\`\\`, \\`\\`Declaration\\`\\`, and \\`\\`Doctype\\`\\`. Just like \\`\\`Comment\\`\\`, these classes are subclasses of \\`\\`NavigableString\\`\\` that add something extra to the string. Here's an example that replaces the comment with a CDATA block:: from bs4 import CData cdata = CData(\"A CDATA block\") comment.replace\\_with(cdata) print(soup.b.prettify()) # **\\# \\#** Navigating the tree =================== Here's the \"Three sisters\" HTML document again:: html\\_doc = \"\"\" The Dormouse's story\n\n**The Dormouse's story**\n\nOnce upon a time there were three little sisters; and their names were [Elsie](http://example.com/elsie)\n, [Lacie](http://example.com/lacie)\n and [Tillie](http://example.com/tillie)\n; and they lived at the bottom of a well.\n\n...\n\n\"\"\" from bs4 import BeautifulSoup soup = BeautifulSoup(html\\_doc, 'html.parser') I'll use this as an example to show you how to move from one part of a document to another. Going down ---------- Tags may contain strings and other tags. These elements are the tag's \\`children\\`. Beautiful Soup provides a lot of different attributes for navigating and iterating over a tag's children. Note that Beautiful Soup strings don't support any of these attributes, because a string can't have children. Navigating using tag names ^^^^^^^^^^^^^^^^^^^^^^^^^^ The simplest way to navigate the parse tree is to say the name of the tag you want. If you want the tag, just say \\`\\`soup.head\\`\\`:: soup.head # The Dormouse's story soup.title # The Dormouse's story You can do use this trick again and again to zoom in on a certain part of the parse tree. This code gets the first **tag beneath the tag:: soup.body.b # **The Dormouse's story** Using a tag name as an attribute will give you only the \\`first\\` tag by that name:: soup.a # [Elsie](http://example.com/elsie)\n If you need to get \\`all\\` the tags, or anything more complicated than the first tag with a certain name, you'll need to use one of the methods described in \\`Searching the tree\\`\\_, such as \\`find\\_all()\\`:: soup.find\\_all('a') # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] \\`\\`.contents\\`\\` and \\`\\`.children\\`\\` ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ A tag's children are available in a list called \\`\\`.contents\\`\\`:: head\\_tag = soup.head head\\_tag # The Dormouse's story head\\_tag.contents \\[The Dormouse's story\\] title\\_tag = head\\_tag.contents\\[0\\] title\\_tag # The Dormouse's story title\\_tag.contents # \\[u'The Dormouse's story'\\] The \\`\\`BeautifulSoup\\`\\` object itself has children. In this case, the tag is the child of the \\`\\`BeautifulSoup\\`\\` object.:: len(soup.contents) # 1 soup.contents\\[0\\].name # u'html' A string does not have \\`\\`.contents\\`\\`, because it can't contain anything:: text = title\\_tag.contents\\[0\\] text.contents # AttributeError: 'NavigableString' object has no attribute 'contents' Instead of getting them as a list, you can iterate over a tag's children using the \\`\\`.children\\`\\` generator:: for child in title\\_tag.children: print(child) # The Dormouse's story \\`\\`.descendants\\`\\` ^^^^^^^^^^^^^^^^ The \\`\\`.contents\\`\\` and \\`\\`.children\\`\\` attributes only consider a tag's \\`direct\\` children. For instance, the tag has a single direct child--the tag:: head\\_tag.contents # \\[<title>The Dormouse's story\\] But the tag itself has a child: the string \"The Dormouse's story\". There's a sense in which that string is also a child of the <head> tag. The \\`\\`.descendants\\`\\` attribute lets you iterate over \\`all\\` of a tag's children, recursively: its direct children, the children of its direct children, and so on:: for child in head\\_tag.descendants: print(child) # <title>The Dormouse's story # The Dormouse's story The tag has only one child, but it has two descendants: the tag and the <title> tag's child. The \\`\\`BeautifulSoup\\`\\` object only has one direct child (the <html> tag), but it has a whole lot of descendants:: len(list(soup.children)) # 1 len(list(soup.descendants)) # 25 .. \\_.string: \\`\\`.string\\`\\` ^^^^^^^^^^^ If a tag has only one child, and that child is a \\`\\`NavigableString\\`\\`, the child is made available as \\`\\`.string\\`\\`:: title\\_tag.string # u'The Dormouse's story' If a tag's only child is another tag, and \\`that\\` tag has a \\`\\`.string\\`\\`, then the parent tag is considered to have the same \\`\\`.string\\`\\` as its child:: head\\_tag.contents # \\[<title>The Dormouse's story\\] head\\_tag.string # u'The Dormouse's story' If a tag contains more than one thing, then it's not clear what \\`\\`.string\\`\\` should refer to, so \\`\\`.string\\`\\` is defined to be \\`\\`None\\`\\`:: print(soup.html.string) # None .. \\_string-generators: \\`\\`.strings\\`\\` and \\`\\`stripped\\_strings\\`\\` ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ If there's more than one thing inside a tag, you can still look at just the strings. Use the \\`\\`.strings\\`\\` generator:: for string in soup.strings: print(repr(string)) # u\"The Dormouse's story\" # u'\\\\n\\\\n' # u\"The Dormouse's story\" # u'\\\\n\\\\n' # u'Once upon a time there were three little sisters; and their names were\\\\n' # u'Elsie' # u',\\\\n' # u'Lacie' # u' and\\\\n' # u'Tillie' # u';\\\\nand they lived at the bottom of a well.' # u'\\\\n\\\\n' # u'...' # u'\\\\n' These strings tend to have a lot of extra whitespace, which you can remove by using the \\`\\`.stripped\\_strings\\`\\` generator instead:: for string in soup.stripped\\_strings: print(repr(string)) # u\"The Dormouse's story\" # u\"The Dormouse's story\" # u'Once upon a time there were three little sisters; and their names were' # u'Elsie' # u',' # u'Lacie' # u'and' # u'Tillie' # u';\\\\nand they lived at the bottom of a well.' # u'...' Here, strings consisting entirely of whitespace are ignored, and whitespace at the beginning and end of strings is removed. Going up -------- Continuing the \"family tree\" analogy, every tag and every string has a \\`parent\\`: the tag that contains it. .. \\_.parent: \\`\\`.parent\\`\\` ^^^^^^^^^^^ You can access an element's parent with the \\`\\`.parent\\`\\` attribute. In the example \"three sisters\" document, the tag is the parent of the tag:: title\\_tag = soup.title title\\_tag # <title>The Dormouse's story title\\_tag.parent # The Dormouse's story The title string itself has a parent: the tag that contains it:: title\\_tag.string.parent # <title>The Dormouse's story The parent of a top-level tag like is the \\`\\`BeautifulSoup\\`\\` object itself:: html\\_tag = soup.html type(html\\_tag.parent) # And the \\`\\`.parent\\`\\` of a \\`\\`BeautifulSoup\\`\\` object is defined as None:: print(soup.parent) # None .. \\_.parents: \\`\\`.parents\\`\\` ^^^^^^^^^^^^ You can iterate over all of an element's parents with \\`\\`.parents\\`\\`. This example uses \\`\\`.parents\\`\\` to travel from an tag buried deep within the document, to the very top of the document:: link = soup.a link # [Elsie](http://example.com/elsie)\n for parent in link.parents: if parent is None: print(parent) else: print(parent.name) # p # body # html # \\[document\\] # None Going sideways -------------- Consider a simple document like this:: sibling\\_soup = BeautifulSoup(\"**text1**text2**\") print(sibling\\_soup.prettify()) # # # \\# **\\# text1 #** \\# \\# text2 # \\# \\# # The **tag and the tag are at the same level: they're both direct children of the same tag. We call them \\`siblings\\`. When a document is pretty-printed, siblings show up at the same indentation level. You can also use this relationship in the code you write. \\`\\`.next\\_sibling\\`\\` and \\`\\`.previous\\_sibling\\`\\` ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ You can use \\`\\`.next\\_sibling\\`\\` and \\`\\`.previous\\_sibling\\`\\` to navigate between page elements that are on the same level of the parse tree:: sibling\\_soup.b.next\\_sibling # text2 sibling\\_soup.c.previous\\_sibling # **text1** The **tag has a \\`\\`.next\\_sibling\\`\\`, but no \\`\\`.previous\\_sibling\\`\\`, because there's nothing before the **tag \\`on the same level of the tree\\`. For the same reason, the tag has a \\`\\`.previous\\_sibling\\`\\` but no \\`\\`.next\\_sibling\\`\\`:: print(sibling\\_soup.b.previous\\_sibling) # None print(sibling\\_soup.c.next\\_sibling) # None The strings \"text1\" and \"text2\" are \\`not\\` siblings, because they don't have the same parent:: sibling\\_soup.b.string # u'text1' print(sibling\\_soup.b.string.next\\_sibling) # None In real documents, the \\`\\`.next\\_sibling\\`\\` or \\`\\`.previous\\_sibling\\`\\` of a tag will usually be a string containing whitespace. Going back to the \"three sisters\" document:: [Elsie](http://example.com/elsie)\n [Lacie](http://example.com/lacie)\n [Tillie](http://example.com/tillie)\n You might think that the \\`\\`.next\\_sibling\\`\\` of the first tag would be the second tag. But actually, it's a string: the comma and newline that separate the first tag from the second:: link = soup.a link # [Elsie](http://example.com/elsie)\n link.next\\_sibling # u',\\\\n' The second tag is actually the \\`\\`.next\\_sibling\\`\\` of the comma:: link.next\\_sibling.next\\_sibling # [Lacie](http://example.com/lacie)\n .. \\_sibling-generators: \\`\\`.next\\_siblings\\`\\` and \\`\\`.previous\\_siblings\\`\\` ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ You can iterate over a tag's siblings with \\`\\`.next\\_siblings\\`\\` or \\`\\`.previous\\_siblings\\`\\`:: for sibling in soup.a.next\\_siblings: print(repr(sibling)) # u',\\\\n' # [Lacie](http://example.com/lacie)\n # u' and\\\\n' # [Tillie](http://example.com/tillie)\n # u'; and they lived at the bottom of a well.' # None for sibling in soup.find(id=\"link3\").previous\\_siblings: print(repr(sibling)) # ' and\\\\n' # [Lacie](http://example.com/lacie)\n # u',\\\\n' # [Elsie](http://example.com/elsie)\n # u'Once upon a time there were three little sisters; and their names were\\\\n' # None Going back and forth -------------------- Take a look at the beginning of the \"three sisters\" document:: The Dormouse's story\n\n**The Dormouse's story**\n\nAn HTML parser takes this string of characters and turns it into a series of events: \"open an tag\", \"open a tag\", \"open a tag\", \"add a string\", \"close the <title> tag\", \"open a <p> tag\", and so on. Beautiful Soup offers tools for reconstructing the initial parse of the document. .. \\_element-generators: \\`\\`.next\\_element\\`\\` and \\`\\`.previous\\_element\\`\\` ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ The \\`\\`.next\\_element\\`\\` attribute of a string or tag points to whatever was parsed immediately afterwards. It might be the same as \\`\\`.next\\_sibling\\`\\`, but it's usually drastically different. Here's the final <a> tag in the \"three sisters\" document. Its \\`\\`.next\\_sibling\\`\\` is a string: the conclusion of the sentence that was interrupted by the start of the <a> tag.:: last\\_a\\_tag = soup.find(\"a\", id=\"link3\") last\\_a\\_tag # <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a> last\\_a\\_tag.next\\_sibling # '; and they lived at the bottom of a well.' But the \\`\\`.next\\_element\\`\\` of that <a> tag, the thing that was parsed immediately after the <a> tag, is \\`not\\` the rest of that sentence: it's the word \"Tillie\":: last\\_a\\_tag.next\\_element # u'Tillie' That's because in the original markup, the word \"Tillie\" appeared before that semicolon. The parser encountered an <a> tag, then the word \"Tillie\", then the closing </a> tag, then the semicolon and rest of the sentence. The semicolon is on the same level as the <a> tag, but the word \"Tillie\" was encountered first. The \\`\\`.previous\\_element\\`\\` attribute is the exact opposite of \\`\\`.next\\_element\\`\\`. It points to whatever element was parsed immediately before this one:: last\\_a\\_tag.previous\\_element # u' and\\\\n' last\\_a\\_tag.previous\\_element.next\\_element # <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a> \\`\\`.next\\_elements\\`\\` and \\`\\`.previous\\_elements\\`\\` ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ You should get the idea by now. You can use these iterators to move forward or backward in the document as it was parsed:: for element in last\\_a\\_tag.next\\_elements: print(repr(element)) # u'Tillie' # u';\\\\nand they lived at the bottom of a well.' # u'\\\\n\\\\n' # <p class=\"story\">...</p> # u'...' # u'\\\\n' # None Searching the tree ================== Beautiful Soup defines a lot of methods for searching the parse tree, but they're all very similar. I'm going to spend a lot of time explaining the two most popular methods: \\`\\`find()\\`\\` and \\`\\`find\\_all()\\`\\`. The other methods take almost exactly the same arguments, so I'll just cover them briefly. Once again, I'll be using the \"three sisters\" document as an example:: html\\_doc = \"\"\" <html><head><title>The Dormouse's story\n\n**The Dormouse's story**\n\nOnce upon a time there were three little sisters; and their names were [Elsie](http://example.com/elsie)\n, [Lacie](http://example.com/lacie)\n and [Tillie](http://example.com/tillie)\n; and they lived at the bottom of a well.\n\n...\n\n\"\"\" from bs4 import BeautifulSoup soup = BeautifulSoup(html\\_doc, 'html.parser') By passing in a filter to an argument like \\`\\`find\\_all()\\`\\`, you can zoom in on the parts of the document you're interested in. Kinds of filters ---------------- Before talking in detail about \\`\\`find\\_all()\\`\\` and similar methods, I want to show examples of different filters you can pass into these methods. These filters show up again and again, throughout the search API. You can use them to filter based on a tag's name, on its attributes, on the text of a string, or on some combination of these. .. \\_a string: A string ^^^^^^^^ The simplest filter is a string. Pass a string to a search method and Beautiful Soup will perform a match against that exact string. This code finds all the **tags in the document:: soup.find\\_all('b') # \\[**The Dormouse's story**\\] If you pass in a byte string, Beautiful Soup will assume the string is encoded as UTF-8. You can avoid this by passing in a Unicode string instead. .. \\_a regular expression: A regular expression ^^^^^^^^^^^^^^^^^^^^ If you pass in a regular expression object, Beautiful Soup will filter against that regular expression using its \\`\\`search()\\`\\` method. This code finds all the tags whose names start with the letter \"b\"; in this case, the tag and the **tag:: import re for tag in soup.find\\_all(re.compile(\"^b\")): print(tag.name) # body # b This code finds all the tags whose names contain the letter 't':: for tag in soup.find\\_all(re.compile(\"t\")): print(tag.name) # html # title .. \\_a list: A list ^^^^^^ If you pass in a list, Beautiful Soup will allow a string match against \\`any\\` item in that list. This code finds all the tags \\`and\\` all the **tags:: soup.find\\_all(\\[\"a\", \"b\"\\]) # \\[**The Dormouse's story**, #** **[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] .. \\_the value True: \\`\\`True\\`\\` ^^^^^^^^ The value \\`\\`True\\`\\` matches everything it can. This code finds \\`all\\` the tags in the document, but none of the text strings:: for tag in soup.find\\_all(True): print(tag.name) # html # head # title # body # p # b # p # a # a # a # p .. a function: A function ^^^^^^^^^^ If none of the other matches work for you, define a function that takes an element as its only argument. The function should return \\`\\`True\\`\\` if the argument matches, and \\`\\`False\\`\\` otherwise. Here's a function that returns \\`\\`True\\`\\` if a tag defines the \"class\" attribute but doesn't define the \"id\" attribute:: def has\\_class\\_but\\_no\\_id(tag): return tag.has\\_attr('class') and not tag.has\\_attr('id') Pass this function into \\`\\`find\\_all()\\`\\` and you'll pick up all the\n\ntags:: soup.find\\_all(has\\_class\\_but\\_no\\_id) # \\[\\\n\\\n**The Dormouse's story**\\\n\\\n, #\\\n\\\nOnce upon a time there were...\\\n\\\n, #\\\n\\\n...\\\n\\\n\\] This function only picks up the\n\ntags. It doesn't pick up the tags, because those tags define both \"class\" and \"id\". It doesn't pick up tags like and , because those tags don't define \"class\". If you pass in a function to filter on a specific attribute like \\`\\`href\\`\\`, the argument passed into the function will be the attribute value, not the whole tag. Here's a function that finds all \\`\\`a\\`\\` tags whose \\`\\`href\\`\\` attribute \\*does not\\* match a regular expression:: def not\\_lacie(href): return href and not re.compile(\"lacie\").search(href) soup.find\\_all(href=not\\_lacie) # \\[<a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>, # <a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>\\] The function can be as complicated as you need it to be. Here's a function that returns \\`\\`True\\`\\` if a tag is surrounded by string objects:: from bs4 import NavigableString def surrounded\\_by\\_strings(tag): return (isinstance(tag.next\\_element, NavigableString) and isinstance(tag.previous\\_element, NavigableString)) for tag in soup.find\\_all(surrounded\\_by\\_strings): print tag.name # p # a # a # a # p Now we're ready to look at the search methods in detail. \\`\\`find\\_all()\\`\\` -------------- Signature: find\\_all(:ref:\\`name <name>\\`, :ref:\\`attrs <attrs>\\`, :ref:\\`recursive <recursive>\\`, :ref:\\`string <string>\\`, :ref:\\`limit <limit>\\`, :ref:\\`\\*\\*kwargs <kwargs>\\`) The \\`\\`find\\_all()\\`\\` method looks through a tag's descendants and retrieves \\`all\\` descendants that match your filters. I gave several examples in \\`Kinds of filters\\`\\_, but here are a few more:: soup.find\\_all(\"title\") # \\[<title>The Dormouse's story\\] soup.find\\_all(\"p\", \"title\") # \\[\\\n\\\n**The Dormouse's story**\\\n\\\n\\] soup.find\\_all(\"a\") # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] soup.find\\_all(id=\"link2\") # \\[[Lacie](http://example.com/lacie)\\\n\\] import re soup.find(string=re.compile(\"sisters\")) # u'Once upon a time there were three little sisters; and their names were\\\\n' Some of these should look familiar, but others are new. What does it mean to pass in a value for \\`\\`string\\`\\`, or \\`\\`id\\`\\`? Why does \\`\\`find\\_all(\"p\", \"title\")\\`\\` find a\n\ntag with the CSS class \"title\"? Let's look at the arguments to \\`\\`find\\_all()\\`\\`. .. \\_name: The \\`\\`name\\`\\` argument ^^^^^^^^^^^^^^^^^^^^^ Pass in a value for \\`\\`name\\`\\` and you'll tell Beautiful Soup to only consider tags with certain names. Text strings will be ignored, as will tags whose names that don't match. This is the simplest usage:: soup.find\\_all(\"title\") # \\[The Dormouse's story\\] Recall from \\`Kinds of filters\\`\\_ that the value to \\`\\`name\\`\\` can be \\`a string\\`\\_, \\`a regular expression\\`\\_, \\`a list\\`\\_, \\`a function\\`\\_, or \\`the value True\\`\\_. .. \\_kwargs: The keyword arguments ^^^^^^^^^^^^^^^^^^^^^ Any argument that's not recognized will be turned into a filter on one of a tag's attributes. If you pass in a value for an argument called \\`\\`id\\`\\`, Beautiful Soup will filter against each tag's 'id' attribute:: soup.find\\_all(id='link2') # \\[[Lacie](http://example.com/lacie)\\\n\\] If you pass in a value for \\`\\`href\\`\\`, Beautiful Soup will filter against each tag's 'href' attribute:: soup.find\\_all(href=re.compile(\"elsie\")) # \\[[Elsie](http://example.com/elsie)\\\n\\] You can filter an attribute based on \\`a string\\`\\_, \\`a regular expression\\`\\_, \\`a list\\`\\_, \\`a function\\`\\_, or \\`the value True\\`\\_. This code finds all tags whose \\`\\`id\\`\\` attribute has a value, regardless of what the value is:: soup.find\\_all(id=True) # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] You can filter multiple attributes at once by passing in more than one keyword argument:: soup.find\\_all(href=re.compile(\"elsie\"), id='link1') # \\[[three](http://example.com/elsie)\\\n\\] Some attributes, like the data-\\* attributes in HTML 5, have names that can't be used as the names of keyword arguments:: data\\_soup = BeautifulSoup('\n\nfoo!\n\n') data\\_soup.find\\_all(data-foo=\"value\") # SyntaxError: keyword can't be an expression You can use these attributes in searches by putting them into a dictionary and passing the dictionary into \\`\\`find\\_all()\\`\\` as the \\`\\`attrs\\`\\` argument:: data\\_soup.find\\_all(attrs={\"data-foo\": \"value\"}) # \\[\\\n\\\nfoo!\\\n\\\n\\] You can't use a keyword argument to search for HTML's 'name' element, because Beautiful Soup uses the \\`\\`name\\`\\` argument to contain the name of the tag itself. Instead, you can give a value to 'name' in the \\`\\`attrs\\`\\` argument:: name\\_soup = BeautifulSoup('') name\\_soup.find\\_all(name=\"email\") # \\[\\] name\\_soup.find\\_all(attrs={\"name\": \"email\"}) # \\[\\] .. \\_attrs: Searching by CSS class ^^^^^^^^^^^^^^^^^^^^^^ It's very useful to search for a tag that has a certain CSS class, but the name of the CSS attribute, \"class\", is a reserved word in Python. Using \\`\\`class\\`\\` as a keyword argument will give you a syntax error. As of Beautiful Soup 4.1.2, you can search by CSS class using the keyword argument \\`\\`class\\_\\`\\`:: soup.find\\_all(\"a\", class\\_=\"sister\") # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] As with any keyword argument, you can pass \\`\\`class\\_\\`\\` a string, a regular expression, a function, or \\`\\`True\\`\\`:: soup.find\\_all(class\\_=re.compile(\"itl\")) # \\[\\\n\\\n**The Dormouse's story**\\\n\\\n\\] def has\\_six\\_characters(css\\_class): return css\\_class is not None and len(css\\_class) == 6 soup.find\\_all(class\\_=has\\_six\\_characters) # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] :ref:\\`Remember \\` that a single tag can have multiple values for its \"class\" attribute. When you search for a tag that matches a certain CSS class, you're matching against \\`any\\` of its CSS classes:: css\\_soup = BeautifulSoup('\n\n') css\\_soup.find\\_all(\"p\", class\\_=\"strikeout\") # \\[\\\n\\\n\\] css\\_soup.find\\_all(\"p\", class\\_=\"body\") # \\[\\\n\\\n\\] You can also search for the exact string value of the \\`\\`class\\`\\` attribute:: css\\_soup.find\\_all(\"p\", class\\_=\"body strikeout\") # \\[\\\n\\\n\\] But searching for variants of the string value won't work:: css\\_soup.find\\_all(\"p\", class\\_=\"strikeout body\") # \\[\\] If you want to search for tags that match two or more CSS classes, you should use a CSS selector:: css\\_soup.select(\"p.strikeout.body\") # \\[\\\n\\\n\\] In older versions of Beautiful Soup, which don't have the \\`\\`class\\_\\`\\` shortcut, you can use the \\`\\`attrs\\`\\` trick mentioned above. Create a dictionary whose value for \"class\" is the string (or regular expression, or whatever) you want to search for:: soup.find\\_all(\"a\", attrs={\"class\": \"sister\"}) # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] .. \\_string: The \\`\\`string\\`\\` argument ^^^^^^^^^^^^^^^^^^^^^^^ With \\`\\`string\\`\\` you can search for strings instead of tags. As with \\`\\`name\\`\\` and the keyword arguments, you can pass in \\`a string\\`\\_, \\`a regular expression\\`\\_, \\`a list\\`\\_, \\`a function\\`\\_, or \\`the value True\\`\\_. Here are some examples:: soup.find\\_all(string=\"Elsie\") # \\[u'Elsie'\\] soup.find\\_all(string=\\[\"Tillie\", \"Elsie\", \"Lacie\"\\]) # \\[u'Elsie', u'Lacie', u'Tillie'\\] soup.find\\_all(string=re.compile(\"Dormouse\")) \\[u\"The Dormouse's story\", u\"The Dormouse's story\"\\] def is\\_the\\_only\\_string\\_within\\_a\\_tag(s): \"\"\"Return True if this string is the only child of its parent tag.\"\"\" return (s == s.parent.string) soup.find\\_all(string=is\\_the\\_only\\_string\\_within\\_a\\_tag) # \\[u\"The Dormouse's story\", u\"The Dormouse's story\", u'Elsie', u'Lacie', u'Tillie', u'...'\\] Although \\`\\`string\\`\\` is for finding strings, you can combine it with arguments that find tags: Beautiful Soup will find all tags whose \\`\\`.string\\`\\` matches your value for \\`\\`string\\`\\`. This code finds the tags whose \\`\\`.string\\`\\` is \"Elsie\":: soup.find\\_all(\"a\", string=\"Elsie\") # \\[[Elsie](http://example.com/elsie)\\\n\\] The \\`\\`string\\`\\` argument is new in Beautiful Soup 4.4.0. In earlier versions it was called \\`\\`text\\`\\`:: soup.find\\_all(\"a\", text=\"Elsie\") # \\[[Elsie](http://example.com/elsie)\\\n\\] .. \\_limit: The \\`\\`limit\\`\\` argument ^^^^^^^^^^^^^^^^^^^^^^ \\`\\`find\\_all()\\`\\` returns all the tags and strings that match your filters. This can take a while if the document is large. If you don't need \\`all\\` the results, you can pass in a number for \\`\\`limit\\`\\`. This works just like the LIMIT keyword in SQL. It tells Beautiful Soup to stop gathering results after it's found a certain number. There are three links in the \"three sisters\" document, but this code only finds the first two:: soup.find\\_all(\"a\", limit=2) # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n\\] .. \\_recursive: The \\`\\`recursive\\`\\` argument ^^^^^^^^^^^^^^^^^^^^^^^^^^ If you call \\`\\`mytag.find\\_all()\\`\\`, Beautiful Soup will examine all the descendants of \\`\\`mytag\\`\\`: its children, its children's children, and so on. If you only want Beautiful Soup to consider direct children, you can pass in \\`\\`recursive=False\\`\\`. See the difference here:: soup.html.find\\_all(\"title\") # \\[The Dormouse's story\\] soup.html.find\\_all(\"title\", recursive=False) # \\[\\] Here's that part of the document:: The Dormouse's story ... The tag is beneath the <html> tag, but it's not \\`directly\\` beneath the <html> tag: the <head> tag is in the way. Beautiful Soup finds the <title> tag when it's allowed to look at all descendants of the <html> tag, but when \\`\\`recursive=False\\`\\` restricts it to the <html> tag's immediate children, it finds nothing. Beautiful Soup offers a lot of tree-searching methods (covered below), and they mostly take the same arguments as \\`\\`find\\_all()\\`\\`: \\`\\`name\\`\\`, \\`\\`attrs\\`\\`, \\`\\`string\\`\\`, \\`\\`limit\\`\\`, and the keyword arguments. But the \\`\\`recursive\\`\\` argument is different: \\`\\`find\\_all()\\`\\` and \\`\\`find()\\`\\` are the only methods that support it. Passing \\`\\`recursive=False\\`\\` into a method like \\`\\`find\\_parents()\\`\\` wouldn't be very useful. Calling a tag is like calling \\`\\`find\\_all()\\`\\` -------------------------------------------- Because \\`\\`find\\_all()\\`\\` is the most popular method in the Beautiful Soup search API, you can use a shortcut for it. If you treat the \\`\\`BeautifulSoup\\`\\` object or a \\`\\`Tag\\`\\` object as though it were a function, then it's the same as calling \\`\\`find\\_all()\\`\\` on that object. These two lines of code are equivalent:: soup.find\\_all(\"a\") soup(\"a\") These two lines are also equivalent:: soup.title.find\\_all(string=True) soup.title(string=True) \\`\\`find()\\`\\` ---------- Signature: find(:ref:\\`name <name>\\`, :ref:\\`attrs <attrs>\\`, :ref:\\`recursive <recursive>\\`, :ref:\\`string <string>\\`, :ref:\\`\\*\\*kwargs <kwargs>\\`) The \\`\\`find\\_all()\\`\\` method scans the entire document looking for results, but sometimes you only want to find one result. If you know a document only has one <body> tag, it's a waste of time to scan the entire document looking for more. Rather than passing in \\`\\`limit=1\\`\\` every time you call \\`\\`find\\_all\\`\\`, you can use the \\`\\`find()\\`\\` method. These two lines of code are \\`nearly\\` equivalent:: soup.find\\_all('title', limit=1) # \\[<title>The Dormouse's story\\] soup.find('title') # The Dormouse's story The only difference is that \\`\\`find\\_all()\\`\\` returns a list containing the single result, and \\`\\`find()\\`\\` just returns the result. If \\`\\`find\\_all()\\`\\` can't find anything, it returns an empty list. If \\`\\`find()\\`\\` can't find anything, it returns \\`\\`None\\`\\`:: print(soup.find(\"nosuchtag\")) # None Remember the \\`\\`soup.head.title\\`\\` trick from \\`Navigating using tag names\\`\\_? That trick works by repeatedly calling \\`\\`find()\\`\\`:: soup.head.title # The Dormouse's story soup.find(\"head\").find(\"title\") # The Dormouse's story \\`\\`find\\_parents()\\`\\` and \\`\\`find\\_parent()\\`\\` ---------------------------------------- Signature: find\\_parents(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`limit \\`, :ref:\\`\\*\\*kwargs \\`) Signature: find\\_parent(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`\\*\\*kwargs \\`) I spent a lot of time above covering \\`\\`find\\_all()\\`\\` and \\`\\`find()\\`\\`. The Beautiful Soup API defines ten other methods for searching the tree, but don't be afraid. Five of these methods are basically the same as \\`\\`find\\_all()\\`\\`, and the other five are basically the same as \\`\\`find()\\`\\`. The only differences are in what parts of the tree they search. First let's consider \\`\\`find\\_parents()\\`\\` and \\`\\`find\\_parent()\\`\\`. Remember that \\`\\`find\\_all()\\`\\` and \\`\\`find()\\`\\` work their way down the tree, looking at tag's descendants. These methods do the opposite: they work their way \\`up\\` the tree, looking at a tag's (or a string's) parents. Let's try them out, starting from a string buried deep in the \"three daughters\" document:: a\\_string = soup.find(string=\"Lacie\") a\\_string # u'Lacie' a\\_string.find\\_parents(\"a\") # \\[[Lacie](http://example.com/lacie)\\\n\\] a\\_string.find\\_parent(\"p\") #\n\nOnce upon a time there were three little sisters; and their names were # [Elsie](http://example.com/elsie)\n, # [Lacie](http://example.com/lacie)\n and # [Tillie](http://example.com/tillie)\n; # and they lived at the bottom of a well.\n\na\\_string.find\\_parents(\"p\", class=\"title\") # \\[\\] One of the three tags is the direct parent of the string in question, so our search finds it. One of the three\n\ntags is an indirect parent of the string, and our search finds that as well. There's a\n\ntag with the CSS class \"title\" \\`somewhere\\` in the document, but it's not one of this string's parents, so we can't find it with \\`\\`find\\_parents()\\`\\`. You may have made the connection between \\`\\`find\\_parent()\\`\\` and \\`\\`find\\_parents()\\`\\`, and the \\`.parent\\`\\_ and \\`.parents\\`\\_ attributes mentioned earlier. The connection is very strong. These search methods actually use \\`\\`.parents\\`\\` to iterate over all the parents, and check each one against the provided filter to see if it matches. \\`\\`find\\_next\\_siblings()\\`\\` and \\`\\`find\\_next\\_sibling()\\`\\` ---------------------------------------------------- Signature: find\\_next\\_siblings(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`limit \\`, :ref:\\`\\*\\*kwargs \\`) Signature: find\\_next\\_sibling(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`\\*\\*kwargs \\`) These methods use :ref:\\`.next\\_siblings \\` to iterate over the rest of an element's siblings in the tree. The \\`\\`find\\_next\\_siblings()\\`\\` method returns all the siblings that match, and \\`\\`find\\_next\\_sibling()\\`\\` only returns the first one:: first\\_link = soup.a first\\_link # [Elsie](http://example.com/elsie)\n first\\_link.find\\_next\\_siblings(\"a\") # \\[[Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] first\\_story\\_paragraph = soup.find(\"p\", \"story\") first\\_story\\_paragraph.find\\_next\\_sibling(\"p\") #\n\n...\n\n\\`\\`find\\_previous\\_siblings()\\`\\` and \\`\\`find\\_previous\\_sibling()\\`\\` ------------------------------------------------------------ Signature: find\\_previous\\_siblings(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`limit \\`, :ref:\\`\\*\\*kwargs \\`) Signature: find\\_previous\\_sibling(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`\\*\\*kwargs \\`) These methods use :ref:\\`.previous\\_siblings \\` to iterate over an element's siblings that precede it in the tree. The \\`\\`find\\_previous\\_siblings()\\`\\` method returns all the siblings that match, and \\`\\`find\\_previous\\_sibling()\\`\\` only returns the first one:: last\\_link = soup.find(\"a\", id=\"link3\") last\\_link # [Tillie](http://example.com/tillie)\n last\\_link.find\\_previous\\_siblings(\"a\") # \\[[Lacie](http://example.com/lacie)\\\n, # [Elsie](http://example.com/elsie)\\\n\\] first\\_story\\_paragraph = soup.find(\"p\", \"story\") first\\_story\\_paragraph.find\\_previous\\_sibling(\"p\") #\n\n**The Dormouse's story**\n\n\\`\\`find\\_all\\_next()\\`\\` and \\`\\`find\\_next()\\`\\` --------------------------------------- Signature: find\\_all\\_next(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`limit \\`, :ref:\\`\\*\\*kwargs \\`) Signature: find\\_next(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`\\*\\*kwargs \\`) These methods use :ref:\\`.next\\_elements \\` to iterate over whatever tags and strings that come after it in the document. The \\`\\`find\\_all\\_next()\\`\\` method returns all matches, and \\`\\`find\\_next()\\`\\` only returns the first match:: first\\_link = soup.a first\\_link # [Elsie](http://example.com/elsie)\n first\\_link.find\\_all\\_next(string=True) # \\[u'Elsie', u',\\\\n', u'Lacie', u' and\\\\n', u'Tillie', # u';\\\\nand they lived at the bottom of a well.', u'\\\\n\\\\n', u'...', u'\\\\n'\\] first\\_link.find\\_next(\"p\") #\n\n...\n\nIn the first example, the string \"Elsie\" showed up, even though it was contained within the tag we started from. In the second example, the last\n\ntag in the document showed up, even though it's not in the same part of the tree as the tag we started from. For these methods, all that matters is that an element match the filter, and show up later in the document than the starting element. \\`\\`find\\_all\\_previous()\\`\\` and \\`\\`find\\_previous()\\`\\` ----------------------------------------------- Signature: find\\_all\\_previous(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`limit \\`, :ref:\\`\\*\\*kwargs \\`) Signature: find\\_previous(:ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, :ref:\\`\\*\\*kwargs \\`) These methods use :ref:\\`.previous\\_elements \\` to iterate over the tags and strings that came before it in the document. The \\`\\`find\\_all\\_previous()\\`\\` method returns all matches, and \\`\\`find\\_previous()\\`\\` only returns the first match:: first\\_link = soup.a first\\_link # [Elsie](http://example.com/elsie)\n first\\_link.find\\_all\\_previous(\"p\") # \\[\\\n\\\nOnce upon a time there were three little sisters; ...\\\n\\\n, #\\\n\\\n**The Dormouse's story**\\\n\\\n\\] first\\_link.find\\_previous(\"title\") # The Dormouse's story The call to \\`\\`find\\_all\\_previous(\"p\")\\`\\` found the first paragraph in the document (the one with class=\"title\"), but it also finds the second paragraph, the\n\ntag that contains the tag we started with. This shouldn't be too surprising: we're looking at all the tags that show up earlier in the document than the one we started with. A\n\ntag that contains an tag must have shown up before the tag it contains. CSS selectors ------------- As of version 4.7.0, Beautiful Soup supports most CSS4 selectors via the \\`SoupSieve \\`\\_ project. If you installed Beautiful Soup through \\`\\`pip\\`\\`, SoupSieve was installed at the same time, so you don't have to do anything extra. \\`\\`BeautifulSoup\\`\\` has a \\`\\`.select()\\`\\` method which uses SoupSieve to run a CSS selector against a parsed document and return all the matching elements. \\`\\`Tag\\`\\` has a similar method which runs a CSS selector against the contents of a single tag. (Earlier versions of Beautiful Soup also have the \\`\\`.select()\\`\\` method, but only the most commonly-used CSS selectors are supported.) The SoupSieve \\`documentation \\`\\_ lists all the currently supported CSS selectors, but here are some of the basics: You can find tags:: soup.select(\"title\") # \\[The Dormouse's story\\] soup.select(\"p:nth-of-type(3)\") # \\[\\\n\\\n...\\\n\\\n\\] Find tags beneath other tags:: soup.select(\"body a\") # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] soup.select(\"html head title\") # \\[The Dormouse's story\\] Find tags \\`directly\\` beneath other tags:: soup.select(\"head > title\") # \\[The Dormouse's story\\] soup.select(\"p > a\") # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] soup.select(\"p > a:nth-of-type(2)\") # \\[[Lacie](http://example.com/lacie)\\\n\\] soup.select(\"p > #link1\") # \\[[Elsie](http://example.com/elsie)\\\n\\] soup.select(\"body > a\") # \\[\\] Find the siblings of tags:: soup.select(\"#link1 ~ .sister\") # \\[[Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] soup.select(\"#link1 + .sister\") # \\[[Lacie](http://example.com/lacie)\\\n\\] Find tags by CSS class:: soup.select(\".sister\") # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] soup.select(\"\\[class~=sister\\]\") # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] Find tags by ID:: soup.select(\"#link1\") # \\[[Elsie](http://example.com/elsie)\\\n\\] soup.select(\"a#link2\") # \\[[Lacie](http://example.com/lacie)\\\n\\] Find tags that match any selector from a list of selectors:: soup.select(\"#link1,#link2\") # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n\\] Test for the existence of an attribute:: soup.select('a\\[href\\]') # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] Find tags by attribute value:: soup.select('a\\[href=\"http://example.com/elsie\"\\]') # \\[[Elsie](http://example.com/elsie)\\\n\\] soup.select('a\\[href^=\"http://example.com/\"\\]') # \\[[Elsie](http://example.com/elsie)\\\n, # [Lacie](http://example.com/lacie)\\\n, # [Tillie](http://example.com/tillie)\\\n\\] soup.select('a\\[href$=\"tillie\"\\]') # \\[[Tillie](http://example.com/tillie)\\\n\\] soup.select('a\\[href\\*=\".com/el\"\\]') # \\[[Elsie](http://example.com/elsie)\\\n\\] There's also a method called \\`\\`select\\_one()\\`\\`, which finds only the first tag that matches a selector:: soup.select\\_one(\".sister\") # [Elsie](http://example.com/elsie)\n If you've parsed XML that defines namespaces, you can use them in CSS selectors.:: from bs4 import BeautifulSoup xml = \"\"\" I'm in namespace 1 I'm in namespace 2 \"\"\" soup = BeautifulSoup(xml, \"xml\") soup.select(\"child\") # \\[I'm in namespace 1, I'm in namespace 2\\] soup.select(\"ns1|child\", namespaces=namespaces) # \\[I'm in namespace 1\\] When handling a CSS selector that uses namespaces, Beautiful Soup uses the namespace abbreviations it found when parsing the document. You can override this by passing in your own dictionary of abbreviations:: namespaces = dict(first=\"http://namespace1/\", second=\"http://namespace2/\") soup.select(\"second|child\", namespaces=namespaces) # \\[I'm in namespace 2\\] All this CSS selector stuff is a convenience for people who already know the CSS selector syntax. You can do all of this with the Beautiful Soup API. And if CSS selectors are all you need, you should parse the document with lxml: it's a lot faster. But this lets you \\`combine\\` CSS selectors with the Beautiful Soup API. Modifying the tree ================== Beautiful Soup's main strength is in searching the parse tree, but you can also modify the tree and write your changes as a new HTML or XML document. Changing tag names and attributes --------------------------------- I covered this earlier, in \\`Attributes\\`\\_, but it bears repeating. You can rename a tag, change the values of its attributes, add new attributes, and delete attributes:: soup = BeautifulSoup('**Extremely bold**') tag = soup.b tag.name = \"blockquote\" tag\\['class'\\] = 'verybold' tag\\['id'\\] = 1 tag #\n\n> Extremely bold\n\ndel tag\\['class'\\] del tag\\['id'\\] tag #\n\n> Extremely bold\n\nModifying \\`\\`.string\\`\\` --------------------- If you set a tag's \\`\\`.string\\`\\` attribute to a new string, the tag's contents are replaced with that string:: markup = '[I linked to _example.com_](http://example.com/)\n' soup = BeautifulSoup(markup) tag = soup.a tag.string = \"New link text.\" tag # [New link text.](http://example.com/)\n Be careful: if the tag contained other tags, they and all their contents will be destroyed. \\`\\`append()\\`\\` ------------ You can add to a tag's contents with \\`\\`Tag.append()\\`\\`. It works just like calling \\`\\`.append()\\`\\` on a Python list:: soup = BeautifulSoup(\"Foo\") soup.a.append(\"Bar\") soup # FooBar soup.a.contents # \\[u'Foo', u'Bar'\\] \\`\\`extend()\\`\\` ------------ Starting in Beautiful Soup 4.7.0, \\`\\`Tag\\`\\` also supports a method called \\`\\`.extend()\\`\\`, which works just like calling \\`\\`.extend()\\`\\` on a Python list:: soup = BeautifulSoup(\"Soup\") soup.a.extend(\\[\"'s\", \" \", \"on\"\\]) soup # Soup's on soup.a.contents # \\[u'Soup', u''s', u' ', u'on'\\] \\`\\`NavigableString()\\`\\` and \\`\\`.new\\_tag()\\`\\` ------------------------------------------------- If you need to add a string to a document, no problem--you can pass a Python string in to \\`\\`append()\\`\\`, or you can call the \\`\\`NavigableString\\`\\` constructor:: soup = BeautifulSoup(\"\") tag = soup.b tag.append(\"Hello\") new\\_string = NavigableString(\" there\") tag.append(new\\_string) tag # **Hello there.** tag.contents # \\[u'Hello', u' there'\\] If you want to create a comment or some other subclass of \\`\\`NavigableString\\`\\`, just call the constructor:: from bs4 import Comment new\\_comment = Comment(\"Nice to see you.\") tag.append(new\\_comment) tag # **Hello there** tag.contents # \\[u'Hello', u' there', u'Nice to see you.'\\] (This is a new feature in Beautiful Soup 4.4.0.) What if you need to create a whole new tag? The best solution is to call the factory method \\`\\`BeautifulSoup.new\\_tag()\\`\\`:: soup = BeautifulSoup(\"\") original\\_tag = soup.b new\\_tag = soup.new\\_tag(\"a\", href=\"http://www.example.com\") original\\_tag.append(new\\_tag) original\\_tag # **[](http://www.example.com/)\n**new\\_tag.string = \"Link text.\" original\\_tag # **[Link text.](http://www.example.com/)\n** Only the first argument, the tag name, is required. \\`\\`insert()\\`\\` ------------ \\`\\`Tag.insert()\\`\\` is just like \\`\\`Tag.append()\\`\\`, except the new element doesn't necessarily go at the end of its parent's \\`\\`.contents\\`\\`. It'll be inserted at whatever numeric position you say. It works just like \\`\\`.insert()\\`\\` on a Python list:: markup = '[I linked to _example.com_](http://example.com/)\n' soup = BeautifulSoup(markup) tag = soup.a tag.insert(1, \"but did not endorse \") tag # [I linked to but did not endorse _example.com_](http://example.com/)\n tag.contents # \\[u'I linked to ', u'but did not endorse', _example.com_\\] \\`\\`insert\\_before()\\`\\` and \\`\\`insert\\_after()\\`\\` ------------------------------------------ The \\`\\`insert\\_before()\\`\\` method inserts tags or strings immediately before something else in the parse tree:: soup = BeautifulSoup(\"**stop**\") tag = soup.new\\_tag(\"i\") tag.string = \"Don't\" soup.b.string.insert\\_before(tag) soup.b # **_Don't_stop** The \\`\\`insert\\_after()\\`\\` method inserts tags or strings immediately following something else in the parse tree:: div = soup.new\\_tag('div') div.string = 'ever' soup.b.i.insert\\_after(\" you \", div) soup.b # **_Don't_ you\n\never\n\nstop** soup.b.contents # \\[_Don't_, u' you',\\\n\\\never\\\n\\\n, u'stop'\\] \\`\\`clear()\\`\\` ----------- \\`\\`Tag.clear()\\`\\` removes the contents of a tag:: markup = '[I linked to _example.com_](http://example.com/)\n' soup = BeautifulSoup(markup) tag = soup.a tag.clear() tag # [](http://example.com/)\n\\`\\`extract()\\`\\` ------------- \\`\\`PageElement.extract()\\`\\` removes a tag or string from the tree. It returns the tag or string that was extracted:: markup = '[I linked to _example.com_](http://example.com/)\n' soup = BeautifulSoup(markup) a\\_tag = soup.a i\\_tag = soup.i.extract() a\\_tag # [I linked to](http://example.com/)\n i\\_tag # _example.com_ print(i\\_tag.parent) None At this point you effectively have two parse trees: one rooted at the \\`\\`BeautifulSoup\\`\\` object you used to parse the document, and one rooted at the tag that was extracted. You can go on to call \\`\\`extract\\`\\` on a child of the element you extracted:: my\\_string = i\\_tag.string.extract() my\\_string # u'example.com' print(my\\_string.parent) # None i\\_tag # \\`\\`decompose()\\`\\` --------------- \\`\\`Tag.decompose()\\`\\` removes a tag from the tree, then \\`completely destroys it and its contents\\`:: markup = '[I linked to _example.com_](http://example.com/)\n' soup = BeautifulSoup(markup) a\\_tag = soup.a soup.i.decompose() a\\_tag # [I linked to](http://example.com/)\n .. \\_replace\\_with(): \\`\\`replace\\_with()\\`\\` ------------------ \\`\\`PageElement.replace\\_with()\\`\\` removes a tag or string from the tree, and replaces it with the tag or string of your choice:: markup = '[I linked to _example.com_](http://example.com/)\n' soup = BeautifulSoup(markup) a\\_tag = soup.a new\\_tag = soup.new\\_tag(\"b\") new\\_tag.string = \"example.net\" a\\_tag.i.replace\\_with(new\\_tag) a\\_tag # [I linked to **example.net**](http://example.com/)\n \\`\\`replace\\_with()\\`\\` returns the tag or string that was replaced, so that you can examine it or add it back to another part of the tree. \\`\\`wrap()\\`\\` ---------- \\`\\`PageElement.wrap()\\`\\` wraps an element in the tag you specify. It returns the new wrapper:: soup = BeautifulSoup(\"\n\nI wish I was bold.\n\n\") soup.p.string.wrap(soup.new\\_tag(\"b\")) # **I wish I was bold.** soup.p.wrap(soup.new\\_tag(\"div\") #\n\n**I wish I was bold.**\n\nThis method is new in Beautiful Soup 4.0.5. \\`\\`unwrap()\\`\\` --------------------------- \\`\\`Tag.unwrap()\\`\\` is the opposite of \\`\\`wrap()\\`\\`. It replaces a tag with whatever's inside that tag. It's good for stripping out markup:: markup = '[I linked to _example.com_](http://example.com/)\n' soup = BeautifulSoup(markup) a\\_tag = soup.a a\\_tag.i.unwrap() a\\_tag # [I linked to example.com](http://example.com/)\n Like \\`\\`replace\\_with()\\`\\`, \\`\\`unwrap()\\`\\` returns the tag that was replaced. \\`\\`smooth()\\`\\` --------------------------- After calling a bunch of methods that modify the parse tree, you may end up with two or more \\`\\`NavigableString\\`\\` objects next to each other. Beautiful Soup doesn't have any problems with this, but since it can't happen in a freshly parsed document, you might not expect behavior like the following:: soup = BeautifulSoup(\"\n\nA one\n\n\") soup.p.append(\", a two\") soup.p.contents # \\[u'A one', u', a two'\\] print(soup.p.encode()) #\n\nA one, a two\n\nprint(soup.p.prettify()) #\n\n\\# A one # , a two #\n\nYou can call \\`\\`Tag.smooth()\\`\\` to clean up the parse tree by consolidating adjacent strings:: soup.smooth() soup.p.contents # \\[u'A one, a two'\\] print(soup.p.prettify()) #\n\n\\# A one, a two #\n\nThe \\`\\`smooth()\\`\\` method is new in Beautiful Soup 4.8.0. Output ====== .. \\_.prettyprinting: Pretty-printing --------------- The \\`\\`prettify()\\`\\` method will turn a Beautiful Soup parse tree into a nicely formatted Unicode string, with a separate line for each tag and each string:: markup = '[I linked to _example.com_](http://example.com/)\n' soup = BeautifulSoup(markup) soup.prettify() # '\\\\n \\\\n \\\\n \\\\n [\\\\n...' print(soup.prettify()) # # # # #](http://example.com/)\n [\\# I linked to # _\\# example.com #_ \\#](http://example.com/)\n \\# # You can call \\`\\`prettify()\\`\\` on the top-level \\`\\`BeautifulSoup\\`\\` object, or on any of its \\`\\`Tag\\`\\` objects:: print(soup.a.prettify()) # [\\# I linked to # _\\# example.com #_ \\#](http://example.com/)\n Non-pretty printing ------------------- If you just want a string, with no fancy formatting, you can call \\`\\`unicode()\\`\\` or \\`\\`str()\\`\\` on a \\`\\`BeautifulSoup\\`\\` object, or a \\`\\`Tag\\`\\` within it:: str(soup) # '[I linked to _example.com_](http://example.com/)\n' unicode(soup.a) # u'[I linked to _example.com_](http://example.com/)\n' The \\`\\`str()\\`\\` function returns a string encoded in UTF-8. See \\`Encodings\\`\\_ for other options. You can also call \\`\\`encode()\\`\\` to get a bytestring, and \\`\\`decode()\\`\\` to get Unicode. .. \\_output\\_formatters: Output formatters ----------------- If you give Beautiful Soup a document that contains HTML entities like \"&lquot;\", they'll be converted to Unicode characters:: soup = BeautifulSoup(\"“Dammit!” he said.\") unicode(soup) # u'\\\\u201cDammit!\\\\u201d he said.' If you then convert the document to a string, the Unicode characters will be encoded as UTF-8. You won't get the HTML entities back:: str(soup) # '\\\\xe2\\\\x80\\\\x9cDammit!\\\\xe2\\\\x80\\\\x9d he said.' By default, the only characters that are escaped upon output are bare ampersands and angle brackets. These get turned into \"&\", \"<\", and \">\", so that Beautiful Soup doesn't inadvertently generate invalid HTML or XML:: soup = BeautifulSoup(\"\n\nThe law firm of Dewey, Cheatem, & Howe\n\n\") soup.p #\n\nThe law firm of Dewey, Cheatem, & Howe\n\nsoup = BeautifulSoup('[A link](http://example.com/?foo=val1&bar=val2)\n') soup.a # [A link](http://example.com/?foo=val1&bar=val2)\n You can change this behavior by providing a value for the \\`\\`formatter\\`\\` argument to \\`\\`prettify()\\`\\`, \\`\\`encode()\\`\\`, or \\`\\`decode()\\`\\`. Beautiful Soup recognizes five possible values for \\`\\`formatter\\`\\`. The default is \\`\\`formatter=\"minimal\"\\`\\`. Strings will only be processed enough to ensure that Beautiful Soup generates valid HTML/XML:: french = \"\n\nIl a dit <<Sacré bleu!>>\n\n\" soup = BeautifulSoup(french) print(soup.prettify(formatter=\"minimal\")) # # #\n\n\\# Il a dit <<SacrÃ© bleu!>> #\n\n\\# # If you pass in \\`\\`formatter=\"html\"\\`\\`, Beautiful Soup will convert Unicode characters to HTML entities whenever possible:: print(soup.prettify(formatter=\"html\")) # # #\n\n\\# Il a dit <<Sacré bleu!>> #\n\n\\# # If you pass in \\`\\`formatter=\"html5\"\\`\\`, it's the same as \\`\\`formatter=\"html5\"\\`\\`, but Beautiful Soup will omit the closing slash in HTML void tags like \"br\":: soup = BeautifulSoup(\"  \n\") print(soup.encode(formatter=\"html\")) #  \nprint(soup.encode(formatter=\"html5\")) #  \nIf you pass in \\`\\`formatter=None\\`\\`, Beautiful Soup will not modify strings at all on output. This is the fastest option, but it may lead to Beautiful Soup generating invalid HTML/XML, as in these examples:: print(soup.prettify(formatter=None)) # # #\n\n\\# Il a dit <\\> #\n\n\\# # link\\_soup = BeautifulSoup('[A link](http://example.com/?foo=val1&bar=val2)\n') print(link\\_soup.a.encode(formatter=None)) # [A link](http://example.com/?foo=val1&bar=val2)\n If you need more sophisticated control over your output, you can use Beautiful Soup's \\`\\`Formatter\\`\\` class. Here's a formatter that converts strings to uppercase, whether they occur in a text node or in an attribute value:: from bs4.formatter import HTMLFormatter def uppercase(str): return str.upper() formatter = HTMLFormatter(uppercase) print(soup.prettify(formatter=formatter)) # # #\n\n\\# IL A DIT <\\> #\n\n\\# # print(link\\_soup.a.prettify(formatter=formatter)) # [\\# A LINK #](http://example.com/?FOO=VAL1&BAR=VAL2)\n Subclassing \\`\\`HTMLFormatter\\`\\` or \\`\\`XMLFormatter\\`\\` will give you even more control over the output. For example, Beautiful Soup sorts the attributes in every tag by default:: attr\\_soup = BeautifulSoup(b'\n\n') print(attr\\_soup.p.encode()) #\n\nTo turn this off, you can subclass the \\`\\`Formatter.attributes()\\`\\` method, which controls which attributes are output and in what order. This implementation also filters out the attribute called \"m\" whenever it appears:: class UnsortedAttributes(HTMLFormatter): def attributes(self, tag): for k, v in tag.attrs.items(): if k == 'm': continue yield k, v print(attr\\_soup.p.encode(formatter=UnsortedAttributes())) #\n\nOne last caveat: if you create a \\`\\`CData\\`\\` object, the text inside that object is always presented \\`exactly as it appears, with no formatting\\`. Beautiful Soup will call your entity substitution function, just in case you've written a custom function that counts all the strings in the document or something, but it will ignore the return value:: from bs4.element import CData soup = BeautifulSoup(\"\") soup.a.string = CData(\"one < three\") print(soup.a.prettify(formatter=\"xml\")) # \\# \\# \\`\\`get\\_text()\\`\\` -------------- If you only want the text part of a document or tag, you can use the \\`\\`get\\_text()\\`\\` method. It returns all the text in a document or beneath a tag, as a single Unicode string:: markup = '[\\\\nI linked to _example.com_\\\\n](http://example.com/)\n' soup = BeautifulSoup(markup) soup.get\\_text() u'\\\\nI linked to example.com\\\\n' soup.i.get\\_text() u'example.com' You can specify a string to be used to join the bits of text together:: # soup.get\\_text(\"|\") u'\\\\nI linked to |example.com|\\\\n' You can tell Beautiful Soup to strip whitespace from the beginning and end of each bit of text:: # soup.get\\_text(\"|\", strip=True) u'I linked to|example.com' But at that point you might want to use the :ref:\\`.stripped\\_strings \\` generator instead, and process the text yourself:: \\[text for text in soup.stripped\\_strings\\] # \\[u'I linked to', u'example.com'\\] Specifying the parser to use ============================ If you just need to parse some HTML, you can dump the markup into the \\`\\`BeautifulSoup\\`\\` constructor, and it'll probably be fine. Beautiful Soup will pick a parser for you and parse the data. But there are a few additional arguments you can pass in to the constructor to change which parser is used. The first argument to the \\`\\`BeautifulSoup\\`\\` constructor is a string or an open filehandle--the markup you want parsed. The second argument is \\`how\\` you'd like the markup parsed. If you don't specify anything, you'll get the best HTML parser that's installed. Beautiful Soup ranks lxml's parser as being the best, then html5lib's, then Python's built-in parser. You can override this by specifying one of the following: \\* What type of markup you want to parse. Currently supported are \"html\", \"xml\", and \"html5\". \\* The name of the parser library you want to use. Currently supported options are \"lxml\", \"html5lib\", and \"html.parser\" (Python's built-in HTML parser). The section \\`Installing a parser\\`\\_ contrasts the supported parsers. If you don't have an appropriate parser installed, Beautiful Soup will ignore your request and pick a different parser. Right now, the only supported XML parser is lxml. If you don't have lxml installed, asking for an XML parser won't give you one, and asking for \"lxml\" won't work either. Differences between parsers --------------------------- Beautiful Soup presents the same interface to a number of different parsers, but each parser is different. Different parsers will create different parse trees from the same document. The biggest differences are between the HTML parsers and the XML parsers. Here's a short document, parsed as HTML:: BeautifulSoup(\"**\") # Since an empty **tag is not valid HTML, the parser turns it into a tag pair. Here's the same document parsed as XML (running this requires that you have lxml installed). Note that the empty **tag is left alone, and that the document is given an XML declaration instead of being put into an tag.:: BeautifulSoup(\"**\", \"xml\") # \\# **There are also differences between HTML parsers. If you give Beautiful Soup a perfectly-formed HTML document, these differences won't matter. One parser will be faster than another, but they'll all give you a data structure that looks exactly like the original HTML document. But if the document is not perfectly-formed, different parsers will give different results. Here's a short, invalid document parsed using lxml's HTML parser. Note that the dangling\n\ntag is simply ignored:: BeautifulSoup(\"\", \"lxml\") # Here's the same document parsed using html5lib:: BeautifulSoup(\"\n\n\", \"html5lib\") #\n\nInstead of ignoring the dangling\n\ntag, html5lib pairs it with an opening\n\ntag. This parser also adds an empty tag to the document. Here's the same document parsed with Python's built-in HTML parser:: BeautifulSoup(\"\n\n\", \"html.parser\") # Like html5lib, this parser ignores the closing\n\ntag. Unlike html5lib, this parser makes no attempt to create a well-formed HTML document by adding a tag. Unlike lxml, it doesn't even bother to add an tag. Since the document \"\" is invalid, none of these techniques is the \"correct\" way to handle it. The html5lib parser uses techniques that are part of the HTML5 standard, so it has the best claim on being the \"correct\" way, but all three techniques are legitimate. Differences between parsers can affect your script. If you're planning on distributing your script to other people, or running it on multiple machines, you should specify a parser in the \\`\\`BeautifulSoup\\`\\` constructor. That will reduce the chances that your users parse a document differently from the way you parse it. Encodings ========= Any HTML or XML document is written in a specific encoding like ASCII or UTF-8. But when you load that document into Beautiful Soup, you'll discover it's been converted to Unicode:: markup = \"\n\nSacr\\\\xc3\\\\xa9 bleu!\n====================\n\n\" soup = BeautifulSoup(markup) soup.h1 #\n\nSacrÃ© bleu!\n============\n\nsoup.h1.string # u'Sacr\\\\xe9 bleu!' It's not magic. (That sure would be nice.) Beautiful Soup uses a sub-library called \\`Unicode, Dammit\\`\\_ to detect a document's encoding and convert it to Unicode. The autodetected encoding is available as the \\`\\`.original\\_encoding\\`\\` attribute of the \\`\\`BeautifulSoup\\`\\` object:: soup.original\\_encoding 'utf-8' Unicode, Dammit guesses correctly most of the time, but sometimes it makes mistakes. Sometimes it guesses correctly, but only after a byte-by-byte search of the document that takes a very long time. If you happen to know a document's encoding ahead of time, you can avoid mistakes and delays by passing it to the \\`\\`BeautifulSoup\\`\\` constructor as \\`\\`from\\_encoding\\`\\`. Here's a document written in ISO-8859-8. The document is so short that Unicode, Dammit can't get a lock on it, and misidentifies it as ISO-8859-7:: markup = b\"\n\n\\\\xed\\\\xe5\\\\xec\\\\xf9\n====================\n\n\" soup = BeautifulSoup(markup) soup.h1\n\nÎ½ÎµÎ¼Ï‰\n========\n\nsoup.original\\_encoding 'ISO-8859-7' We can fix this by passing in the correct \\`\\`from\\_encoding\\`\\`:: soup = BeautifulSoup(markup, from\\_encoding=\"iso-8859-8\") soup.h1\n\n××•×œ×©\n========\n\nsoup.original\\_encoding 'iso8859-8' If you don't know what the correct encoding is, but you know that Unicode, Dammit is guessing wrong, you can pass the wrong guesses in as \\`\\`exclude\\_encodings\\`\\`:: soup = BeautifulSoup(markup, exclude\\_encodings=\\[\"ISO-8859-7\"\\]) soup.h1\n\n××•×œ×©\n========\n\nsoup.original\\_encoding 'WINDOWS-1255' Windows-1255 isn't 100% correct, but that encoding is a compatible superset of ISO-8859-8, so it's close enough. (\\`\\`exclude\\_encodings\\`\\` is a new feature in Beautiful Soup 4.4.0.) In rare cases (usually when a UTF-8 document contains text written in a completely different encoding), the only way to get Unicode may be to replace some characters with the special Unicode character \"REPLACEMENT CHARACTER\" (U+FFFD, ï¿½). If Unicode, Dammit needs to do this, it will set the \\`\\`.contains\\_replacement\\_characters\\`\\` attribute to \\`\\`True\\`\\` on the \\`\\`UnicodeDammit\\`\\` or \\`\\`BeautifulSoup\\`\\` object. This lets you know that the Unicode representation is not an exact representation of the original--some data was lost. If a document contains ï¿½, but \\`\\`.contains\\_replacement\\_characters\\`\\` is \\`\\`False\\`\\`, you'll know that the ï¿½ was there originally (as it is in this paragraph) and doesn't stand in for missing data. Output encoding --------------- When you write out a document from Beautiful Soup, you get a UTF-8 document, even if the document wasn't in UTF-8 to begin with. Here's a document written in the Latin-1 encoding:: markup = b'''\n\nSacr\\\\xe9 bleu!\n\n''' soup = BeautifulSoup(markup) print(soup.prettify()) # # # # # #\n\n\\# SacrÃ© bleu! #\n\n\\# # Note that the tag has been rewritten to reflect the fact that the document is now in UTF-8. If you don't want UTF-8, you can pass an encoding into \\`\\`prettify()\\`\\`:: print(soup.prettify(\"latin-1\")) # # # # ... You can also call encode() on the \\`\\`BeautifulSoup\\`\\` object, or any element in the soup, just as if it were a Python string:: soup.p.encode(\"latin-1\") # '\n\nSacr\\\\xe9 bleu!\n\n' soup.p.encode(\"utf-8\") # '\n\nSacr\\\\xc3\\\\xa9 bleu!\n\n' Any characters that can't be represented in your chosen encoding will be converted into numeric XML entity references. Here's a document that includes the Unicode character SNOWMAN:: markup = u\"**\\\\N{SNOWMAN}**\" snowman\\_soup = BeautifulSoup(markup) tag = snowman\\_soup.b The SNOWMAN character can be part of a UTF-8 document (it looks like â˜ƒ), but there's no representation for that character in ISO-Latin-1 or ASCII, so it's converted into \"☃\" for those encodings:: print(tag.encode(\"utf-8\")) # **â˜ƒ** print tag.encode(\"latin-1\") # **☃** print tag.encode(\"ascii\") # **☃** Unicode, Dammit --------------- You can use Unicode, Dammit without using Beautiful Soup. It's useful whenever you have data in an unknown encoding and you just want it to become Unicode:: from bs4 import UnicodeDammit dammit = UnicodeDammit(\"Sacr\\\\xc3\\\\xa9 bleu!\") print(dammit.unicode\\_markup) # SacrÃ© bleu! dammit.original\\_encoding # 'utf-8' Unicode, Dammit's guesses will get a lot more accurate if you install the \\`\\`chardet\\`\\` or \\`\\`cchardet\\`\\` Python libraries. The more data you give Unicode, Dammit, the more accurately it will guess. If you have your own suspicions as to what the encoding might be, you can pass them in as a list:: dammit = UnicodeDammit(\"Sacr\\\\xe9 bleu!\", \\[\"latin-1\", \"iso-8859-1\"\\]) print(dammit.unicode\\_markup) # SacrÃ© bleu! dammit.original\\_encoding # 'latin-1' Unicode, Dammit has two special features that Beautiful Soup doesn't use. Smart quotes ^^^^^^^^^^^^ You can use Unicode, Dammit to convert Microsoft smart quotes to HTML or XML entities:: markup = b\"\n\nI just \\\\x93love\\\\x94 Microsoft Word\\\\x92s smart quotes\n\n\" UnicodeDammit(markup, \\[\"windows-1252\"\\], smart\\_quotes\\_to=\"html\").unicode\\_markup # u'\n\nI just “love” Microsoft Word’s smart quotes\n\n' UnicodeDammit(markup, \\[\"windows-1252\"\\], smart\\_quotes\\_to=\"xml\").unicode\\_markup # u'\n\nI just “love” Microsoft Word’s smart quotes\n\n' You can also convert Microsoft smart quotes to ASCII quotes:: UnicodeDammit(markup, \\[\"windows-1252\"\\], smart\\_quotes\\_to=\"ascii\").unicode\\_markup # u'\n\nI just \"love\" Microsoft Word\\\\'s smart quotes\n\n' Hopefully you'll find this feature useful, but Beautiful Soup doesn't use it. Beautiful Soup prefers the default behavior, which is to convert Microsoft smart quotes to Unicode characters along with everything else:: UnicodeDammit(markup, \\[\"windows-1252\"\\]).unicode\\_markup # u'\n\nI just \\\\u201clove\\\\u201d Microsoft Word\\\\u2019s smart quotes\n\n' Inconsistent encodings ^^^^^^^^^^^^^^^^^^^^^^ Sometimes a document is mostly in UTF-8, but contains Windows-1252 characters such as (again) Microsoft smart quotes. This can happen when a website includes data from multiple sources. You can use \\`\\`UnicodeDammit.detwingle()\\`\\` to turn such a document into pure UTF-8. Here's a simple example:: snowmen = (u\"\\\\N{SNOWMAN}\" \\* 3) quote = (u\"\\\\N{LEFT DOUBLE QUOTATION MARK}I like snowmen!\\\\N{RIGHT DOUBLE QUOTATION MARK}\") doc = snowmen.encode(\"utf8\") + quote.encode(\"windows\\_1252\") This document is a mess. The snowmen are in UTF-8 and the quotes are in Windows-1252. You can display the snowmen or the quotes, but not both:: print(doc) # â˜ƒâ˜ƒâ˜ƒï¿½I like snowmen!ï¿½ print(doc.decode(\"windows-1252\")) # Ã¢ËœÆ’Ã¢ËœÆ’Ã¢ËœÆ’â€œI like snowmen!â€ Decoding the document as UTF-8 raises a \\`\\`UnicodeDecodeError\\`\\`, and decoding it as Windows-1252 gives you gibberish. Fortunately, \\`\\`UnicodeDammit.detwingle()\\`\\` will convert the string to pure UTF-8, allowing you to decode it to Unicode and display the snowmen and quote marks simultaneously:: new\\_doc = UnicodeDammit.detwingle(doc) print(new\\_doc.decode(\"utf8\")) # â˜ƒâ˜ƒâ˜ƒâ€œI like snowmen!â€ \\`\\`UnicodeDammit.detwingle()\\`\\` only knows how to handle Windows-1252 embedded in UTF-8 (or vice versa, I suppose), but this is the most common case. Note that you must know to call \\`\\`UnicodeDammit.detwingle()\\`\\` on your data before passing it into \\`\\`BeautifulSoup\\`\\` or the \\`\\`UnicodeDammit\\`\\` constructor. Beautiful Soup assumes that a document has a single encoding, whatever it might be. If you pass it a document that contains both UTF-8 and Windows-1252, it's likely to think the whole document is Windows-1252, and the document will come out looking like \\`\\`Ã¢ËœÆ’Ã¢ËœÆ’Ã¢ËœÆ’â€œI like snowmen!â€\\`\\`. \\`\\`UnicodeDammit.detwingle()\\`\\` is new in Beautiful Soup 4.1.0. Line numbers ============ The \\`\\`html.parser\\` and \\`\\`html5lib\\`\\` parsers can keep track of where in the original document each Tag was found. You can access this information as \\`\\`Tag.sourceline\\`\\` (line number) and \\`\\`Tag.sourcepos\\`\\` (position of the start tag within a line):: markup = \"Paragraph 1\n\n\\\\n\n\nParagraph 2\n\n\" soup = BeautifulSoup(markup, 'html.parser') for tag in soup.find\\_all('p'): print(tag.sourceline, tag.sourcepos, tag.string) # (1, 0, u'Paragraph 1') # (2, 3, u'Paragraph 2') Note that the two parsers mean slightly different things by \\`\\`sourceline\\`\\` and \\`\\`sourcepos\\`\\`. For html.parser, these numbers represent the position of the initial less-than sign. For html5lib, these numbers represent the position of the final greater-than sign:: soup = BeautifulSoup(markup, 'html5lib') for tag in soup.find\\_all('p'): print(tag.sourceline, tag.sourcepos, tag.string) # (2, 1, u'Paragraph 1') # (3, 7, u'Paragraph 2') You can shut off this feature by passing \\`\\`store\\_line\\_numbers=False\\` into the \\`\\`BeautifulSoup\\`\\` constructor:: markup = \"Paragraph 1\n\n\\\\n\n\nParagraph 2\n\n\" soup = BeautifulSoup(markup, 'html.parser', store\\_line\\_numbers=False) soup.p.sourceline # None This feature is new in 4.8.1, and the parsers based on lxml don't support it. Comparing objects for equality ============================== Beautiful Soup says that two \\`\\`NavigableString\\`\\` or \\`\\`Tag\\`\\` objects are equal when they represent the same HTML or XML markup. In this example, the two **tags are treated as equal, even though they live in different parts of the object tree, because they both look like \"**pizza**\":: markup = \"\n\nI want **pizza** and more **pizza**!\n\n\" soup = BeautifulSoup(markup, 'html.parser') first\\_b, second\\_b = soup.find\\_all('b') print first\\_b == second\\_b # True print first\\_b.previous\\_element == second\\_b.previous\\_element # False If you want to see whether two variables refer to exactly the same object, use \\`is\\`:: print first\\_b is second\\_b # False Copying Beautiful Soup objects ============================== You can use \\`\\`copy.copy()\\`\\` to create a copy of any \\`\\`Tag\\`\\` or \\`\\`NavigableString\\`\\`:: import copy p\\_copy = copy.copy(soup.p) print p\\_copy #\n\nI want **pizza** and more **pizza**!\n\nThe copy is considered equal to the original, since it represents the same markup as the original, but it's not the same object:: print soup.p == p\\_copy # True print soup.p is p\\_copy # False The only real difference is that the copy is completely detached from the original Beautiful Soup object tree, just as if \\`\\`extract()\\`\\` had been called on it:: print p\\_copy.parent # None This is because two different \\`\\`Tag\\`\\` objects can't occupy the same space at the same time. Parsing only part of a document =============================== Let's say you want to use Beautiful Soup look at a document's** **tags. It's a waste of time and memory to parse the entire document and then go over it again looking for tags. It would be much faster to ignore everything that wasn't an tag in the first place. The \\`\\`SoupStrainer\\`\\` class allows you to choose which parts of an incoming document are parsed. You just create a \\`\\`SoupStrainer\\`\\` and pass it in to the \\`\\`BeautifulSoup\\`\\` constructor as the \\`\\`parse\\_only\\`\\` argument. (Note that \\*this feature won't work if you're using the html5lib parser\\*. If you use html5lib, the whole document will be parsed, no matter what. This is because html5lib constantly rearranges the parse tree as it works, and if some part of the document didn't actually make it into the parse tree, it'll crash. To avoid confusion, in the examples below I'll be forcing Beautiful Soup to use Python's built-in parser.) \\`\\`SoupStrainer\\`\\` ---------------- The \\`\\`SoupStrainer\\`\\` class takes the same arguments as a typical method from \\`Searching the tree\\`\\_: :ref:\\`name \\`, :ref:\\`attrs \\`, :ref:\\`string \\`, and :ref:\\`\\*\\*kwargs \\`. Here are three \\`\\`SoupStrainer\\`\\` objects:: from bs4 import SoupStrainer only\\_a\\_tags = SoupStrainer(\"a\") only\\_tags\\_with\\_id\\_link2 = SoupStrainer(id=\"link2\") def is\\_short\\_string(string): return len(string) < 10 only\\_short\\_strings = SoupStrainer(string=is\\_short\\_string) I'm going to bring back the \"three sisters\" document one more time, and we'll see what the document looks like when it's parsed with these three \\`\\`SoupStrainer\\`\\` objects:: html\\_doc = \"\"\" The Dormouse's story\n\n**The Dormouse's story**\n\nOnce upon a time there were three little sisters; and their names were [Elsie](http://example.com/elsie)\n, [Lacie](http://example.com/lacie)\n and [Tillie](http://example.com/tillie)\n; and they lived at the bottom of a well.\n\n...\n\n\"\"\" print(BeautifulSoup(html\\_doc, \"html.parser\", parse\\_only=only\\_a\\_tags).prettify()) # [\\# Elsie #](http://example.com/elsie)\n \\# [\\# Lacie #](http://example.com/lacie)\n \\# [\\# Tillie #](http://example.com/tillie)\n print(BeautifulSoup(html\\_doc, \"html.parser\", parse\\_only=only\\_tags\\_with\\_id\\_link2).prettify()) # [\\# Lacie #](http://example.com/lacie)\n print(BeautifulSoup(html\\_doc, \"html.parser\", parse\\_only=only\\_short\\_strings).prettify()) # Elsie # , # Lacie # and # Tillie # ... # You can also pass a \\`\\`SoupStrainer\\`\\` into any of the methods covered in \\`Searching the tree\\`\\_. This probably isn't terribly useful, but I thought I'd mention it:: soup = BeautifulSoup(html\\_doc) soup.find\\_all(only\\_short\\_strings) # \\[u'\\\\n\\\\n', u'\\\\n\\\\n', u'Elsie', u',\\\\n', u'Lacie', u' and\\\\n', u'Tillie', # u'\\\\n\\\\n', u'...', u'\\\\n'\\] Troubleshooting =============== .. \\_diagnose: \\`\\`diagnose()\\`\\` -------------- If you're having trouble understanding what Beautiful Soup does to a document, pass the document into the \\`\\`diagnose()\\`\\` function. (New in Beautiful Soup 4.2.0.) Beautiful Soup will print out a report showing you how different parsers handle the document, and tell you if you're missing a parser that Beautiful Soup could be using:: from bs4.diagnose import diagnose with open(\"bad.html\") as fp: data = fp.read() diagnose(data) # Diagnostic running on Beautiful Soup 4.2.0 # Python version 2.7.3 (default, Aug 1 2012, 05:16:07) # I noticed that html5lib is not installed. Installing it may help. # Found lxml version 2.3.2.0 # # Trying to parse your data with html.parser # Here's what html.parser did with the document: # ... Just looking at the output of diagnose() may show you how to solve the problem. Even if not, you can paste the output of \\`\\`diagnose()\\`\\` when asking for help. Errors when parsing a document ------------------------------ There are two different kinds of parse errors. There are crashes, where you feed a document to Beautiful Soup and it raises an exception, usually an \\`\\`HTMLParser.HTMLParseError\\`\\`. And there is unexpected behavior, where a Beautiful Soup parse tree looks a lot different than the document used to create it. Almost none of these problems turn out to be problems with Beautiful Soup. This is not because Beautiful Soup is an amazingly well-written piece of software. It's because Beautiful Soup doesn't include any parsing code. Instead, it relies on external parsers. If one parser isn't working on a certain document, the best solution is to try a different parser. See \\`Installing a parser\\`\\_ for details and a parser comparison. The most common parse errors are \\`\\`HTMLParser.HTMLParseError: malformed start tag\\`\\` and \\`\\`HTMLParser.HTMLParseError: bad end tag\\`\\`. These are both generated by Python's built-in HTML parser library, and the solution is to :ref:\\`install lxml or html5lib. \\` The most common type of unexpected behavior is that you can't find a tag that you know is in the document. You saw it going in, but \\`\\`find\\_all()\\`\\` returns \\`\\`\\[\\]\\`\\` or \\`\\`find()\\`\\` returns \\`\\`None\\`\\`. This is another common problem with Python's built-in HTML parser, which sometimes skips tags it doesn't understand. Again, the solution is to :ref:\\`install lxml or html5lib. \\` Version mismatch problems ------------------------- \\* \\`\\`SyntaxError: Invalid syntax\\`\\` (on the line \\`\\`ROOT\\_TAG\\_NAME = u'\\[document\\]'\\`\\`): Caused by running the Python 2 version of Beautiful Soup under Python 3, without converting the code. \\* \\`\\`ImportError: No module named HTMLParser\\`\\` - Caused by running the Python 2 version of Beautiful Soup under Python 3. \\* \\`\\`ImportError: No module named html.parser\\`\\` - Caused by running the Python 3 version of Beautiful Soup under Python 2. \\* \\`\\`ImportError: No module named BeautifulSoup\\`\\` - Caused by running Beautiful Soup 3 code on a system that doesn't have BS3 installed. Or, by writing Beautiful Soup 4 code without knowing that the package name has changed to \\`\\`bs4\\`\\`. \\* \\`\\`ImportError: No module named bs4\\`\\` - Caused by running Beautiful Soup 4 code on a system that doesn't have BS4 installed. .. \\_parsing-xml: Parsing XML ----------- By default, Beautiful Soup parses documents as HTML. To parse a document as XML, pass in \"xml\" as the second argument to the \\`\\`BeautifulSoup\\`\\` constructor:: soup = BeautifulSoup(markup, \"xml\") You'll need to :ref:\\`have lxml installed \\`. Other parser problems --------------------- \\* If your script works on one computer but not another, or in one virtual environment but not another, or outside the virtual environment but not inside, it's probably because the two environments have different parser libraries available. For example, you may have developed the script on a computer that has lxml installed, and then tried to run it on a computer that only has html5lib installed. See \\`Differences between parsers\\`\\_ for why this matters, and fix the problem by mentioning a specific parser library in the \\`\\`BeautifulSoup\\`\\` constructor. \\* Because \\`HTML tags and attributes are case-insensitive \\`\\_, all three HTML parsers convert tag and attribute names to lowercase. That is, the markup is converted to . If you want to preserve mixed-case or uppercase tags and attributes, you'll need to :ref:\\`parse the document as XML. \\` .. \\_misc: Miscellaneous ------------- \\* \\`\\`UnicodeEncodeError: 'charmap' codec can't encode character u'\\\\xfoo' in position bar\\`\\` (or just about any other \\`\\`UnicodeEncodeError\\`\\`) - This is not a problem with Beautiful Soup. This problem shows up in two main situations. First, when you try to print a Unicode character that your console doesn't know how to display. (See \\`this page on the Python wiki \\`\\_ for help.) Second, when you're writing to a file and you pass in a Unicode character that's not supported by your default encoding. In this case, the simplest solution is to explicitly encode the Unicode string into UTF-8 with \\`\\`u.encode(\"utf8\")\\`\\`. \\* \\`\\`KeyError: \\[attr\\]\\`\\` - Caused by accessing \\`\\`tag\\['attr'\\]\\`\\` when the tag in question doesn't define the \\`\\`attr\\`\\` attribute. The most common errors are \\`\\`KeyError: 'href'\\`\\` and \\`\\`KeyError: 'class'\\`\\`. Use \\`\\`tag.get('attr')\\`\\` if you're not sure \\`\\`attr\\`\\` is defined, just as you would with a Python dictionary. \\* \\`\\`AttributeError: 'ResultSet' object has no attribute 'foo'\\`\\` - This usually happens because you expected \\`\\`find\\_all()\\`\\` to return a single tag or string. But \\`\\`find\\_all()\\`\\` returns a \\_list\\_ of tags and strings--a \\`\\`ResultSet\\`\\` object. You need to iterate over the list and look at the \\`\\`.foo\\`\\` of each one. Or, if you really only want one result, you need to use \\`\\`find()\\`\\` instead of \\`\\`find\\_all()\\`\\`. \\* \\`\\`AttributeError: 'NoneType' object has no attribute 'foo'\\`\\` - This usually happens because you called \\`\\`find()\\`\\` and then tried to access the \\`.foo\\`\\` attribute of the result. But in your case, \\`\\`find()\\`\\` didn't find anything, so it returned \\`\\`None\\`\\`, instead of returning a tag or a string. You need to figure out why your \\`\\`find()\\`\\` call isn't returning anything. Improving Performance --------------------- Beautiful Soup will never be as fast as the parsers it sits on top of. If response time is critical, if you're paying for computer time by the hour, or if there's any other reason why computer time is more valuable than programmer time, you should forget about Beautiful Soup and work directly atop \\`lxml \\`\\_. That said, there are things you can do to speed up Beautiful Soup. If you're not using lxml as the underlying parser, my advice is to :ref:\\`start \\`. Beautiful Soup parses documents significantly faster using lxml than using html.parser or html5lib. You can speed up encoding detection significantly by installing the \\`cchardet \\`\\_ library. \\`Parsing only part of a document\\`\\_ won't save you much time parsing the document, but it can save a lot of memory, and it'll make \\`searching\\` the document much faster. Translating this documentation ============================== New translations of the Beautiful Soup documentation are greatly appreciated. Translations should be licensed under the MIT license, just like Beautiful Soup and its English documentation are. There are two ways of getting your translation into the main code base and onto the Beautiful Soup website: 1. Create a branch of the Beautiful Soup repository, add your translation, and propose a merge with the main branch, the same as you would do with a proposed change to the source code. 2. Send a message to the Beautiful Soup discussion group with a link to your translation, or attach your translation to the message. Use the Chinese or Brazilian Portuguese translations as your model. In particular, please translate the source file \\`\\`doc/source/index.rst\\`\\`, rather than the HTML version of the documentation. This makes it possible to publish the documentation in a variety of formats, not just HTML. Beautiful Soup 3 ================ Beautiful Soup 3 is the previous release series, and is no longer being actively developed. It's currently packaged with all major Linux distributions: :kbd:\\`$ apt-get install python-beautifulsoup\\` It's also published through PyPi as \\`\\`BeautifulSoup\\`\\`.: :kbd:\\`$ easy\\_install BeautifulSoup\\` :kbd:\\`$ pip install BeautifulSoup\\` You can also \\`download a tarball of Beautiful Soup 3.2.0 \\`\\_. If you ran \\`\\`easy\\_install beautifulsoup\\`\\` or \\`\\`easy\\_install BeautifulSoup\\`\\`, but your code doesn't work, you installed Beautiful Soup 3 by mistake. You need to run \\`\\`easy\\_install beautifulsoup4\\`\\`. \\`The documentation for Beautiful Soup 3 is archived online \\`\\_. Porting code to BS4 ------------------- Most code written against Beautiful Soup 3 will work against Beautiful Soup 4 with one simple change. All you should have to do is change the package name from \\`\\`BeautifulSoup\\`\\` to \\`\\`bs4\\`\\`. So this:: from BeautifulSoup import BeautifulSoup becomes this:: from bs4 import BeautifulSoup \\* If you get the \\`\\`ImportError\\`\\` \"No module named BeautifulSoup\", your problem is that you're trying to run Beautiful Soup 3 code, but you only have Beautiful Soup 4 installed. \\* If you get the \\`\\`ImportError\\`\\` \"No module named bs4\", your problem is that you're trying to run Beautiful Soup 4 code, but you only have Beautiful Soup 3 installed. Although BS4 is mostly backwards-compatible with BS3, most of its methods have been deprecated and given new names for \\`PEP 8 compliance \\`\\_. There are numerous other renames and changes, and a few of them break backwards compatibility. Here's what you'll need to know to convert your BS3 code and habits to BS4: You need a parser ^^^^^^^^^^^^^^^^^ Beautiful Soup 3 used Python's \\`\\`SGMLParser\\`\\`, a module that was deprecated and removed in Python 3.0. Beautiful Soup 4 uses \\`\\`html.parser\\`\\` by default, but you can plug in lxml or html5lib and use that instead. See \\`Installing a parser\\`\\_ for a comparison. Since \\`\\`html.parser\\`\\` is not the same parser as \\`\\`SGMLParser\\`\\`, you may find that Beautiful Soup 4 gives you a different parse tree than Beautiful Soup 3 for the same markup. If you swap out \\`\\`html.parser\\`\\` for lxml or html5lib, you may find that the parse tree changes yet again. If this happens, you'll need to update your scraping code to deal with the new tree. Method names ^^^^^^^^^^^^ \\* \\`\\`renderContents\\`\\` -> \\`\\`encode\\_contents\\`\\` \\* \\`\\`replaceWith\\`\\` -> \\`\\`replace\\_with\\`\\` \\* \\`\\`replaceWithChildren\\`\\` -> \\`\\`unwrap\\`\\` \\* \\`\\`findAll\\`\\` -> \\`\\`find\\_all\\`\\` \\* \\`\\`findAllNext\\`\\` -> \\`\\`find\\_all\\_next\\`\\` \\* \\`\\`findAllPrevious\\`\\` -> \\`\\`find\\_all\\_previous\\`\\` \\* \\`\\`findNext\\`\\` -> \\`\\`find\\_next\\`\\` \\* \\`\\`findNextSibling\\`\\` -> \\`\\`find\\_next\\_sibling\\`\\` \\* \\`\\`findNextSiblings\\`\\` -> \\`\\`find\\_next\\_siblings\\`\\` \\* \\`\\`findParent\\`\\` -> \\`\\`find\\_parent\\`\\` \\* \\`\\`findParents\\`\\` -> \\`\\`find\\_parents\\`\\` \\* \\`\\`findPrevious\\`\\` -> \\`\\`find\\_previous\\`\\` \\* \\`\\`findPreviousSibling\\`\\` -> \\`\\`find\\_previous\\_sibling\\`\\` \\* \\`\\`findPreviousSiblings\\`\\` -> \\`\\`find\\_previous\\_siblings\\`\\` \\* \\`\\`getText\\`\\` -> \\`\\`get\\_text\\`\\` \\* \\`\\`nextSibling\\`\\` -> \\`\\`next\\_sibling\\`\\` \\* \\`\\`previousSibling\\`\\` -> \\`\\`previous\\_sibling\\`\\` Some arguments to the Beautiful Soup constructor were renamed for the same reasons: \\* \\`\\`BeautifulSoup(parseOnlyThese=...)\\`\\` -> \\`\\`BeautifulSoup(parse\\_only=...)\\`\\` \\* \\`\\`BeautifulSoup(fromEncoding=...)\\`\\` -> \\`\\`BeautifulSoup(from\\_encoding=...)\\`\\` I renamed one method for compatibility with Python 3: \\* \\`\\`Tag.has\\_key()\\`\\` -> \\`\\`Tag.has\\_attr()\\`\\` I renamed one attribute to use more accurate terminology: \\* \\`\\`Tag.isSelfClosing\\`\\` -> \\`\\`Tag.is\\_empty\\_element\\`\\` I renamed three attributes to avoid using words that have special meaning to Python. Unlike the others, these changes are \\*not backwards compatible.\\* If you used these attributes in BS3, your code will break on BS4 until you change them. \\* \\`\\`UnicodeDammit.unicode\\`\\` -> \\`\\`UnicodeDammit.unicode\\_markup\\`\\` \\* \\`\\`Tag.next\\`\\` -> \\`\\`Tag.next\\_element\\`\\` \\* \\`\\`Tag.previous\\`\\` -> \\`\\`Tag.previous\\_element\\`\\` Generators ^^^^^^^^^^ I gave the generators PEP 8-compliant names, and transformed them into properties: \\* \\`\\`childGenerator()\\`\\` -> \\`\\`children\\`\\` \\* \\`\\`nextGenerator()\\`\\` -> \\`\\`next\\_elements\\`\\` \\* \\`\\`nextSiblingGenerator()\\`\\` -> \\`\\`next\\_siblings\\`\\` \\* \\`\\`previousGenerator()\\`\\` -> \\`\\`previous\\_elements\\`\\` \\* \\`\\`previousSiblingGenerator()\\`\\` -> \\`\\`previous\\_siblings\\`\\` \\* \\`\\`recursiveChildGenerator()\\`\\` -> \\`\\`descendants\\`\\` \\* \\`\\`parentGenerator()\\`\\` -> \\`\\`parents\\`\\` So instead of this:: for parent in tag.parentGenerator(): ... You can write this:: for parent in tag.parents: ... (But the old code will still work.) Some of the generators used to yield \\`\\`None\\`\\` after they were done, and then stop. That was a bug. Now the generators just stop. There are two new generators, :ref:\\`.strings and .stripped\\_strings \\`. \\`\\`.strings\\`\\` yields NavigableString objects, and \\`\\`.stripped\\_strings\\`\\` yields Python strings that have had whitespace stripped. XML ^^^ There is no longer a \\`\\`BeautifulStoneSoup\\`\\` class for parsing XML. To parse XML you pass in \"xml\" as the second argument to the \\`\\`BeautifulSoup\\`\\` constructor. For the same reason, the \\`\\`BeautifulSoup\\`\\` constructor no longer recognizes the \\`\\`isHTML\\`\\` argument. Beautiful Soup's handling of empty-element XML tags has been improved. Previously when you parsed XML you had to explicitly say which tags were considered empty-element tags. The \\`\\`selfClosingTags\\`\\` argument to the constructor is no longer recognized. Instead, Beautiful Soup considers any empty tag to be an empty-element tag. If you add a child to an empty-element tag, it stops being an empty-element tag. Entities ^^^^^^^^ An incoming HTML or XML entity is always converted into the corresponding Unicode character. Beautiful Soup 3 had a number of overlapping ways of dealing with entities, which have been removed. The \\`\\`BeautifulSoup\\`\\` constructor no longer recognizes the \\`\\`smartQuotesTo\\`\\` or \\`\\`convertEntities\\`\\` arguments. (\\`Unicode, Dammit\\`\\_ still has \\`\\`smart\\_quotes\\_to\\`\\`, but its default is now to turn smart quotes into Unicode.) The constants \\`\\`HTML\\_ENTITIES\\`\\`, \\`\\`XML\\_ENTITIES\\`\\`, and \\`\\`XHTML\\_ENTITIES\\`\\` have been removed, since they configure a feature (transforming some but not all entities into Unicode characters) that no longer exists. If you want to turn Unicode characters back into HTML entities on output, rather than turning them into UTF-8 characters, you need to use an :ref:\\`output formatter \\`. Miscellaneous ^^^^^^^^^^^^^ :ref:\\`Tag.string <.string>\\` now operates recursively. If tag A contains a single tag B and nothing else, then A.string is the same as B.string. (Previously, it was None.) \\`Multi-valued attributes\\`\\_ like \\`\\`class\\`\\` have lists of strings as their values, not strings. This may affect the way you search by CSS class. If you pass one of the \\`\\`find\\*\\`\\` methods both :ref:\\`string \\` \\`and\\` a tag-specific argument like :ref:\\`name \\`, Beautiful Soup will search for tags that match your tag-specific criteria and whose :ref:\\`Tag.string <.string>\\` matches your value for :ref:\\`string \\`. It will \\`not\\` find the strings themselves. Previously, Beautiful Soup ignored the tag-specific arguments and looked for strings. The \\`\\`BeautifulSoup\\`\\` constructor no longer recognizes the \\`markupMassage\\` argument. It's now the parser's responsibility to handle markup correctly. The rarely-used alternate parser classes like \\`\\`ICantBelieveItsBeautifulSoup\\`\\` and \\`\\`BeautifulSOAP\\`\\` have been removed. It's now the parser's decision how to handle ambiguous markup. The \\`\\`prettify()\\`\\` method now returns a Unicode string, not a bytestring.**************************","metadata":{"title":"The Dormouse's story","scrapeId":"c96f2197-a910-46f2-9ca1-a3b78b22a63a","sourceURL":"https://beautiful-soup-4.readthedocs.io/en/latest/_sources/index.rst.txt","url":"https://beautiful-soup-4.readthedocs.io/en/latest/_sources/index.rst.txt","statusCode":200}}]}