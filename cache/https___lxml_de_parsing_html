{"success":true,"status":"completed","completed":1,"total":1,"creditsUsed":1,"expiresAt":"2025-03-05T21:00:19.000Z","data":[{"markdown":"Menu\n\n![](https://lxml.de/python-xml-title.png)\n\n[Like the tool?  \\\nHelp making it better!  \\\nYour donation helps!](https://lxml.de/index.html#support-the-project)\n\nParsing XML and HTML with lxml\n==============================\n\nlxml provides a very simple and powerful API for parsing XML and HTML. It supports one-step parsing as well as step-by-step parsing using an event-driven API (currently only for XML).\n\nContents\n\n*   [Parsers](https://lxml.de/parsing.html#parsers)\n    *   [Parser options](https://lxml.de/parsing.html#parser-options)\n        \n    *   [Error log](https://lxml.de/parsing.html#error-log)\n        \n    *   [Parsing HTML](https://lxml.de/parsing.html#parsing-html)\n        \n    *   [Doctype information](https://lxml.de/parsing.html#doctype-information)\n        \n*   [The target parser interface](https://lxml.de/parsing.html#the-target-parser-interface)\n    \n*   [The feed parser interface](https://lxml.de/parsing.html#the-feed-parser-interface)\n    \n*   [Incremental event parsing](https://lxml.de/parsing.html#incremental-event-parsing)\n    *   [Event types](https://lxml.de/parsing.html#event-types)\n        \n    *   [Modifying the tree](https://lxml.de/parsing.html#modifying-the-tree)\n        \n    *   [Selective tag events](https://lxml.de/parsing.html#selective-tag-events)\n        \n    *   [Comments and PIs](https://lxml.de/parsing.html#comments-and-pis)\n        \n    *   [Events with custom targets](https://lxml.de/parsing.html#events-with-custom-targets)\n        \n*   [iterparse and iterwalk](https://lxml.de/parsing.html#iterparse-and-iterwalk)\n    *   [iterwalk](https://lxml.de/parsing.html#iterwalk)\n        \n*   [Python unicode strings](https://lxml.de/parsing.html#python-unicode-strings)\n    *   [Serialising to Unicode strings](https://lxml.de/parsing.html#serialising-to-unicode-strings)\n        \n\nThe usual setup procedure:\n\n\\>>> from lxml import etree\n\nThe following examples also use StringIO or BytesIO to show how to parse from files and file-like objects. Both are available in the io module:\n\nfrom io import StringIO, BytesIO\n\nParsers\n=======\n\nParsers are represented by parser objects. There is support for parsing both XML and (broken) HTML. Note that XHTML is best parsed as XML, parsing it with the HTML parser can lead to unexpected results. Here is a simple example for parsing XML from an in-memory string:\n\n\\>>> xml \\= '<a xmlns=\"test\"><b xmlns=\"test\"/></a>'\n\n\\>>> root \\= etree.fromstring(xml)\n\\>>> etree.tostring(root)\nb'<a xmlns=\"test\"><b xmlns=\"test\"/></a>'\n\nTo read from a file or file-like object, you can use the parse() function, which returns an ElementTree object that wraps the document root:\n\n\\>>> tree \\= etree.parse(StringIO(xml))\n\\>>> etree.tostring(tree.getroot())\nb'<a xmlns=\"test\"><b xmlns=\"test\"/></a>'\n\nNote how the parse() function reads from a file-like object here. If parsing is done from a real file, it is more common (and also somewhat more efficient) to pass a filename:\n\n\\>>> tree \\= etree.parse(\"doc/test.xml\")\n\nlxml can parse from a local file, an HTTP URL or an FTP URL. It also auto-detects and reads gzip-compressed XML files (.gz).\n\nIf you want to parse from a string (bytes or text) and still provide a base URL for the document (e.g. to support relative paths in an XInclude), you can pass the base\\_url keyword argument:\n\n\\>>> root \\= etree.fromstring(xml, base\\_url\\=\"http://where.it/is/from.xml\")\n\nParser options\n--------------\n\nThe parsers accept a number of setup options as keyword arguments. The above example is easily extended to clean up namespaces during parsing:\n\n\\>>> parser \\= etree.XMLParser(ns\\_clean\\=True)\n\\>>> xml\\_root \\= etree.fromstring(xml, parser)\n\\>>> etree.tostring(xml\\_root)\nb'<a xmlns=\"test\"><b/></a>'\n\nThe keyword arguments in the constructor are mainly based on the libxml2 parser configuration. A DTD will also be loaded if validation or attribute default values are requested.\n\nAvailable boolean keyword arguments:\n\n*   attribute\\_defaults - read the DTD (if referenced by the document) and add the default attributes from it\n*   dtd\\_validation - validate while parsing (if a DTD was referenced)\n*   load\\_dtd - load and parse the DTD while parsing (no validation is performed)\n*   no\\_network - prevent network access when looking up external documents (on by default)\n*   ns\\_clean - try to clean up redundant namespace declarations\n*   recover - try hard to parse through broken XML\n*   remove\\_blank\\_text - discard blank text nodes between tags, also known as ignorable whitespace. This is best used together with a DTD or schema (which tells data and noise apart), otherwise a heuristic will be applied.\n*   remove\\_comments - discard comments\n*   remove\\_pis - discard processing instructions\n*   strip\\_cdata - replace CDATA sections by normal text content (on by default)\n*   resolve\\_entities - replace entities by their text value (on by default)\n*   huge\\_tree - disable security restrictions and support very deep trees and very long text content (only affects libxml2 2.7+)\n*   compact - use compact storage for short text content (on by default)\n*   collect\\_ids - collect XML IDs in a hash table while parsing (on by default). Disabling this can substantially speed up parsing of documents with many different IDs if the hash lookup is not used afterwards.\n\nOther keyword arguments:\n\n*   encoding - override the document encoding\n*   target - a parser target object that will receive the parse events (see [The target parser interface](https://lxml.de/parsing.html#the-target-parser-interface)\n    )\n*   schema - an XMLSchema to validate against (see [validation](https://lxml.de/validation.html#xmlschema)\n    )\n\nError log\n---------\n\nParsers have an error\\_log property that lists the errors and warnings of the last parser run:\n\n\\>>> parser \\= etree.XMLParser()\n\\>>> print(len(parser.error\\_log))\n0\n\n\\>>> tree \\= etree.XML(\"<root>\\\\n</b>\", parser)  \\# doctest: +ELLIPSIS\nTraceback (most recent call last):\n  ...\nlxml.etree.XMLSyntaxError: Opening and ending tag mismatch: root line 1 and b, line 2, column 5...\n\n\\>>> print(len(parser.error\\_log))\n1\n\n\\>>> error \\= parser.error\\_log\\[0\\]\n\\>>> print(error.message)\nOpening and ending tag mismatch: root line 1 and b\n\\>>> print(error.line)\n2\n\\>>> print(error.column)\n5\n\nEach entry in the log has the following properties:\n\n*   message: the message text\n*   domain: the domain ID (see the lxml.etree.ErrorDomains class)\n*   type: the message type ID (see the lxml.etree.ErrorTypes class)\n*   level: the log level ID (see the lxml.etree.ErrorLevels class)\n*   line: the line at which the message originated (if applicable)\n*   column: the character column at which the message originated (if applicable)\n*   filename: the name of the file in which the message originated (if applicable)\n\nFor convenience, there are also three properties that provide readable names for the ID values:\n\n*   domain\\_name\n*   type\\_name\n*   level\\_name\n\nTo filter for a specific kind of message, use the different filter\\_\\*() methods on the error log (see the lxml.etree.\\_ListErrorLog class).\n\nParsing HTML\n------------\n\nHTML parsing is similarly simple. The parsers have a recover keyword argument that the HTMLParser sets by default. It lets libxml2 try its best to return a valid HTML tree with all content it can manage to parse. It will not raise an exception on parser errors. You should use libxml2 version 2.6.21 or newer to take advantage of this feature.\n\n\\>>> broken\\_html \\= \"<html><head><title>test<body><h1>page title</h3>\"\n\n\\>>> parser \\= etree.HTMLParser()\n\\>>> html\\_root   \\= etree.fromstring(broken\\_html, parser)\n\n\\>>> result \\= etree.tostring(html\\_root,\n...                         pretty\\_print\\=True, method\\=\"html\")\n\\>>> print(result)\n<html>\n  <head>\n    <title>test</title>\n  </head>\n  <body>\n    <h1>page title</h1>\n  </body>\n</html>\n\nAs a nicer alias for parsing HTML literals, lxml has an HTML() function, similar to the XML() shortcut known from ElementTree:\n\n\\>>> html\\_root \\= etree.HTML(\"\"\"\n...   <html>\n...      <body>\n...         <h1>page title</h1>\n...     </body>\n...   </html>\n... \"\"\")\n\nNote: The support for parsing broken HTML depends entirely on libxml2's recovery algorithm. It is _not_ the fault of lxml if you find documents that are so heavily broken that the parser cannot handle them. There is also no guarantee that the resulting tree will contain all data from the original document. The parser may have to drop seriously broken parts when struggling to keep parsing. Especially misplaced meta tags can suffer from this, which may lead to encoding problems.\n\nNote that the result is a valid HTML tree, but it may not be a well-formed XML tree. For example, XML forbids double hyphens in comments, which the HTML parser will happily accept in recovery mode. Therefore, if your goal is to serialise an HTML document as an XML/XHTML document after parsing, you may have to apply some manual preprocessing first.\n\nAlso note that the HTML parser is meant to parse HTML documents. For XHTML documents, use the XML parser, which is namespace aware.\n\nDoctype information\n-------------------\n\nThe use of the libxml2 parsers makes some additional information available at the API level. Currently, ElementTree objects can access the DOCTYPE information provided by a parsed document, as well as the XML version and the original encoding. Since lxml 3.5, the doctype references are mutable.\n\n\\>>> pub\\_id  \\= \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\\>>> sys\\_url \\= \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n\\>>> doctype\\_string \\= '<!DOCTYPE html PUBLIC \"%s\" \"%s\">' % (pub\\_id, sys\\_url)\n\\>>> xml\\_header \\= '<?xml version=\"1.0\" encoding=\"ascii\"?>'\n\\>>> xhtml \\= xml\\_header + doctype\\_string + '<html><body></body></html>'\n\n\\>>> tree \\= etree.parse(StringIO(xhtml))\n\\>>> docinfo \\= tree.docinfo\n\\>>> print(docinfo.public\\_id)\n\\-//W3C//DTD XHTML 1.0 Transitional//EN\n\\>>> print(docinfo.system\\_url)\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\n\\>>> docinfo.doctype \\== doctype\\_string\nTrue\n\n\\>>> print(docinfo.xml\\_version)\n1.0\n\\>>> print(docinfo.encoding)\nascii\n\n\\>>> docinfo.system\\_url \\= None\n\\>>> docinfo.public\\_id \\= None\n\\>>> print(etree.tostring(tree))\n<!DOCTYPE html>\n<html><body/></html>\n\nThe target parser interface\n===========================\n\n[As in ElementTree](http://effbot.org/elementtree/elementtree-xmlparser.htm)\n, and similar to a SAX event handler, you can pass a target object to the parser:\n\n\\>>> class EchoTarget(object):\n...     def start(self, tag, attrib):\n...         print(\"start %s %r\" % (tag, dict(attrib)))\n...     def end(self, tag):\n...         print(\"end %s\" % tag)\n...     def data(self, data):\n...         print(\"data %r\" % data)\n...     def comment(self, text):\n...         print(\"comment %s\" % text)\n...     def close(self):\n...         print(\"close\")\n...         return \"closed!\"\n\n\\>>> parser \\= etree.XMLParser(target \\= EchoTarget())\n\n\\>>> result \\= etree.XML(\"<element>some<!--comment-->text</element>\",\n...                    parser)\nstart element {}\ndata 'some'\ncomment comment\ndata 'text'\nend element\nclose\n\n\\>>> print(result)\nclosed!\n\nIt is important for the .close() method to reset the parser target to a usable state, so that you can reuse the parser as often as you like:\n\n\\>>> result \\= etree.XML(\"<element>some<!--comment-->text</element>\",\n...                    parser)\nstart element {}\ndata 'some'\ncomment comment\ndata 'text'\nend element\nclose\n\n\\>>> print(result)\nclosed!\n\nStarting with lxml 2.3, the .close() method will also be called in the error case. This diverges from the behaviour of ElementTree, but allows target objects to clean up their state in all situations, so that the parser can reuse them afterwards.\n\n\\>>> class CollectorTarget(object):\n...     def \\_\\_init\\_\\_(self):\n...         self.events \\= \\[\\]\n...     def start(self, tag, attrib):\n...         self.events.append(\"start %s %r\" % (tag, dict(attrib)))\n...     def end(self, tag):\n...         self.events.append(\"end %s\" % tag)\n...     def data(self, data):\n...         self.events.append(\"data %r\" % data)\n...     def comment(self, text):\n...         self.events.append(\"comment %s\" % text)\n...     def close(self):\n...         self.events.append(\"close\")\n...         return \"closed!\"\n\n\\>>> parser \\= etree.XMLParser(target \\= CollectorTarget())\n\n\\>>> result \\= etree.XML(\"<element>some</error>\",\n...                    parser)        \\# doctest: +ELLIPSIS\nTraceback (most recent call last):\n  ...\nlxml.etree.XMLSyntaxError: Opening and ending tag mismatch...\n\n\\>>> for event in parser.target.events:\n...     print(event)\nstart element {}\ndata 'some'\nclose\n\nNote that the parser does _not_ build a tree when using a parser target. The result of the parser run is whatever the target object returns from its .close() method. If you want to return an XML tree here, you have to create it programmatically in the target object. An example for a parser target that builds a tree is the TreeBuilder:\n\n\\>>> parser \\= etree.XMLParser(target \\= etree.TreeBuilder())\n\n\\>>> result \\= etree.XML(\"<element>some<!--comment-->text</element>\",\n...                    parser)\n\n\\>>> print(result.tag)\nelement\n\\>>> print(result\\[0\\].text)\ncomment\n\nThe feed parser interface\n=========================\n\nSince lxml 2.0, the parsers have a feed parser interface that is compatible to the [ElementTree parsers](http://effbot.org/elementtree/elementtree-xmlparser.htm)\n. You can use it to feed data into the parser in a controlled step-by-step way.\n\nIn lxml.etree, you can use both interfaces to a parser at the same time: the parse() or XML() functions, and the feed parser interface. Both are independent and will not conflict (except if used in conjunction with a parser target object as described above).\n\nTo start parsing with a feed parser, just call its feed() method to feed it some data.\n\n\\>>> parser \\= etree.XMLParser()\n\n\\>>> for data in ('<?xml versio', 'n=\"1.0\"?', '><roo', 't><a', '/></root>'):\n...     parser.feed(data)\n\nWhen you are done parsing, you **must** call the close() method to retrieve the root Element of the parse result document, and to unlock the parser:\n\n\\>>> root \\= parser.close()\n\n\\>>> print(root.tag)\nroot\n\\>>> print(root\\[0\\].tag)\na\n\nIf you do not call close(), the parser will stay locked and subsequent feeds will keep appending data, usually resulting in a non well-formed document and an unexpected parser error. So make sure you always close the parser after use, also in the exception case.\n\nAnother way of achieving the same step-by-step parsing is by writing your own file-like object that returns a chunk of data on each read() call. Where the feed parser interface allows you to actively pass data chunks into the parser, a file-like object passively responds to read() requests of the parser itself. Depending on the data source, either way may be more natural.\n\nNote that the feed parser has its own error log called feed\\_error\\_log. Errors in the feed parser do not show up in the normal error\\_log and vice versa.\n\nYou can also combine the feed parser interface with the target parser:\n\n\\>>> parser \\= etree.XMLParser(target \\= EchoTarget())\n\n\\>>> parser.feed(\"<eleme\")\n\\>>> parser.feed(\"nt>some text</elem\")\nstart element {}\ndata 'some text'\n\\>>> parser.feed(\"ent>\")\nend element\n\n\\>>> result \\= parser.close()\nclose\n\\>>> print(result)\nclosed!\n\nAgain, this prevents the automatic creation of an XML tree and leaves all the event handling to the target object. The close() method of the parser forwards the return value of the target's close() method.\n\nIncremental event parsing\n=========================\n\nIn Python 3.4, the xml.etree.ElementTree package gained an extension to the feed parser interface that is implemented by the XMLPullParser class. It additionally allows processing parse events after each incremental parsing step, by calling the .read\\_events() method and iterating over the result. This is most useful for non-blocking execution environments where data chunks arrive one after the other and should be processed as far as possible in each step.\n\nThe same feature is available in lxml 3.3. The basic usage is as follows:\n\n\\>>> parser \\= etree.XMLPullParser(events\\=('start', 'end'))\n\n\\>>> def print\\_events(parser):\n...     for action, element in parser.read\\_events():\n...         print('%s: %s' % (action, element.tag))\n\n\\>>> parser.feed('<root>some text')\n\\>>> print\\_events(parser)\nstart: root\n\\>>> print\\_events(parser)    \\# well, no more events, as before ...\n\n\\>>> parser.feed('<child><a />')\n\\>>> print\\_events(parser)\nstart: child\nstart: a\nend: a\n\n\\>>> parser.feed('</child></roo')\n\\>>> print\\_events(parser)\nend: child\n\\>>> parser.feed('t>')\n\\>>> print\\_events(parser)\nend: root\n\nJust like the normal feed parser, the XMLPullParser builds a tree in memory (and you should always call the .close() method when done with parsing):\n\n\\>>> root \\= parser.close()\n\\>>> etree.tostring(root)\nb'<root>some text<child><a/></child></root>'\n\nHowever, since the parser provides incremental access to that tree, you can explicitly delete content that you no longer need once you have processed it. Read the section on [Modifying the tree](https://lxml.de/parsing.html#modifying-the-tree)\n below to see what you can do here and what kind of modifications you should avoid.\n\nIn lxml, it is enough to call the .read\\_events() method once as the iterator it returns can be reused when new events are available.\n\nAlso, as known from other iterators in lxml, you can pass a tag argument that selects which parse events are returned by the .read\\_events() iterator.\n\nEvent types\n-----------\n\nThe parse events are tuples (event-type, object). The event types supported by ElementTree and lxml.etree are the strings 'start', 'end', 'start-ns' and 'end-ns'. The 'start' and 'end' events represent opening and closing elements. They are accompanied by the respective Element instance. By default, only 'end' events are generated, whereas the example above requested the generation of both 'start' and 'end' events.\n\nThe 'start-ns' and 'end-ns' events notify about namespace declarations. They do not come with Elements. Instead, the value of the 'start-ns' event is a tuple (prefix, namespaceURI) that designates the beginning of a prefix-namespace mapping. The corresponding end-ns event does not have a value (None). It is common practice to use a list as namespace stack and pop the last entry on the 'end-ns' event.\n\n\\>>> def print\\_events(events):\n...     for action, obj in events:\n...         if action in ('start', 'end'):\n...             print(\"%s: %s\" % (action, obj.tag))\n...         elif action \\== 'start-ns':\n...             print(\"%s: %s\" % (action, obj))\n...         else:\n...             print(action)\n\n\\>>> event\\_types \\= (\"start\", \"end\", \"start-ns\", \"end-ns\")\n\\>>> parser \\= etree.XMLPullParser(event\\_types)\n\\>>> events \\= parser.read\\_events()\n\n\\>>> parser.feed('<root><element>')\n\\>>> print\\_events(events)\nstart: root\nstart: element\n\\>>> parser.feed('text</element><element>text</element>')\n\\>>> print\\_events(events)\nend: element\nstart: element\nend: element\n\\>>> parser.feed('<empty-element xmlns=\"http://testns/\" />')\n\\>>> print\\_events(events)\nstart-ns: ('', 'http://testns/')\nstart: {http://testns/}empty-element\nend: {http://testns/}empty-element\nend-ns\n\\>>> parser.feed('</root>')\n\\>>> print\\_events(events)\nend: root\n\nModifying the tree\n------------------\n\nYou can modify the element and its descendants when handling the 'end' event. To save memory, for example, you can remove subtrees that are no longer needed:\n\n\\>>> parser \\= etree.XMLPullParser()\n\\>>> events \\= parser.read\\_events()\n\n\\>>> parser.feed('<root><element key=\"value\">text</element>')\n\\>>> parser.feed('<element><child /></element>')\n\\>>> for action, elem in events:\n...     print('%s: %d' % (elem.tag, len(elem)))  \\# processing\n...     elem.clear(keep\\_tail\\=True)               \\# delete children\nelement: 0\nchild: 0\nelement: 1\n\\>>> parser.feed('<empty-element xmlns=\"http://testns/\" /></root>')\n\\>>> for action, elem in events:\n...     print('%s: %d' % (elem.tag, len(elem)))  \\# processing\n...     elem.clear(keep\\_tail\\=True)               \\# delete children\n{http://testns/}empty-element: 0\nroot: 3\n\n\\>>> root \\= parser.close()\n\\>>> etree.tostring(root)\nb'<root/>'\n\n**WARNING**: During the 'start' event, any content of the element, such as the descendants, following siblings or text, is not yet available and should not be accessed. Only attributes are guaranteed to be set. During the 'end' event, the element and its descendants can be freely modified, but its following siblings should not be accessed. During either of the two events, you **must not** modify or move the ancestors (parents) of the current element. You should also avoid moving or discarding the element itself. The golden rule is: do not touch anything that will have to be touched again by the parser later on.\n\nIf you have elements with a long list of children in your XML file and want to save more memory during parsing, you can clean up the preceding siblings of the current element:\n\n\\>>> for event, element in parser.read\\_events():\n...     \\# ... do something with the element\n...     element.clear(keep\\_tail\\=True)   \\# clean up children\n...     while element.getprevious() is not None:\n...         del element.getparent()\\[0\\]  \\# clean up preceding siblings\n\nThe while loop deletes multiple siblings in a row. This is only necessary if you skipped over some of them using the tag keyword argument. Otherwise, a simple if should do. The more selective your tag is, however, the more thought you will have to put into finding the right way to clean up the elements that were skipped. Therefore, it is sometimes easier to traverse all elements and do the tag selection by hand in the event handler code.\n\nSelective tag events\n--------------------\n\nAs an extension over ElementTree, lxml.etree accepts a tag keyword argument just like element.iter(tag). This restricts events to a specific tag or namespace:\n\n\\>>> parser \\= etree.XMLPullParser(tag\\=\"element\")\n\n\\>>> parser.feed('<root><element key=\"value\">text</element>')\n\\>>> parser.feed('<element><child /></element>')\n\\>>> parser.feed('<empty-element xmlns=\"http://testns/\" /></root>')\n\n\\>>> for action, elem in parser.read\\_events():\n...     print(\"%s: %s\" % (action, elem.tag))\nend: element\nend: element\n\n\\>>> event\\_types \\= (\"start\", \"end\")\n\\>>> parser \\= etree.XMLPullParser(event\\_types, tag\\=\"{http://testns/}\\*\")\n\n\\>>> parser.feed('<root><element key=\"value\">text</element>')\n\\>>> parser.feed('<element><child /></element>')\n\\>>> parser.feed('<empty-element xmlns=\"http://testns/\" /></root>')\n\n\\>>> for action, elem in parser.read\\_events():\n...     print(\"%s: %s\" % (action, elem.tag))\nstart: {http://testns/}empty-element\nend: {http://testns/}empty-element\n\nComments and PIs\n----------------\n\nAs an extension over ElementTree, the XMLPullParser in lxml.etree also supports the event types 'comment' and 'pi' for the respective XML structures.\n\n\\>>> event\\_types \\= (\"start\", \"end\", \"comment\", \"pi\")\n\\>>> parser \\= etree.XMLPullParser(event\\_types)\n\n\\>>> parser.feed('<?some pi ?><!-- a comment --><root>')\n\\>>> parser.feed('<element key=\"value\">text</element>')\n\\>>> parser.feed('<!-- another comment -->')\n\\>>> parser.feed('<element>text</element>tail')\n\\>>> parser.feed('<empty-element xmlns=\"http://testns/\" />')\n\\>>> parser.feed('</root>')\n\n\\>>> for action, elem in parser.read\\_events():\n...     if action in ('start', 'end'):\n...         print(\"%s: %s\" % (action, elem.tag))\n...     elif action \\== 'pi':\n...         print(\"%s: -%s\\=%s\\-\" % (action, elem.target, elem.text))\n...     else: \\# 'comment'\n...         print(\"%s: -%s\\-\" % (action, elem.text))\npi: -some=pi -\ncomment: - a comment -\nstart: root\nstart: element\nend: element\ncomment: - another comment -\nstart: element\nend: element\nstart: {http://testns/}empty-element\nend: {http://testns/}empty-element\nend: root\n\n\\>>> root \\= parser.close()\n\\>>> print(root.tag)\nroot\n\nEvents with custom targets\n--------------------------\n\nYou can combine the pull parser with a parser target. In that case, it is the target's responsibility to generate event values. Whatever it returns from its .start() and .end() methods will be returned by the pull parser as the second item of the parse events tuple.\n\n\\>>> class Target(object):\n...     def start(self, tag, attrib):\n...         print('-> start(%s)' % tag)\n...         return '>>START: %s<<' % tag\n...     def end(self, tag):\n...         print('-> end(%s)' % tag)\n...         return '>>END: %s<<' % tag\n...     def close(self):\n...         print('-> close()')\n...         return \"CLOSED!\"\n\n\\>>> event\\_types \\= ('start', 'end')\n\\>>> parser \\= etree.XMLPullParser(event\\_types, target\\=Target())\n\n\\>>> parser.feed('<root><child1 /><child2 /></root>')\n\\-> start(root)\n\\-> start(child1)\n\\-> end(child1)\n\\-> start(child2)\n\\-> end(child2)\n\\-> end(root)\n\n\\>>> for action, value in parser.read\\_events():\n...     print('%s: %s' % (action, value))\nstart: >>START: root<<\nstart: >>START: child1<<\nend: >>END: child1<<\nstart: >>START: child2<<\nend: >>END: child2<<\nend: >>END: root<<\n\n\\>>> print(parser.close())\n\\-> close()\nCLOSED!\n\nAs you can see, the event values do not even have to be Element objects. The target is generally free to decide how it wants to create an XML tree or whatever else it wants to make of the parser callbacks. In many cases, however, you will want to make your custom target inherit from the TreeBuilder class in order to have it build a tree that you can process normally. The start() and .end() methods of TreeBuilder return the Element object that was created, so you can override them and modify the input or output according to your needs. Here is an example that filters attributes before they are being added to the tree:\n\n\\>>> class AttributeFilter(etree.TreeBuilder):\n...     def start(self, tag, attrib):\n...         attrib \\= dict(attrib)\n...         if 'evil' in attrib:\n...             del attrib\\['evil'\\]\n...         return super(AttributeFilter, self).start(tag, attrib)\n\n\\>>> parser \\= etree.XMLPullParser(target\\=AttributeFilter())\n\\>>> parser.feed('<root><child1 test=\"123\" /><child2 evil=\"YES\" /></root>')\n\n\\>>> for action, element in parser.read\\_events():\n...     print('%s: %s(%r)' % (action, element.tag, element.attrib))\nend: child1({'test': '123'})\nend: child2({})\nend: root({})\n\n\\>>> root \\= parser.close()\n\niterparse and iterwalk\n======================\n\nAs known from ElementTree, the iterparse() utility function returns an iterator that generates parser events for an XML file (or file-like object), while building the tree. You can think of it as a blocking wrapper around the XMLPullParser that automatically and incrementally reads data from the input file for you and provides a single iterator for them:\n\n\\>>> xml \\= '''\n... <root>\n...   <element key='value'>text</element>\n...   <element>text</element>tail\n...   <empty-element xmlns=\"http://testns/\" />\n... </root>\n... '''\n\n\\>>> context \\= etree.iterparse(StringIO(xml))\n\\>>> for action, elem in context:\n...     print(\"%s: %s\" % (action, elem.tag))\nend: element\nend: element\nend: {http://testns/}empty-element\nend: root\n\nAfter parsing, the resulting tree is available through the root property of the iterator:\n\n\\>>> context.root.tag\n'root'\n\nThe other event types can be activated with the events keyword argument:\n\n\\>>> events \\= (\"start\", \"end\")\n\\>>> context \\= etree.iterparse(StringIO(xml), events\\=events)\n\\>>> for action, elem in context:\n...     print(\"%s: %s\" % (action, elem.tag))\nstart: root\nstart: element\nend: element\nstart: element\nend: element\nstart: {http://testns/}empty-element\nend: {http://testns/}empty-element\nend: root\n\niterparse() also supports the tag argument for selective event iteration and several other parameters that control the parser setup. The tag argument can be a single tag or a sequence of tags. You can also use it to parse HTML input by passing html=True.\n\niterwalk\n--------\n\nFor convenience, lxml also provides an iterwalk() function. It behaves exactly like iterparse(), but works on Elements and ElementTrees. Here is an example for a tree parsed by iterparse():\n\n\\>>> f \\= StringIO(xml)\n\\>>> context \\= etree.iterparse(\n...             f, events\\=(\"start\", \"end\"), tag\\=\"element\")\n\n\\>>> for action, elem in context:\n...     print(\"%s: %s\" % (action, elem.tag))\nstart: element\nend: element\nstart: element\nend: element\n\n\\>>> root \\= context.root\n\nAnd now we can take the resulting in-memory tree and iterate over it using iterwalk() to get the exact same events without parsing the input again:\n\n\\>>> context \\= etree.iterwalk(\n...             root, events\\=(\"start\", \"end\"), tag\\=\"element\")\n\n\\>>> for action, elem in context:\n...     print(\"%s: %s\" % (action, elem.tag))\nstart: element\nend: element\nstart: element\nend: element\n\nIn order to avoid wasting time on uninteresting parts of the tree, the iterwalk iterator can be instructed to skip over an entire subtree with its .skip\\_subtree() method.\n\n\\>>> root \\= etree.XML('''\n... <root>\n...   <a> <b /> </a>\n...   <c />\n... </root>\n... ''')\n\n\\>>> context \\= etree.iterwalk(root, events\\=(\"start\", \"end\"))\n\n\\>>> for action, elem in context:\n...     print(\"%s: %s\" % (action, elem.tag))\n...     if action \\== 'start' and elem.tag \\== 'a':\n...         context.skip\\_subtree()  \\# ignore <b>\nstart: root\nstart: a\nend: a\nstart: c\nend: c\nend: root\n\nNote that .skip\\_subtree() only has an effect when handling start or start-ns events.\n\nPython unicode strings\n======================\n\nlxml.etree has broader support for Python unicode strings than the ElementTree library. First of all, where ElementTree would raise an exception, the parsers in lxml.etree can handle unicode strings straight away. This is most helpful for XML snippets embedded in source code using the XML() function:\n\n\\>>> root \\= etree.XML( '<test> \\\\uf8d1 + \\\\uf8d2 </test>' )\n\nThis requires, however, that unicode strings do not specify a conflicting encoding themselves and thus lie about their real encoding:\n\n\\>>> etree.XML( '<?xml version=\"1.0\" encoding=\"ASCII\"?>\\\\n' +\n...            '<test> \\\\uf8d1 + \\\\uf8d2 </test>' )\nTraceback (most recent call last):\n  ...\nValueError: Unicode strings with encoding declaration are not supported. Please use bytes input or XML fragments without declaration.\n\nSimilarly, you will get errors when you try the same with HTML data in a unicode string that specifies a charset in a meta tag of the header. You should generally avoid converting XML/HTML data to unicode before passing it into the parsers. It is both slower and error prone.\n\nSerialising to Unicode strings\n------------------------------\n\nTo serialize the result, you would normally use the tostring() module function, which serializes to plain ASCII by default or a number of other byte encodings if asked for:\n\n\\>>> etree.tostring(root)\nb'<test> &#63697; + &#63698; </test>'\n\n\\>>> etree.tostring(root, encoding\\='UTF-8', xml\\_declaration\\=False)\nb'<test> \\\\xef\\\\xa3\\\\x91 + \\\\xef\\\\xa3\\\\x92 </test>'\n\nAs an extension, lxml.etree recognises the name 'unicode' as an argument to the encoding parameter to build a Python unicode representation of a tree:\n\n\\>>> etree.tostring(root, encoding\\='unicode')\n'<test> \\\\uf8d1 + \\\\uf8d2 </test>'\n\n\\>>> el \\= etree.Element(\"test\")\n\\>>> etree.tostring(el, encoding\\='unicode')\n'<test/>'\n\n\\>>> subel \\= etree.SubElement(el, \"subtest\")\n\\>>> etree.tostring(el, encoding\\='unicode')\n'<test><subtest/></test>'\n\n\\>>> tree \\= etree.ElementTree(el)\n\\>>> etree.tostring(tree, encoding\\='unicode')\n'<test><subtest/></test>'\n\nThe result of tostring(encoding='unicode') can be treated like any other Python unicode string and then passed back into the parsers. However, if you want to save the result to a file or pass it over the network, you should use write() or tostring() with a byte encoding (typically UTF-8) to serialize the XML. The main reason is that unicode strings returned by tostring(encoding='unicode') are not byte streams and they never have an XML declaration to specify their encoding. These strings are most likely not parsable by other XML libraries.\n\nFor normal byte encodings, the tostring() function automatically adds a declaration as needed that reflects the encoding of the returned string. This makes it possible for other parsers to correctly parse the XML byte stream. Note that using tostring() with UTF-8 is also considerably faster in most cases.","metadata":{"language":"en","title":"Parsing XML and HTML with lxml","generator":"Docutils 0.20.1: https://docutils.sourceforge.io/","viewport":"width=device-width, initial-scale=1","scrapeId":"a72b0049-5e1b-4b3c-8b80-d488a4217457","sourceURL":"https://lxml.de/parsing.html","url":"https://lxml.de/parsing.html","statusCode":200}}]}