{"success":true,"status":"completed","completed":100,"total":100,"creditsUsed":100,"expiresAt":"2025-03-05T21:15:20.000Z","data":[{"markdown":"TypeScript Documentation\n========================\n\n#### Get Started\n\nQuick introductions based on your background or preference.\n\n*   [TS for the New Programmer](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)\n    \n*   [TypeScript for JS Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)\n    \n*   [TS for Java/C# Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html)\n    \n*   [TS for Functional Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)\n    \n*   [TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)\n    \n\n#### Handbook\n\nA great first read for your daily TS work.\n\n*   [The TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)\n    \n*   [The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)\n    \n*   [Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)\n    \n*   [Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)\n    \n*   [More on Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)\n    \n*   [Object Types](https://www.typescriptlang.org/docs/handbook/2/objects.html)\n    \n*   Type Manipulation\n*   *   [Creating Types from Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)\n        \n    *   [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)\n        \n    *   [Keyof Type Operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)\n        \n    *   [Typeof Type Operator](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)\n        \n    *   [Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)\n        \n    *   [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)\n        \n    *   [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)\n        \n    *   [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)\n        \n*   [Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)\n    \n*   [Modules](https://www.typescriptlang.org/docs/handbook/2/modules.html)\n    \n\n#### Reference\n\nDeep dive reference materials.\n\n*   [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)\n    \n*   [Cheat Sheets](https://www.typescriptlang.org/cheatsheets/)\n    \n*   [Decorators](https://www.typescriptlang.org/docs/handbook/decorators.html)\n    \n*   [Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)\n    \n*   [Enums](https://www.typescriptlang.org/docs/handbook/enums.html)\n    \n*   [Iterators and Generators](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html)\n    \n*   [JSX](https://www.typescriptlang.org/docs/handbook/jsx.html)\n    \n*   [Mixins](https://www.typescriptlang.org/docs/handbook/mixins.html)\n    \n*   [Namespaces](https://www.typescriptlang.org/docs/handbook/namespaces.html)\n    \n*   [Namespaces and Modules](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html)\n    \n*   [Symbols](https://www.typescriptlang.org/docs/handbook/symbols.html)\n    \n*   [Triple-Slash Directives](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html)\n    \n*   [Type Compatibility](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)\n    \n*   [Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)\n    \n*   [Variable Declaration](https://www.typescriptlang.org/docs/handbook/variable-declarations.html)\n    \n\n#### Modules Reference\n\nHow TypeScript models JavaScript modules.\n\n*   [Introduction](https://www.typescriptlang.org/docs/handbook/modules/introduction.html)\n    \n*   [Theory](https://www.typescriptlang.org/docs/handbook/modules/theory.html)\n    \n*   Guides\n*   *   [Choosing Compiler Options](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html)\n        \n*   [Reference](https://www.typescriptlang.org/docs/handbook/modules/reference.html)\n    \n*   Appendices\n*   *   [ESM/CJS Interoperability](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html)\n        \n\n#### Tutorials\n\nUsing TypeScript in several environments.\n\n*   [ASP.NET Core](https://www.typescriptlang.org/docs/handbook/asp-net-core.html)\n    \n*   [Gulp](https://www.typescriptlang.org/docs/handbook/gulp.html)\n    \n*   [DOM Manipulation](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html)\n    \n*   [Migrating from JavaScript](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html)\n    \n*   [Using Babel with TypeScript](https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html)\n    \n\n#### Declaration Files\n\nLearn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.\n\n*   [Introduction](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)\n    \n*   [Declaration Reference](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)\n    \n*   [Library Structures](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html)\n    \n*   .d.ts Templates\n*   *   [Modules .d.ts](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html)\n        \n    *   [Module: Plugin](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)\n        \n    *   [Module: Class](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html)\n        \n    *   [Module: Function](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html)\n        \n    *   [Global .d.ts](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html)\n        \n    *   [Global: Modifying Module](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)\n        \n*   [Do's and Don'ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)\n    \n*   [Deep Dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)\n    \n*   [Publishing](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)\n    \n*   [Consumption](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html)\n    \n\n#### JavaScript\n\nHow to use TypeScript-powered JavaScript tooling.\n\n*   [JS Projects Utilizing TypeScript](https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html)\n    \n*   [Type Checking JavaScript Files](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)\n    \n*   [JSDoc Reference](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n    \n*   [Creating .d.ts Files from .js files](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html)\n    \n\n#### Project Configuration\n\nCompiler configuration reference.\n\n*   [What is a tsconfig.json](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n    \n*   [Compiler Options in MSBuild](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html)\n    \n*   [TSConfig Reference](https://www.typescriptlang.org/tsconfig/)\n    \n*   [tsc CLI Options](https://www.typescriptlang.org/docs/handbook/compiler-options.html)\n    \n*   [Project References](https://www.typescriptlang.org/docs/handbook/project-references.html)\n    \n*   [Integrating with Build Tools](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html)\n    \n*   [Configuring Watch](https://www.typescriptlang.org/docs/handbook/configuring-watch.html)\n    \n*   [Nightly Builds](https://www.typescriptlang.org/docs/handbook/nightly-builds.html)\n    \n\n#### Cheat Sheets\n\nDownloadable syntax reference pages for different parts of everyday TypeScript code.\n\n*   [Control Flow Analysis](https://www.typescriptlang.org/static/TypeScript%20Control%20Flow%20Analysis-8a549253ad8470850b77c4c5c351d457.png)\n    \n*   [Classes](https://www.typescriptlang.org/static/TypeScript%20Classes-83cc6f8e42ba2002d5e2c04221fa78f9.png)\n    \n*   [Interfaces](https://www.typescriptlang.org/static/TypeScript%20Interfaces-34f1ad12132fb463bd1dfe5b85c5b2e6.png)\n    \n*   [Types](https://www.typescriptlang.org/static/TypeScript%20Types-ae199d69aeecf7d4a2704a528d0fd3f9.png)\n    \n*   [Download PDFs and PNGs](https://www.typescriptlang.org/assets/typescript-cheat-sheets.zip)\n    \n\nLearning Resources\n------------------\n\n#### Get Started\n\n*   [JS to TS](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)\n    \n*   [New to Programming](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)\n    \n*   [OOP to JS](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html)\n    \n*   [Functional to JS](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)\n    \n*   [Installation](https://www.typescriptlang.org/download/)\n    \n\n#### Handbook\n\n*   [Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)\n    \n*   [Creating Types from Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)\n    \n*   [Object Types](https://www.typescriptlang.org/docs/handbook/2/objects.html)\n    \n*   [Variable Declarations](https://www.typescriptlang.org/docs/handbook/variable-declarations.html)\n    \n*   [More on Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)\n    \n\n#### Tools\n\n*   [Playground](https://www.typescriptlang.org/play/)\n    \n*   [TSConfig Reference](https://www.typescriptlang.org/tsconfig/)\n    \n\n#### Release Notes\n\n*   [What's new in 5.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html)\n    \n\n#### Tutorials\n\n*   [ASP.NET](https://www.typescriptlang.org/docs/handbook/asp-net-core.html)\n    \n*   [Migrating from JS](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html)\n    \n*   [Working with the DOM](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html)\n    \n*   [React & Webpack](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html)\n    \n\nMSG","metadata":{"ogDescription":"Find TypeScript starter projects: from Angular to React or Node.js and CLIs.","twitter:site":"typescriptlang","description":"Find TypeScript starter projects: from Angular to React or Node.js and CLIs.","language":"en","ogTitle":"The starting point for learning TypeScript","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","title":"TypeScript: The starting point for learning TypeScript","og:title":"The starting point for learning TypeScript","og:description":"Find TypeScript starter projects: from Angular to React or Node.js and CLIs.","scrapeId":"cc77c0f1-673b-407b-9834-38f7e2a8278e","sourceURL":"https://www.typescriptlang.org/docs/","url":"https://www.typescriptlang.org/docs/","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript for the New Programmer\n=================================\n\nCongratulations on choosing TypeScript as one of your first languages — you’re already making good decisions!\n\nYou’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#what-is-javascript-a-brief-history)\nWhat is JavaScript? A Brief History\n----------------------------------------------------------------------------------------------------------------------------------------------------\n\nJavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.\n\nWeb browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is the long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for rich _applications_ of all kinds.\n\nMore than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The “run anywhere” nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use _only_ JavaScript to program their entire stack!\n\nTo summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own _quirks_ — oddities and surprises, and JavaScript’s humble beginning makes it have _many_ of these. Some examples:\n\n*   JavaScript’s equality operator (`==`) _coerces_ its operands, leading to unexpected behavior:\n    \n    js\n    \n    `   if (\"\" == 0) {    // It is! But why??  }  if (1 < x < 3) {    // True for *any* value of x!  }   `\n    \n*   JavaScript also allows accessing properties which aren’t present:\n    \n    js\n    \n    `   const obj = { width: 10, height: 15 };  // Why is this NaN? Spelling is hard!  const area = obj.width * obj.heigth;   `\n    \n\nMost programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#typescript-a-static-type-checker)\nTypeScript: A Static Type Checker\n------------------------------------------------------------------------------------------------------------------------------------------------\n\nWe said earlier that some languages wouldn’t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as _static checking_. Determining what’s an error and what’s not based on the kinds of values being operated on is known as static _type_ checking.\n\nTypeScript checks a program for errors before execution, and does so based on the _kinds of values_, making it a _static type checker_. For example, the last example above has an error because of the _type_ of `obj`. Here’s the error TypeScript found:\n\nts\n\n`  const obj = { width: 10, height: 15 };  const area = obj.width * obj.heigth;  Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?2551Property 'heigth' does not exist on type '{ width: number; height: number; }'. Did you mean 'height'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYBQBjOAO0QBdQ4AjAK1AF5QBvUAdwEsATUgC1WwAYANKG6Q2Ac26k+GUAF8A3AWJlQAQ2iQ19CjQB07Lt1AAqXdT2iJPBUA)\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#a-typed-superset-of-javascript)\nA Typed Superset of JavaScript\n\nHow does TypeScript relate to JavaScript, though?\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#syntax)\nSyntax\n\nTypeScript is a language that is a _superset_ of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a _syntax_ error because it’s missing a `)`:\n\nts\n\n`  let a = (4  ')' expected.1005')' expected.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYMFYBQAbSAF1AENQBeUACgBYg)\n\nTypeScript doesn’t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#types)\nTypes\n\nHowever, TypeScript is a _typed_ superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about `obj.heigth` was not a _syntax_ error: it is an error of using some kind of value (a _type_) in an incorrect way.\n\nAs another example, this is JavaScript code that you can run in your browser, and it _will_ log a value:\n\njs\n\n`   console.log(4 / []);   `\n\nThis syntactically-legal program logs `Infinity`. TypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:\n\nts\n\n`  console.log(4 / []);  The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.2363The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsGBQBjOAO0TgBtIA6MuAcwAoAWUMAbQF0BKAbiA)\n\nIt’s possible you really _did_ intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.)\n\nIf you move some code from a JavaScript file to a TypeScript file, you might see _type errors_ depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors.\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#runtime-behavior)\nRuntime Behavior\n\nTypeScript is also a programming language that preserves the _runtime behavior_ of JavaScript. For example, dividing by zero in JavaScript produces `Infinity` instead of throwing a runtime exception. As a principle, TypeScript **never** changes the runtime behavior of JavaScript code.\n\nThis means that if you move code from JavaScript to TypeScript, it is **guaranteed** to run the same way, even if TypeScript thinks that the code has type errors.\n\nKeeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#erased-types)\nErased Types\n\nRoughly speaking, once TypeScript’s compiler is done with checking your code, it _erases_ the types to produce the resulting “compiled” code. This means that once your code is compiled, the resulting plain JS code has no type information.\n\nThis also means that TypeScript never changes the _behavior_ of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.\n\nFinally, TypeScript doesn’t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#learning-javascript-and-typescript)\nLearning JavaScript and TypeScript\n---------------------------------------------------------------------------------------------------------------------------------------------------\n\nWe frequently see the question “Should I learn JavaScript or TypeScript?“.\n\nThe answer is that you can’t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.\n\nThere are many, many resources available for programmers to learn JavaScript; you should _not_ ignore these resources if you’re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged `javascript` than `typescript`, but _all_ of the `javascript` questions also apply to TypeScript.\n\nIf you find yourself searching for something like “how to sort a list in TypeScript”, remember: **TypeScript is JavaScript’s runtime with a compile-time type checker**. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#next-steps)\nNext Steps\n---------------------------------------------------------------------------------------------------\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n*   Learn some of the JavaScript fundamentals, we recommend either:\n    \n    *   [Microsoft’s JavaScript Resources](https://developer.microsoft.com/javascript/)\n         or\n    *   [JavaScript guide at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide)\n        \n*   Continue to [TypeScript for JavaScript Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)\n    \n*   Read the full Handbook [from start to finish](https://www.typescriptlang.org/docs/handbook/intro.html)\n    \n*   Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/get-started/TS%20for%20the%20New%20Programmer.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (19)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nEB![Eli Barzilay  (2)](https://gravatar.com/avatar/7384b5fcebe0e04cdd109255e1189e5135524f0ebc6ff0ff807b0b9d6ebd3976?s=32&&d=blank)\n\nXL![Xavi Lee  (1)](https://gravatar.com/avatar/f6d2d530383d4b4dea1defeaf555de1e180f6d4def57d9384e69a0993c06e88c?s=32&&d=blank)\n\nNS![Nick Schonning  (1)](https://gravatar.com/avatar/a490b76edb21047df004539971c9258a6c3bd8da6bc3ca94c89da3e6398ef08e?s=32&&d=blank)\n\nAO![Alex Ownejazayeri  (1)](https://gravatar.com/avatar/f4e77fd11fbf67de251933bcc176094333d48e200645ea92f86ea748cf71f963?s=32&&d=blank)\n\n8+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogTitle":"Documentation - TypeScript for the New Programmer","language":"en","og:title":"Documentation - TypeScript for the New Programmer","title":"TypeScript: Documentation - TypeScript for the New Programmer","theme-color":"#3178C6","description":"Learn TypeScript from scratch","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","twitter:site":"typescriptlang","og:description":"Learn TypeScript from scratch","generator":"Gatsby 5.13.5","ogDescription":"Learn TypeScript from scratch","scrapeId":"ddebb1f9-106e-4b57-ad15-daf3d4c5e908","sourceURL":"https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html","url":"https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nThe TypeScript Handbook\n=======================\n\n[](https://www.typescriptlang.org/docs/handbook/intro.html#about-this-handbook)\nAbout this Handbook\n---------------------------------------------------------------------------------------------------\n\nOver 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript’s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.\n\nThe most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).\n\nIf you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation on either the [Microsoft Learn JavaScript tutorial](https://developer.microsoft.com/javascript/)\n or read [JavaScript at the Mozilla Web Docs](https://developer.mozilla.org/docs/Web/JavaScript/Guide)\n. If you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook.\n\n[](https://www.typescriptlang.org/docs/handbook/intro.html#how-is-this-handbook-structured)\nHow is this Handbook Structured\n---------------------------------------------------------------------------------------------------------------------------\n\nThe handbook is split into two sections:\n\n*   **The Handbook**\n    \n    The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.\n    \n    You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language’s features and behaviors.\n    \n    A reader who completes the walkthrough should be able to:\n    \n    *   Read and understand commonly-used TypeScript syntax and patterns\n    *   Explain the effects of important compiler options\n    *   Correctly predict type system behavior in most cases\n    \n    In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.\n    \n*   **Reference Files**\n    \n    The reference section below the handbook in the navigation is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity.\n    \n\n### [](https://www.typescriptlang.org/docs/handbook/intro.html#non-goals)\nNon-Goals\n\nThe Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won’t be covered in order to keep things short.\n\nSpecifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we’ll include links to background reading that you can use to read up on those concepts.\n\nThe Handbook also isn’t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript’s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven’t read about yet.\n\nFinally, the Handbook won’t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web.\n\n[](https://www.typescriptlang.org/docs/handbook/intro.html#get-started)\nGet Started\n-----------------------------------------------------------------------------------\n\nBefore getting started with [The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)\n, we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages.\n\n*   [TypeScript for the New Programmer](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)\n    \n*   [TypeScript for JavaScript Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)\n    \n*   [TypeScript for Java/C# Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html)\n    \n*   [TypeScript for Functional Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)\n    \n\nOtherwise, jump to [The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)\n.\n\n[### The Basics\\\n\\\nStep one in learning TypeScript: The basic types.](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/The%20Handbook.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (22)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nMW![Maira Wenzel  (1)](https://gravatar.com/avatar/17d8cbeddac419bedf98a1092ca1d4b90c1beac40c312cdcabd97ae37e51a21d?s=32&&d=blank)\n\nM![MingYuan  (1)](https://gravatar.com/avatar/1ea0a4769c93bea4d0bad10ec45ae58dc6407eb397de38aa47abb2893f715d62?s=32&&d=blank)\n\nN![navya9singh  (1)](https://gravatar.com/avatar/e896fd3c90d7bd8d3c276d3ea2dd552ae62d81d4a497cdd589f551c5eb5ccb93?s=32&&d=blank)\n\n谭![谭九鼎  (1)](https://gravatar.com/avatar/34ce2fd19a49f19667974c636f94764b0d9c727087e723af4b08802b10bdbcf9?s=32&&d=blank)\n\n5+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:description":"Your first step to learn TypeScript","og:title":"Handbook - The TypeScript Handbook","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"Your first step to learn TypeScript","title":"TypeScript: Handbook - The TypeScript Handbook","theme-color":"#3178C6","language":"en","ogTitle":"Handbook - The TypeScript Handbook","ogDescription":"Your first step to learn TypeScript","scrapeId":"c92f9112-3025-4092-b2d7-cb2d531184d8","sourceURL":"https://www.typescriptlang.org/docs/handbook/intro.html","url":"https://www.typescriptlang.org/docs/handbook/intro.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript for Java/C# Programmers\n==================================\n\nTypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java.\n\nTypeScript’s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program. While TypeScript provides many familiar features for these developers, it’s worth stepping back to see how JavaScript (and therefore TypeScript) differ from traditional OOP languages. Understanding these differences will help you write better JavaScript code, and avoid common pitfalls that programmers who go straight from C#/Java to TypeScript may fall into.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#co-learning-javascript)\nCo-learning JavaScript\n-------------------------------------------------------------------------------------------------------------------------------\n\nIf you’re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to. Some of the ways that TypeScript models types are quite different from Java or C#, and it’s important to keep these in mind when learning TypeScript.\n\nIf you’re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScript _without_ types first to understand JavaScript’s runtime behaviors. Because TypeScript doesn’t change how your code _runs_, you’ll still have to learn how JavaScript works in order to write code that actually does something!\n\nIt’s important to remember that TypeScript uses the same _runtime_ as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs. Don’t limit yourself to TypeScript-specific resources!\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#rethinking-the-class)\nRethinking the Class\n---------------------------------------------------------------------------------------------------------------------------\n\nC# and Java are what we might call _mandatory OOP_ languages. In these languages, the _class_ is the basic unit of code organization, and also the basic container of all data _and_ behavior at runtime. Forcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domain _needs_ to be represented this way.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#free-functions-and-data)\nFree Functions and Data\n\nIn JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-defined `class` or `struct`. This flexibility is extremely powerful. “Free” functions (those not associated with a class) working over data without an implied OOP hierarchy tend to be the preferred model for writing programs in JavaScript.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#static-classes)\nStatic Classes\n\nAdditionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#oop-in-typescript)\nOOP in TypeScript\n---------------------------------------------------------------------------------------------------------------------\n\nThat said, you can still use classes if you like! Some problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript’s support for JavaScript classes will make these models even more powerful. TypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods.\n\nWe’ll cover classes later in this guide.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#rethinking-types)\nRethinking Types\n-------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s understanding of a _type_ is actually quite different from C# or Java’s. Let’s explore some differences.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#nominal-reified-type-systems)\nNominal Reified Type Systems\n\nIn C# or Java, any given value or object has one exact type - either `null`, a primitive, or a known class type. We can call methods like `value.GetType()` or `value.getClass()` to query the exact type at runtime. The definition of this type will reside in a class somewhere with some name, and we can’t use two classes with similar shapes in lieu of each other unless there’s an explicit inheritance relationship or commonly-implemented interface.\n\nThese aspects describe a _reified, nominal_ type system. The types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#types-as-sets)\nTypes as Sets\n\nIn C# or Java, it’s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations.\n\nIn TypeScript, it’s better to think of a type as a _set of values_ that share something in common. Because types are just sets, a particular value can belong to _many_ sets at the same time.\n\nOnce you start thinking of types as sets, certain operations become very natural. For example, in C#, it’s awkward to pass around a value that is _either_ a `string` or `int`, because there isn’t a single type that represents this sort of value.\n\nIn TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the `string` set or the `number` set? It simply belongs to the _union_ of those sets: `string | number`.\n\nTypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you’ll find them more intuitive if you think of types as sets.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#erased-structural-types)\nErased Structural Types\n\nIn TypeScript, objects are _not_ of a single exact type. For example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two.\n\nts\n\n`   interface Pointlike {    x: number;    y: number;  }  interface Named {    name: string;  }  function logPoint(point: Pointlike) {    console.log(\"x = \" + point.x + \", y = \" + point.y);  }  function logName(x: Named) {    console.log(\"Hello, \" + x.name);  }  const obj = {    x: 0,    y: 0,    name: \"Origin\",  };  logPoint(obj);  logName(obj);   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRgDbANYoDeAUMsgB4BcyIArgLYBG0A3KcgJ7V1OvEC+xLNHhJkAOTj0IAE2QkyIKRGoBnMFFABzNoOIxaIBGGDoQybOi0YsACgAOmcNRvhcBAJTz2CM6vTYEAB0llq2AETkyAC8yOHIANTIjlhBUUnhADScMXGJyU5gQRweusT6hsam5qGS0rZUEsoyXgrIviD+gSFWEQASENiW2fFJ5EFK0qUC5R3qyOiMAFa5bY0ADJnsXMib7JMqcQDymlqgWQJsxKGuYLaLS9O1yvfLpUA)\n\nTypeScript’s type system is _structural_, not nominal: We can use `obj` as a `Pointlike` because it has `x` and `y` properties that are both numbers. The relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship.\n\nTypeScript’s type system is also _not reified_: There’s nothing at runtime that will tell us that `obj` is `Pointlike`. In fact, the `Pointlike` type is not present _in any form_ at runtime.\n\nGoing back to the idea of _types as sets_, we can think of `obj` as being a member of both the `Pointlike` set of values and the `Named` set of values.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#consequences-of-structural-typing)\nConsequences of Structural Typing\n\nOOP programmers are often surprised by two particular aspects of structural typing.\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#empty-types)\nEmpty Types\n\nThe first is that the _empty type_ seems to defy expectation:\n\nts\n\n`   class Empty {}  function fn(arg: Empty) {    // do something?  }  // No error, but this isn't an 'Empty' ?  fn({ k: 10 });   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4CgcDMBXAO2GQEsB7Y6fYgCjACcBzALjiTQEpMdpoAekHQAJpWgRK8AKbIAFuWIsA-Dlw5h0AHISZTJpSYAaaACNCyaAvIxbxAORWwNBwhSoH0NXXoZoANYcAIwADNBY3ADcQA)\n\nTypeScript determines if the call to `fn` here is valid by seeing if the provided argument is a valid `Empty`. It does so by examining the _structure_ of `{ k: 10 }` and `class Empty { }`. We can see that `{ k: 10 }` has _all_ of the properties that `Empty` does, because `Empty` has no properties. Therefore, this is a valid call!\n\nThis may seem surprising, but it’s ultimately a very similar relationship to one enforced in nominal OOP languages. A subclass cannot _remove_ a property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base. Structural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types.\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#identical-types)\nIdentical Types\n\nAnother frequent source of surprise comes with identical types:\n\nts\n\n`   class Car {    drive() {      // hit the gas    }  }  class Golfer {    drive() {      // hit the ball far    }  }  // No error?  let w: Car = new Golfer();   `\n\nAgain, this isn’t an error because the _structures_ of these classes are the same. While this may seem like a potential source of confusion, in practice, identical classes that shouldn’t be related are not common.\n\nWe’ll learn more about how classes relate to each other in the Classes chapter.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#reflection)\nReflection\n\nOOP programmers are accustomed to being able to query the type of any value, even a generic one:\n\ncsharp\n\n`   // C#  static void LogType<T>() {      Console.WriteLine(typeof(T).Name);  }   `\n\nBecause TypeScript’s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime.\n\nJavaScript does have some limited primitives like `typeof` and `instanceof`, but remember that these operators are still working on the values as they exist in the type-erased output code. For example, `typeof (new Car())` will be `\"object\"`, not `Car` or `\"Car\"`.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#next-steps)\nNext Steps\n-------------------------------------------------------------------------------------------------------\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n*   Read the full Handbook [from start to finish](https://www.typescriptlang.org/docs/handbook/intro.html)\n    \n*   Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/get-started/TS%20for%20OOPers.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nTZ![Tao Zhou  (1)](https://gravatar.com/avatar/225607fff8db43310b1fbcf877e3c5a950e4604debe524963c6c80ab02006610?s=32&&d=blank)\n\nSP![Samuel Pak  (1)](https://gravatar.com/avatar/39c1210eab25470347a4e56ce171dba5420437748b1b9b329ceb749430656c30?s=32&&d=blank)\n\nL![Lalit  (1)](https://gravatar.com/avatar/1141f3a23b684ef5b2f4f672d37d64e9fa1721d4d4fc4abbe4424df096acaeb9?s=32&&d=blank)\n\nGD![Gonzalo Diethelm  (1)](https://gravatar.com/avatar/4c68fff95bb59e388e86c9d72300c2394f80672eebf707f339dd63c890caae56?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"description":"Learn TypeScript if you have a background in object-oriented languages","og:title":"Documentation - TypeScript for Java/C# Programmers","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","generator":"Gatsby 5.13.5","og:description":"Learn TypeScript if you have a background in object-oriented languages","title":"TypeScript: Documentation - TypeScript for Java/C# Programmers","language":"en","ogDescription":"Learn TypeScript if you have a background in object-oriented languages","ogTitle":"Documentation - TypeScript for Java/C# Programmers","theme-color":"#3178C6","scrapeId":"4d6e761e-f172-4360-b8d5-60d28051cad3","sourceURL":"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html","url":"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript for JavaScript Programmers\n=====================================\n\nTypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system.\n\nFor example, JavaScript provides language primitives like `string` and `number`, but it doesn’t check that you’ve consistently assigned these. TypeScript does.\n\nThis means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.\n\nThis tutorial provides a brief overview of TypeScript, focusing on its type system.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#types-by-inference)\nTypes by Inference\n-------------------------------------------------------------------------------------------------------------------\n\nTypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.\n\nts\n\n`   let helloWorld = \"Hello World\";            let helloWorld: string   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAFizA9gdXgJ2AEwgXggIgBKwITJrq4DcAUAPQ0QQB6A-EA)\n\nBy understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that `helloWorld` is a `string` in the above example.\n\nYou may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#defining-types)\nDefining Types\n-----------------------------------------------------------------------------------------------------------\n\nYou can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.\n\nFor example, to create an object with an inferred type which includes `name: string` and `id: number`, you can write:\n\nts\n\n`   const user = {    name: \"Hayes\",    id: 0,  };   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwFAxmAQwFtEAuGAIgAkCBPRCCgGlxgEsATcgBhYF8A3EA)\n\nYou can explicitly describe this object’s shape using an `interface` declaration:\n\nts\n\n`   interface User {    name: string;    id: number;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvkA)\n\nYou can then declare that a JavaScript object conforms to the shape of your new `interface` by using syntax like `: TypeName` after a variable declaration:\n\nts\n\n`   const user: User = {    name: \"Hayes\",    id: 0,  };   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvrgD0Q5AFoJCDmAljcCAPYgqyDpigUMWALw4mRUhQBEACTgBPCOiMAaJqwoAGO-3pA)\n\nIf you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:\n\nts\n\n`   interface User {    name: string;    id: number;  }  const user: User = {    username: \"Hayes\",  Object literal may only specify known properties, and 'username' does not exist in type 'User'.2353Object literal may only specify known properties, and 'username' does not exist in type 'User'.    id: 0,  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAFVEZQBvHUUA8gW0lUSOkIBzANytQeACaoCAV04AjGKIC+OHJTgE+oGQ2ip6jALzMxumB26oARAAlyAT0iJrAGjGTUABnfLhQA)\n\nSince JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:\n\nts\n\n`   interface User {    name: string;    id: number;  }  class UserAccount {    name: string;    id: number;    constructor(name: string, id: number) {      this.name = name;      this.id = id;    }  }  const user: User = new UserAccount(\"Murphy\", 1);   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnIhwC2EAXMumFKAOYDc+ywAJhSAK7EBG0jAvrlwIANnHTo0mKAEEECAPYdwOJkVIUqNEAyat2XXlEZNFILRwRgFUABTrylanQA0zNoUPQAlKoIEwAAtgdAA6B2QAXkISCEZ-ZCCQ0NYo93jkQUFhBXMwZA5pCgwsaJAIAHcpaDlFZTBbACIAWQ4oAAdAgE9GtwBGb3ogA)\n\nYou can use interfaces to annotate parameters and return values to functions:\n\nts\n\n`   function deleteUser(user: User) {    // ...  }  function getAdminUser(): User {    //...  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAEtIBcCm8AzAQwGNdQBVFfUAbzVFEiIFtcAuUFbeLAcwDcDUBgAmnSAFcWAI3xCAvmhCgAtOpKTs61WgKTIJbBmiRQo3ABtceKvgAUk6vE534ASjrCVAOj9olPQMjEzM+GwBBURYsN3t3V2cvRhA-HwCgA)\n\nThere is already a small set of primitive types available in JavaScript: `boolean`, `bigint`, `null`, `number`, `string`, `symbol`, and `undefined`, which you can use in an interface. TypeScript extends this list with a few more, such as `any` (allow anything), [`unknown`](https://www.typescriptlang.org/play#example/unknown-and-never)\n (ensure someone using this type declares what the type is), [`never`](https://www.typescriptlang.org/play#example/unknown-and-never)\n (it’s not possible that this type could happen), and `void` (a function which returns `undefined` or has no return value).\n\nYou’ll see that there are two syntaxes for building types: [Interfaces and Types](https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces)\n. You should prefer `interface`. Use `type` when you need specific features.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#composing-types)\nComposing Types\n-------------------------------------------------------------------------------------------------------------\n\nWith TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: unions and generics.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#unions)\nUnions\n\nWith a union, you can declare that a type could be one of many types. For example, you can describe a `boolean` type as being either `true` or `false`:\n\nts\n\n`   type MyBool = true | false;   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAsiBCB7RAbKBeKwBOBXaAPlAGYCGKAzhANxA)\n\n_Note:_ If you hover over `MyBool` above, you’ll see that it is classed as `boolean`. That’s a property of the Structural Type System. More on this below.\n\nA popular use-case for union types is to describe the set of `string` or `number` [literals](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)\n that a value is allowed to be:\n\nts\n\n`   type WindowStates = \"open\" | \"closed\" | \"minimized\";  type LockStates = \"locked\" | \"unlocked\";  type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6glgOwCYHsDuBlYBDYEDOUAvFAEQqQKlQA+ZAxgDYr4RLV2kC2icPAXm1IBuAFChIUADIp6Aayy4CxMs3lDaZAK4I1coWInQACizjA4ANwgB5JEgByWrgCMIAJ3wBVZB4AqEAgqAIyaAMyaAKyaAOyaAJzCQA)\n\nUnions provide a way to handle different types too. For example, you may have a function that takes an `array` or a `string`:\n\nts\n\n`   function getLength(obj: string | string[]) {    return obj.length;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQDKrMqALACjgCMArALkQGcoAnGHRAH2roeQG0BdASkQG8AUIkS10IWkhKkAdABtsuPAG5BAXyA)\n\nTo learn the type of a variable, use `typeof`:\n\n| Type | Predicate |\n| --- | --- |\n| string | `typeof s === \"string\"` |\n| number | `typeof n === \"number\"` |\n| boolean | `typeof b === \"boolean\"` |\n| undefined | `typeof undefined === \"undefined\"` |\n| function | `typeof f === \"function\"` |\n| array | `Array.isArray(a)` |\n\nFor example, you can make a function return different values depending on whether it is passed a string or an array:\n\nts\n\n`   function wrapInArray(obj: string | string[]) {    if (typeof obj === \"string\") {      return [obj];                (parameter) obj: string    }    return obj;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwE4EMAOBJMBBVDATwAo4AjAKwC5EBnKVGMAc0QB97HmWBtAXQCUiAN4AoRIhjBEJKEUwBTODIqVEAXi2IARAyasdw8ZMmpFUEKiS81-ANxiA9E9NvTAPQD8ExAF9fc0trRDVHPyA)\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#generics)\nGenerics\n\nGenerics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.\n\nts\n\n`   type StringArray = Array<string>;  type NumberArray = Array<number>;  type ObjectWithNameArray = Array<{ name: string }>;   `\n\nYou can declare your own types that use generics:\n\nts\n\n``  interface Backpack<Type> {    add: (obj: Type) => void;    get: () => Type;  }  // This line is a shortcut to tell TypeScript there is a  // constant called `backpack`, and to not worry about where it came from.  declare const backpack: Backpack<string>;  // object is a string, because we declared it above as the variable part of Backpack.  const object = backpack.get();  // Since the backpack variable is a string, you can't pass a number to the add function.  backpack.add(23);  Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAEI0DWADswDwAqAni5AHygA3nlChKAEwmoAFHABGAK1Q8+ASlABeQQDc4BCQG5RoAOaQSsjdtCrIxgL548IWwAsCiUABtidT+KgiG4IJNQAriSgJHDRkN7etryQAMrU0AQsUSRuMP5elC5g1HBEiCSUpKDUlAmQEqAABvLMbNRMjQA04kQNMaBEcFEA7gjQ3OLycJGgw7nQ-lE1ALZ05PDLAHR4EpDU3pQL1aXloC3tbUyojBcc5RlEpvzGRaAKintRAZRBJA+m3Xke0o4UQdGGdF2+0O9VABCilCmOjolC8OToOkOBER3jobGgUTg5AYrWY2xKZUJSk+WjOpPam3MJBkaherhSxFo0VydNu7VAmIyOPygXuxABoG402qlQA5FE2IgCgNwssgdBorF0eIpKByOEiNQSARSttzqwyZIJDJMKygA)\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#structural-type-system)\nStructural Type System\n---------------------------------------------------------------------------------------------------------------------------\n\nOne of TypeScript’s core principles is that type checking focuses on the _shape_ that values have. This is sometimes called “duck typing” or “structural typing”.\n\nIn a structural type system, if two objects have the same shape, they are considered to be of the same type.\n\nts\n\n``   interface Point {    x: number;    y: number;  }  function logPoint(p: Point) {    console.log(`${p.x}, ${p.y}`);  }  // logs \"12, 26\"  const point = { x: 12, y: 26 };  logPoint(point);   ``[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwFDLIAeAXMiAK4C2ARtANwHICeZltDeAvnnjBSARhg6EMgA26AOYYsACgAOZWeACUuJglEBndOIgA6SVLkADACQ4FBolwA0yS9eZdTqxjzwB6LxOnbkACIARgAmB1CANkC8LRBtbAVMcGQAXlxiMjCHVmQo5C5GYxUwRWSwdyA)\n\nThe `point` variable is never declared to be a `Point` type. However, TypeScript compares the shape of `point` to the shape of `Point` in the type-check. They have the same shape, so the code passes.\n\nThe shape-matching only requires a subset of the object’s fields to match.\n\nts\n\n`  const point3 = { x: 12, y: 26, z: 89 };  logPoint(point3); // logs \"12, 26\"  const rect = { x: 33, y: 3, width: 30, height: 80 };  logPoint(rect); // logs \"33, 3\"  const color = { hex: \"#187ABF\" };  logPoint(color);  Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.   Type '{ hex: string; }' is missing the following properties from type 'Point': x, y2345Argument of type '{ hex: string; }' is not assignable to parameter of type 'Point'.   Type '{ hex: string; }' is missing the following properties from type 'Point': x, y`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAApzEmgDeeooAHqkQK4BbAEYwA3B1ABPXoJHRxAXzx5yfItRIE4RUABs4Ac0bMAFAAdUx0gEo2E6tsRxdkAHT6DJgAYASVmdcuBQAaUD8AyQUva0U8EFAAWiTqPhIkhLwHIkQWMyZSDFAAXjZuVABGNFDpdAA2UIAvVAAOAE5QBXEPKxJzfJIMGNB4j0RQACJK0LRa8eUsnNBoSA1i0p5QDAxq1G3QAHcCABMSAAtdgAZQ08gCA1OSFouOrsMek2WNIZHDMfGt0IYOaZRwsBz6aBrVigG4bcYAYnKzQA7ABBABCADFxi88N1+iZwQgYkA)\n\nThere is no difference between how classes and objects conform to shapes:\n\nts\n\n`   class VirtualPoint {    x: number;    y: number;    constructor(x: number, y: number) {      this.x = x;      this.y = y;    }  }  const newVPoint = new VirtualPoint(13, 56);  logPoint(newVPoint); // logs \"13, 56\"   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAApzEmgDeeooAHqkQK4BbAEYwA3B1ABPXoJHRxAXzx5yfItRIE4RUABs4Ac0bMAFAAdUx0gEo2E6tsRxdkAHT6DJgAYASVmdcuBQAaUD8AyQUva0U8EFAAWiTqPhIkhLxqXUpERFAANQJoEj5KXSsWdk4eUH5hMQlpWtkG+0cSaD4NBBMaurlQpv6YWyrOUBIACwJEQNAAXm5xcYnp2ckFqWXQJSVM9trIAHd8is2iY4KikrKKkwBGDFCcADYYvA87i5OKmNB4jx5ABEj2eLyBQA)\n\nIf the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#next-steps)\nNext Steps\n---------------------------------------------------------------------------------------------------\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n\n*   Read the full Handbook [from start to finish](https://www.typescriptlang.org/docs/handbook/intro.html)\n    \n*   Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/get-started/TS%20for%20JS%20Programmers.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (24)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nJB![Jonathan Berger  (1)](https://gravatar.com/avatar/3e13b0deabdbc1f1ec9ce15a1b98bbdf252e8e964ed8273cab7c98d46347087a?s=32&&d=blank)\n\nDS![Dustin Stender  (1)](https://gravatar.com/avatar/1eafab582a6fc4e59d86a901673be6c257f34b18d7d1cb91545cd27abb217d83?s=32&&d=blank)\n\nMK![Matt Kantor  (1)](https://gravatar.com/avatar/cd99d5732d2c37b59e6e5d4d57f9a4628fb4d36da885219f2173f18ec697c446?s=32&&d=blank)\n\nJCR![Juan Carlos Ruiz  (1)](https://gravatar.com/avatar/2bf72a3b3c99cdaffb37f05f9384d25c973ea7e920ee98593cab1a2b779f88c7?s=32&&d=blank)\n\n19+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:title":"Documentation - TypeScript for JavaScript Programmers","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogTitle":"Documentation - TypeScript for JavaScript Programmers","theme-color":"#3178C6","twitter:site":"typescriptlang","title":"TypeScript: Documentation - TypeScript for JavaScript Programmers","description":"Learn how TypeScript extends JavaScript","language":"en","ogDescription":"Learn how TypeScript extends JavaScript","og:description":"Learn how TypeScript extends JavaScript","scrapeId":"067e1c8c-8c6d-4312-a2a2-7ec1405df4f4","sourceURL":"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html","url":"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript for Functional Programmers\n=====================================\n\nTypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.\n\nThis introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell’s type system. It also describes unique features of TypeScript’s type system that arise from its modelling of JavaScript code.\n\nThis introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#prerequisites)\nPrerequisites\n--------------------------------------------------------------------------------------------------------------\n\nIn this introduction, I assume you know the following:\n\n*   How to program in JavaScript, the good parts.\n*   Type syntax of a C-descended language.\n\nIf you need to learn the good parts of JavaScript, read [JavaScript: The Good Parts](https://shop.oreilly.com/product/9780596517748.do)\n. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. [R4RS Scheme](https://people.csail.mit.edu/jaffer/r4rs.pdf)\n is a good example.\n\n[The C++ Programming Language](http://www.stroustrup.com/4th.html)\n is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: `x: string` instead of `string x`.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#concepts-not-in-haskell)\nConcepts not in Haskell\n----------------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#built-in-types)\nBuilt-in types\n\nJavaScript defines 8 built-in types:\n\n| Type | Explanation |\n| --- | --- |\n| `Number` | a double-precision IEEE 754 floating point. |\n| `String` | an immutable UTF-16 string. |\n| `BigInt` | integers in the arbitrary precision format. |\n| `Boolean` | `true` and `false`. |\n| `Symbol` | a unique value usually used as a key. |\n| `Null` | equivalent to the unit type. |\n| `Undefined` | also equivalent to the unit type. |\n| `Object` | similar to records. |\n\n[See the MDN page for more detail](https://developer.mozilla.org/docs/Web/JavaScript/Data_structures)\n.\n\nTypeScript has corresponding primitive types for the built-in types:\n\n*   `number`\n*   `string`\n*   `bigint`\n*   `boolean`\n*   `symbol`\n*   `null`\n*   `undefined`\n*   `object`\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#other-important-typescript-types)\nOther important TypeScript types\n\n| Type | Explanation |\n| --- | --- |\n| `unknown` | the top type. |\n| `never` | the bottom type. |\n| object literal | e.g. `{ property: Type }` |\n| `void` | for functions with no documented return value |\n| `T[]` | mutable arrays, also written `Array<T>` |\n| `[T, T]` | tuples, which are fixed-length but mutable |\n| `(t: T) => U` | functions |\n\nNotes:\n\n1.  Function syntax includes parameter names. This is pretty hard to get used to!\n    \n    ts\n    \n    `   let fst: (a: any, b: any) => any = (a, b) => a;  // or more precisely:  let fst: <T, U>(a: T, b: U) => T = (a, b) => a;   `\n    \n2.  Object literal type syntax closely mirrors object literal value syntax:\n    \n    ts\n    \n    `   let o: { n: number; xs: object[] } = { n: 1, xs: [] };   `\n    \n3.  `[T, T]` is a subtype of `T[]`. This is different than Haskell, where tuples are not related to lists.\n    \n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#boxed-types)\nBoxed types\n\nJavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type `number` and the boxed type `Number`. The boxed types are rarely needed, since their methods return primitives.\n\nts\n\n`   (1).toExponential();  // equivalent to  Number.prototype.toExponential.call(1);   `\n\nNote that calling a method on a numeric literal requires it to be in parentheses to aid the parser.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#gradual-typing)\nGradual typing\n\nTypeScript uses the type `any` whenever it can’t tell what the type of an expression should be. Compared to `Dynamic`, calling `any` a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an `any[]` without marking the value in any way:\n\nts\n\n`   // with \"noImplicitAny\": false in tsconfig.json, anys: any[]  const anys = [];  anys.push(1);  anys.push(\"oh no\");  anys.push({ anything: \"goes\" });   `[Try](https://www.typescriptlang.org/play/#code/PTAEHcEsBcAtQEQDsD2BJAtgBwDaQMYwCCSAnggFygBmAhjgM4CmokSo0D+KS1kA5gDoAVgx4AaULTIMq00gG0AugChuSBtCkzQAXlDKA3CvkNBWAK4NYACgCMASmOnzV2whTxUCJyZmvrGwBvbVI4Nn4qBH4UJgYEUABfJyA)\n\nAnd you can use an expression of type `any` anywhere:\n\nts\n\n`   anys.map(anys[1]); // oh no, \"oh no\" is not a function   `\n\n`any` is contagious, too — if you initialize a variable with an expression of type `any`, the variable has type `any` too.\n\nts\n\n`   let sepsis = anys[0] + anys[1]; // this could mean anything   `\n\nTo get an error when TypeScript produces an `any`, use `\"noImplicitAny\": true`, or `\"strict\": true` in `tsconfig.json`.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#structural-typing)\nStructural typing\n\nStructural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:\n\nts\n\n`   // @strict: false  let o = { x: \"hi\", extra: 1 }; // ok  let o2: { x: string } = o; // ok   `\n\nHere, the object literal `{ x: \"hi\", extra: 1 }` has a matching literal type `{ x: string, extra: number }`. That type is assignable to `{ x: string }` since it has all the required properties and those properties have assignable types. The extra property doesn’t prevent assignment, it just makes it a subtype of `{ x: string }`.\n\nNamed types just give a name to a type; for assignability purposes there’s no difference between the type alias `One` and the interface type `Two` below. They both have a property `p: string`. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)\n\nts\n\n`   type One = { p: string };  interface Two {    p: string;  }  class Three {    p = \"Hello\";  }  let x: One = { p: \"hi\" };  let two: Two = x;  two = new Three();   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lAHkA7UgXlAG9QjVE9oBLCgc1AF8BuHBzwwAZgEMAxqQAqAdzj0coRs1YdOAnjgkAbMYkShpAC2iRSdJY1C0ARAAlIOnXFuacOHZDygAHqkoaehVQW2M2W14BLx88eVQ5BVpfATik0CpZI1NzAAoASj4gA)\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#unions)\nUnions\n\nIn TypeScript, union types are untagged. In other words, they are not discriminated unions like `data` in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.\n\nts\n\n`   function start(    arg: string | string[] | (() => string) | { s: string }  ): string {    // this is super common in JavaScript    if (typeof arg === \"string\") {      return commonCase(arg);    } else if (Array.isArray(arg)) {      return arg.map(commonCase).join(\",\");    } else if (typeof arg === \"function\") {      return commonCase(arg());    } else {      return commonCase(arg.s);    }    function commonCase(s: string): string {      // finally, just convert a string to another string      return s;    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZygQwE5QBQChGKYDmAXClBjGEYgD7mXUDaAunYttgJSIC8AfAypEe9AN4oyqRjQC+uLlIrDEY-IgD0GxFAAWMZIgMoQABwCmGRBDgBbWwiNIAUmgBuaAMoRKpqOphgDigATws4IOI+Xl5EACJpYTieNQICDHMoEAwkG3sEAGE0ZHNsYi4AbnVZRHMAGxKjIOwAQQwMNBCAOgM2jpCyjBEU9XTM7KRiLts0U2w8hzAikq4ugCs4Kmw4gBpkqoIa+sbA4LDzCMIh6Ni40EhYBGTVUcQMrJzrO0Xl0uJuSrVWoNcwvNJvcafBaFYp-IZdZCAw64dT3aDwXLfGElbDIJQyRRCahgtJaRDAKhoOp1EI7RBrECoL5gNyWKCEIk0KBwQhgOB6Syc17vCYoA6IeSyIA)\n\n`string`, `Array` and `Function` have built-in type predicates, conveniently leaving the object type for the `else` branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it’s best to build only discriminated unions.\n\nThe following types have built-in predicates:\n\n| Type | Predicate |\n| --- | --- |\n| string | `typeof s === \"string\"` |\n| number | `typeof n === \"number\"` |\n| bigint | `typeof m === \"bigint\"` |\n| boolean | `typeof b === \"boolean\"` |\n| symbol | `typeof g === \"symbol\"` |\n| undefined | `typeof undefined === \"undefined\"` |\n| function | `typeof f === \"function\"` |\n| array | `Array.isArray(a)` |\n| object | `typeof o === \"object\"` |\n\nNote that functions and arrays are objects at runtime, but have their own predicates.\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#intersections)\nIntersections\n\nIn addition to unions, TypeScript also has intersections:\n\nts\n\n`   type Combined = { a: number } & { b: string };  type Conflicting = { a: number } & { a: string };   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gWwEYEsB2EAmUC8UDeUAhgFxRoCuyEATlAL5QBkBUSZAzsDegOYMBuAFChIsOGgBmAGxQBjYH1ytS5KkloNmKztyX0BQA)\n\n`Combined` has two properties, `a` and `b`, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so `Conflicting.a: number & string`.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#unit-types)\nUnit types\n\nUnit types are subtypes of primitive types that contain exactly one primitive value. For example, the string `\"foo\"` has the type `\"foo\"`. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:\n\nts\n\n`   declare function pad(s: string, n: number, direction: \"left\" | \"right\"): string;  pad(\"hi\", 10, \"left\");   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFBFS4lVnEsAjAAYWk6Rt1A)\n\nWhen needed, the compiler _widens_ — converts to a supertype — the unit type to the primitive type, such as `\"foo\"` to `string`. This happens when using mutability, which can hamper some uses of mutable variables:\n\nts\n\n`  let s = \"right\";  pad(\"hi\", 10, s); // error: 'string' is not assignable to '\"left\" | \"right\"'  Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.2345Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUACaQDGANgIbSSgBmArgHbEAuAlnA6AA7kEAUKUImbRWDAOYAaUA1QM6AWwBGMaQVZUW7WaABEpSDWa7QAHz2jxAC2MBKVMNESA3HhCgAtF+J1mXj3gGzEKgALwWrNbGrjz8ulasutIAjAAM0oi2zqDuMPDQqADkjmLihaCsiDJwweSIiJEM5EoGoMxwoIX6hsZmEVG6hUA)\n\nHere’s how the error happens:\n\n*   `\"right\": \"right\"`\n*   `s: string` because `\"right\"` widens to `string` on assignment to a mutable variable.\n*   `string` is not assignable to `\"left\" | \"right\"`\n\nYou can work around this with a type annotation for `s`, but that in turn prevents assignments to `s` of variables that are not of type `\"left\" | \"right\"`.\n\nts\n\n`   let s: \"left\" | \"right\" = \"right\";  pad(\"hi\", 10, s);   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFAB6Q-AC05sMgznT+qRmpVJ02QqVZVrgLzvP4g0Sk4ipY4iwAjAAMLGTqukA)\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#concepts-similar-to-haskell)\nConcepts similar to Haskell\n------------------------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#contextual-typing)\nContextual typing\n\nTypeScript has some obvious places where it can infer types, like variable declarations:\n\nts\n\n`   let s = \"I'm a string!\";   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzhC8ECICSByAthAhtMAnAlgHYDmAhAgNxA)\n\nBut it also infers types in a few other places that you may not expect if you’ve worked with other C-syntax languages:\n\nts\n\n`   declare function map<T, U>(f: (t: T) => U, ts: T[]): U[];  let sns = map((n) => n.toString(), [1, 2, 3]);   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKRALngY1fIEp4BeO2tQwBnTgG0Aul1Y1JAbgBQEEBnjDUwvoRIMGqHv3ioAdBhwBlDDCyoA5gy7UxARmoAmagGYpcoA)\n\nHere, `n: number` in this example also, despite the fact that `T` and `U` have not been inferred before the call. In fact, after `[1,2,3]` has been used to infer `T=number`, the return type of `n => n.toString()` is used to infer `U=string`, causing `sns` to have the type `string[]`.\n\nNote that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare `map` with the array first:\n\nts\n\n`   declare function map<T, U>(ts: T[], f: (t: T) => U): U[];   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKDAZwC55yBtAXWsXabtyASngBeOrWHsaPANxA)\n\nContextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as `string` or `number`. And it can infer return types from context:\n\nts\n\n`   declare function run<T>(thunk: (t: T) => void): T;  let i: { inference: string } = run((o) => {    o.inference = \"INSERT STATE HERE\";  });   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXxjQB4AVAPgAoMALNAawC54qmSBKeAXjPgDccswNqwDcAKAggM8LEwDeM1IhBx0IJgGcMMLKgDm8AL5cCaChRwdu8OWPjwcAOl3LVYBJ3gAiAJIA5AGUAUQAlEngAkgBBEiD4AAlQoK9xQzYRIA)\n\nThe type of `o` is determined to be `{ inference: string }` because\n\n1.  Declaration initializers are contextually typed by the declaration’s type: `{ inference: string }`.\n2.  The return type of a call uses the contextual type for inferences, so the compiler infers that `T={ inference: string }`.\n3.  Arrow functions use the contextual type to type their parameters, so the compiler gives `o: { inference: string }`.\n\nAnd it does so while you are typing, so that after typing `o.`, you get completions for the property `inference`, along with any other properties you’d have in a real program. Altogether, this feature can make TypeScript’s inference look a bit like a unifying type inference engine, but it is not.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#type-aliases)\nType aliases\n\nType aliases are mere aliases, just like `type` in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.\n\nts\n\n`   type Size = [number, number];  let x: Size = [101.1, 999.9];   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyglgL2gXigbQHYFcC2AjCAJwBopt8iBdAbgCgAbCYKADwC5ZEV0BGABh4A6HqQCc4waJpA)\n\nThe closest equivalent to `newtype` is a _tagged intersection_:\n\nts\n\n`   type FString = string & { __compileTimeOnly: any };   `\n\nAn `FString` is just like a normal string, except that the compiler thinks it has a property named `__compileTimeOnly` that doesn’t actually exist. This means that `FString` can still be assigned to `string`, but not the other way round.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions)\nDiscriminated Unions\n\nThe closest equivalent to `data` is a union of types with discriminant properties, normally called discriminated unions in TypeScript:\n\nts\n\n`   type Shape =    | { kind: \"circle\"; radius: number }    | { kind: \"square\"; x: number }    | { kind: \"triangle\"; x: number; y: number };   `\n\nUnlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading `|` is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:\n\nts\n\n`   type Shape =    | { kind: \"circle\"; radius: number }    | { kind: \"square\"; x: number }    | { kind: \"triangle\"; x: number; y: number };  function area(s: Shape) {    if (s.kind === \"circle\") {      return Math.PI * s.radius * s.radius;    } else if (s.kind === \"square\") {      return s.x * s.x;    } else {      return (s.x * s.y) / 2;    }  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoaABmfCS0wEQA9iRQWhAIABRCsIiQAJR48kRBUEkAdBZkqCgoNPRMzhm48pjawHwMMQCyCMBweQAKAJJQAFRQAnncvIJ9A0M8-AIBmDJQEMwC0Nm5g4XFpdTqmtrUVTVcEPWN47pjg7ozsvOL0NWYtUcNMfln-YMgGQD0UABMV3IZEA)\n\nNote that the return type of `area` is inferred to be `number` because TypeScript knows the function is total. If some variant is not covered, the return type of `area` will be `number | undefined` instead.\n\nAlso, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:\n\nts\n\n`   function height(s: Shape) {    if (s.kind === \"circle\") {      return 2 * s.radius;    } else {      // s.kind: \"square\" | \"triangle\"      return s.x;    }  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoAPSBUAC04bR8wOGhaABmfCS0wEQA9iRQcBBEDnDAABRCsIiQAJR48kRxUIUAdBZkqCgoNPRMzuW48pjawHwMGQBMUABUUAK13LyCAZgyUBDMAtBdmJjB4-XKVuqa2tQK1rb2TmzdXBB9A5u6s7JoMkA)\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#type-parameters)\nType Parameters\n\nLike most C-descended languages, TypeScript requires declaration of type parameters:\n\nts\n\n`   function liftArray<T>(t: T): Array<T> {    return [t];  }   `\n\nThere is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:\n\nts\n\n`   function firstish<T extends { length: number }>(t1: T, t2: T): T {    return t1.length > t2.length ? t1 : t2;  }   `\n\nTypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.\n\nBecause TypeScript is structural, it doesn’t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to _propagate_ type information, such as constraining parameters to be the same type:\n\nts\n\n`   function length<T extends ArrayLike<unknown>>(t: T): number {}  function length(t: ArrayLike<unknown>): number {}   `\n\nIn the first `length`, T is not necessary; notice that it’s only referenced once, so it’s not being used to constrain the type of the return value or other parameters.\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#higher-kinded-types)\nHigher-kinded types\n\nTypeScript does not have higher kinded types, so the following is not legal:\n\nts\n\n`   function length<T extends ArrayLike<unknown>, U>(m: T<U>) {}   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#point-free-programming)\nPoint-free programming\n\nPoint-free programming — heavy use of currying and function composition — is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you’ll end up specifying type parameters instead of value parameters. The result is so verbose that it’s usually better to avoid point-free programming.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#module-system)\nModule system\n\nJavaScript’s modern module syntax is a bit like Haskell’s, except that any file with `import` or `export` is implicitly a module:\n\nts\n\n`   import { value, Type } from \"npm-package\";  import { other, Types } from \"./local-package\";  import * as prefix from \"../lib/third-package\";   `\n\nYou can also import commonjs modules — modules written using node.js’ module system:\n\nts\n\n`   import f = require(\"single-function-package\");   `\n\nYou can export with an export list:\n\nts\n\n`   export { f };  function f() {    return g();  }  function g() {} // g is not exported   `\n\nOr by marking each export individually:\n\nts\n\n`   export function f() { return g() }  function g() { }   `\n\nThe latter style is more common but both are allowed, even in the same file.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#readonly-and-const)\n`readonly` and `const`\n\nIn JavaScript, mutability is the default, although it allows variable declarations with `const` to declare that the _reference_ is immutable. The referent is still mutable:\n\njs\n\n`   const a = [1, 2, 3];  a.push(102); // ):  a[0] = 101; // D:   `\n\nTypeScript additionally has a `readonly` modifier for properties.\n\nts\n\n`   interface Rx {    readonly x: number;  }  let rx: Rx = { x: 1 };  rx.x = 12; // error   `\n\nIt also ships with a mapped type `Readonly<T>` that makes all properties `readonly`:\n\nts\n\n`   interface X {    x: number;  }  let rx: Readonly<X> = { x: 1 };  rx.x = 12; // error   `\n\nAnd it has a specific `ReadonlyArray<T>` type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:\n\nts\n\n`   let a: ReadonlyArray<number> = [1, 2, 3];  let b: readonly number[] = [1, 2, 3];  a.push(102); // error  b[0] = 101; // error   `\n\nYou can also use a const-assertion, which operates on arrays and object literals:\n\nts\n\n`   let a = [1, 2, 3] as const;  a.push(102); // error  a[0] = 101; // error   `\n\nHowever, none of these options are the default, so they are not consistently used in TypeScript code.\n\n### [](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#next-steps)\nNext Steps\n\nThis doc is a high level overview of the syntax and types you would use in everyday code. From here you should:\n\n*   Read the full Handbook [from start to finish](https://www.typescriptlang.org/docs/handbook/intro.html)\n    \n*   Explore the [Playground examples](https://www.typescriptlang.org/play#show-examples)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/get-started/TS%20for%20Functional%20Programmers.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nUJ![Udoh Jeremiah  (1)](https://gravatar.com/avatar/0880cb582158d9b9e48ba161403af6f6f5ede3b87dfc17b1bb9980400ddcf3f4?s=32&&d=blank)\n\nMF![Martin Fischer  (1)](https://gravatar.com/avatar/dc885100e48a5949f1a44bcd6fce398735ff3294f20607ddee8bb45acb29601a?s=32&&d=blank)\n\nJRSDS![Jonas Raoni Soares da Silva  (1)](https://gravatar.com/avatar/4fb24f001151259b6d527f44766dbc5d504092289d74f0da8f0a79c5325b3cf3?s=32&&d=blank)\n\nRC![Ryan Cavanaugh  (1)](https://gravatar.com/avatar/b58b1520745cd2abf1e669bb63537180cabe29a17be2773ca10160d7970a6a5d?s=32&&d=blank)\n\n11+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","title":"TypeScript: Documentation - TypeScript for Functional Programmers","ogTitle":"Documentation - TypeScript for Functional Programmers","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","description":"Learn TypeScript if you have a background in functional programming","ogDescription":"Learn TypeScript if you have a background in functional programming","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","twitter:site":"typescriptlang","theme-color":"#3178C6","og:title":"Documentation - TypeScript for Functional Programmers","og:description":"Learn TypeScript if you have a background in functional programming","scrapeId":"8928c744-3b15-4cce-a234-cc2969047aa3","sourceURL":"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html","url":"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript Tooling in 5 minutes\n===============================\n\nLet’s get started by building a simple web application with TypeScript.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#installing-typescript)\nInstalling TypeScript\n---------------------------------------------------------------------------------------------------------------------------------\n\nThere are two main ways to add TypeScript to your project:\n\n*   Via npm (the Node.js package manager)\n*   By installing TypeScript’s Visual Studio plugins\n\nVisual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript language support by default but does not include the TypeScript compiler, `tsc`. If you didn’t install TypeScript with Visual Studio, you can still [download it](https://www.typescriptlang.org/download)\n.\n\nFor npm users:\n\nshell\n\n`   > npm install -g typescript   `\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#building-your-first-typescript-file)\nBuilding your first TypeScript file\n-------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn your editor, type the following JavaScript code in `greeter.ts`:\n\nts\n\n`   function greeter(person) {    return \"Hello, \" + person;  }  let user = \"Jane User\";  document.body.textContent = greeter(user);   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAkCuk6Wq0koA5gE7XVbVuACkSDK7AJSgA3rVCheWBtw4AiABLVkyaABpQq0AGpQo7uMgBuWgF9atZP1AMa3UAF4DAKTKRqoAFVXVWtaABNodAZ4akgsADoAI2gw-HiBAA8sAGF2ATiPLl5+QSEXQQlLIA)\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#compiling-your-code)\nCompiling your code\n-----------------------------------------------------------------------------------------------------------------------------\n\nWe used a `.ts` extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.\n\nAt the command line, run the TypeScript compiler:\n\nshell\n\n`   tsc greeter.ts   `\n\nThe result will be a file `greeter.js` which contains the same JavaScript that you fed in. We’re up and running using TypeScript in our JavaScript app!\n\nNow we can start taking advantage of some of the new tools TypeScript offers. Add a `: string` type annotation to the ‘person’ function parameter as shown here:\n\nts\n\n`   function greeter(person: string) {    return \"Hello, \" + person;  }  let user = \"Jane User\";  document.body.textContent = greeter(user);   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFABxwGcEAuRIqVGMZASkQG8AoRRDKEVJAIgAl0AG0FwANIh6IA1IkKoSYANzMAvs2aCsiEERyIAvBIBSAQzDpEAVV2oey5gBM4EEAFt0YKADoARnAcAnl7YAB5QAMII2J4GKBhYOLg6OHSKQA)\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#type-annotations)\nType annotations\n-----------------------------------------------------------------------------------------------------------------------\n\nType annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:\n\nts\n\n`  function greeter(person: string) {    return \"Hello, \" + person;  }  let user = [0, 1, 2];  document.body.textContent = greeter(user);  Argument of type 'number[]' is not assignable to parameter of type 'string'.2345Argument of type 'number[]' is not assignable to parameter of type 'string'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUwAUADjIraohdCol6ASlABvPKFBMKRaHQBEACUgAbNXAA0oRaADUoLkloBuPAF88eNS1BFEMUAF5QAbQAMOgIw60AXXM8ABM4MiIAW0gSCgA6ACM4YIBPWNYADwoAYVpWGJcGJhZ2BxgRUyA)\n\nRe-compiling, you’ll now see an error:\n\nshell\n\n`   error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.   `\n\nSimilarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of arguments. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.\n\nNotice that although there were errors, the `greeter.js` file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#interfaces)\nInterfaces\n-----------------------------------------------------------------------------------------------------------\n\nLet’s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit `implements` clause.\n\nts\n\n`   interface Person {    firstName: string;    lastName: string;  }  function greeter(person: Person) {    return \"Hello, \" + person.firstName + \" \" + person.lastName;  }  let user = { firstName: \"Jane\", lastName: \"User\" };  document.body.textContent = greeter(user);   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyMwUGYAcnALYQBcyFUoA5gNxHIA2cF1dRszacAvgQIwAriARhgOZKygQIkKAAoADphyN05HAEp8XFWClRcAIgASEbtywAaZNeQBqZDsMgAdKTkVLQoXu7uXj7Y-rz8IWIS3GrIUhjQyAC8+CRkcYJuAFJwIBDWrrHB+dYAqmlQ7qKcBAAmWAhSdOB+AEZYzQCefpAAHmAAwjiQ4JlKKmrQGqnQRuxAA)\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#classes)\nClasses\n-----------------------------------------------------------------------------------------------------\n\nFinally, let’s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.\n\nHere we’re going to create a `Student` class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.\n\nAlso of note, the use of `public` on parameters to the constructor is a shorthand that allows us to automatically create properties with that name.\n\nts\n\n`   class Student {    fullName: string;    constructor(      public firstName: string,      public middleInitial: string,      public lastName: string    ) {      this.fullName = firstName + \" \" + middleInitial + \" \" + lastName;    }  }  interface Person {    firstName: string;    lastName: string;  }  function greeter(person: Person) {    return \"Hello, \" + person.firstName + \" \" + person.lastName;  }  let user = new Student(\"Jane\", \"M.\", \"User\");  document.body.textContent = greeter(user);   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAuBXAJgUwHb2gbwFDWgDNEQQA5MAW1QC5oJ4AnAS3QHMBufaYAe3QaNEweL0YAKbgQAOiAEYhmwIs0YMK1OoNZsANFOiyFS6JWbJkIVAEl0zeMzAgtTHfoIz5i5eHVVa9K7s3ACUOAbwABbMEAB0xKQaqNAAvCpq8EnQANTQAET5OabmljZ2Dk5FBQW5vpn+XAQAvrgtuKzwqIyEYMDJAApdEPzhBISqfpqBLOyN0HVJLjOcrbi4xOgizCNsjKionRLSQ-x0g2r8YXgEe0iM6PkAEqikvLqFuccX6PET9dRVD6GE4-BYNVa4KxYRAQLqpaDoVAAdzgSDQmHEeQAUmBEXl3nkALKxfH5ACqsMYeRCXFwyF4wEQ1EwsTkvGQAE9Yp0AB7wADC-E6mHhu32h3EMK6NKAA)\n\nRe-run `tsc greeter.ts` and you’ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.\n\n[](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#running-your-typescript-web-app)\nRunning your TypeScript web app\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\nNow type the following in `greeter.html`:\n\nhtml\n\n`   <!DOCTYPE html>  <html>    <head>      <title>TypeScript Greeter</title>    </head>    <body>      <script src=\"greeter.js\"></script>    </body>  </html>   `\n\nOpen `greeter.html` in the browser to run your first simple TypeScript web application!\n\nOptional: Open `greeter.ts` in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.\n\nThe type information provided works together with the tools to work with JavaScript at application scale. For more examples of what’s possible in TypeScript, see the Samples section of the website.\n\n![Visual Studio picture](https://www.typescriptlang.org/images/docs/greet_person.png)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/tutorials/TypeScript%20Tooling%20in%205%20minutes.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (14)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nH![hanyujie2002  (1)](https://gravatar.com/avatar/fc66f7c17396f1b321ca3ea775726d166dbc375d8e3e8e5693182420417dc519?s=32&&d=blank)\n\nDS![Daniel Schroeder  (1)](https://gravatar.com/avatar/4e7f0cf35b6537f8b8ff4b5b2d35aaf135a5520db46929ca4cdc8ac55bd88098?s=32&&d=blank)\n\nM![mahadyC  (1)](https://gravatar.com/avatar/904937ffe0a3a8015b632ab2fc70848e109f8a338e7c474d825622eaffa58580?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"generator":"Gatsby 5.13.5","ogTitle":"Documentation - TypeScript Tooling in 5 minutes","theme-color":"#3178C6","language":"en","description":"A tutorial to understand how to create a small website with TypeScript","og:title":"Documentation - TypeScript Tooling in 5 minutes","twitter:site":"typescriptlang","ogDescription":"A tutorial to understand how to create a small website with TypeScript","og:description":"A tutorial to understand how to create a small website with TypeScript","title":"TypeScript: Documentation - TypeScript Tooling in 5 minutes","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","scrapeId":"096e2b02-4fc2-4472-9ec2-602174338fc5","sourceURL":"https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html","url":"https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nThe Basics\n==========\n\nWelcome to the first page of the handbook. If this is your first experience with TypeScript - you may want to start at one of the '[Getting Started](https://www.typescriptlang.org/docs/handbook/intro.html#get-started)\n' guides\n\nEach and every value in JavaScript has a set of behaviors you can observe from running different operations. That sounds abstract, but as a quick example, consider some operations we might run on a variable named `message`.\n\njs\n\n`   // Accessing the property 'toLowerCase'  // on 'message' and then calling it  message.toLowerCase();  // Calling 'message'  message();   `\n\nIf we break this down, the first runnable line of code accesses a property called `toLowerCase` and then calls it. The second one tries to call `message` directly.\n\nBut assuming we don’t know the value of `message` - and that’s pretty common - we can’t reliably say what results we’ll get from trying to run any of this code. The behavior of each operation depends entirely on what value we had in the first place.\n\n*   Is `message` callable?\n*   Does it have a property called `toLowerCase` on it?\n*   If it does, is `toLowerCase` even callable?\n*   If both of these values are callable, what do they return?\n\nThe answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right.\n\nLet’s say `message` was defined in the following way.\n\njs\n\n`   const message = \"Hello World!\";   `\n\nAs you can probably guess, if we try to run `message.toLowerCase()`, we’ll get the same string only in lower-case.\n\nWhat about that second line of code? If you’re familiar with JavaScript, you’ll know this fails with an exception:\n\ntxt\n\n`   TypeError: message is not a function   `\n\nIt’d be great if we could avoid mistakes like this.\n\nWhen we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the _type_ of the value - what sorts of behaviors and capabilities it has. That’s part of what that `TypeError` is alluding to - it’s saying that the string `\"Hello World!\"` cannot be called as a function.\n\nFor some values, such as the primitives `string` and `number`, we can identify their type at runtime using the `typeof` operator. But for other things like functions, there’s no corresponding runtime mechanism to identify their types. For example, consider this function:\n\njs\n\n`   function fn(x) {    return x.flip();  }   `\n\nWe can _observe_ by reading the code that this function will only work if given an object with a callable `flip` property, but JavaScript doesn’t surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what `fn` does with a particular value is to call it and see what happens. This kind of behavior makes it hard to predict what the code will do before it runs, which means it’s harder to know what your code is going to do while you’re writing it.\n\nSeen in this way, a _type_ is the concept of describing which values can be passed to `fn` and which will crash. JavaScript only truly provides _dynamic_ typing - running the code to see what happens.\n\nThe alternative is to use a _static_ type system to make predictions about what the code is expected to do _before_ it runs.\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#static-type-checking)\nStatic type-checking\n-------------------------------------------------------------------------------------------------------------\n\nThink back to that `TypeError` we got earlier from trying to call a `string` as a function. _Most people_ don’t like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.\n\nIf we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through.\n\nIdeally, we could have a tool that helps us find these bugs _before_ our code runs. That’s what a static type-checker like TypeScript does. _Static types systems_ describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.\n\nts\n\n`  const message = \"hello!\";  message();  This expression is not callable.   Type 'String' has no call signatures.2349This expression is not callable.   Type 'String' has no call signatures.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBOAUAMZwB2iALqALaSKICGA5pKALygBEAFpADY9wBCdgG48earUaQAFAEphQA)\n\nRunning that last sample with TypeScript will give us an error message before we run the code in the first place.\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#non-exception-failures)\nNon-exception Failures\n-----------------------------------------------------------------------------------------------------------------\n\nSo far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because [the ECMAScript specification](https://tc39.github.io/ecma262/)\n has explicit instructions on how the language should behave when it runs into something unexpected.\n\nFor example, the specification says that trying to call something that isn’t callable should throw an error. Maybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value `undefined`:\n\njs\n\n`   const user = {    name: \"Daniel\",    age: 26,  };  user.location; // returns undefined   `\n\nUltimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error. In TypeScript, the following code produces an error about `location` not being defined:\n\nts\n\n`  const user = {    name: \"Daniel\",    age: 26,  };  user.location;  Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBjOAO0QBdQBXRGUAXlAG9dRQiBDAW0lQCIARNkQCWkADY8ANM1BsA5t3QA2KQF8A3LlxUYAOlFx8bUkOJqgA)\n\nWhile sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches _a lot_ of legitimate bugs.\n\nFor example: typos,\n\nts\n\n`   const announcement = \"Hello World!\";  // How quickly can you spot the typos?  announcement.toLocaleLowercase();  announcement.toLocalLowerCase();  // We probably meant to write this...  announcement.toLocaleLowerCase();   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AIaQwCukGApgLYWT4C8oARABIUA270oA6suwBMAhEwDcaNCFAtoAd1ABHEgEsMAa3YBPUBiKhN0EqBQAHaPlwALCqFyazKAPxoipctVq4AdLmgAZaF12CgDZCnhdFAoACgBKcVdDdxo6H39AgnZQ8IBhAii48UkwHhsTJAAjAgqtUBoiC25ZeGVcGytlFC9ul2IkyhTvXwCgkLlc-Jj4oA)\n\nuncalled functions,\n\nts\n\n`   function flipCoin() {    // Meant to be Math.random()    return Math.random < 0.5;  Operator '<' cannot be applied to types '() => number' and 'number'.2365Operator '<' cannot be applied to types '() => number' and 'number'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBMAzAGwCsRAZgpNgC4BLaJFCd8AgA4BhaAMgAKAJSgA3kVChSAWRS5IfUH2igARilBbcfABYA6cnrTQAtkvWhyKPgnIjLN+0cXUAAeUAAGWzYAbiIAXyA)\n\nor basic logic errors.\n\nts\n\n`   const value = Math.random() < 0.5 ? \"a\" : \"b\";  if (value !== \"a\") {    // ...  } else if (value === \"b\") {  This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.2367This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.    // Oops, unreachable  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqAG4CGANgK6SgC8oAstWQBYB001xACZwAtgAoAlKAA8oAAw8ArKAD8oAETV1oVOoBG6gNx4AlgDNQYmgyYBCZq03qpAbzyhQIUDx94AvqCQtIhM5pbWjCwOGgau7p5gAPJwAA6IADSg9MTQkNQEXNR6tJD+QA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#types-for-tooling)\nTypes for Tooling\n-------------------------------------------------------------------------------------------------------\n\nTypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can _also_ prevent us from making those mistakes in the first place.\n\nThe type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. Once it has that information, it can also start _suggesting_ which properties you might want to use.\n\nThat means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. That’s part of what people often refer to when they talk about tooling in TypeScript.\n\nts\n\n`   import express from \"express\";  const app = express();  app.get(\"/\", function (req, res) {    res.sen             *   send *   sendDate *   sendfile *   sendFile *   sendStatus  });  app.listen(3000);   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAggUxQWWgCYCuANlgJKQAuWSADmgJYC2dyVoWAHnfDiqABmSZqABE3XvzEBuNAGNokFBwCGdOqAC8nHnxQoAFAEo5adXQB0AcyxVDY4GIA0QopHlVGS0Ib4BHV31jUABvNFBQfUsULEgMMEik0AA9AB80AF9TNHMNSxJGFTjDAGYABkrTIA)\n\nTypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so it’s likely that [your favorite editor has TypeScript support available](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#tsc-the-typescript-compiler)\n`tsc`, the TypeScript compiler\n------------------------------------------------------------------------------------------------------------------------------\n\nWe’ve been talking about type-checking, but we haven’t yet used our type-_checker_. Let’s get acquainted with our new friend `tsc`, the TypeScript compiler. First we’ll need to grab it via npm.\n\nsh\n\n`   npm install -g typescript   `\n\n> This installs the TypeScript Compiler `tsc` globally. You can use `npx` or similar tools if you’d prefer to run `tsc` from a local `node_modules` package instead.\n\nNow let’s move to an empty folder and try writing our first TypeScript program: `hello.ts`:\n\nts\n\n`   // Greets the world.  console.log(\"Hello world!\");   `[Try](https://www.typescriptlang.org/play/#code/PTAEHECcFNoFwM6jgC2qA7ge0gGwCYB0AUAMZYB2CWu0huWA5gBQBEAEtLg5jgQISsAlAG4gA)\n\nNotice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript. And now let’s type-check it by running the command `tsc` which was installed for us by the `typescript` package.\n\nsh\n\n`   tsc hello.ts   `\n\nTada!\n\nWait, “tada” _what_ exactly? We ran `tsc` and nothing happened! Well, there were no type errors, so we didn’t get any output in our console since there was nothing to report.\n\nBut check again - we got some _file_ output instead. If we look in our current directory, we’ll see a `hello.js` file next to `hello.ts`. That’s the output from our `hello.ts` file after `tsc` _compiles_ or _transforms_ it into a plain JavaScript file. And if we check the contents, we’ll see what TypeScript spits out after it processes a `.ts` file:\n\njs\n\n`   // Greets the world.  console.log(\"Hello world!\");   `\n\nIn this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.\n\nWhat about if we _did_ introduce a type-checking error? Let’s rewrite `hello.ts`:\n\nts\n\n``   // This is an industrial-grade general-purpose greeter function:  function greet(person, date) {    console.log(`Hello ${person}, today is ${date}!`);  }  greet(\"Brendan\");   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAlAFQBYEsVQDQBDSIyAEwFcUAXePEgGwFoBzeEygU1HZ6QeXNgAdq8UdBR9OPHnWGgAZtUgBjOnmiQAXGlUatO-vHl0AFKOEodAGlCUSigJSgA3mlCh1O28x4AOmZodgsAAwAJHmYQ0AASd2tUHQBfBzpoJwBPIkJEp0VUgEJwlwBuNFS0NDkFCwAiACEzKjIGiqA)\n\nIf we run `tsc hello.ts` again, notice that we get an error on the command line!\n\ntxt\n\n`   Expected 2 arguments, but got 1.   `\n\nTypeScript is telling us we forgot to pass an argument to the `greet` function, and rightfully so. So far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#emitting-with-errors)\nEmitting with Errors\n-------------------------------------------------------------------------------------------------------------\n\nOne thing you might not have noticed from the last example was that our `hello.js` file changed again. If we open that file up then we’ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that `tsc` reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, _you_ will know better than TypeScript.\n\nTo reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time that’s okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it?\n\nSo TypeScript doesn’t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)\n compiler option. Try changing your `hello.ts` file and running `tsc` with that flag:\n\nsh\n\n`   tsc --noEmitOnError hello.ts   `\n\nYou’ll notice that `hello.js` never gets updated.\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#explicit-types)\nExplicit Types\n-------------------------------------------------------------------------------------------------\n\nUp until now, we haven’t told TypeScript what `person` or `date` are. Let’s edit the code to tell TypeScript that `person` is a `string`, and that `date` should be a `Date` object. We’ll also use the `toDateString()` method on `date`.\n\nts\n\n``   function greet(person: string, date: Date) {    console.log(`Hello ${person}, today is ${date.toDateString()}!`);  }   ``[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6gA)\n\nWhat we did was add _type annotations_ on `person` and `date` to describe what types of values `greet` can be called with. You can read that signature as ”`greet` takes a `person` of type `string`, and a `date` of type `Date`“.\n\nWith this, TypeScript can tell us about other cases where `greet` might have been called incorrectly. For example…\n\nts\n\n``  function greet(person: string, date: Date) {    console.log(`Hello ${person}, today is ${date.toDateString()}!`);  }  greet(\"Maddison\", Date());  Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'.``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUAUADjIraohdFRL0ANKAAmAQwqRUAESmQAlKADeeUKDK1uAG0gA6HXHqsABgAlIOo6AAkKzkloBfURTiSAnqCqI7KyWl9d3lpAGV+QRNFZwBCU0UAbjxnPDxGZjYAIgBZCTExX1os0VDIVkUkoA)\n\nHuh? TypeScript reported an error on our second argument, but why?\n\nPerhaps surprisingly, calling `Date()` in JavaScript returns a `string`. On the other hand, constructing a `Date` with `new Date()` actually gives us what we were expecting.\n\nAnyway, we can quickly fix up the error:\n\nts\n\n``   function greet(person: string, date: Date) {    console.log(`Hello ${person}, today is ${date.toDateString()}!`);  }  greet(\"Maddison\", new Date());   ``[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6BATRMHAAiAFkmBgYLBFD6MHQAd0QHdGxuXyA)\n\nKeep in mind, we don’t always have to write explicit type annotations. In many cases, TypeScript can even just _infer_ (or “figure out”) the types for us even if we omit them.\n\nts\n\n`   let msg = \"hello there!\";        let msg: string   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgzg5hAvBARACxMYB7CYMBOIAhCgNwBQA9FRBAHoD8QA)\n\nEven though we didn’t tell TypeScript that `msg` had the type `string` it was able to figure that out. That’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.\n\n> Note: The message bubble inside the previous code sample is what your editor would show if you had hovered over the word.\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#erased-types)\nErased Types\n---------------------------------------------------------------------------------------------\n\nLet’s take a look at what happens when we compile the above function `greet` with `tsc` to output JavaScript:\n\nts\n\n`\"use strict\";  function greet(person, date) {      console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));  }  greet(\"Maddison\", new Date());` [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFygmQCsmAZgK4B2AxuqrM6EQSWQAoADiQKQulSOgKpmRADSgAJnnQlKAEVUkAlKADemUKFZdxAGxIA6c7CICABgAkS526AAk+kWK4BfRXRYFQBPUFRIT30VNSsgrTUAZWlZex0-AEIHHQBuTD9MTF5+dAEAIgBZPCUlCK4yxWYSeFAEkgEdXKA)\n\nNotice two things here:\n\n1.  Our `person` and `date` parameters no longer have type annotations.\n2.  Our “template string” - that string that used backticks (the `` ` `` character) - was converted to plain strings with concatenations.\n\nMore on that second point later, but let’s now focus on that first point. Type annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.\n\n> **Remember**: Type annotations never change the runtime behavior of your program.\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#downleveling)\nDownleveling\n---------------------------------------------------------------------------------------------\n\nOne other difference from the above was that our template string was rewritten from\n\njs\n\n``   `Hello ${person}, today is ${date.toDateString()}!`;   ``\n\nto\n\njs\n\n`   \"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\");   `\n\nWhy did this happen?\n\nTemplate strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - _don’t ask_). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES5). This process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called _downleveling_.\n\nBy default TypeScript targets ES5, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the [`target`](https://www.typescriptlang.org/tsconfig#target)\n option. Running with `--target es2015` changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running `tsc --target es2015 hello.ts` gives us the following output:\n\njs\n\n``   function greet(person, date) {    console.log(`Hello ${person}, today is ${date.toDateString()}!`);  }  greet(\"Maddison\", new Date());   ``\n\n> While the default target is ES5, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#strictness)\nStrictness\n-----------------------------------------------------------------------------------------\n\nDifferent users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially `null`/`undefined` values. Much like how `tsc` emits in the face of errors, these defaults are put in place to stay out of your way. If you’re migrating existing JavaScript, that might be a desirable first step.\n\nIn contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on.\n\nTypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n flag in the CLI, or `\"strict\": true` in a [`tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n and [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#noimplicitany)\n`noImplicitAny`\n-------------------------------------------------------------------------------------------------\n\nRecall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type: `any`. This isn’t the worst thing that can happen - after all, falling back to `any` is just the plain JavaScript experience anyway.\n\nHowever, using `any` often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code. Turning on the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n flag will issue an error on any variables whose type is implicitly inferred as `any`.\n\n[](https://www.typescriptlang.org/docs/handbook/2/basic-types.html#strictnullchecks)\n`strictNullChecks`\n-------------------------------------------------------------------------------------------------------\n\nBy default, values like `null` and `undefined` are assignable to any other type. This can make writing some code easier, but forgetting to handle `null` and `undefined` is the cause of countless bugs in the world - some consider it a [billion dollar mistake](https://www.youtube.com/watch?v=ybrQvs4x0Ps)\n! The [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n flag makes handling `null` and `undefined` more explicit, and _spares_ us from worrying about whether we _forgot_ to handle `null` and `undefined`.\n\n[### The TypeScript Handbook\\\n\\\nYour first step to learn TypeScript](https://www.typescriptlang.org/docs/handbook/intro.html)\n\n[### Everyday Types\\\n\\\nThe language primitives.](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Basics.md)\n ❤\n\nContributors to this page:  \n\nRC![Ryan Cavanaugh  (55)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nRT![Rich Trott  (4)](https://gravatar.com/avatar/68952226d6c1715ac554e22eda3569417724d4616f0b09bc81770344878635b7?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (4)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)\n\nEB![Eli Barzilay  (2)](https://gravatar.com/avatar/74530a34228bb8fa1f87ae92c78909b7?s=32&&d=blank)\n\n18+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","description":"Step one in learning TypeScript: The basic types.","og:description":"Step one in learning TypeScript: The basic types.","twitter:site":"typescriptlang","ogDescription":"Step one in learning TypeScript: The basic types.","title":"TypeScript: Documentation - The Basics","og:title":"Documentation - The Basics","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogTitle":"Documentation - The Basics","theme-color":"#3178C6","scrapeId":"18bd6312-c2dc-4c96-81ca-9212462a9bea","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/basic-types.html","url":"https://www.typescriptlang.org/docs/handbook/2/basic-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nEveryday Types\n==============\n\nIn this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript. This isn’t an exhaustive list, and future chapters will describe more ways to name and use other types.\n\nTypes can also appear in many more _places_ than just type annotations. As we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs.\n\nWe’ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code. These will later form the core building blocks of more complex types.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean)\nThe primitives: `string`, `number`, and `boolean`\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nJavaScript has three very commonly used [primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\n: `string`, `number`, and `boolean`. Each has a corresponding type in TypeScript. As you might expect, these are the same names you’d see if you used the JavaScript `typeof` operator on a value of those types:\n\n*   `string` represents string values like `\"Hello, world\"`\n*   `number` is for numbers like `42`. JavaScript does not have a special runtime value for integers, so there’s no equivalent to `int` or `float` - everything is simply `number`\n*   `boolean` is for the two values `true` and `false`\n\n> The type names `String`, `Number`, and `Boolean` (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. _Always_ use `string`, `number`, or `boolean` for types.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#arrays)\nArrays\n------------------------------------------------------------------------------------\n\nTo specify the type of an array like `[1, 2, 3]`, you can use the syntax `number[]`; this syntax works for any type (e.g. `string[]` is an array of strings, and so on). You may also see this written as `Array<number>`, which means the same thing. We’ll learn more about the syntax `T<U>` when we cover _generics_.\n\n> Note that `[number]` is a different thing; refer to the section on [Tuples](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)\n> .\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any)\n`any`\n--------------------------------------------------------------------------------\n\nTypeScript also has a special type, `any`, that you can use whenever you don’t want a particular value to cause typechecking errors.\n\nWhen a value is of type `any`, you can access any properties of it (which will in turn be of type `any`), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:\n\nts\n\n``   let obj: any = { x: 0 };  // None of the following lines of code will throw compiler errors.  // Using `any` disables all further type checking, and it is assumed  // you know the environment better than TypeScript.  obj.foo();  obj();  obj.bar = 100;  obj = \"hello\";  const n: number = obj;   ``[Try](https://www.typescriptlang.org/play/#code/DYUwLgBA9gRgVgLggQwHYE8IF4IG8IAeSADBAL4DcAsAFAD0dEAclKiNAGYRgAW7HUYMCgB3AJaoA5hGASQAZ04QAxlAAm7cUO48ATqJVQAtgAcxoXRBC79u+QDpaDCAFV5E6QAM06TxDVi8sgwoIrI2hwArrq81tzoJuzKfMoA1h4ANCioahBikIEo8vKRRiBqTozoUJEQqagGsVaoAG5i+qhlqJAw4GBxvGgQACoJIADKyrpiJmCONLBw9gJQABQAlNQL8Btbi-YwyJY4AIzExHvw2BAARHxCUDdbqqjykKhIqKW9x9DwFEA)\n\nThe `any` type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#noimplicitany)\n`noImplicitAny`\n\nWhen you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to `any`.\n\nYou usually want to avoid this, though, because `any` isn’t type-checked. Use the compiler flag [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n to flag any implicit `any` as an error.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-annotations-on-variables)\nType Annotations on Variables\n----------------------------------------------------------------------------------------------------------------------------------\n\nWhen you declare a variable using `const`, `var`, or `let`, you can optionally add a type annotation to explicitly specify the type of the variable:\n\nts\n\n`   let myName: string = \"Alice\";   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAtgngcgQyiAXBAzmATgSwHYDmEAvBAEQCCwOAxiGQNwCwAUAPRsRfdcB6-A-hAAqMAA4gICPHgD2YBGByy8QA)\n\n> TypeScript doesn’t use “types on the left”-style declarations like `int x = 0;` Type annotations will always go _after_ the thing being typed.\n\nIn most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically _infer_ the types in your code. For example, the type of a variable is inferred based on the type of its initializer:\n\nts\n\n`   // No type annotation needed -- 'myName' inferred as type 'string'  let myName = \"Alice\";   `[Try](https://www.typescriptlang.org/play/#code/PTAEDkHtQFwTwA4FNQEMB27I1TAlpOqOkkgCbmgC0VoA5ALZzioNJ2h7oBmSATn0qoAzrEQo6wmHy4BzOgFgAUABskMUExZtQAXlAAiAIIq8AYyQGA3EA)\n\nFor the most part you don’t need to explicitly learn the rules of inference. If you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#functions)\nFunctions\n------------------------------------------------------------------------------------------\n\nFunctions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#parameter-type-annotations)\nParameter Type Annotations\n\nWhen you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:\n\nts\n\n`   // Parameter type annotation  function greet(name: string) {    console.log(\"Hello, \" + name.toUpperCase() + \"!!\");  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAUEMCdIWwKYBcHVEgngBwaSA7fAeyUiQEsj8BYAKADMBXfAYwqtAHNoFkAKfPAQAuUAGck0cvk4BKUAG86oUCBXqNm9QD1de3ctAsqYogBsEAOjNFOfAEQAJBGZsAaUPdABqUIMSWSEQAqlg40ADCkGIIfPK+9gCEifayANx0AL5AA)\n\nWhen a parameter has a type annotation, arguments to that function will be checked:\n\nts\n\n`  // Would be a runtime error if executed!  greet(42);  Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOgDmNkrABRNKAW0ipEraOyY8AlKgBucdkQDchEKAC0e0g1Z6dWsAHU4DckVAAjWpVDRmHcaBjxoodnXcAPMkNIIgBCQj5IAUEsNHl1IA)\n\n> Even if you don’t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#return-type-annotations)\nReturn Type Annotations\n\nYou can also add return type annotations. Return type annotations appear after the parameter list:\n\nts\n\n`   function getFavoriteNumber(): number {    return 26;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQGIEMBucBOMUqAciALYBGq+AFAJQBciYF1+iA3gLABQiiAPSCBoseIliAejNky+A-OhD4kAJgBsAbj4BfIA)\n\nMuch like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its `return` statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#functions-which-return-promises)\nFunctions Which Return Promises\n\nIf you want to annotate the return type of a function which returns a promise, you should use the `Promise` type:\n\nts\n\n`   async function getFavoriteNumber(): Promise<number> {    return 26;  }   `[Try](https://www.typescriptlang.org/play/#code/IYZwngdgxgBAZgV2gFwJYHsIwOYFNkBiwAbugE6rK4ByCAtgEa5kAUAlAFwwAKZ6dqELgA8EekzIA+GAG8AsACgYMMvgRksAJgBsAbkUBfIA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#anonymous-functions)\nAnonymous Functions\n\nAnonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.\n\nHere’s an example:\n\nts\n\n`   const names = [\"Alice\", \"Bob\", \"Eve\"];  // Contextual typing for function - parameter s inferred to have type string  names.forEach(function (s) {    console.log(s.toUpperCase());  });  // Contextual typing also applies to arrow functions  names.forEach((s) => {    console.log(s.toUpperCase());  });   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMEYCwAoAYzgDtEAXUEgQwFtJFQBeUAbQCIBBAGwEtDI7ADSh2AITgAjYaICiAN0EBdANwECIUAGFS5SAA9yAV2rdQ5AJ4AHXiQDmoAGYInRkoXK9SoALSgr1NB0kHrQoIy2jjDQkAAm5nCgABbUiubWkOHk0LZ2BDT0iAB0ztCy1IRJABSObh5eJKBViACUoADeBKCgxGRw3JBF3HB2zUXkcACqVlYwWtSIkFUtLWr4AL6r6viaOiR6hiZmljb2oKaIidQzfAwJ57BwAO6u7p6kiPnBxaXllVXNNpMAB8HS6PQ+-UGw1GxQm01m0Hmi2WWw2qyAA)\n\nEven though the parameter `s` didn’t have a type annotation, TypeScript used the types of the `forEach` function, along with the inferred type of the array, to determine the type `s` will have.\n\nThis process is called _contextual typing_ because the _context_ that the function occurred within informs what type it should have.\n\nSimilar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it _does_ happen can help you notice when type annotations aren’t needed. Later, we’ll see more examples of how the context that a value occurs in can affect its type.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#object-types)\nObject Types\n------------------------------------------------------------------------------------------------\n\nApart from primitives, the most common sort of type you’ll encounter is an _object type_. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.\n\nFor example, here’s a function that takes a point-like object:\n\nts\n\n`   // The parameter's type annotation is an object type  function printCoord(pt: { x: number; y: number }) {    console.log(\"The coordinate's x value is \" + pt.x);    console.log(\"The coordinate's y value is \" + pt.y);  }  printCoord({ x: 3, y: 7 });   `[Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQBwIYCcEFtoBdpIOQGdQMBPOWBAO3IHsMEMBLK80egi0KgIwCtoBjDIRLQAsACgAZgFdyAxszhJ65DAGEqVJABMAFHAwAuUAG9QADyPkpqTtgDcoIpeu2koAL4BKE+NCgQfoFBwSF+AHoRkVHRMZG+oHxMeFQANtAAdClUAOY6AERQsImaWsp00PjmoABuCClSsKygeaAA1PAY6WaedvGJ5MlpmTn5hQka2mVYlUQ1dQ0sBC3t+ulEPeLu4orKahO6phagAMwANI5GAOwePUA)\n\nHere, we annotated the parameter with a type with two properties - `x` and `y` - which are both of type `number`. You can use `,` or `;` to separate the properties, and the last separator is optional either way.\n\nThe type part of each property is also optional. If you don’t specify a type, it will be assumed to be `any`.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#optional-properties)\nOptional Properties\n\nObject types can also specify that some or all of their properties are _optional_. To do this, add a `?` after the property name:\n\nts\n\n`   function printName(obj: { first: string; last?: string }) {    // ...  }  // Both OK  printName({ first: \"Bob\" });  printName({ first: \"Alice\", last: \"Alisson\" });   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAcgQwLYCmAFHAEYBWAXIgN6LAyoDOU1L6YA5gNyIA2OFgH42UDp0QBfAJS0AsAChEiAPQrEAOi2LJitYgBCcKAAtEAeQDSitBmz5idBs1aIAREdJup07jY72hEROjCzUbgCCfDAQBG4ANPyCrpHRTEwI3jLcQA)\n\nIn JavaScript, if you access a property that doesn’t exist, you’ll get the value `undefined` rather than a runtime error. Because of this, when you _read_ from an optional property, you’ll have to check for `undefined` before using it.\n\nts\n\n`   function printName(obj: { first: string; last?: string }) {    // Error - might crash if 'obj.last' wasn't provided!    console.log(obj.last.toUpperCase());  'obj.last' is possibly 'undefined'.18048'obj.last' is possibly 'undefined'.    if (obj.last !== undefined) {      // OK      console.log(obj.last.toUpperCase());    }    // A safe alternative using modern JavaScript syntax:    console.log(obj.last?.toUpperCase());  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwA4AMAWDBYAKADMBXAOwGMAXASznNAAdpbzqA5AQwFtIAKOACMAVqgDeoYrSTVUiaq3IBzANygANlwUB+eYrbLQAXwCUocUVCgQoAKKwEoALSgetZQAtqoStG2eoLTEoADkwiIAdFoKoaAA7trkoT4scAButAAmkFkAhFa+DIhwGpDRcMqCotHa1JHUcACqTEwwAMLaAqamqoXBoNVRMT55ALxjoBQ50uS55paE1ta2APIA0oXWlMWl5RqVQ7UKDc2tHV38PX1LJkSFtgCCoIhcxJCgXBrUMORcdOkPqREIY3HActBGAApLjpLgAZT8tCYPkQAE92FwAB7IQo7cglMoVKoRY7UHSnFptaCdRDdXpEYxAA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)\nUnion Types\n----------------------------------------------------------------------------------------------\n\nTypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, it’s time to start _combining_ them in interesting ways.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#defining-a-union-type)\nDefining a Union Type\n\nThe first way to combine types you might see is a _union_ type. A union type is a type formed from two or more other types, representing values that may be _any one_ of those types. We refer to each of these types as the union’s _members_.\n\nLet’s write a function that can operate on strings or numbers:\n\nts\n\n`  function printId(id: number | string) {    console.log(\"Your ID is: \" + id);  }  // OK  printId(101);  // OK  printId(\"202\");  // Error  printId({ myID: 22342 });  Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.2345Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFABmArgHYDGALgJZxmgAO0NZVAkgCYAUNnqZEgFsARjFAAfUIiosyAcwCUoAN6FQoCvURwANpAB0uuPO4AiAJpwS0UOwAioGilBnQAaiedFAbkIBfQhBQAHkAaUJmVg4eAEYABljfILBwyLkY8zR4tDNkgmCAUVgEdOiubhVQIQBPB1Q0TCw0UH9fIA)\n\n> The separator of the union members is allowed before the first element, so you could also write this:\n> \n> ts\n> \n> `   function printTextOrNumberOrBool(    textOrNumberOrBool:      | string      | number      | boolean  ) {    console.log(textOrNumberOrBool);  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAKgUwB5QDyqAciALYBGOqxAQnHADYAUAsAFCKJT5GkVqtVA2YAuTt24AfRAGco6MAHNJU2WEE01MxJUZMcAQzCcAlIgDeaiAjnMcAOiZxlLXgWJkqNegbMA3JwAvkA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#working-with-union-types)\nWorking with Union Types\n\nIt’s easy to _provide_ a value matching a union type - simply provide a type matching any of the union’s members. If you _have_ a value of a union type, how do you work with it?\n\nTypeScript will only allow an operation if it is valid for _every_ member of the union. For example, if you have the union `string | number`, you can’t use methods that are only available on `string`:\n\nts\n\n`   function printId(id: number | string) {    console.log(id.toUpperCase());  Property 'toUpperCase' does not exist on type 'string | number'.   Property 'toUpperCase' does not exist on type 'number'.2339Property 'toUpperCase' does not exist on type 'string | number'.   Property 'toUpperCase' does not exist on type 'number'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoAMwFcA7AYwBcBLOU0AB2mtMoEkATACmo9VOIBbAEYxQAH1CJKzUgHMAlKADeBUKHJ1EcADaQAdDrhyeHfZTgBVBgxgBhAIaJIXBQoDcBAL5A)\n\nThe solution is to _narrow_ the union with code, the same as you would in JavaScript without type annotations. _Narrowing_ occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.\n\nFor example, TypeScript knows that only a `string` value will have a `typeof` value `\"string\"`:\n\nts\n\n`   function printId(id: number | string) {    if (typeof id === \"string\") {      // In this branch, id is of type 'string'      console.log(id.toUpperCase());    } else {      // Here, id is of type 'number'      console.log(id);    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAkgEwBQw4BciYIAtgEYCmqiAPogM5TpgDmAlIgN4CwAKESIYwRHigBPZNThjCiALzLEAIhZt2q7vyHDEAegOIsSKAAsYTRJVQBDSOYA0InCOtzEUmYgDkGjHZfQX1ECAQmOAAbagA6KLh2AhxYqDgAVWQZVABhOyZqPE5OAG4QxABfRGoogt5y4SNEAAlaahcFK0RPb2o-MipaYL1hcLBImPjE5NLyisEKoA)\n\nAnother example is to use a function like `Array.isArray`:\n\nts\n\n`   function welcomePeople(x: string[] | string) {    if (Array.isArray(x)) {      // Here: 'x' is 'string[]'      console.log(\"Hello, \" + x.join(\" and \"));    } else {      // Here: 'x' is 'string'      console.log(\"Welcome lone traveler \" + x);    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAdwKYBsJwLaoAqpwAO6qAFAB4BciAzlAE4xgDmA2gLqIA+djzLAJSIA3gFgAUIkQxgiMgEEGDAIYBPAHQxaS1WsqDh4qdMQB6M4gASqBqhoByCg5m1ED+k1acHk04iwwWjhSDXQ4FjIAIht0cIAaRCjEAGpECg0AKzhmaMQVMAATJMMAbj9EAF9EDFpUUQrpC2tbe3dnV3dPAV8TaUDg0PDIqIB1DCxcRHCwesYVADcMWyTU9MFyk0rJSqA)\n\nNotice that in the `else` branch, we don’t need to do anything special - if `x` wasn’t a `string[]`, then it must have been a `string`.\n\nSometimes you’ll have a union where all the members have something in common. For example, both arrays and strings have a `slice` method. If every member in a union has a property in common, you can use that property without narrowing:\n\nts\n\n`   // Return type is inferred as number[] | string  function getFirstThree(x: number[] | string) {    return x.slice(0, 3);  }   `[Try](https://www.typescriptlang.org/play/#code/PTAECUFMBcFcCcB2poE8AOlQEsDOPEAzSeeSAE1AEN9FYBbAIxIG0BdUAH1F2nm0QBzALAAoQrEQBjaNgD2yQTABi2eLwAqACzKQAFAA8AXKDpNWHbr35CAlKADeY0KDJwkoAwDpcAG2xS+gAMADSgAMy2ANxiAL5AA)\n\n> It might be confusing that a _union_ of types appears to have the _intersection_ of those types’ properties. This is not an accident - the name _union_ comes from type theory. The _union_ `number | string` is composed by taking the union _of the values_ from each type. Notice that given two sets with corresponding facts about each set, only the _intersection_ of those facts applies to the _union_ of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about _every_ person is that they must be wearing a hat.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)\nType Aliases\n------------------------------------------------------------------------------------------------\n\nWe’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.\n\nA _type alias_ is exactly that - a _name_ for any _type_. The syntax for a type alias is:\n\nts\n\n`   type Point = {    x: number;    y: number;  };  // Exactly the same as the earlier example  function printCoord(pt: Point) {    console.log(\"The coordinate's x value is \" + pt.x);    console.log(\"The coordinate's y value is \" + pt.y);  }  printCoord({ x: 100, y: 100 });   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbwLACgpQAeAXFEgK4C2ARhAE4DceBIpFN9TuAvl3gPT8oAUUIBDAMbAANiCjAAFtADOYytDHL5SqBDF1pCervGUw0iHgBm5JFIRwkUMHWTAAwnDh0AJgAowYFJ4NwBKLGYoCUdlOAsAOmk4AHM-ACIAFR1o7x9kMWAIAHItQigANzFpcmgELTSoAGpnYHjCUK4CaKRYhKTUzOyvX3zCkqg5Sura+qaW+JAOvG48PBc3T1y-TCJSAEYABgOAGgn9o6huDqA)\n\nYou can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:\n\nts\n\n`   type ID = number | string;   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAkgIlAvFAdgVwLYCMICcoA+UAzsLgJYoDmA3EA)\n\nNote that aliases are _only_ aliases - you cannot use type aliases to create different/distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might _look_ illegal, but is OK according to TypeScript because both types are aliases for the same type:\n\nts\n\n`   type UserInputSanitizedString = string;  function sanitizeInput(str: string): UserInputSanitizedString {    return sanitize(str);  }  // Create a sanitized input  let userInput = sanitizeInput(getInput());  // Can still be re-assigned with a string though  userInput = \"new input\";   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBJVAB2QwAoBKALngGcMYtUCBuAWAChRIsBCnTY8zKKizYAXiGosYjRewINmrVT14B6HfAC0RsFSMG+GAJ7kEAVSYgYZShgDKk6VjnBXmjvABeDTYObT4RTFx8Jg9ZEGcqBVZlPzVGe0cEt1ivEB9U+ABvPnh4OAxkGGicuSSYWm0AXz4+PXgAYTgoDAQoCSk44Hh2Fz4IYnhkBycKKkD+zzks6iJSWZpaBpbdfXbJDSwICHgAIwQ4AygmJiwCVDz4AHdpAAt4PpV-DBecZAIXvhTTLreYAInuj2G61BnCAA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces)\nInterfaces\n--------------------------------------------------------------------------------------------\n\nAn _interface declaration_ is another way to name an object type:\n\nts\n\n`   interface Point {    x: number;    y: number;  }  function printCoord(pt: Point) {    console.log(\"The coordinate's x value is \" + pt.x);    console.log(\"The coordinate's y value is \" + pt.y);  }  printCoord({ x: 100, y: 100 });   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgAoHtRmQbwLABQyyAHgFzIgCuAtgEbQDchxAnhdfU4QL6GEwqIBGGDoQyAA5QsAYXTooAEwAUksBQxYAlLhbIE4gM7oANhAB0p9AHMVAIgAqACxSHFS0HEgByI6WQANzhTKhRgf3tkAGopMAsSbWYiA2MzS2s7J1dUjy9ff1YgkLDkCOQo2PULViTefgJpOQVlFRxSCgBGAAZugBpkdmQe7uQeJKA)\n\nJust like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the _structure_ of the value we passed to `printCoord` - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a _structurally typed_ type system.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)\nDifferences Between Type Aliases and Interfaces\n\nType aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an `interface` are available in `type`, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.\n\n| `Interface` | `Type` |\n| --- | --- |\n| Extending an interface<br><br>`interface Animal {   name: string; }   interface Bear extends Animal {   honey: boolean; }   const bear = getBear(); bear.name; bear.honey;` | Extending a type via intersections<br><br>`type Animal = {   name: string; }   type Bear = Animal & {    honey: boolean; }   const bear = getBear(); bear.name; bear.honey;` |\n| Adding new fields to an existing interface<br><br>`interface Window {   title: string; }   interface Window {   ts: TypeScriptAPI; }   const src = 'const a = \"Hello World\"'; window.ts.transpileModule(src, {});` | A type cannot be changed after being created<br><br>`type Window = {   title: string; }   type Window = {   ts: TypeScriptAPI; }    // Error: Duplicate identifier 'Window'.` |\n\nYou’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away.\n\n*   Prior to TypeScript version 4.2, type alias names [_may_ appear in error messages](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA)\n    , sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.\n*   Type aliases may not participate [in declaration merging, but interfaces can](https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA)\n    .\n*   Interfaces may only be used to [declare the shapes of objects, not rename primitives](https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA)\n    .\n*   Interface names will [_always_ appear in their original form](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA)\n     in error messages, but _only_ when they are used by name.\n*   Using interfaces with `extends` [can often be more performant for the compiler](https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections)\n     than type aliases with intersections\n\nFor the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use `interface` until you need to use features from `type`.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)\nType Assertions\n------------------------------------------------------------------------------------------------------\n\nSometimes you will have information about the type of a value that TypeScript can’t know about.\n\nFor example, if you’re using `document.getElementById`, TypeScript only knows that this will return _some_ kind of `HTMLElement`, but you might know that your page will always have an `HTMLCanvasElement` with a given ID.\n\nIn this situation, you can use a _type assertion_ to specify a more specific type:\n\nts\n\n`   const myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtgTwMIEMwDcURgXhgExGAFc4BTMKAOgHMyoBRAGzPMoCEEBJfACgCI4KAJZgA+sDSYI-AJQwsMABIAVALIAZVBizNWFKAG4gA)\n\nLike a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code.\n\nYou can also use the angle-bracket syntax (except if the code is in a `.tsx` file), which is equivalent:\n\nts\n\n`   const myCanvas = <HTMLCanvasElement>document.getElementById(\"main_canvas\");   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtgTwMIEMwDcURgXhgHgAkAVAWQBlUMsBRAGwFM4GwoA+AExGAFdnWAdAHMGUekxZQAQggCSHABQAiOCgCWYAPrA0mCEoCUAbiA)\n\n> Reminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion. There won’t be an exception or `null` generated if the type assertion is wrong.\n\nTypeScript only allows type assertions which convert to a _more specific_ or _less specific_ version of a type. This rule prevents “impossible” coercions like:\n\nts\n\n`  const x = \"hello\" as number;  Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.2352Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCsaCwAoAYzgDtEAXUAD1AF5QAiAC0gBtW4HQBDRUEgK4BbAEYwA3EA)\n\nSometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to `any` (or `unknown`, which we’ll introduce later), then to the desired type:\n\nts\n\n`   const a = expr as any as T;   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3iAHgBxgC54oUBPAbgFgAoDMvBAFXgF54BvE4gRgvgBGxAEz8wxAMzwAvtRoB6efAC0qsAFcMq5bWTosUNtnwwSaEuTPwmFIA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)\nLiteral Types\n--------------------------------------------------------------------------------------------------\n\nIn addition to the general types `string` and `number`, we can refer to _specific_ strings and numbers in type positions.\n\nOne way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both `var` and `let` allow for changing what is held inside the variable, and `const` does not. This is reflected in how TypeScript creates types for literals.\n\nts\n\n``   let changingString = \"Hello World\";  changingString = \"Olá Mundo\";  // Because `changingString` can represent any possible string, that  // is how TypeScript describes it in the type system  changingString;          let changingString: string  const constantString = \"Hello World\";  // Because `constantString` can only represent 1 possible string, it  // has a literal type representation  constantString;          const constantString: \"Hello World\"   ``[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAxgFghgOwOYEtkGUwCc1IgXggCIAJEYYAewgHVKtgATIgbgFgAoWRVDbXAsQDywAIcQAsgFcEjSq04B6RRABCIKHCkBnEBAAG3ZLkw5k+6IghYQABxu6EkRAE8Itytu0oARqAja-MgANBBg8GBKKijaEDCUAO4QACoutiDoUDi2kIwg2lm++RAokGhhMHpgaXraLoEgALacRrxIprjsHMoQAHoA-JwtlAiB0COBiGAdyIKk5FS09EwK3Srqmjp6hhNgUzNIFpoIECPAbjb2+SBOEACM7p7efrVBSKGlUXFwsXAQwKUQFg4MAwjVrHYHDc9mAUCNhqM9k4Dl0egMgA)\n\nBy themselves, literal types aren’t very valuable:\n\nts\n\n`  let x: \"hello\" = \"hello\";  // OK  x = \"hello\";  // ...  x = \"howdy\";  Type '\"howdy\"' is not assignable to type '\"hello\"'.2322Type '\"howdy\"' is not assignable to type '\"hello\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UAiAC0gILktAF5Qa6HKBufEUAeQDS+Miza16jHnj4A6eSLE04AdwAmAT25A)\n\nIt’s not much use to have a variable that can only have one value!\n\nBut by _combining_ literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:\n\nts\n\n`  function printText(s: string, alignment: \"left\" | \"right\" | \"center\") {    // ...  }  printText(\"Hello, world\", \"left\");  printText(\"G'day, mate\", \"centre\");  Argument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'.2345Argument of type '\"centre\"' is not assignable to parameter of type '\"left\" | \"right\" | \"center\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFABmArgHYDGALgJZxmgAO0NZVAKpAB5UAUKoRFRZkA5gBpQAQwA2NUWQC2kNqgBEMyESprQAH1BqWogBY79hiiqow1ASlABvQqFAhQAOi+EAvoWasHNx8agASkDIycJIA7ggyACZqkhpaOnYA3P4iQTy8agDiAOQJUgCekopSNsmW1tCQ9hlAA)\n\nNumeric literal types work the same way:\n\nts\n\n`   function compare(a: string, b: string): -1 | 0 | 1 {    return a === b ? 0 : a > b ? 1 : -1;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbADgQwE4FMAUmAXIgM5TYxgDmANIgEYnmU0CUJAtAIyIA+iAAz9EvAN4BYAFCJEeKCGxJMiALzrGiAPxDEJFQD5NO3l24BuaQF8gA)\n\nOf course, you can combine these with non-literal types:\n\nts\n\n`  interface Options {    width: number;  }  function configure(x: Options | \"auto\") {    // ...  }  configure({ width: 100 });  configure(\"auto\");  configure(\"automatic\");  Argument of type '\"automatic\"' is not assignable to parameter of type 'Options | \"auto\"'.2345Argument of type '\"automatic\"' is not assignable to parameter of type 'Options | \"auto\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACWAdgC4wBmAhgMaSgDyADmUXCYqAN6GigB3IgBMyAC1QkArgFsARjADchAL6FKUkrTYdQtDpSIBzKdEgAKAB6oWOzqAA+oAETUpZOM4CUPPqBCgAHTBqoT6JIYmZubcgiLiqACMAAzJoCpeygThkaYWru6emWEGxnnmBR4y1Gy03opAA)\n\nThere’s one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types `true` and `false`. The type `boolean` itself is actually just an alias for the union `true | false`.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-inference)\nLiteral Inference\n\nWhen you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:\n\nts\n\n`   const obj = { counter: 0 };  if (someCondition) {    obj.counter = 1;  }   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEAwqsAJYYmoBc8ARkkhCFCgNwCwAUAPRfwC0AsAFcMAvp2TosSGgCt4AXngBvREiEoMIGNQAM8AL7sOJAGbwAFDnxEUpcqgCUKzvHgzZAOmQatMRfAAjMYGQA)\n\nTypeScript doesn’t assume the assignment of `1` to a field which previously had `0` is an error. Another way of saying this is that `obj.counter` must have the type `number`, not `0`, because types are used to determine both _reading_ and _writing_ behavior.\n\nThe same applies to strings:\n\nts\n\n`  declare function handleRequest(url: string, method: \"GET\" | \"POST\"): void;  const req = { url: \"https://example.com\", method: \"GET\" };  handleRequest(req.url, req.method);  Argument of type 'string' is not assignable to parameter of type '\"GET\" | \"POST\"'.2345Argument of type 'string' is not assignable to parameter of type '\"GET\" | \"POST\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOgAWlTRcpABKkAI4NIiVgAoG0cqmnR2TAOYAaUAFtIrHnCKoARAHEAogBVjoAD6hjABQDyAZWsBKVADc47IgDchISkXNKgNGKgALygAN6g8ooOPKysAA4oIJAAHpTa6UIAdKHaxlq6+oYmFtagAL5BBHwCQqISUrKRRUla3ZUGRB4BQA)\n\nIn the above example `req.method` is inferred to be `string`, not `\"GET\"`. Because code can be evaluated between the creation of `req` and the call of `handleRequest` which could assign a new string like `\"GUESS\"` to `req.method`, TypeScript considers this code to have an error.\n\nThere are two ways to work around this.\n\n1.  You can change the inference by adding a type assertion in either location:\n    \n    ts\n    \n    `   // Change 1:  const req = { url: \"https://example.com\", method: \"GET\" as \"GET\" };  // Change 2  handleRequest(req.url, req.method as \"GET\");   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAspVgIQAlEAR2RAGcMAKZGCALngZi1QHMAaeAFsQGAjmAcARAHEAogBUp8AD7wpABQDyAZSUBKDgDccWYAG4AsACgA9LfgBaZ2GQZnjm-fgBhInwQARjYbMDwGeDgqeABeeABveBZ2dQIMDAAHOjZ7EAAPKCEMsgA6MKEpQRExCWl5JXgoOnV65QBfKzsHP2JeBAAmG39SCmpaBkYokuTBKerxYEbm2UUpfXMgA)\n    \n    Change 1 means “I intend for `req.method` to always have the _literal type_ `\"GET\"`”, preventing the possible assignment of `\"GUESS\"` to that field after. Change 2 means “I know for other reasons that `req.method` has the value `\"GET\"`“.\n    \n2.  You can use `as const` to convert the entire object to be type literals:\n    \n    ts\n    \n    `   const req = { url: \"https://example.com\", method: \"GET\" } as const;  handleRequest(req.url, req.method);   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAspVgIQAlEAR2RAGcMAKZGCALngZi1QHMAaeAFsQGAjmAcARAHEAogBUp8AD7wpABQDyAZSUBKDgDccWYAG4AsACgA9LfgBaZ2GQZnjm2DwN4cKvAAvPAA3vAs7OoEGBgADnRs9iAAHlBCsWQAdN5CUoIiYhLS8krwAL7wUHTw3qgMVtZEJGSUNPRM-pkRgp0F4sD65kA)\n    \n\nThe `as const` suffix acts like `const` but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like `string` or `number`.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)\n`null` and `undefined`\n----------------------------------------------------------------------------------------------------------------\n\nJavaScript has two primitive values used to signal absent or uninitialized value: `null` and `undefined`.\n\nTypeScript has two corresponding _types_ by the same names. How these types behave depends on whether you have the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n option on.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#strictnullchecks-off)\n`strictNullChecks` off\n\nWith [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n _off_, values that might be `null` or `undefined` can still be accessed normally, and the values `null` and `undefined` can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; we always recommend people turn [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n on if it’s practical to do so in their codebase.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#strictnullchecks-on)\n`strictNullChecks` on\n\nWith [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n _on_, when a value is `null` or `undefined`, you will need to test for those values before using methods or properties on that value. Just like checking for `undefined` before using an optional property, we can use _narrowing_ to check for values that might be `null`:\n\nts\n\n`   function doSomething(x: string | null) {    if (x === null) {      // do nothing    } else {      console.log(\"Hello, \" + x.toUpperCase());    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAB4BciAzlAE6FGIA+iYIANhwJSIDeAWABQiRDGCJyiALyy2nHv2GjRAelUo4bOPkbLEAX0TYO1bEpEqICanA7YAdBzikARAAkTzgDSJXiAGpEMgcoOABVAAdI7DoAYQBDMxJubgBufQNhAyA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-)\nNon-null Assertion Operator (Postfix `!`)\n\nTypeScript also has a special syntax for removing `null` and `undefined` from a type without doing any explicit checking. Writing `!` after any expression is effectively a type assertion that the value isn’t `null` or `undefined`:\n\nts\n\n`   function liveDangerously(x?: number | null) {    // No error    console.log(x!.toFixed());  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGxgNwKYBECGYDmGATnCAM7ICeAFAB4D8AXImCALYBGxiAPiyMmQBKRAG8AsAChEiAPSzEAOTiJiJIlJkQEZOMgwA6ZHHx0AhAahwAYjFoYAJtSFCA3FIC+QA)\n\nJust like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use `!` when you know that the value _can’t_ be `null` or `undefined`.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#enums)\nEnums\n----------------------------------------------------------------------------------\n\nEnums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is _not_ a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the [Enum reference page](https://www.typescriptlang.org/docs/handbook/enums.html)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#less-common-primitives)\nLess Common Primitives\n--------------------------------------------------------------------------------------------------------------------\n\nIt’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system. Though we will not go into depth here.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#bigint)\n`bigint`\n\nFrom ES2020 onwards, there is a primitive in JavaScript used for very large integers, `BigInt`:\n\nts\n\n`   // Creating a bigint via the BigInt function  const oneHundred: bigint = BigInt(100);  // Creating a BigInt via the literal syntax  const anotherHundred: bigint = 100n;   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGXBYAKCJFAGFZFpIBLAO3lGlACMb57JQA3G5yABaJQAIXYBJOlwBmAVzoBjWgHs6RBaoxdViABLyAJpQNo2HKaAC8oiVIAUARhw4AlAG4iJMBSq0GTG3hJLl5+IVAAGxpIRFhoCNAMAE8paAAPdU0uaDplQVj9OiNEE1Z2TitQJxw6NyA)\n\nYou can learn more about BigInt in [the TypeScript 3.2 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint)\n.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#symbol)\n`symbol`\n\nThere is a primitive in JavaScript used to create a globally unique reference via the function `Symbol()`:\n\nts\n\n`   const firstName = Symbol(\"name\");  const secondName = Symbol(\"name\");  if (firstName === secondName) {  This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.2367This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.    // Can't ever happen  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AsAFADGcAdogC6gBmAlkhQHICGAtpKALygDKAnqwBGcADYAKAESk2kCQEoA3IRLkqiSCoAmLdl14Dh4qTPlKChWtVBi6DHR06PQ6rfbmgA3oVCgQoAMLMpADkVJAAbjCgABbMAA5xkKSEAL5AA)\n\nYou can learn more about them in [Symbols reference page](https://www.typescriptlang.org/docs/handbook/symbols.html)\n.\n\n[### The Basics\\\n\\\nStep one in learning TypeScript: The basic types.](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)\n\n[### Narrowing\\\n\\\nUnderstand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects.](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Everyday%20Types.md)\n ❤\n\nContributors to this page:  \n\nRC![Ryan Cavanaugh  (56)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nOT![Orta Therox  (22)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nUG![Utku Gultopu  (3)](https://gravatar.com/avatar/57ca90821f163c29b09973048909283947ca2545a74f9e8bf6bdaba54670600a?s=32&&d=blank)\n\nAB![Andrew Branch  (2)](https://gravatar.com/avatar/86ed396e4ffb41b052654b9f8ad4d1caaf732bc42985860b0cac8191a66e33df?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (2)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)\n\n31+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","og:description":"The language primitives.","language":"en","title":"TypeScript: Documentation - Everyday Types","og:title":"Documentation - Everyday Types","ogDescription":"The language primitives.","generator":"Gatsby 5.13.5","ogTitle":"Documentation - Everyday Types","theme-color":"#3178C6","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","description":"The language primitives.","scrapeId":"e7936873-0846-45b8-8151-597b60d54b0d","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html","url":"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nNarrowing\n=========\n\nImagine we have a function called `padLeft`.\n\nts\n\n`   function padLeft(padding: number | string, input: string): string {    throw new Error(\"Not implemented yet!\");  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkRQAFkzgB3ath0BRJpqb4ARADk4UQbWQAbbLWxgo2dIgCe2KAEJTkgG5FAF8gA)\n\nIf `padding` is a `number`, it will treat that as the number of spaces we want to prepend to `input`. If `padding` is a `string`, it should just prepend `padding` to `input`. Let’s try to implement the logic for when `padLeft` is passed a `number` for `padding`.\n\nts\n\n`   function padLeft(padding: number | string, input: string): string {    return \" \".repeat(padding) + input;  Argument of type 'string | number' is not assignable to parameter of type 'number'.   Type 'string' is not assignable to type 'number'.2345Argument of type 'string | number' is not assignable to parameter of type 'number'.   Type 'string' is not assignable to type 'number'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAA4CGAJgDKQEUAUTzzVJAOaoSRALYAjGKAA+oRBWgDBAGlAD6RCqgVKhASh2LloAN55QoaJApFodAESgHAOmv1Ijbr34HQAanUSTQoAbjwAXyA)\n\nUh-oh, we’re getting an error on `padding`. TypeScript is warning us that we’re passing a value with type `number | string` to the `repeat` function, which only accepts a `number`, and it’s right. In other words, we haven’t explicitly checked if `padding` is a `number` first, nor are we handling the case where it’s a `string`, so let’s do exactly that.\n\nts\n\n`   function padLeft(padding: number | string, input: string): string {    if (typeof padding === \"number\") {      return \" \".repeat(padding) + input;    }    return padding + input;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkHBE+KAE9k2OGqIlyiALynEAIhoNm5yQuUrETbFBBMk5iwDpnO1AQNeOwBqQTBhKABuBwBfB2dXdxQMQzJEUKERaJigA)\n\nIf this mostly looks like uninteresting JavaScript code, that’s sort of the point. Apart from the annotations we put in place, this TypeScript code looks like JavaScript. The idea is that TypeScript’s type system aims to make it as easy as possible to write typical JavaScript code without bending over backwards to get type safety.\n\nWhile it might not look like much, there’s actually a lot going on under the covers here. Much like how TypeScript analyzes runtime values using static types, it overlays type analysis on JavaScript’s runtime control flow constructs like `if/else`, conditional ternaries, loops, truthiness checks, etc., which can all affect those types.\n\nWithin our `if` check, TypeScript sees `typeof padding === \"number\"` and understands that as a special form of code called a _type guard_. TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called _type guards_) and assignments, and the process of refining types to more specific types than declared is called _narrowing_. In many editors we can observe these types as they change, and we’ll even do so in our examples.\n\nts\n\n`   function padLeft(padding: number | string, input: string): string {    if (typeof padding === \"number\") {      return \" \".repeat(padding) + input;                            (parameter) padding: number    }    return padding + input;               (parameter) padding: string  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJRjuvRAG8AUIkHBE+KAE9k2OGqIlyiALynEAIhoNm5yQuUrETbFBBMk5iwDpnO1AQNeOwBqQTBhKABuBxUAeljHRKTEgD0AfgcAXwdnV3cUDEMyRFChEWi4hNSMzKA)\n\nThere are a couple of different constructs TypeScript understands for narrowing.\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards)\n`typeof` type guards\n---------------------------------------------------------------------------------------------------------\n\nAs we’ve seen, JavaScript supports a `typeof` operator which can give very basic information about the type of values we have at runtime. TypeScript expects this to return a certain set of strings:\n\n*   `\"string\"`\n*   `\"number\"`\n*   `\"bigint\"`\n*   `\"boolean\"`\n*   `\"symbol\"`\n*   `\"undefined\"`\n*   `\"object\"`\n*   `\"function\"`\n\nLike we saw with `padLeft`, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.\n\nIn TypeScript, checking against the value returned by `typeof` is a type guard. Because TypeScript encodes how `typeof` operates on different values, it knows about some of its quirks in JavaScript. For example, notice that in the list above, `typeof` doesn’t return the string `null`. Check out the following example:\n\nts\n\n`   function printAll(strs: string | string[] | null) {    if (typeof strs === \"object\") {      for (const s of strs) {  'strs' is possibly 'null'.18047'strs' is possibly 'null'.        console.log(s);      }    } else if (typeof strs === \"string\") {      console.log(strs);    } else {      // do nothing    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMBGUOAOABgBYB2AKADMBXAOwGMAXASzjtAAdoW6mBBADaCAFIiZJU4nnQDmoAD6hpvWQG0AuotB0awgJSgA3hVCgWVUCKYBPTpDiXpiUAF53oAERwARgCtIZk9DEzMzKgQrBnZxZVBHZQlEENMws2i6RDhBSAA6QThZMX0AblSzAF9UitBIQURIc0trOwcnJLcPTxU5YONy0AysnPzCsSTS6tr6xtCwkFAAEzgdOCYAC1VqigqgA)\n\nIn the `printAll` function, we try to check if `strs` is an object to see if it’s an array type (now might be a good time to reinforce that arrays are object types in JavaScript). But it turns out that in JavaScript, `typeof null` is actually `\"object\"`! This is one of those unfortunate accidents of history.\n\nUsers with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that `strs` was only narrowed down to `string[] | null` instead of just `string[]`.\n\nThis might be a good segue into what we’ll call “truthiness” checking.\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing)\nTruthiness narrowing\n===========================================================================================================\n\nTruthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript.\n\nIn JavaScript, we can use any expression in conditionals, `&&`s, `||`s, `if` statements, Boolean negations (`!`), and more. As an example, `if` statements don’t expect their condition to always have the type `boolean`.\n\nts\n\n``   function getUsersOnlineMessage(numUsersOnline: number) {    if (numUsersOnline) {      return `There are ${numUsersOnline} online now!`;    }    return \"Nobody's here. :(\";  }   ``[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwKZQKoGdUCcsDyYANjGKgLKpZYCGaAFGCALbZ6ElmoBcizLAEZ4AlIgDeAKESIYwRE1bt8RUuTFSZM3OhC4kAAwAqACzypEtHYgAk4gcs5rUAX0QJn-OAHcAhAYBuaUQXYJ0oPSQAIgA5OEE4ABMATwByLEQzHQA6RB4GKKCXIA)\n\nIn JavaScript, constructs like `if` first “coerce” their conditions to `boolean`s to make sense of them, and then choose their branches depending on whether the result is `true` or `false`. Values like\n\n*   `0`\n*   `NaN`\n*   `\"\"` (the empty string)\n*   `0n` (the `bigint` version of zero)\n*   `null`\n*   `undefined`\n\nall coerce to `false`, and other values get coerced to `true`. You can always coerce values to `boolean`s by running them through the `Boolean` function, or by using the shorter double-Boolean negation. (The latter has the advantage that TypeScript infers a narrow literal boolean type `true`, while inferring the first as type `boolean`.)\n\nts\n\n`  // both of these result in 'true'  Boolean(\"hello\"); // type: boolean, value: true  !!\"world\"; // type: true,    value: true  This kind of expression is always truthy.2872This kind of expression is always truthy.`[Try](https://www.typescriptlang.org/play/#code/PTAECMHsBcAtUgM1HApgZ1aAThgrgDbSgCWAdqAOTTZ6qUBQAQpJAagIZkAUARLKgIFIvAJQBuUCBQBPAA6oAXBFbsuAGlAA3DgTrKadBgEJjvAO6RsBACa9J06PKUpaqTaE869Lw6iA)\n\nIt’s fairly popular to leverage this behavior, especially for guarding against values like `null` or `undefined`. As an example, let’s try using it for our `printAll` function.\n\nts\n\n`   function printAll(strs: string | string[] | null) {    if (strs && typeof strs === \"object\") {      for (const s of strs) {        console.log(s);      }    } else if (typeof strs === \"string\") {      console.log(strs);    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRDGCIiJQogBkcxFACeyAKZxJVWQF49iAERwARgCs10AwJFixwOKikQExSok1NS10bbHOwhHA4agB0OHA0RHwA3D5iAL4+8YhqOIRq4pL4Kuoe2oh6OoZULFZCcYj+gcFhEdJesQnC8UA)\n\nYou’ll notice that we’ve gotten rid of the error above by checking if `strs` is truthy. This at least prevents us from dreaded errors when we run our code like:\n\ntxt\n\n`   TypeError: null is not iterable   `\n\nKeep in mind though that truthiness checking on primitives can often be error prone. As an example, consider a different attempt at writing `printAll`\n\nts\n\n`   function printAll(strs: string | string[] | null) {    // !!!!!!!!!!!!!!!!    //  DON'T DO THIS!    //   KEEP READING    // !!!!!!!!!!!!!!!!    if (strs) {      if (typeof strs === \"object\") {        for (const s of strs) {          console.log(s);        }      } else if (typeof strs === \"string\") {        console.log(strs);      }    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRAHpxiAISy58hdNESpiACIB5AHIByACrqNiPQAkAkgGUlYyWMQBpAKKOACogBKjrGrNaA4sq2isFyyjDAiEQkhAIidojhkVAAnsgApnARVISIALz5iABEcABGAFZp0IWxyvHAcKiREAjElIiZTKQ18fHNYIRwOGkAdDhwNER8ANy1dgC+s3OIaTiEaQkR+CnpHdl5BYVULNVCs2J9A0Oj41FdM-ELYgtzQA)\n\nWe wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly.\n\nTypeScript doesn’t hurt us here at all, but this behavior is worth noting if you’re less familiar with JavaScript. TypeScript can often help you catch bugs early on, but if you choose to do _nothing_ with a value, there’s only so much that it can do without being overly prescriptive. If you want, you can make sure you handle situations like these with a linter.\n\nOne last word on narrowing by truthiness is that Boolean negations with `!` filter out from negated branches.\n\nts\n\n`   function multiplyAll(    values: number[] | undefined,    factor: number  ): number[] | undefined {    if (!values) {      return values;    } else {      return values.map((x) => x * factor);    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwIJpoAUAUIogG4CGaIApgM4BciYIyARnQE4DaAuogA+icABM6wGGDpiANGUTAq0ONxZtOPEgEoN7Ln0Ejxk6bMQBvRTGCIiAQmq1GOq4vLc6UENyTP6BgBuRQBfRDo0Bjp3ck9vX38aQIA6ZCpMIiIADzcAXgA+RGzEAColFSg1HRDyUJJQoA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#equality-narrowing)\nEquality narrowing\n-------------------------------------------------------------------------------------------------------\n\nTypeScript also uses `switch` statements and equality checks like `===`, `!==`, `==`, and `!=` to narrow types. For example:\n\nts\n\n`   function example(x: string | number, y: string | boolean) {    if (x === y) {      // We can now call any 'string' method on 'x' or 'y'.      x.toUpperCase();              (method) String.toUpperCase(): string      y.toLowerCase();              (method) String.toLowerCase(): string    } else {      console.log(x);                   (parameter) x: string | number      console.log(y);                   (parameter) y: string | boolean    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUwB4EMC2AHANsgClQC5EBnKAJxjAHNEAfRMETAI2UoBpEBPUitTqNEbOHHzowASkQBvAFCJEMYIiKIAvNr6zFy5QHpDiAOrJEEKczgB3S+ly5EU3ogDkgmrXeJMyKAALOAATRAQPVF84Sg9edwA6JQNUBKg4AFVsbE4AYXQyQmkAbmSjEwA9AH4yvjS4ABk7PIKi0oNEY0Rq5IBfFFxC+VqIBDIJZATcOFoiEtqujqWejtGwcfwpmYJeeY7FpYMVxF6FXqA)\n\nWhen we checked that `x` and `y` are both equal in the above example, TypeScript knew their types also had to be equal. Since `string` is the only common type that both `x` and `y` could take on, TypeScript knows that `x` and `y` must be `string`s in the first branch.\n\nChecking against specific literal values (as opposed to variables) works also. In our section about truthiness narrowing, we wrote a `printAll` function which was error-prone because it accidentally didn’t handle empty strings properly. Instead we could have done a specific check to block out `null`s, and TypeScript still correctly removes `null` from the type of `strs`.\n\nts\n\n`   function printAll(strs: string | string[] | null) {    if (strs !== null) {      if (typeof strs === \"object\") {        for (const s of strs) {                           (parameter) strs: string[]          console.log(s);        }      } else if (typeof strs === \"string\") {        console.log(strs);                       (parameter) strs: string      }    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwE4zFAggGxwCgGcpVCAuRY9MAc0QB9KSMaBtAXQcTBDwEpEAbwBQiRDGCIiJQogCEAXgXdeOASLFiJUqAE9kAUziSqspcoBEcAEYArA9AvrRmscDiopEBMUqJjTKTOrq4A9KEhkYgAegD8LpHeYIRwOAYAdDhwNER8ANwJmgC+hUWIBjiEBuKS+HqGAaaI5ogWVCxOQoViSSlpmdnSQQWR4VGacaUuJUVAA)\n\nJavaScript’s looser equality checks with `==` and `!=` also get narrowed correctly. If you’re unfamiliar, checking whether something `== null` actually not only checks whether it is specifically the value `null` - it also checks whether it’s potentially `undefined`. The same applies to `== undefined`: it checks whether a value is either `null` or `undefined`.\n\nts\n\n`   interface Container {    value: number | null | undefined;  }  function multiplyValue(container: Container, factor: number) {    // Remove both 'null' and 'undefined' from the type.    if (container.value != null) {      console.log(container.value);                               (property) Container.value: number      // Now we can safely multiply 'container.value'.      container.value *= factor;    }  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHtx1NZBvAKGWQDc4AbAVwgC5kRKBbAI1wB97LzzkPKQAJhBg4BAbgIBfAgRj8EYYJmSMuigA7kAngDUK1ABQJMYbCGh0MWHFAA0yeAvRQ6DFtACU+IsgD0v5AAlCEZ0EhRmdDAAC2QAcgZuOOQ4QXj+IRFzAWSYKHRGZBiUMC11CAA6H2AYZCMTM2gKsioUAEIAXk5uL0JiYmMQAGd0ckrydABzeutzKGb9CA8Jfr8A1Y3N1YA9AH4ZVf9kADl0AHdkM5QEVOQhuBgIbRU1YE0teMHTGwXWuKrVl9GvMWtRkAAqLqOMDOFbIaSSIA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-in-operator-narrowing)\nThe `in` operator narrowing\n-----------------------------------------------------------------------------------------------------------------------\n\nJavaScript has an operator for determining if an object or its prototype chain has a property with a name: the `in` operator. TypeScript takes this into account as a way to narrow down potential types.\n\nFor example, with the code: `\"value\" in x`. where `\"value\"` is a string literal and `x` is a union type. The “true” branch narrows `x`’s types which have either an optional or required property `value`, and the “false” branch narrows to types which have an optional or missing property `value`.\n\nts\n\n`   type Fish = { swim: () => void };  type Bird = { fly: () => void };  function move(animal: Fish | Bird) {    if (\"swim\" in animal) {      return animal.swim();    }    return animal.fly();  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw4dRAVwB2AY2Bw6aqPjo0IJAIZqCJ8cXjIoAHz6DGFDByhQ4o0gCJcBbx56ZhbiLm7uUAIQwCoCQeb4lgB0fvjknO4sSu5RMXFQwYniSRIg6RwsQA)\n\nTo reiterate, optional properties will exist in both sides for narrowing. For example, a human could both swim and fly (with the right equipment) and thus should show up in both sides of the `in` check:\n\nts\n\n`   type Fish = { swim: () => void };  type Bird = { fly: () => void };  type Human = { swim?: () => void; fly?: () => void };  function move(animal: Fish | Bird | Human) {    if (\"swim\" in animal) {      animal;          (parameter) animal: Fish | Human    } else {      animal;          (parameter) animal: Bird | Human    }  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuy7hoACQCu+AIYA7NJmx58AfmkVU1ekzZQJIE6TMX5rTh1FrtAY2Bw6u-HQ0ECQ6BJrixPDIUAA+fILMcepa2hQYHFBQcKKkAES4BLlZuqFa4mkZmVCl4ZwA9HWZAHpGlSxQEOII0OlV1dph4vWNUC1tHCxAA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing)\n`instanceof` narrowing\n-------------------------------------------------------------------------------------------------------------\n\nJavaScript has an operator for checking whether or not a value is an “instance” of another value. More specifically, in JavaScript `x instanceof Foo` checks whether the _prototype chain_ of `x` contains `Foo.prototype`. While we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed with `new`. As you might have guessed, `instanceof` is also a type guard, and TypeScript narrows in branches guarded by `instanceof`s.\n\nts\n\n`   function logValue(x: Date | string) {    if (x instanceof Date) {      console.log(x.toUTCString());                   (parameter) x: Date    } else {      console.log(x.toUpperCase());                   (parameter) x: string    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgcwGoENkgKYAUAHgFyIAiWUeiAPogM5QBOMYaAlIgN4BQiiGMETFBYJlkh44wytS58BAiAgZxkeAHSo0xTVDgBVACoBhAMos2ujhwDc-JQHonSt0oB6AfkcBfRHjIDDSKSiri6lo6egaGAA5xeMymWMEEtg5uLu7u3n68vkA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#assignments)\nAssignments\n-----------------------------------------------------------------------------------------\n\nAs we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.\n\nts\n\n`   let x = Math.random() < 0.5 ? 10 : \"hello world!\";       let x: string | number  x = 1;  console.log(x);               let x: number  x = \"goodbye!\";  console.log(x);               let x: string   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EFkCGYAWA6ATkgdgEwHsBbACgEoIAeCABnQFYIB+CARhogC4IAiVEYMAIQA7gUzA8AQh4BuAFAB6RRAgA9JvJjxWC+QGMCOAM4FQ6IQHMSUMguWrHT9Zu29LBAngBGATxAyeoYmZiAWBNa29irOThpAA)\n\nNotice that each of these assignments is valid. Even though the observed type of `x` changed to `number` after our first assignment, we were still able to assign a `string` to `x`. This is because the _declared type_ of `x` - the type that `x` started with - is `string | number`, and assignability is always checked against the declared type.\n\nIf we’d assigned a `boolean` to `x`, we’d have seen an error since that wasn’t part of the declared type.\n\nts\n\n`   let x = Math.random() < 0.5 ? 10 : \"hello world!\";       let x: string | number  x = 1;  console.log(x);               let x: number  x = true;  Type 'boolean' is not assignable to type 'string | number'.2322Type 'boolean' is not assignable to type 'string | number'.  console.log(x);               let x: string | number   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABtIAXUAD1AF5QBZAQ0IAsA6aGgOwBM4BbACgEpQAHlAAGRgFZQAflABGEaFQAiepDx44oAO4I87AIRKA3DhChQAPSk4ylWSZwBjOK0RwCjDQHMeJPibNzIOCrGwpQQmgAV0gHZ1d3SE84Hz8AsGDMqyA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#control-flow-analysis)\nControl flow analysis\n-------------------------------------------------------------------------------------------------------------\n\nUp until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches. But there’s a bit more going on than just walking up from every variable and looking for type guards in `if`s, `while`s, conditionals, etc. For example\n\nts\n\n`   function padLeft(padding: number | string, input: string) {    if (typeof padding === \"number\") {      return \" \".repeat(padding) + input;    }    return padding + input;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABABwIYBMAyBTYUAUa66MYA5gFyJggC2ARtgE6IA+iAzlE6WQDSJSyEFCpce5AJSIA3gChEg4InxQAnsmxxlREuUQBeI4gBENBsxPT5ixU2xQQTJCdMA6e5tQFdvaQGpBMGEoAG4FRABfCPtHZxQMPTJEQKERcMigA)\n\n`padLeft` returns from within its first `if` block. TypeScript was able to analyze this code and see that the rest of the body (`return padding + input;`) is _unreachable_ in the case where `padding` is a `number`. As a result, it was able to remove `number` from the type of `padding` (narrowing from `string | number` to `string`) for the rest of the function.\n\nThis analysis of code based on reachability is called _control flow analysis_, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments. When a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point.\n\nts\n\n`   function example() {    let x: string | number | boolean;    x = Math.random() < 0.5;    console.log(x);                 let x: boolean    if (Math.random() < 0.5) {      x = \"hello\";      console.log(x);                   let x: string    } else {      x = 100;      console.log(x);                   let x: number    }    return x;            let x: string | number  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUwB4EMC2AHANsgCgEpEBvAKEUXykVQC5EBnKAJxjAHNEAfRMEJgBGyVr0RC4cfOjABucpTqIAvIgCy6KAAsAdK1kATOJmKIAPIgAMugKwKlEBE2nJduOJwKoiCqgHp-KmCQxAA9AH5FKhhgRAJNHX0jEzNLG1sSChDUVUQAIm1kXA98v2CnMBd8d09vXyUAoNCQyKUAXxRcJmQyRuU1AEYrK3KqSuq3Dy8fMcRAltaoqnboxFZkKBBWJFRyhaXydqA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)\nUsing type predicates\n-------------------------------------------------------------------------------------------------------------\n\nWe’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.\n\nTo define a user-defined type guard, we simply need to define a function whose return type is a _type predicate_:\n\nts\n\n`   function isFish(pet: Fish | Bird): pet is Fish {    return (pet as Fish).swim !== undefined;  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw6MIAY3EBDAdFEBXAHYrgcOnqgBzCMADK+dePEAFS+WLxkUAD59BjTgHo-KABaEJUdYBCgjl0DIxMoRDckEkhgV0QUL34hMmJUhIRYDMwOKCgtYB0BUxTLKHVCpLIAOlwCKABCVHR9ZVE4PQhfDhYgA)\n\n`pet is Fish` is our type predicate in this example. A predicate takes the form `parameterName is Type`, where `parameterName` must be the name of a parameter from the current function signature.\n\nAny time `isFish` is called with some variable, TypeScript will _narrow_ that variable to that specific type if the original type is compatible.\n\nts\n\n`   // Both calls to 'swim' and 'fly' are now okay.  let pet = getSmallPet();  if (isFish(pet)) {    pet.swim();  } else {    pet.fly();  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMoBfAbgChRIoAhOAE7N0WAGYAbEMXJVaDZuw6MIAY3EBDAdFEBXAHYrgcOnqgBzCMADK+dePEAFS+WLxkUAD59BjTroNGJlCIbkgkkMCuiChe-EJkxBHBCLDRmBxQUFrAOgKm4ZZQ6imhZAB0uARQAISo6PrKonB6EL4cLBwA9J1QALT9KjrA-b1dPbx0wCgqduIpwHRQAOSV+EtFesxLEiDrmtB6dDhQdADW6iBlHOKFSegW1rb2TsDknBxwoqQh0QXAZBQMBkoBEKnh8G92lAIHNoEDMqCdpCWEA)\n\nNotice that TypeScript not only knows that `pet` is a `Fish` in the `if` branch; it also knows that in the `else` branch, you _don’t_ have a `Fish`, so you must have a `Bird`.\n\nYou may use the type guard `isFish` to filter an array of `Fish | Bird` and obtain an array of `Fish`:\n\nts\n\n`   const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];  const underWater1: Fish[] = zoo.filter(isFish);  // or, equivalently  const underWater2: Fish[] = zoo.filter(isFish) as Fish[];  // The predicate may need repeating for more complex examples  const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {    if (pet.name === \"sharkey\") return false;    return isFish(pet);  });   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYglgZwBZQLxQN5QQdzgWwC4oAKASjQD4oA3AezgBMBuKAOwEN8JiFgAnOGwDmUAL7MAUKEhQAQnH6M0mKADMANiGLkqtBi3Zce2AUNETJjCAGMNHftDUBXNjeBw6bKMIjAAyvgcGhoACn7kxPDIUAA+8ooski5uHl5QiNFIJJDAUYgo8QpKZMS5GQiwBZiSUFCOwM783jl+UByVWWQAdLgEUACEqOiu1mpCEElikgD0M1AAtEs2zsBLC5I2XnxQAF50dDpZcQklANoAuipnvgFBIeHA5AA0Pn6BwWERZK+3Hw-fC5SLZsHajCD8ADqHGAEIAjPlkJcVPs6N1xhpYfwSJkCmQpHMoHR+K8IABHZxwGjBCBsYBaTbbYBQcFQmEQgBMiKQyPQqPRcExEJxCC67U6BUuUlm8wAKkhoGBHIw4DZ2VAgiB2BBJvUIJAYeZ1MSNcToFt8GANBAAB5QW1cK0QBCM0HM1nQrEAZm5vL2BwFQuxrWApSg5UQVRiqGoGFqGTUpFy3U43DQwygACJkA4ANYQECZigNJreNTBBAQKR1EvNCpZEP4yRifFAA)\n\nIn addition, classes can [use `this is Type`](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-based-type-guards)\n to narrow their type.\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#assertion-functions)\nAssertion functions\n---------------------------------------------------------------------------------------------------------\n\nTypes can also be narrowed using [Assertion functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions)\nDiscriminated unions\n===========================================================================================================\n\nMost of the examples we’ve looked at so far have focused around narrowing single variables with simple types like `string`, `boolean`, and `number`. While this is common, most of the time in JavaScript we’ll be dealing with slightly more complex structures.\n\nFor some motivation, let’s imagine we’re trying to encode shapes like circles and squares. Circles keep track of their radiuses and squares keep track of their side lengths. We’ll use a field called `kind` to tell which shape we’re dealing with. Here’s a first attempt at defining `Shape`.\n\nts\n\n`   interface Shape {    kind: \"circle\" | \"square\";    radius?: number;    sideLength?: number;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyA1qACYBcyARAsFAgDYTXIA+NAzgI4CucUFgG5CyKHDLBenAPxUQvALYAjaCKKdgZCABkIIAOZh0c5ApVr8AXyA)\n\nNotice we’re using a union of string literal types: `\"circle\"` and `\"square\"` to tell us whether we should treat the shape as a circle or square respectively. By using `\"circle\" | \"square\"` instead of `string`, we can avoid misspelling issues.\n\nts\n\n`   function handleShape(shape: Shape) {    // oops!    if (shape.kind === \"rect\") {  This comparison appears to be unintentional because the types '\"circle\" | \"square\"' and '\"rect\"' have no overlap.2367This comparison appears to be unintentional because the types '\"circle\" | \"square\"' and '\"rect\"' have no overlap.      // ...    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAJYB2ALjAGYCGAxpKAMoAWlADnQN56igDWxAJqgBE1AtGoAbSENAAfUEMQBHAK6Vo0gNxdQ0SvwIrEAflREVAWwBGMbd0QF+kADKQiAcxKNToc9dt4AL54eCCgALSR1CokkeF45CpE1CQEcESgzET8UkyskAAUiMxsqHlsAJSgnNxhcHAsiACEOgTkoEUlkAB0fNmgALxDChopQlU13KBh3bM6wYFAA)\n\nWe can write a `getArea` function that applies the right logic based on if it’s dealing with a circle or square. We’ll first try dealing with circles.\n\nts\n\n`   function getArea(shape: Shape) {    return Math.PI * shape.radius ** 2;  'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoASwDsAXGAMwEMBjSUAZQAsmAHdgN7lQoANY0AJqgBELStBYAbSNNAAfUNMQBHAK5NoKgNzDQ0JhMq7EAflTVdAWwBGMEyMSUJkADKRqAOa0XHagDi5u5AC+5OQgoAC0SSy6tEkJ5Ay61Cy0lHDUoAGQtACChkwAFIg8-KjcfJAAlKBCIoa0utCFALJMwQB0AAoAkqAAVKA1jQPmltYTk2gmUUA)\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n that gives us an error - which is appropriate since `radius` might not be defined. But what if we perform the appropriate checks on the `kind` property?\n\nts\n\n`   function getArea(shape: Shape) {    if (shape.kind === \"circle\") {      return Math.PI * shape.radius ** 2;  'shape.radius' is possibly 'undefined'.18048'shape.radius' is possibly 'undefined'.    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoASwDsAXGAMwEMBjSUAZQAsmAHdgN7lQoANY0AJqgBELStBYAbSNNAAfUNMQBHAK5NoKgNzDQ0JhMq7EAflTVdAWwBGMEyMSUJkADKRqAOa0XHagDi5u5AC+5OQgoAC0SSy6tEkJ5Ay61Cy0lHDUoAGQtACChkwAFIg8-KjcfJAAlKBCIpQMoNW1kAB04tQSoAC8o5pyCsrSLW0iZiW60IUAskzBvQAKAJKgAFSgNY295pbWe-to7qAxUUA)\n\nHmm, TypeScript still doesn’t know what to do here. We’ve hit a point where we know more about our values than the type checker does. We could try to use a non-null assertion (a `!` after `shape.radius`) to say that `radius` is definitely present.\n\nts\n\n`   function getArea(shape: Shape) {    if (shape.kind === \"circle\") {      return Math.PI * shape.radius! ** 2;    }  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8BQyyA1qACYBcyARAsFAgDYTXIA+NAzgI4CucUFgG5CyKHDLBenAPxUQvALYAjaCKKdgZCABkIIAOZh0c5ApVr8AX3z4A9HeQBaFwl5gXT-DF4gEYYAB7EGQDCDAAQUE4AApOTBwqDGwIAEpkAiJgGGQ4hIgAOlIQMmQAXgqaOgZmanTMojFw3igQgFk4YwKABQBJZAAqZHiUgvFJaQBCQaGAJnVkGysgA)\n\nBut this doesn’t feel ideal. We had to shout a bit at the type-checker with those non-null assertions (`!`) to convince it that `shape.radius` was defined, but those assertions are error-prone if we start to move code around. Additionally, outside of [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n we’re able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them). We can definitely do better.\n\nThe problem with this encoding of `Shape` is that the type-checker doesn’t have any way to know whether or not `radius` or `sideLength` are present based on the `kind` property. We need to communicate what _we_ know to the type checker. With that in mind, let’s take another swing at defining `Shape`.\n\nts\n\n`   interface Circle {    kind: \"circle\";    radius: number;  }  interface Square {    kind: \"square\";    sideLength: number;  }  type Shape = Circle | Square;   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1JiA)\n\nHere, we’ve properly separated `Shape` out into two types with different values for the `kind` property, but `radius` and `sideLength` are declared as required properties in their respective types.\n\nLet’s see what happens here when we try to access the `radius` of a `Shape`.\n\nts\n\n`   function getArea(shape: Shape) {    return Math.PI * shape.radius ** 2;  Property 'radius' does not exist on type 'Shape'.   Property 'radius' does not exist on type 'Square'.2339Property 'radius' does not exist on type 'Shape'.   Property 'radius' does not exist on type 'Square'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBLAOwBcYAzAQwGNJQBhfaKgG1oG9dRQBrIgE1QAiKoxaRBAbk6hoFPvgCuKUIQUBbAEYwpAX1wES5arQDKARwUVo7ab0IDQgxBavipXRPj6QAMpEIA5sQAFqiqmtq4erjEAJ4ADqbBFImgALz0oqygAD6g5pbWUrggoAC0FVQKxBVluGQKhFTE+HCEoAGQxACC1hQAFIjJiagmw5AAlKAcXNbECtDtALIUIQB0AAoAkqAAVKBDKZBrsvJKe-toukA)\n\nLike with our first definition of `Shape`, this is still an error. When `radius` was optional, we got an error (with [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n enabled) because TypeScript couldn’t tell whether the property was present. Now that `Shape` is a union, TypeScript is telling us that `shape` might be a `Square`, and `Square`s don’t have `radius` defined on them! Both interpretations are correct, but only the union encoding of `Shape` will cause an error regardless of how [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n is configured.\n\nBut what if we tried checking the `kind` property again?\n\nts\n\n`   function getArea(shape: Shape) {    if (shape.kind === \"circle\") {      return Math.PI * shape.radius ** 2;                          (parameter) shape: Circle    }  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1FnwAejjkAFoUhC4wFKT8GC4QBDBgAHsQZGsIMABBdTgACh5fbyoFBogASmQCImAYZDqWgDotMkCAoNoQxnbOojZyrigSgFk4e36ABQBJZAAqZHq-CH72Tl4d3YAmIxmEmdu7mYA9AH5WSXEgA)\n\nThat got rid of the error! When every type in a union contains a common property with literal types, TypeScript considers that to be a _discriminated union_, and can narrow out the members of the union.\n\nIn this case, `kind` was that common property (which is what’s considered a _discriminant_ property of `Shape`). Checking whether the `kind` property was `\"circle\"` got rid of every type in `Shape` that didn’t have a `kind` property with the type `\"circle\"`. That narrowed `shape` down to the type `Circle`.\n\nThe same checking works with `switch` statements as well. Now we can try to write our complete `getArea` without any pesky `!` non-null assertions.\n\nts\n\n`   function getArea(shape: Shape) {    switch (shape.kind) {      case \"circle\":        return Math.PI * shape.radius ** 2;                            (parameter) shape: Circle      case \"square\":        return shape.sideLength ** 2;                  (parameter) shape: Square    }  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJUsAE8ADortxvyAF40ehxkAB9kZVV1FnwAejjkAFoUhC4wFKT8GC4QBDBgAHsQZGsIMABBdTgACh5fbyoFBogASmQCYwB3YDAEO2Q6loA6LTJ2zqJkBDgeFFoQxgpWKbZyrigSgFk4e2GABQBJZAAqZHq-CGH2Tl5Ts4AmIymE1bf3ogA9AH4V6dn5npoks-kR1GANiULt5hiYzJYbPZ7sgnn9Xu8fqxJOIgA)\n\nThe important thing here was the encoding of `Shape`. Communicating the right information to TypeScript - that `Circle` and `Square` were really two separate types with specific `kind` fields - was crucial. Doing that lets us write type-safe TypeScript code that looks no different than the JavaScript we would’ve written otherwise. From there, the type system was able to do the “right” thing and figure out the types in each branch of our `switch` statement.\n\n> As an aside, try playing around with the above example and remove some of the return keywords. You’ll see that type-checking can help avoid bugs when accidentally falling through different clauses in a `switch` statement.\n\nDiscriminated unions are useful for more than just talking about circles and squares. They’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client/server communication), or encoding mutations in a state management framework.\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type)\nThe `never` type\n=================================================================================================\n\nWhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a `never` type to represent a state which shouldn’t exist.\n\n[](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#exhaustiveness-checking)\nExhaustiveness checking\n=================================================================================================================\n\nThe `never` type is assignable to every type; however, no type is assignable to `never` (except `never` itself). This means you can use narrowing and rely on `never` turning up to do exhaustive checking in a `switch` statement.\n\nFor example, adding a `default` to our `getArea` function which tries to assign the shape to `never` will not raise an error when every possible case has been handled.\n\nts\n\n`   type Shape = Circle | Square;  function getArea(shape: Shape) {    switch (shape.kind) {      case \"circle\":        return Math.PI * shape.radius ** 2;      case \"square\":        return shape.sideLength ** 2;      default:        const _exhaustiveCheck: never = shape;        return _exhaustiveCheck;    }  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMLCggNig3gKGWQGtQATALmQCIENsJqBuQ5KOM4AVwGcqQuAWwBG0FgF98+UJFiIUAZQCOXOFDytSISjR4q1jFkR7AyEADIQQAczAALfkNFQJ+APRvkAWh8IuYHy98MABPAAdFOzgI5ABeNHocZAAfZGVVdRZ8GC4QBDBgAHsQZGsIMABBdTgACh4oiKoFBogASmQCYwB3YDAEO2Q6loA6LTJ2zqJkBDgeFFpExgpWKbZyrigSgFk4e2GABQBJZAAqZHroiGH2Tl5Ts4AmIymZud19dWpl1aJ1MA2ShcIsMTGZLDZ7PdkE8VsgzPAuFgwN8fghijwwMgAPoQAAeUV4BQAbhBUHYIAhiPwICSoHFzi1nqs-gDsXiCRjgCSyRTiM9JOIgA)\n\nAdding a new member to the `Shape` union, will cause a TypeScript error:\n\nts\n\n`   interface Triangle {    kind: \"triangle\";    sideLength: number;  }  type Shape = Circle | Square | Triangle;  function getArea(shape: Shape) {    switch (shape.kind) {      case \"circle\":        return Math.PI * shape.radius ** 2;      case \"square\":        return shape.sideLength ** 2;      default:        const _exhaustiveCheck: never = shape;  Type 'Triangle' is not assignable to type 'never'.2322Type 'Triangle' is not assignable to type 'never'.        return _exhaustiveCheck;    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lAGE9pKAbGgbx1FAGtCATVAESUGzSAIDcHUNHK88AVxSgC8gLYAjGJIC+OfMTJUaAZQCO88tDZSeBfqAGJzlsZM6I8vSABlIBAOZEABaoKhpaOLogoAC0cZTyRHEx+iTQFNSgACrQeOQBLKDsnLb2AkS5+f4sElIeXr4BwaFqmtA6ekQAngAOJkHkfaAAvHQihQA+oGYWVqBTOXkFkJI4pPIElER4cASg-pBEAIJW5AAUiAN9qMZXkACURXUA7nhElEGgF3cAdKWPxU4oEo5EQNCE4zEyCkQOkh3k0D2AFlyMEfgAFACSoAAVKBLoNID8ZHJFLi8Wg3ECQWCHE5ZlCYUCrEQEXsCX0fvUfH5Ap8cRSqZwvBR5EwiNDYZxKLtEERQAB9SAADwGim2ADdILQgpBKFxQpAtdARvi7kLmfDEYqVWq5XgtTq9VwqbptEA)\n\n[### Everyday Types\\\n\\\nThe language primitives.](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)\n\n[### More on Functions\\\n\\\nLearn about how Functions work in TypeScript.](https://www.typescriptlang.org/docs/handbook/2/functions.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Narrowing.md)\n ❤\n\nContributors to this page:  \n\nRC![Ryan Cavanaugh  (52)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nSB![Siarhei Bobryk  (2)](https://gravatar.com/avatar/4660d4b2ddaaa85219ef02fa5e815dd88cd34d6c97fa96de46cfd9a03ef94733?s=32&&d=blank)\n\nAB![Andrew Branch  (2)](https://gravatar.com/avatar/86ed396e4ffb41b052654b9f8ad4d1caaf732bc42985860b0cac8191a66e33df?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (2)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)\n\n27+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","title":"TypeScript: Documentation - Narrowing","ogTitle":"Documentation - Narrowing","ogDescription":"Understand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects.","og:title":"Documentation - Narrowing","og:description":"Understand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects.","twitter:site":"typescriptlang","generator":"Gatsby 5.13.5","theme-color":"#3178C6","description":"Understand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects.","scrapeId":"67487f7c-0c90-460d-b13d-d9374036030e","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/narrowing.html","url":"https://www.typescriptlang.org/docs/handbook/2/narrowing.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nObject Types\n============\n\nIn JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through _object types_.\n\nAs we’ve seen, they can be anonymous:\n\nts\n\n`   function greet(person: { name: string; age: number }) {    return \"Hello \" + person.name;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIgN6JgCGAtumYVKjGMgNyLXINUi0AjAogC+ASgoAoRIgD0smYqXLlAPXUbNW7TtXTEGKCFRIARAAl0AGytxEpxAGpE+IggB0Neu0kigA)\n\nor they can be named by using either an interface:\n\nts\n\n`   interface Person {    name: string;    age: number;  }  function greet(person: Person) {    return \"Hello \" + person.name;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyA9CcRcgHo21HIhwC2EAXMhmFKAOYDc9ODzYMArkwBG0AQF8CBGKJAIwwHMh5QIEMAAoADphzt0UbCACU+elrCiouAEQAJCABs3WZI+QBqZIZmOAB0jCyyQA)\n\nor a type alias:\n\nts\n\n`   type Person = {    name: string;    age: number;  };  function greet(person: Person) {    return \"Hello \" + person.name;  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbwFBSgHpCoA9ci-KVAQwFsIAuKRYeAS1QHMBuKmrk2oBXOgCMEfAL59cAM2GoAxsHZooXeBAjAAFJCRpmcQ6gCUOKluDD46AEQAJCABsXyKPagBqKAZSoAHS0DNJAA)\n\nIn all three examples above, we’ve written functions that take objects that contain the property `name` (which must be a `string`) and `age` (which must be a `number`).\n\n[](https://www.typescriptlang.org/docs/handbook/2/objects.html#quick-reference)\nQuick Reference\n-----------------------------------------------------------------------------------------------\n\nWe have cheat-sheets available for both [`type` and `interface`](https://www.typescriptlang.org/cheatsheets)\n, if you want a quick look at the important every-day syntax at a glance.\n\n[](https://www.typescriptlang.org/docs/handbook/2/objects.html#property-modifiers)\nProperty Modifiers\n-----------------------------------------------------------------------------------------------------\n\nEach property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)\nOptional Properties\n\nMuch of the time, we’ll find ourselves dealing with objects that _might_ have a property set. In those cases, we can mark those properties as _optional_ by adding a question mark (`?`) to the end of their names.\n\nts\n\n`   interface PaintOptions {    shape: Shape;    xPos?: number;    yPos?: number;  }  function paintShape(opts: PaintOptions) {    // ...  }  const shape = getShape();  paintShape({ shape });  paintShape({ shape, xPos: 100 });  paintShape({ shape, yPos: 100 });  paintShape({ shape, xPos: 100, yPos: 100 });   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUIB6acgC0ihLTCL5hUJFiIUABTiaA8liasAzslyFkyM2IgieE68gAeu5mYD8IkLQC2AEbQkjayNgB6LgCeHt6+AcFQocjhyFFEhHQMpmxYBuBO-MwmZiL6RiYsIGYCli7hAHTNhJkI5mC29sgAvBxcRYKS+ZqDuF28yPgCwwXc9nzjdrwANG5xIgCMAAzbUzOEI4ULS-ZrsZ5bu-uzoycTOGvul8g72+cbr9fT4kA)\n\nIn this example, both `xPos` and `yPos` are considered optional. We can choose to provide either of them, so every call above to `paintShape` is valid. All optionality really says is that if the property _is_ set, it better have a specific type.\n\nWe can also read from those properties - but when we do under [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n, TypeScript will tell us they’re potentially `undefined`.\n\nts\n\n`   function paintShape(opts: PaintOptions) {    let xPos = opts.xPos;                       (property) PaintOptions.xPos?: number | undefined    let yPos = opts.yPos;                       (property) PaintOptions.yPos?: number | undefined    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6KxsPZDD9Lu6egD1bcsrvG1r6nKbhzXbOntn9fvNOpuXCfCA)\n\nIn JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value `undefined`. We can just handle `undefined` specially by checking for it.\n\nts\n\n`   function paintShape(opts: PaintOptions) {    let xPos = opts.xPos === undefined ? 0 : opts.xPos;           let xPos: number    let yPos = opts.yPos === undefined ? 0 : opts.yPos;           let yPos: number    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6Kxtamrr6UhhQCGJkW2QABmQRBubWzQ9kMP0APVtyyu82uvGmle0OzpBu3v7BkbGcjZ9p2eQF81mm28J8IA)\n\nNote that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it.\n\nts\n\n`   function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {    console.log(\"x coordinate at\", xPos);                                      (parameter) xPos: number    console.log(\"y coordinate at\", yPos);                                      (parameter) yPos: number    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTflwDIwAaSx9kAF5kAAZ87xtisuR8ESVVdRYQTQEdcwQtZnIIADpyZnY+ACILZE7mKGJQOEhkWeH8qxsBD2Qw-U2t7Z3d-QA9Ww6unv7Bkc9x5knpkFmUBYqfVfMNvfeP5EPX8N6-wnwQA)\n\nHere we used [a destructuring pattern](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n for `paintShape`’s parameter, and provided [default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values)\n for `xPos` and `yPos`. Now `xPos` and `yPos` are both definitely present within the body of `paintShape`, but optional for any callers to `paintShape`.\n\n> Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript.\n> \n> ts\n> \n> `   function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {    render(shape);  Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'?    render(xPos);  Cannot find name 'xPos'.2304Cannot find name 'xPos'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAgTUBOT0TlxATAKzeeicAzAAYALLVSQszcumqgAygAsyieQG8AvrQAm1dMjJN5JAK6R0WVNEihjkPUwAUAD2LmA1jADukAJQA3PRgALRh6KZYYSG0ZhZWNqA6TGTeTuqglCpqxMqq1AA0oC4ACtAcoJCm8ABGzKAAvKAAjMLCoMAAVAB0vZ1gmn6g6rSgdtQOzE5Z+YGj45POpeVzmkA)\n> \n> In an object destructuring pattern, `shape: Shape` means “grab the property `shape` and redefine it locally as a variable named `Shape`.” Likewise `xPos: number` creates a variable named `number` whose value is based on the parameter’s `xPos`.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties)\n`readonly` Properties\n\nProperties can also be marked as `readonly` for TypeScript. While it won’t change any behavior at runtime, a property marked as `readonly` can’t be written to during type-checking.\n\nts\n\n``   interface SomeType {    readonly prop: string;  }  function doSomething(obj: SomeType) {    // We can read from 'obj.prop'.    console.log(`prop has the value '${obj.prop}'.`);    // But we can't re-assign it.    obj.prop = \"hello\";  Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.  }   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKAMpwC2kAKgJ4AOdA3nqKGiRKAEzhEANu1Cd4nVIhLRiAcwDceAL5485AK5FqJAuNBjGLEgAtVACjgAjAFaoLbLpACUoPgJCgAdTpqSiJBYRFQcngmUAByRycAOlk4Tjik-lBqcUQ4CUgkiTgVWwADVM5QK0pEUGs6ADdKCT06OIASHkSUuU0Mss8NLP8AIT0SUAB3YNC4yaEAWlrEAhUwghJMgR7K0ABeUAAiK0gJYqONTSA)\n\nUsing the `readonly` modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to.\n\nts\n\n``   interface Home {    readonly resident: { name: string; age: number };  }  function visitForBirthday(home: Home) {    // We can read and update properties from 'home.resident'.    console.log(`Happy birthday ${home.resident.name}!`);    home.resident.age++;  }  function evict(home: Home) {    // But we can't write to the 'resident' property itself on a 'Home'.    home.resident = {  Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property.      name: \"Victor the Evictor\",      age: 42,    };  }   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKABJwC2dA3nqKNJJQCZxEANgE8ukRAV6RSqVqCKUWqRCWjEA5gG5QldZFREArkwBGMUAF9NeC3jzlDRaiQIDQANwISSAMQQAhAmgSAAteSmEAChDmfQZYgEpQdk4QUAB1OmpKIjE+HSJeUEMAB3CyUBL4EpgXcVByeCZQAHIYlgA6bgkpUhaOjlBqAUQ4QUgOwTh1SIADekoSktETINDw0QASVnaJ7slpEg6FFgsAQlmE605drvED0g7dSABqF+tbe0dnV1zIT2c0ViqEYLCSKVAaX8hhIoAA7lkci1YXC1BUSHBQKE6C19r0SC1KtVaqICCREJBBORQG5KK1QZB+oNbnjDqAALzJQacE5xABEADUCM4EFiQnQAKIAjHQPkAGm5Oj0qCwaAVnCsNiAA)\n\nIt’s important to manage expectations of what `readonly` implies. It’s useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn’t factor in whether properties on two types are `readonly` when checking whether those types are compatible, so `readonly` properties can also change via aliasing.\n\nts\n\n`   interface Person {    name: string;    age: number;  }  interface ReadonlyPerson {    readonly name: string;    readonly age: number;  }  let writablePerson: Person = {    name: \"Person McPersonface\",    age: 42,  };  // works  let readonlyPerson: ReadonlyPerson = writablePerson;  console.log(readonlyPerson.age); // prints '42'  writablePerson.age++;  console.log(readonlyPerson.age); // prints '43'   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LAL4ECoSLEQoAShDgATHABsAnuijZchYlFkKQKkuU616IZqx3ylyth2oge-KEJGKIYZAHd6YOLzdqGtSBOMgAvPispBTUAEQhuACyCAnwSLEANKzsnAAsAExZgiwEAPSlXlhQANYYBG4elnoqCdQyVvqqmKER3sC+-hAJJQg42G4AdIpYDAAUTdYJEzkAlEzI5cgADqZgGMgA5AUHBH0DAd0gyxwA1DcsoyDjEFMz87qLl9cQaxsVO2J9kcAMwHIA)\n\nUsing [mapping modifiers](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers)\n, you can remove `readonly` attributes.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)\nIndex Signatures\n\nSometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values.\n\nIn those cases you can use an index signature to describe the types of possible values, for example:\n\nts\n\n`   interface StringArray {    [index: number]: string;  }  const myArray: StringArray = getStringArray();  const secondItem = myArray[1];              const secondItem: string   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBlDGLVAgQRhigE8AKASgC54yKrb6GBuAFAB6YfAC0ksMgyTxgyhhAxEUMAi6UadRvADeg+PADalUAA8OqZAFsARsoC6HAM7ktQgL6DBYPG-gbBl5GDk0eHQZ4AF5CYnDtPlYhP1QAl3A8YABJJRsYwODI4wBGRyFRIyqAPQB+IA)\n\nAbove, we have a `StringArray` interface which has an index signature. This index signature states that when a `StringArray` is indexed with a `number`, it will return a `string`.\n\nOnly some types are allowed for index signature properties: `string`, `number`, `symbol`, template string patterns, and union types consisting only of these.\n\nIt is possible to support multiple types of indexers...\n\nIt is possible to support multiple types of indexers. Note that when using both \\`number\\` and \\`string\\` indexers, the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a `number`, JavaScript will actually convert that to a `string` before indexing into an object. That means that indexing with `100` (a `number`) is the same thing as indexing with `\"100\"` (a `string`), so the two need to be consistent.\n\nts\n\n`   interface Animal {    name: string;  }  interface Dog extends Animal {    breed: string;  }  // Error: indexing with a numeric string might get you a completely separate type of Animal!  interface NotOkay {    [x: number]: Animal;  'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.    [x: string]: Dog;  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBmAUCBIgC7QCWAxsQArwAOMxAngJIB2ZxZAhgDZkAvblzhtUAMz6JIeMm2IxJFSKACCHALZ9QAbzyhQbbhsioS5NgHMA3HgC+eWfMXdloACJxLoSAA8FbAAmiGqa2noGAEbQkJCBZqRyNvaOhACisAiocoF+SaAA7pwAFqDchgCuJuQUoOb5GmSWxcSglpCtTHAVZaAUcBp0vB2QvEx1kHTc0MIqzAygcOKhZFq8AIROCtBKKgBycMQA8gDW3OMRoADavqhsVZEwALqo6qt8tgY3CRaWLx5eWx2IA)\n\nWhile string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that `obj.property` is also available as `obj[\"property\"]`. In the following example, `name`’s type does not match the string index’s type, and the type checker gives an error:\n\nts\n\n`   interface NumberDictionary {    [index: string]: number;    length: number; // ok    name: string;  Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMWBQIIZ4lVMdcBLAOwBcYAzAQwGNJQA5AVwFsAjGACIVmNCnCqNoAT1ABvXKFABtagBNIAD1SIa0agHMAuqio9+0ANy4FoADaQq+mgAsTZmBdAE4AaxsTuSG1dAysAXyA)\n\nHowever, properties of different types are acceptable if the index signature is a union of the property types:\n\nts\n\n`   interface NumberOrStringDictionary {    [index: string]: number | string;    length: number; // ok, length is a number    name: string; // ok, name is a string  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaB5KAZTClAHMARYBMYAexDigE9kBvAKGWQG1QATCAA8AXMgDOJcgF0xILLijIAPhKkgyAbi7IANhA1gAFnIXRNyAPSXkdANYAaPQbLHkwccjjJ5OaDsZMCDFJUg0La1tHHzgg909vUPIOAF8gA)\n\nFinally, you can make index signatures `readonly` in order to prevent assignment to their indices:\n\nts\n\n`  interface ReadonlyStringArray {    readonly [index: number]: string;  }  let myArray: ReadonlyStringArray = getReadOnlyStringArray();  myArray[2] = \"Mallory\";  Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.`[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMAlEKYAeVQgE8BlDGLVAgQRhiloAoBKAFzwyFPHUbNWHLrQDcAKAD0i+AFp1YZBnWqlKgAIhOOGAGchAJgCsAFgvyWGI4ihgEI4GIZMW7Tt3gAb3l4eDhRGlp4AG0WUAAPIVRkAFsAIyMAXSFTH1YFAF95eQhieBTaaW4hDy8JXyqogF5CYg9qcTy-GX4FCsboi0z4FoAiAFkoCAgTWlHZIA)\n\nYou can’t set `myArray[2]` because the index signature is `readonly`.\n\n[](https://www.typescriptlang.org/docs/handbook/2/objects.html#excess-property-checks)\nExcess Property Checks\n-------------------------------------------------------------------------------------------------------------\n\nWhere and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation.\n\nts\n\n`  interface SquareConfig {    color?: string;    width?: number;  }  function createSquare(config: SquareConfig): { color: string; area: number } {    return {      color: config.color || \"red\",      area: config.width ? config.width * config.width : 20,    };  }  let mySquare = createSquare({ colour: \"red\", width: 100 });  Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2Dk5ykFSglgCeEbygALzekL6Q15CBiS1lqD2Qff16S8ZUABGHY7AqxTRAA)\n\nNotice the given argument to `createSquare` is spelled _`colour`_ instead of `color`. In plain JavaScript, this sort of thing fails silently.\n\nYou could argue that this program is correctly typed, since the `width` properties are compatible, there’s no `color` property present, and the extra `colour` property is insignificant.\n\nHowever, TypeScript takes the stance that there’s probably a bug in this code. Object literals get special treatment and undergo _excess property checking_ when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error:\n\nts\n\n`  let mySquare = createSquare({ colour: \"red\", width: 100 });  Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEi0yqgepA+v09EtjKgAIw7HYFWKaIA)\n\nGetting around these checks is actually really simple. The easiest method is to just use a type assertion:\n\nts\n\n`   let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEptjKgAIw7PagOAAByYZCoz1QO0aeEK9EQbC4kQE81imiAA)\n\nHowever, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way. If `SquareConfig` can have `color` and `width` properties with the above types, but could _also_ have any number of other properties, then we could define it like so:\n\nts\n\n`   interface SquareConfig {    color?: string;    width?: number;    [propName: string]: unknown;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OmEAGsQBYSEEBfIA)\n\nHere we’re saying that `SquareConfig` can have any number of properties, and as long as they aren’t `color` or `width`, their types don’t matter.\n\nOne final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since assigning `squareOptions` won’t undergo excess property checks, the compiler won’t give you an error:\n\nts\n\n`   let squareOptions = { colour: \"red\", width: 100 };  let mySquare = createSquare(squareOptions);   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iCAvlSoxMIBGGBE6uOJAzZcACnrEyHUznxESpAJQcKdRsw7deIAcns4DjklaGRVSiFcMEwoEEjaWnomKA4rJwA6ZOZkAB9c5AAiXDFCgBohWkC0xzIM0QlJZBYPa1J68SlkACpWzIaujgAmAAYK2lU1KgB6aeQAWkWETDBF+aoGCDAuLHsAeQAHPSJOZABeSg8mWI5iiFKykU7JDgBGEZHwwU3t+QBPOy4c6GCDGCCAiDmTi7XCHY4gTjOfhAA)\n\nThe above workaround will work as long as you have a common property between `squareOptions` and `SquareConfig`. In this example, it was the property `width`. It will however, fail if the variable does not have any common object property. For example:\n\nts\n\n`  let squareOptions = { colour: \"red\" };  let mySquare = createSquare(squareOptions);  Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYME4BQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCqmzETNCE2SIiYpLQqL6hAHSlCKAAPvWgAERsms0ANKoiyRUhfFUa2jqgUtF+vINauqAAVOPVQzOoaAAMXSIWlrggoAC0B1RMxAd7uOKQxKCIzEEA8gAOjlyIoAC8gtGS+aitkO2ZFQXK5GACegTY7xckDckAhkC8N08kEez0IiDCSiAA)\n\nKeep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs.\n\nThat means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a `color` or `colour` property to `createSquare`, you should fix up the definition of `SquareConfig` to reflect that.\n\n[](https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-types)\nExtending Types\n-----------------------------------------------------------------------------------------------\n\nIt’s pretty common to have types that might be more specific versions of other types. For example, we might have a `BasicAddress` type that describes the fields necessary for sending letters and packages in the U.S.\n\nts\n\n`   interface BasicAddress {    name?: string;    street: string;    city: string;    country: string;    postalCode: string;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvkA)\n\nIn some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an `AddressWithUnit`.\n\nts\n\n`   interface AddressWithUnit {    name?: string;    unit: string;    street: string;    city: string;    country: string;    postalCode: string;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIIBN1QgZxwdWDAAsBVEI5AbwChlkQ4BbCAfgC5kcwpQBzANx1kAVwphO3XiEE0A9HIB6ylapXCpECBK49+Q+giIBPSXpkHkCAPZiep3dNn0ADte5wANgGFr6CGZOQgC+QA)\n\nThis does the job, but the downside here is that we had to repeat all the other fields from `BasicAddress` when our changes were purely additive. Instead, we can extend the original `BasicAddress` type and just add the new fields that are unique to `AddressWithUnit`.\n\nts\n\n`   interface BasicAddress {    name?: string;    street: string;    city: string;    country: string;    postalCode: string;  }  interface AddressWithUnit extends BasicAddress {    unit: string;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvhQqhIsRCnyFiGAOoyAFgCqIDLIEAAekCB4pOhYuAREJOT8mjK2ShT2QA)\n\nThe `extends` keyword on an `interface` allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, `AddressWithUnit` didn’t need to repeat the `street` property, and because `street` originates from `BasicAddress`, a reader will know that those two types are related in some way.\n\n`interface`s can also extend from multiple types.\n\nts\n\n`   interface Colorful {    color: string;  }  interface Circle {    radius: number;  }  interface ColorfulCircle extends Colorful, Circle {}  const cc: ColorfulCircle = {    color: \"red\",    radius: 42,  };   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xxoksiKqYFASYUJMlDgATYLlo0QuALYAjaG07dw0eEjSU8mQcNHIIAD0ggptfdkMAaNEJFjNFEPXIIaGezHxjV2QAXiJScgMaACIoCClohwjJGTkaABYAJiT2FiA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)\nIntersection Types\n-----------------------------------------------------------------------------------------------------\n\n`interface`s allowed us to build up new types from other types by extending them. TypeScript provides another construct called _intersection types_ that is mainly used to combine existing object types.\n\nAn intersection type is defined using the `&` operator.\n\nts\n\n`   interface Colorful {    color: string;  }  interface Circle {    radius: number;  }  type ColorfulCircle = Colorful & Circle;   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xoksiKqwKAkwoSZKHAAmwXLRohcAWwBG0Np2JgAngAd+lPJgFCRyALxoDMfMgBkaQcIgsgA)\n\nHere, we’ve intersected `Colorful` and `Circle` to produce a new type that has all the members of `Colorful` _and_ `Circle`.\n\nts\n\n``  function draw(circle: Colorful & Circle) {    console.log(`Color was ${circle.color}`);    console.log(`Radius was ${circle.radius}`);  }  // okay  draw({ color: \"blue\", radius: 42 });  // oops  draw({ color: \"red\", raidus: 42 });  Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAMJwA2C5Ark6AN56ijXMEqRCWjEA5gG48AX0KkKNOvQLRqTOjz7RKAEwJsUoImwC2AIxjS5IUAFoH1NiQd287ItRIE4RULp0AdwAKalV1SFRGFmh2TgAyBnCNAEpuXn5fRGZIADoWcWCAA2iEUEDKRFAAEi4wtQ1cgRiZIpTpPgEibMaC4oAlPQMqiqra+ojcnX1DVvbZPDxbOABrSgBPPADKEK5MmNQAInMmNkhDgBpQaeHULDRQGXmlsDg4AAdELaDgveahUCHaCQXSXa6UAi6Qx3B5PSRAA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/objects.html#interface-extension-vs-intersection)\nInterface Extension vs. Intersection\n----------------------------------------------------------------------------------------------------------------------------------------\n\nWe just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an `extends` clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.\n\nIf interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error.\n\nIn the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results.\n\nFor example, the following code will throw an error because the properties are incompatible:\n\nts\n\n`   interface Person {    name: string;  }  interface Person {    name: number;  }   `\n\nIn contrast, the following code will compile, but it results in a `never` type:\n\nts\n\n`   interface Person1 {    name: string;  }  interface Person2 {    name: number;  }  type Staff = Person1 & Person2  declare const staffer: Staff;  staffer.name;             (property) name: never   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsQEZkDeAUMsiHALYQBcyGYUoA5gNxEC+RRoksiK6KNhAAmQiTKUaZAK4UARtDaciYAJ4AHFAGUwcGDGQBeNJhz4AZKaE4RXACYQEAGzhQUCHPTp6D0Wrr6MGz0QdAAdORUbAD0MaQJpAB6APxAA)\n\nIn this case, Staff would require the name property to be both a string and a number, which results in property being of type `never`.\n\n[](https://www.typescriptlang.org/docs/handbook/2/objects.html#generic-object-types)\nGeneric Object Types\n---------------------------------------------------------------------------------------------------------\n\nLet’s imagine a `Box` type that can contain any value - `string`s, `number`s, `Giraffe`s, whatever.\n\nts\n\n`   interface Box {    contents: any;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5k4QBPAbjwF8g)\n\nRight now, the `contents` property is typed as `any`, which works, but can lead to accidents down the line.\n\nWe could instead use `unknown`, but that would mean that in cases where we already know the type of `contents`, we’d need to do precautionary checks, or use error-prone type assertions.\n\nts\n\n`   interface Box {    contents: unknown;  }  let x: Box = {    contents: \"hello world\",  };  // we could check 'x.contents'  if (typeof x.contents === \"string\") {    console.log(x.contents.toLowerCase());  }  // or we could use a type assertion  console.log((x.contents as string).toLowerCase());   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5kBXEAaxHQHcQBuPAXzzwBsIwyTNQzYAvLgJESkCtQBEACwi9e6ZM3RReAE3kAaLhzwB6ExpTEauosoT1kAckwA6YqQqO8wGMgAUYACeAA4Q6L6u7rJg5Mhi8cjy5GBQoADm8gCUkoTu5Oj8LmppfpEyZDEuYOgAMizQAMJw5BB+mZkc3KbmWhbS1jq0LchwyEGhI+QtUGDAJHh5BRBF6CWlbuUUk8jJqSBpmVW19VBNLW0dQA)\n\nOne type safe approach would be to instead scaffold out different `Box` types for every type of `contents`.\n\nts\n\n`   interface NumberBox {    contents: number;  }  interface StringBox {    contents: string;  }  interface BooleanBox {    contents: boolean;  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lADkBXAWwCMYAhOAD1AG8dRQlOMUjEUoAk1bQA3DgC+OfCOgVqoAMpFohAOYdufAUJFjUibXrmLlJVVRoc4AG0jkCB3v0HCSZ0MxwLm4E1kA)\n\nBut that means we’ll have to create different functions, or overloads of functions, to operate on these types.\n\nts\n\n`   function setContents(box: StringBox, newContents: string): void;  function setContents(box: NumberBox, newContents: number): void;  function setContents(box: BooleanBox, newContents: boolean): void;  function setContents(box: { contents: any }, newContents: any) {    box.contents = newContents;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaAhAewA9kBvAKGWQQPAnAGcAuZELXKAbnIF9zzQkWIhQBlMFFABzQiQpUadRiwYTp3PgLrCkyQgQA2EOCFllK1WpGXJsBQ8ZAbyAehfIAtF4TowXj+Qw6CAIYMC0yAwQYADCVvRgDAAUdkQs4pIgMsQANKwQAO5xSokqalkAlCwAbgTAACbcQSFhEVGx8YwpxCwYOPi5+UWdpazs0FXItQ1NwaHhIJHRxdaJ3Wl69kYmsnkghSsJzLZbjpPTjYFzrYvth12pLKSWJccmAJ7IPHsHI28g7wq5ioqQAdIpVgxkABeIb3RIaIA)\n\nThat’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.\n\nInstead, we can make a _generic_ `Box` type which declares a _type parameter_.\n\nts\n\n`   interface Box<Type> {    contents: Type;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA)\n\nYou might read this as “A `Box` of `Type` is something whose `contents` have type `Type`”. Later on, when we refer to `Box`, we have to give a _type argument_ in place of `Type`.\n\nts\n\n`   let box: Box<string>;   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSgen7IAtKIQBXMKOGUANhDDIARljYYcTMFFABzEpyA)\n\nThink of `Box` as a template for a real type, where `Type` is a placeholder that will get replaced with some other type. When TypeScript sees `Box<string>`, it will replace every instance of `Type` in `Box<Type>` with `string`, and end up working with something like `{ contents: string }`. In other words, `Box<string>` and our earlier `StringBox` work identically.\n\nts\n\n`   interface Box<Type> {    contents: Type;  }  interface StringBox {    contents: string;  }  let boxA: Box<string> = { contents: \"hello\" };  boxA.contents;            (property) Box<string>.contents: string  let boxB: StringBox = { contents: \"world\" };  boxB.contents;            (property) StringBox.contents: string   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfS0SLEQoAymCigA5hkwVqtepGZsm4qdz6UANhDDIARlgCCbGdlUSQksgF4KChsuQAiABYQtW9M+Q9uhzCMAOjpHMCZuAHpImmQAPQB+Sm1dAyxUNjFLaSxkO3IHJXC2ZwB3dCgtABMfP0oA1BDFRnComJpEoA)\n\n`Box` is reusable in that `Type` can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new `Box` type at all (though we certainly could if we wanted to).\n\nts\n\n`   interface Box<Type> {    contents: Type;  }  interface Apple {    // ....  }  // Same as '{ contents: Apple }'.  type AppleBox = Box<Apple>;   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSy0JFiIUAQUKEANiio0A9HOQA6FUt78FyAMpwAtijhNkAcnK16kZm3FSUPY2rBExE6RkzIAvGizYb0kk4gA)\n\nThis also means that we can avoid overloads entirely by instead using [generic functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#generic-functions)\n.\n\nts\n\n`   function setContents<Type>(box: Box<Type>, newContents: Type) {    box.contents = newContents;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSygPQDkAWjEIArmDEjKMCSARhg9ZEwhgAwvUjM8RUgAoARljYYcHUgBpkICAHdtDZmysBKCtWSnMAOjoXMCZkAF47R2ddYO4eIA)\n\nIt is worth noting that type aliases can also be generic. We could have defined our new `Box<Type>` interface, which was:\n\nts\n\n`   interface Box<Type> {    contents: Type;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA)\n\nby using a type alias instead:\n\nts\n\n`   type Box<Type> = {    contents: Type;  };   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBVwQHxQLxQN4BQUUAxnAHbASUDOAXFGpANwEC+zQA)\n\nSince type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.\n\nts\n\n`   type OrNull<Type> = Type | null;  type OneOrMany<Type> = Type | Type[];  type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;               type OneOrManyOrNull<Type> = OneOrMany<Type> | null  type OneOrManyOrNullStrings = OneOrManyOrNull<string>;                   type OneOrManyOrNullStrings = OneOrMany<string> | null   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGBQAXATwAdJQB5aAOQFcAbOgHgBUTIA+UAXlFdNAA+oAHb06AblwE2FYZEoBZAIbDCLNpx58yQ7QG0AupOn9ycxSsKVaDdaU0VqYxmfnRlqux3aSQofwB6APxSRKbm7pbWYgDK+NAAlsIA5ojcsm4eVk62iPFJyT64foFBQA)\n\nWe’ll circle back to type aliases in just a little bit.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/objects.html#the-array-type)\nThe `Array` Type\n\nGeneric object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.\n\nIt turns out we’ve been working with a type just like that throughout this handbook: the `Array` type. Whenever we write out types like `number[]` or `string[]`, that’s really just a shorthand for `Array<number>` and `Array<string>`.\n\nts\n\n`   function doSomething(value: Array<string>) {    // ...  }  let myArray: string[] = [\"hello\", \"world\"];  // either of these work!  doSomething(myArray);  doSomething(new Array(\"hello\", \"world\"));   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAG4CGANiNgFyICCATsxQJ4A8AzlM4UQB8ASkQBvAFCJEAehmIAdEokBfCRKq5EmdizbsGvfsQDaAXUQBeRCYBEebFSpxbAGkS2A7nGZVktswBudTlEbBh8bGZEOGBESO5sRG9mAGsAQglUDBx8ARIdPQ5hYOysXAJiEjBsTyZWDhJ7R2c3DxS-W2ESoA)\n\nMuch like the `Box` type above, `Array` itself is a generic type.\n\nts\n\n`   interface Array<Type> {    /**     * Gets or sets the length of the array.     */    length: number;    /**     * Removes the last element from an array and returns it.     */    pop(): Type | undefined;    /**     * Appends new elements to an array, and returns the new length of the array.     */    push(...items: Type[]): number;    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsBkEsBGAuUAXATgVwKYCh5I0cMAzAQwGMdQA5LAW0RNAG8BfAoki60AZUyEA5m06FiZKjQBC0aABsc5SGK6TeNfgE8mitSFABaE5SxoTR9T2mgAghgzltAHgAq2gA44AfGzygoMAAVMEBgcGgAOI4aADOoNAYoHGxCWgAFjRKkMKZiaToWaDkjs4AdOGgwcDhOXkZqJCMzBgA3HjhIWGB1aAASjgM0ABuOOnFCuRxaKA4Sgw4RKCkGNAMJaqlTtqbACagGLFYGJAJ8GiVvTXhntCeABQAlKge3qAAPqBYkHs4pIQcHsOl1QlVInZPN5fglIDgAO5zBZLeLoaCbEplbQAGn2h2OpwmNDhiPq+WghUyNG2FXBtUCniwcQyD3KbIuQziry8OAA2gBdF6gZpMEggwKGNmVdhAA)\n\nModern JavaScript also provides other data structures which are generic, like `Map<K, V>`, `Set<T>`, and `Promise<T>`. All this really means is that because of how `Map`, `Set`, and `Promise` behave, they can work with any sets of types.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/objects.html#the-readonlyarray-type)\nThe `ReadonlyArray` Type\n\nThe `ReadonlyArray` is a special type that describes arrays that shouldn’t be changed.\n\nts\n\n``   function doStuff(values: ReadonlyArray<string>) {    // We can read from 'values'...    const copy = values.slice();    console.log(`The first value is ${values[0]}`);    // ...but we can't mutate 'values'.    values.push(\"hello!\");  Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.  }   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUACVI3BsV4BPAIKxuUgDyJy0SsQDmAPgCUoAN65QoEKADqkUKW61oYuqHzwAtqADkPfoLcA6P0asaFUCABylQAF5QTwFEH0ReSlJIdh0AbgDSILheSB9eOA12AAMAFQALS3xKJHJovgFQSkRQABJ9GMEAbQAGAF0AX2L03ADTPx8AI0I6gHdLa2I3OucZ7nJLDwbvHwDOuJDCRHL2ACJK3gKAQlORgaA)\n\nMuch like the `readonly` modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns `ReadonlyArray`s, it tells us we’re not meant to change the contents at all, and when we see a function that consumes `ReadonlyArray`s, it tells us that we can pass any array into that function without worrying that it will change its contents.\n\nUnlike `Array`, there isn’t a `ReadonlyArray` constructor that we can use.\n\nts\n\n`  new ReadonlyArray(\"red\", \"green\", \"blue\");  'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcBmAUAHaQDuoASpAIYAmcBANgJ4CCsljAFAETSTVcAaUFwDmvSAUHCARvQCukLgEoA3EA)\n\nInstead, we can assign regular `Array`s to `ReadonlyArray`s.\n\nts\n\n`   const roArray: ReadonlyArray<string> = [\"red\", \"green\", \"blue\"];   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBATiAgnOBDAngLhgJQKaoAm4ANusmugDzRwCWYA5gHwwC8MA2gERx6HcANDG6M+eMEJEAjEgFc83ALoBuIA)\n\nJust as TypeScript provides a shorthand syntax for `Array<Type>` with `Type[]`, it also provides a shorthand syntax for `ReadonlyArray<Type>` with `readonly Type[]`.\n\nts\n\n``   function doStuff(values: readonly string[]) {    // We can read from 'values'...    const copy = values.slice();    console.log(`The first value is ${values[0]}`);    // ...but we can't mutate 'values'.    values.push(\"hello!\");  Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.  }   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUNEjcGxXgE9QictErEA5gG0AugEpQAb1yhQIPYaPGToAHoXLV6xd36wAdUihS3WiLGh88ALagA5Dz8gv4AdOF2pDSyLnAADtIAvKBBAoihiLyUpJDs6gDckdFwvJChvHCK7AAGACoAFs74lEjkKXwCoJSIoAAkWqmCygAMqgC+1QW4dgbhoQBGhG0A7s6uxP5tPkvc5M6BHSGhdoPpcYSI9ewARI28FQCE11NjQA)\n\nOne last thing to note is that unlike the `readonly` property modifier, assignability isn’t bidirectional between regular `Array`s and `ReadonlyArray`s.\n\nts\n\n`  let x: readonly string[] = [];  let y: string[] = [];  x = y;  y = x;  The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYAMaBQAbSAF1AA9VpIBDAEzgDt8BPURI6AS3oHMBtAXVABeUAIDcBYqCao2nHgOGj+E3KSVMJLEaTFA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)\nTuple Types\n\nA _tuple type_ is another sort of `Array` type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.\n\nts\n\n`   type StringNumberPair = [string, number];   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8ACgIaLxQC8UA2gM4IqoA0UyO+8AugNwBQA9PyjCRoseKgA9aTNlzJQA)\n\nHere, `StringNumberPair` is a tuple type of `string` and `number`. Like `ReadonlyArray`, it has no representation at runtime, but is significant to TypeScript. To the type system, `StringNumberPair` describes arrays whose `0` index contains a `string` and whose `1` index contains a `number`.\n\nts\n\n`   function doSomething(pair: [string, number]) {    const a = pair[0];           const a: string    const b = pair[1];           const b: number    // ...  }  doSomething([\"hello\", 42]);   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyIDaAzlNYUQDSJgiYBG2agF0AlIgDeAKESIICFogqIAvIko0GABiEBuaYgD0BmTIB6Afn1ywCvirVVqDAIy79Rk4gvvjAOn+SAL6SkqgYOPjsJAwARHjYADYJcDFcACwATKI6QA)\n\nIf we try to index past the number of elements, we’ll get an error.\n\nts\n\n`   function doSomething(pair: [string, number]) {    // ...    const c = pair[2];  Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCcBmAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWioA2ogrQevADSgSRVgCMYAXQCUoAN55QoEKAB0ZvAdBla0q6AC8oEWIloNAbjwBfIA)\n\nWe can also [destructure tuples](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring)\n using JavaScript’s array destructuring.\n\nts\n\n`   function doSomething(stringHash: [string, number]) {    const [inputString, hash] = stringHash;    console.log(inputString);                      const inputString: string    console.log(hash);                   const hash: number  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAM5QBOhRAEgIZl4BciA2hdcQDSJgiYARtkoBdAJSIA3gChEiCAgrtCABxBQ0VGrzyM8oxAF5EnGgyYBuGXIVK4AG2wA6B3FJqNWrkXHX5APQB8iGhiAB6APw28opgZI4ubqR6TH62QWFhUTIAvkA)\n\n> Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements `0` and `1` to whatever we wanted.\n> \n> However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.\n\nOther than those length checks, simple tuple types like these are equivalent to types which are versions of `Array`s that declare properties for specific indexes, and that declare `length` with a numeric literal type.\n\nts\n\n`   interface StringNumberPair {    // specialized properties    length: 2;    0: string;    1: number;    // Other 'Array<string | number>' members...    slice(start?: number, end?: number): Array<string | number>;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMpiqA5gOQK4C2ARtAApzBTIDeAUMsgPSPIDOADhAsHADbAAvCABNk7KAHtOUMMAit6yXhBBYwACwBcyAEwBuRQAZtrDNgMMAjNpCESUA4ubIA8hujIA5AEEoUOACeADymmKrIAD7ItsTQAHyeyAQQsVCsAHSZiqz8SAAUpnAyAPw2dtAANMgqwqXR5VAAlNq+-sGh2JH1qXEGAL5AA)\n\nAnother thing you may be interested in is that tuples can have optional properties by writing out a question mark (`?` after an element’s type). Optional tuple elements can only come at the end, and also affect the type of `length`.\n\nts\n\n``   type Either2dOr3d = [number, number, number?];  function setCoordinate(coord: Either2dOr3d) {    const [x, y, z] = coord;                  const z: number | undefined    console.log(`Provided coordinates had ${coord.length} dimensions`);                                                      (property) length: 2 | 3  }   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAoglsAFhATgJgCYHkUGYNQC8UA2gHYCuAtgEaoA0UltDT1dKA-ALoDcAUPwBmFMgGNgcAPZkoAZwjAAwlKkoMcMgENgEABRjV6gFywEydNjwYAlFADe-KFENk5wUgA9GIRgC9uIhcjDAFnAHpw52iY5wA9TkFnVzkpABsIADo0qQBzPQADAAUUKQA3OAwIAkM1DW1dOShELQIAEnta9WyIMlykAF8oDSpeuWk3ApswqEjY+YXFpaWE-gGgA)\n\nTuples can also have rest elements, which have to be an array/tuple type.\n\nts\n\n`   type StringNumberBooleans = [string, number, ...boolean[]];  type StringBooleansNumber = [string, ...boolean[], number];  type BooleansStringNumber = [...boolean[], string, number];   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3AChQkWGzQlyVWljwEGzVkjSDho9ZK48t8GfPDRVY2nH0Ze2xkyECRa8RK572Zi6W0kA)\n\n*   `StringNumberBooleans` describes a tuple whose first two elements are `string` and `number` respectively, but which may have any number of `boolean`s following.\n*   `StringBooleansNumber` describes a tuple whose first element is `string` and then any number of `boolean`s and ending with a `number`.\n*   `BooleansStringNumber` describes a tuple whose starting elements are any number of `boolean`s and ending with a `string` then a `number`.\n\nA tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.\n\nts\n\n`   const a: StringNumberBooleans = [\"hello\", 1];  const b: StringNumberBooleans = [\"beautiful\", 2, true];  const c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3ACgA9PKgBaVQGNMwVctlritYFEoAuWGzRY8BEuSq0GzAEQALCGTLFHXAIwzd+1ihcUzgkC15rUTs6RiZHfEpNRAAzTDIvKAAmLgRMCD89Ayg1EPMMCKIo6hinAHdieDIAEwyAZhz4PK5kyjIaCA6uqB6+gahc-OkgA)\n\nWhy might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in [rest parameters and arguments](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters-and-arguments)\n, so that the following:\n\nts\n\n`   function readButtonInput(...args: [string, number, ...boolean[]]) {    const [name, version, ...input] = args;    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBQB016yA5gM4BciA2g1MjGHQDSJgQAWwBGqZP2qURcOABsMYVgF1lASkQBvAFCJEEBBzZh0Q1PwBu4hvDCTq3MlGWIAvIlqMA3LsQB6P0QpbQBfIA)\n\nis basically equivalent to:\n\nts\n\n`   function readButtonInput(name: string, version: number, ...input: boolean[]) {    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBRjoC2qAXIgM5TIxgDmANIgG6rKN4YBmBDUARv24A6WWzJQG4uHAA2GMAG0AugEpEAbwBQiRAHoziWdKMBfIA)\n\nThis is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-tuple-types)\n`readonly` Tuple Types\n\nOne final note about tuple types - tuple types have `readonly` variants, and can be specified by sticking a `readonly` modifier in front of them - just like with array shorthand syntax.\n\nts\n\n`   function doSomething(pair: readonly [string, number]) {    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyLXYWpgA2AnogNoDOU1hIgBpEYEJgBG2agF0AlIgDeAKESIA9OrXaduvdoB6R4ydNmTqjVoB0t5QF8gA)\n\nAs you might expect, writing to any property of a `readonly` tuple isn’t allowed in TypeScript.\n\nts\n\n`   function doSomething(pair: readonly [string, number]) {    pair[0] = \"hello!\";  Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWipokYYxIAbAJ6gA2ogrQevADSgSRVgCMYAXQCUoAN55QoEWKU4joALygARJ0izZcAISuA3HgAvkA)\n\nTuples tend to be created and left un-modified in most code, so annotating types as `readonly` tuples when possible is a good default. This is also important given that array literals with `const` assertions will be inferred with `readonly` tuple types.\n\nts\n\n`  let point = [3, 4] as const;  function distanceFromOrigin([x, y]: [number, number]) {    return Math.sqrt(x ** 2 + y ** 2);  }  distanceFromOrigin(point);  Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.   The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.   The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUADaQAuoADnAJYB2pAvKANoYA0oWAuqAIaKgDGcaomIBuPHgBmAV2r9ilIaAAmlEdzmQAYvAC2AeWiUA5jQAUjAB5sAnh1SNq03QCMYbJ65gcAlKADeeKCg0CTS0NSgALLcxAAWAHSIAI7QxGaWoABUWeigANSgNtm5aD7iAL4SquqaOnAGRqbUZhQ0xOVAA)\n\nHere, `distanceFromOrigin` never modifies its elements, but expects a mutable tuple. Since `point`’s type was inferred as `readonly [3, 4]`, it won’t be compatible with `[number, number]` since that type can’t guarantee `point`’s elements won’t be mutated.\n\n[### More on Functions\\\n\\\nLearn about how Functions work in TypeScript.](https://www.typescriptlang.org/docs/handbook/2/functions.html)\n\n[### Creating Types from Types\\\n\\\nAn overview of the ways in which you can create more types from existing types.](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Object%20Types.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (52)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)\n\nOT![Orta Therox  (16)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\n3![38elements  (2)](https://gravatar.com/avatar/42fa33f4abe38332521af807b218cf50a663c2eaa0a1d0d67b8cd0d630e18eee?s=32&&d=blank)\n\nBR![Bruce Robertson  (2)](https://gravatar.com/avatar/767f24e9ea0ec0c6a35dceec531073373a75fe45b01d3d9fcacac5b90685641a?s=32&&d=blank)\n\nAR![Alan Rempel  (2)](https://gravatar.com/avatar/84169e1e9274061346599a2b98b2dbb1c60adaf2a0341a4f29407643153a900c?s=32&&d=blank)\n\n23+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"How TypeScript describes the shapes of JavaScript objects.","ogTitle":"Documentation - Object Types","title":"TypeScript: Documentation - Object Types","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","generator":"Gatsby 5.13.5","og:description":"How TypeScript describes the shapes of JavaScript objects.","twitter:site":"typescriptlang","og:title":"Documentation - Object Types","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","description":"How TypeScript describes the shapes of JavaScript objects.","scrapeId":"f163924e-4d74-46ba-bfe2-833f21fa2975","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/objects.html","url":"https://www.typescriptlang.org/docs/handbook/2/objects.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nMore on Functions\n=================\n\nFunctions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class. They’re also values, and just like other values, TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions.\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-type-expressions)\nFunction Type Expressions\n---------------------------------------------------------------------------------------------------------------------\n\nThe simplest way to describe a function is with a _function type expression_. These types are syntactically similar to arrow functions:\n\nts\n\n`   function greeter(fn: (a: string) => void) {    fn(\"Hello, World\");  }  function printToConsole(s: string) {    console.log(s);  }  greeter(printToConsole);   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFMMALkVwENiBnKVGMZASkQF4A+RANzhgBNGBvALAAoRIgK4ARAAl0AG1lwANIgDqcVLO4T6AbmEBfYcNCRYCRAAcaYKABU4AYQQU4s9LgqVqtBokEjECGdXdAA6BWQPXQMjITRMbDwrWjtHYLddIA)\n\nThe syntax `(a: string) => void` means “a function with one parameter, named `a`, of type `string`, that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly `any`.\n\n> Note that the parameter name is **required**. The function type `(string) => void` means “a function with a parameter named `string` of type `any`“!\n\nOf course, we can use a type alias to name a function type:\n\nts\n\n`   type GreetFunction = (a: string) => void;  function greeter(fn: GreetFunction) {    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwBiBXAdgY2ASwPbpQC8UAFAIYBcUAzsHDugOYCUxAfFAG544AmAbgCwAKABmGbPkJMESCHFJj01eIhSTcBNgG9RUKAHpDUAHTnRAXyA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#call-signatures)\nCall Signatures\n-------------------------------------------------------------------------------------------------\n\nIn JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a _call signature_ in an object type:\n\nts\n\n`   type DescribableFunction = {    description: string;    (someArg: number): boolean;  };  function doSomething(fn: DescribableFunction) {    console.log(fn.description + \" returned \" + fn(6));  }  function myFunc(someArg: number) {    return someArg > 3;  }  myFunc.description = \"default description\";  doSomething(myFunc);   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAIhDOBjATgSwEYEN0BsIDEBXAO0WFQHtioBeKAbwFgAoKKAEwRVTHKoC4o8YGmIBzANws2ACngUAthACCyMYOKEF6CMgCUg9BQp5MxKcwC+FgGYkylauwoBlRRGAALVOJk3ignBIaFi4BPZ8xHoM0lCIVPJ4AHQ4FGJ+xEmcwTyRUADUUABEUMgehMjEEOzFBVD+MgBsenoWliwsdqR5CiBEpHLuqupQmtq60UyspeWVQkNqUAB8UADMbSy9-YhZXGi8jrTFnDaYhDjAHHu5jkUWLM5uSl4+6Vv2rUA)\n\nNote that the syntax is slightly different compared to a function type expression - use `:` between the parameter list and the return type rather than `=>`.\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#construct-signatures)\nConstruct Signatures\n-----------------------------------------------------------------------------------------------------------\n\nJavaScript functions can also be invoked with the `new` operator. TypeScript refers to these as _constructors_ because they usually create a new object. You can write a _construct signature_ by adding the `new` keyword in front of a call signature:\n\nts\n\n`   type SomeConstructor = {    new (s: string): SomeObject;  };  function fn(ctor: SomeConstructor) {    return new ctor(\"hello\");  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgeQEYCsIGNhQLxQCGAdiANwCwAUAPQ1QC0TWArsEw9aJLIhAMJxiAZ2AAnFjjhj8UAN7UoUYhADuUABTCAXFFFiAlsQDmASl3wkaTDkpUAvnYBmLYjgNCoT4hqliLfIIi4pLA0qbyilBiEMAsYsTKalB+GgBEABYQADbZcGmmdvZAA)\n\nSome objects, like JavaScript’s `Date` object, can be called with or without `new`. You can combine call and construct signatures in the same type arbitrarily:\n\nts\n\n``   interface CallOrConstruct {    (n?: number): string;    new (s: string): Date;  }  function fn(ctor: CallOrConstruct) {    // Passing an argument of type `number` to `ctor` matches it against    // the first definition in the `CallOrConstruct` interface.    console.log(ctor(10));                   (parameter) ctor: CallOrConstruct (n?: number) => string    // Similarly, passing an argument of type `string` to `ctor` matches it    // against the second definition in the `CallOrConstruct` interface.    console.log(new ctor(\"10\"));                       (parameter) ctor: CallOrConstruct new (s: string) => Date  }  fn(Date);   ``[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJwDYYPJVQexAGcwoBXBMZAbwFgAoZZAChAH4AuZEMgWwCNoASi4kooAOYBuBkxAQA7iyKjSkkcgAicSDPoBfBgxhkQlYIWQwQzSvihd0WXAWKkKYITVnIA9L+QABTgiIklkOBAIqAk+CHBkfBhkMABPAAcUAAMeAWgslPxkLLsoAt4dBAALCCJkYCo4CThQEh9-FJqrYCgSZAATCBhQBoso0E7spxw8QjEPAtBIWEQIADofBDn8DHWMfAlbMHtmAEYABiEhPSZbu-uOgD02I0Y-AIBlYF5gDDgoDCpAA0yHSITCIAkESi-1ivHiVCSKQy2TEkgKx2KpXKlRqdQa7QCTRabkmyCIEC2IH6AyGIzAY3qUTAXSy0xcc3clEW4Gg8CQGzeVKIOz2B1YimQpWYACILjKrjd7srlU8XgZXtZmNpINcgA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#generic-functions)\nGeneric Functions\n-----------------------------------------------------------------------------------------------------\n\nIt’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:\n\nts\n\n`   function firstElement(arr: any[]) {    return arr[0];  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAFAIaqoBci5YAngNoC6AlIgN4CwAUIolR4oIVEkqomABhYBuPgF8gA)\n\nThis function does its job, but unfortunately has the return type `any`. It’d be better if the function returned the type of the array element.\n\nIn TypeScript, _generics_ are used when we want to describe a correspondence between two values. We do this by declaring a _type parameter_ in the function signature:\n\nts\n\n`   function firstElement<Type>(arr: Type[]): Type | undefined {    return arr[0];  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAPACoCeADngHwAUAhqqgFyJW0DaAugJQcueRAB9E4ACZ4UYPJMQBvALAAoRIlR4oIVEhapuABl4BuNQF8gA)\n\nBy adding a type parameter `Type` to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:\n\nts\n\n`   // s is of type 'string'  const s = firstElement([\"a\", \"b\", \"c\"]);  // n is of type 'number'  const n = firstElement([1, 2, 3]);  // u is of type undefined  const u = firstElement([]);   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVKxgGcMBRCEAWxFQwB4AVATwAcQA+AClhgC55mbANoBdAJT9BCAD7w0oRFlQhgAbgCwAKAD02+AFpDYZBkP6tu+EXhZrORPAysEAchIwlAcxdaweElbwALwExGQU1LScQgBEUDEANPAxAEaJyWAx4ho6evi28PaOzvAuqMiUKSAwPpp+qAH4IYph5FQ0GNEAjEkATEkAzNkWesg2dg5ObHKoCkoqvv4YcsGhJG2RnaJiqkA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#inference)\nInference\n\nNote that we didn’t have to specify `Type` in this sample. The type was _inferred_ - chosen automatically - by TypeScript.\n\nWe can use multiple type parameters as well. For example, a standalone version of `map` would look like this:\n\nts\n\n`   function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {    return arr.map(func);  }  // Parameter 'n' is of type 'string'  // 'parsed' is of type 'number[]'  const parsed = map([\"1\", \"2\", \"3\"], (n) => parseInt(n));   `[Try](https://www.typescriptlang.org/play/#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYFgAoAMwFdMBjRbTUAWwENwAeASU3BNgBpQB5TjrAB8ACnqRIALlBtBAbQC6PUhWljI6abM4BKUAF4hfAbun9Y8haADehUKBiwSkGuMgA6BuBEryOgNyEAL6EhCCgAAri9LRwyKAA5JgJoAgAzqDYRKCwAJ7g0IlpsJAImOgJYWAJ4OJp0AAmKemZ2XkFiZgktABGyIqVBOTUxRB1jQZ0jCJyAEQAjLM8swBMS6CzAMyzSqAimHqGY5D1bLD7OgFAA)\n\nNote that in this example, TypeScript could infer both the type of the `Input` type parameter (from the given `string` array), as well as the `Output` type parameter based on the return value of the function expression (`number`).\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#constraints)\nConstraints\n\nWe’ve written some generic functions that can work on _any_ kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a _constraint_ to limit the kinds of types that a type parameter can accept.\n\nLet’s write a function that returns the longer of two values. To do this, we need a `length` property that’s a number. We _constrain_ the type parameter to that type by writing an `extends` clause:\n\nts\n\n`  function longest<Type extends { length: number }>(a: Type, b: Type) {    if (a.length >= b.length) {      return a;    } else {      return b;    }  }  // longerArray is of type 'number[]'  const longerArray = longest([1, 2], [1, 2, 3]);  // longerString is of type 'alice' | 'bob'  const longerString = longest(\"alice\", \"bob\");  // Error! Numbers don't have a 'length' property  const notOK = longest(10, 100);  Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdG00BYAKADMBXAOwGMAXASzitABtmBzSROgHgBUAngAdIoSAA86kKgBNEoAN5sZHOgAtUVCgFsARjFABfAHwAKAIaohogDSg91kZACUS0qFAMyoSwDpWVQ1QEwBeBwCg9TdFD09QaEg6CmgWCwBuOKNxVkQxWJJ4hKSUlj1MwuNSI1JSEDZOGABBWAtBLwU4HzpnUABybX0YAG0AXT7SGmYeBqouaBboNtBw9jnuOjNhgEZ7NFH7Hb37DFGXCvq1+YBlOmgGOY7QLtAe0X6LVgYaSD7QAB9+no4HoJiQplQZlcYLd7o9Vo0eGYAESfb6QZH2ZHAvTI851MAAUVgCAAhKAAHK6AxIUCyZh9OigdQWABuYgs-UCcw0f2E8FE0B6k2mTKocDoAHkANIrWZcJHbAAM9mVSvOQA)\n\nThere are a few interesting things to note in this example. We allowed TypeScript to _infer_ the return type of `longest`. Return type inference also works on generic functions.\n\nBecause we constrained `Type` to `{ length: number }`, we were allowed to access the `.length` property of the `a` and `b` parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.\n\nThe types of `longerArray` and `longerString` were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!\n\nFinally, just as we’d like, the call to `longest(10, 100)` is rejected because the `number` type doesn’t have a `.length` property.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#working-with-constrained-values)\nWorking with Constrained Values\n\nHere’s a common error when working with generic constraints:\n\nts\n\n`   function minimumLength<Type extends { length: number }>(    obj: Type,    minimum: number  ): Type {    if (obj.length >= minimum) {      return obj;    } else {      return { length: minimum };  Type '{ length: number; }' is not assignable to type 'Type'.   '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.   '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAzAVwDsBjAFwEs4TQBbKkq+o+gGUhIHMKALADwAVAJ4AHSKEgAPClwAmiUAG9QAGy68+qEmwBGMUAF8AfAAp8oUHD0ArVKIkAaSwyYs2O-THwBKB+KSyq5UBKBmNrYAdBo8-KAmALxuzKz0viquVtCQFETQdJEA3K5GUmqIQVmgOXkFKuqa-KiMqWzGJXhWRvhGQA)\n\nIt might look like this function is OK - `Type` is constrained to `{ length: number }`, and the function either returns `Type` or a value matching that constraint. The problem is that the function promises to return the _same_ kind of object as was passed in, not just _some_ object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:\n\nts\n\n`   // 'arr' gets value { length: 6 }  const arr = minimumLength([1, 2, 3], 6);  // and crashes here because arrays have  // a 'slice' method, but not the returned object!  console.log(arr.slice(0));   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFstUsDkCAZEVAcwwAsAeAFQE8AHBEADw2uADO8AN7wI1OvQBc8VOQBGIGPAC+APgAUAWABQ8eDnkArGW04AaXfqIkyBGXIKKYugJSmOIANy6A9L-gAWmCwZAxgwL8AgHJYGGj4GhAMIQA3KAhkBFFxWgYZADZVXTA8AQx4OPgAXkJiUnIqPPoNAG0ARnN4ACYugGYAXS6C1x8df0rUYHgwGCgBehAhRbh4RTAoZAEEOKhWZahUkCjK+GiBCCwwEASCZPocYC75MNkcCoYEOAxkGFQQaaGIzgDAAQhKZRw4gAdBAcDQNHFoRcriANAAGVyjIA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#specifying-type-arguments)\nSpecifying Type Arguments\n\nTypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:\n\nts\n\n`   function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {    return arr1.concat(arr2);  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbARjMBTAPAFQE8AHbAPgAoBDAJxoEYAuRI0gbQF0AaRWmgJmatsnAJRCSIjogDeAWABQiRDWxQQNJH3oA6FJCpRqdfqIDcigL5A)\n\nNormally it would be an error to call this function with mismatched arrays:\n\nts\n\n`  const arr = combine([1, 2, 3], [\"hello\"]);  Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgATSAYwBsBDaSUAMwFcA7YgFwEs4HRi4BbAI1YNIAHgAqATwAOkAHwAKStACMqCdIDaAXQA0oRWlVTIWgJSGNmgNz4QoALQPidZg7v5uDRMz2xQAXi5eASE5dSVdNF0MHVB1ACIAC0hSUjg4zRNLIA)\n\nIf you intended to do this, however, you could manually specify `Type`:\n\nts\n\n`   const arr = combine<string | number>([1, 2, 3], [\"hello\"]);   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXzBwFsAjLVEAHgBUBPABxAD4AKWGARgC547GBtALoAaeOwBMPPiCEBKKQxmCA3AFgAUAHpN8ALT6wyDPt0bCqAM4YxMGPAC8BYmQqUrMcgHN4AH3ipkUhAYVn4OUXFRAGYReH4AIgALEAgIHHjBWWUgA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#guidelines-for-writing-good-generic-functions)\nGuidelines for Writing Good Generic Functions\n\nWriting generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#push-type-parameters-down)\nPush Type Parameters Down\n\nHere are two ways of writing a function that appear similar:\n\nts\n\n`   function firstElement1<Type>(arr: Type[]) {    return arr[0];  }  function firstElement2<Type extends any[]>(arr: Type) {    return arr[0];  }  // a: number (good)  const a = firstElement1([1, 2, 3]);  // b: any (bad)  const b = firstElement2([1, 2, 3]);   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAjADwAqAngA54B8AFAIaqoBciN9A2gLoBKRAG8AsAChEiVHighUSNql4AGfgG5JAX0mTQkWAmRpMuQsSgAmKnTyI8ADyjEAJukQsw1Ac2VcePGFxKRk5BSV2NU0dPQkAenjPLjAQAgAjPFREJgBzODhXQUkIBExPRABeEwxsfCISUiZeUgAaRCt2gGYhLQSk9K4vahz0liKSsqhEdKqas3rLK2a2ju7eoA)\n\nThese might seem identical at first glance, but `firstElement1` is a much better way to write this function. Its inferred return type is `Type`, but `firstElement2`’s inferred return type is `any` because TypeScript has to resolve the `arr[0]` expression using the constraint type, rather than “waiting” to resolve the element during a call.\n\n> **Rule**: When possible, use the type parameter itself rather than constraining it\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#use-fewer-type-parameters)\nUse Fewer Type Parameters\n\nHere’s another pair of similar functions:\n\nts\n\n`   function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {    return arr.filter(func);  }  function filter2<Type, Func extends (arg: Type) => boolean>(    arr: Type[],    func: Func  ): Type[] {    return arr.filter(func);  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAbKBTATgRgDwAqAngA4YB8AFAIZZYBcixZA2gLoA0y4EjNWAc0bMMASkQBecogBGcOKgzUwo4aQztEAbwCwAKESIsGKCCxJaWAHQp02SqEiiA3PoC++-Y+jwktzFgATITqXABiPIgYAB6YYAAmAM6I-EJM6uJSsvKKylT6hpZqrJwF3JCMEZD6qukl2mXGpuaIljZoAQ48Lu5AA)\n\nWe’ve created a type parameter `Func` that _doesn’t relate two values_. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. `Func` doesn’t do anything but make the function harder to read and reason about!\n\n> **Rule**: Always use as few type parameters as possible\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#type-parameters-should-appear-twice)\nType Parameters Should Appear Twice\n\nSometimes we forget that a function might not need to be generic:\n\nts\n\n`   function greet<Str extends string>(s: Str) {    console.log(\"Hello, \" + s);  }  greet(\"world\");   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QDwGUqqLoAeU6YAJgM6JUExjIB8AFFQFyL6oCUiA3gFgAUIkQQEVOABt0AOmlxkLAEQAJdNMUAaRCsQBqWjwDcIgL4iRaTFFUB3OKmkUVpoA)\n\nWe could just as easily have written a simpler version:\n\nts\n\n`   function greet(s: string) {    console.log(\"Hello, \" + s);  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQGcBciuUqMYyAlIgN4CwAUIohArnADboB07cy2AIgAS6drwA0iAYgDURCgG4GAXyA)\n\nRemember, type parameters are for _relating the types of multiple values_. If a type parameter is only used once in the function signature, it’s not relating anything. This includes the inferred return type; for example, if `Str` was part of the inferred return type of `greet`, it would be relating the argument and return types, so would be used _twice_ despite appearing only once in the written code.\n\n> **Rule**: If a type parameter only appears in one location, strongly reconsider if you actually need it\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters)\nOptional Parameters\n---------------------------------------------------------------------------------------------------------\n\nFunctions in JavaScript often take a variable number of arguments. For example, the `toFixed` method of `number` takes an optional digit count:\n\nts\n\n`   function f(n: number) {    console.log(n.toFixed()); // 0 arguments    console.log(n.toFixed(3)); // 1 argument  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFGAXIsIC2AjAUwCcBKRAbwFgAoRRCBAZzgBsCA6FuAczXajgAxGAA8CAExQkSAbkQB6eYgAMiAIZFuuAmCiMadBmGZtOPPgOFjJAZmlzFiAIzrN23TQC+QA)\n\nWe can model this in TypeScript by marking the parameter as _optional_ with `?`:\n\nts\n\n`   function f(x?: number) {    // ...  }  f(); // OK  f(10); // OK   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwPwC5FhAWwCMBTAJwEpEBvAWAChFEB6JxAOg-oF97VyBuZqwDyAaV4oAjAAYBQxGKA)\n\nAlthough the parameter is specified as type `number`, the `x` parameter will actually have the type `number | undefined` because unspecified parameters in JavaScript get the value `undefined`.\n\nYou can also provide a parameter _default_:\n\nts\n\n`   function f(x = 10) {    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFAD0QXkQRgAwCUiA3gLABQiiA9NYgHSMUC+QA)\n\nNow in the body of `f`, `x` will have type `number` because any `undefined` argument will be replaced with `10`. Note that when a parameter is optional, callers can always pass `undefined`, as this simply simulates a “missing” argument:\n\nts\n\n`   // All OK  f();  f(10);  f(undefined);   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVIAoAPAfgC55VkBbAIxBgEoKA3HLYAbgFgAoAen7wAtKLDIMo4X0HwAghAjwA8gGk+iAox69NARgAM2jQTShEWVCGDagA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters-in-callbacks)\nOptional Parameters in Callbacks\n\nOnce you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:\n\nts\n\n`   function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {    for (let i = 0; i < arr.length; i++) {      callback(arr[i], i);    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWwJ4DE4CcCiBDCACwAo8ssAuRPMVAbQF0AaRCPAG3YCMCBrK0lgDmVGqhYwwAEwCmADwD8VMCGRcZWAJSIAvAD5EANzgwp2gN4BYAFCJEwbImLsZURDF2IADAG53iAB5qcgA6FzAhKEI-GABqWIsbOzs2Th4IXkEsOhhmd00fJMQAXxtioA)\n\nWhat people usually intend when writing `index?` as an optional parameter is that they want both of these calls to be legal:\n\nts\n\n`   myForEach([1, 2, 3], (a) => console.log(a));  myForEach([1, 2, 3], (a, i) => console.log(a, i));   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDmFRpsKIcAyQAHQMcI7NIRmUpbLyytW19Y0ObgIt0XTtnT19A0xzIUNAA)\n\nWhat this _actually_ means is that _`callback` might get invoked with one argument_. In other words, the function definition says that the implementation might look like this:\n\nts\n\n`   function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {    for (let i = 0; i < arr.length; i++) {      // I don't feel like providing the index today      callback(arr[i]);    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKADMBXAOwGMAXASzntAFsBPAMQQBRAIaMAFgAphsVMPo8A2gF0ANKEbCANpoBGogNaop0AOaz5a1vQAmkAB4B+VPVpcdMAJSgAvAD5QAG5wrNZeAN5UoKDUCKASmpDMoKw+oEQA3MmgADyg0tAAdAn0JsximawA1JXhkVGgIKAAkqDWHADkSdSQkJqgmqz6kKAADvABIVYmoGXDVrZ2M3DWwjx1URraeoz6xtAKrEoe6XUAvlSnQA)\n\nIn turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:\n\nts\n\n`   myForEach([1, 2, 3], (a, i) => {    console.log(i.toFixed());  'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.  });   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDm4CYVGgAN4mdMKIcAyQAHQMcI5KAoN8cJICXpDUSiEhGZQAvstAA)\n\nIn JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.\n\n> **Rule**: When writing a function type for a callback, _never_ write an optional parameter unless you intend to _call_ the function without passing that argument\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)\nFunction Overloads\n-------------------------------------------------------------------------------------------------------\n\nSome JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a `Date` that takes either a timestamp (one argument) or a month/day/year specification (three arguments).\n\nIn TypeScript, we can specify a function that can be called in different ways by writing _overload signatures_. To do this, write some number of function signatures (usually two or more), followed by the body of the function:\n\nts\n\n`  function makeDate(timestamp: number): Date;  function makeDate(m: number, d: number, y: number): Date;  function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {    if (d !== undefined && y !== undefined) {      return new Date(y, mOrTimestamp, d);    } else {      return new Date(mOrTimestamp);    }  }  const d1 = makeDate(12345678);  const d2 = makeDate(5, 5, 5);  const d3 = makeDate(1, 3);  No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGCwAoAMwFcA7AYwBcBLOU0AWwEMBrSAEScsgAoaHIiSkwYAHVKWIMARjACUqTtwDcBEhRp1GrDl14MJU2dAA0oACaGZMMwE8rxhaCWRVRMlVr1mbFzwYA8tAAKtQCQiLioJLWphYA-A42oLaJ0UbyinqgAN4EoKDUhKA85qAAhAC8laBk5pCE1KSQZQBkrSkV1bWk9Y3N5nK5+QWg0JCUxND0zQDuzno8tmaBIWGCwmJmg24FAL6gkAA2iJDD+KNjE1MzkPN+q6Hhm6Jyu6B7BJ-45HRCFgBGUA1Hy6bg8AFoADMABYMAA2LAADjeBF+pH+5jQwO0vkWGDMBNAGFRPz+lAsUJxoL8ALMULeQA)\n\nIn this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the _overload signatures_.\n\nThen, we wrote a function implementation with a compatible signature. Functions have an _implementation_ signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#overload-signatures-and-the-implementation-signature)\nOverload Signatures and the Implementation Signature\n\nThis is a common source of confusion. Often people will write code like this and not understand why there is an error:\n\nts\n\n`  function fn(x: string): void;  function fn() {    // ...  }  // Expected to be able to call with zero arguments  fn();  Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYCwAoAMwFcA7AYwBcBLOU0Q0gCgA9VFLprSBzASlQA3ONQAmAbgIkKNOg2Z9QAbwKhQIUADptBAL4ENAURYAHSFUijQlOKABGkUAEM7AG0c3Q5J69egA7tSUABagAF4wtk7QPMQAtpCklIhSCuJAA)\n\nAgain, the signature used to write the function body can’t be “seen” from the outside.\n\n> The signature of the _implementation_ is not visible from the outside. When writing an overloaded function, you should always have _two_ or more signatures above the implementation of the function.\n\nThe implementation signature must also be _compatible_ with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:\n\nts\n\n`   function fn(x: boolean): void;  // Argument type isn't right  function fn(x: string): void;  This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.  function fn(x: boolean) {}   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqgEZxwA2kAhmQCUqAG5waAEwDchEKACC0AOYkAtpDJVQVAJ4AHSKBqIyAcm3QaygBZVCpSrXqMW7UIipWyykaHFSssTk1HQMTGyc3HyCQqAA3gC+QA)\n\nts\n\n`   function fn(x: string): string;  // Return type isn't right  function fn(x: number): boolean;  This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.  function fn(x: string | number) {    return \"oops\";  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqoldDWQOYCUHLj14BuQiFAAlSFRLQGVAJ4AHSKBqIyAciqhuvABZVCpSrXqMW7UGRIBbAEYxBoR3DgAbSAEMy44nJqOgYmNiFuPlAAH1sHZ2h+UABvQlB9WXkGACIPFURsgIBfIA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#writing-good-overloads)\nWriting Good Overloads\n\nLike generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.\n\nLet’s consider a function that returns the length of a string or an array:\n\nts\n\n`   function len(s: string): number;  function len(arr: any[]): number;  function len(x: any) {    return x.length;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQGcBcitQBOMYA5gJR5ggC2ARqoQNwCwAUKJLAiuhgIaFCefmACeAbQC6lRNXqNWHcNHhI0mAB4jx5RAG92iRIVRQQhJJoB0G0lAAWSgL5A)\n\nThis function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string _or_ an array, because TypeScript can only resolve a function call to a single overload:\n\nts\n\n`  len(\"\"); // OK  len([0]); // OK  len(Math.random() > 0.5 ? \"hello\" : [0]);  No overload matches this call.   Overload 1 of 2, '(s: string): number', gave the following error.     Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.       Type 'number[]' is not assignable to type 'string'.   Overload 2 of 2, '(arr: any[]): number', gave the following error.     Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.       Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.   Overload 1 of 2, '(s: string): number', gave the following error.     Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.       Type 'number[]' is not assignable to type 'string'.   Overload 2 of 2, '(arr: any[]): number', gave the following error.     Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.       Type 'string' is not assignable to type 'any[]'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYBsBOAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOjmRMAUKUIlbR2TAOYBKVEwYBbAEYwA3IRIVqtRiw5cefftWipKTAJ4BtALozQcpasIhQAWnekGrd68K8BAEQBUiqgLgDyANJ+hpYADLahEdEE-vwAspSsABYAdNBmRHDy-FKgAHygcbkArKAA-KAB2ZDk5HABoKjxiUA)\n\nBecause both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:\n\nts\n\n`   function len(x: any[] | string) {    return x.length;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQA8BciCGYAngNoC6iAPogM5QBOMYA5gJSIDeAsAFCKL1UUEPSRYAdGhZQAFgG5eAXyA)\n\nThis is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.\n\n> Always prefer parameters with union types instead of overloads when possible\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#declaring-this-in-a-function)\nDeclaring `this` in a Function\n-----------------------------------------------------------------------------------------------------------------------------\n\nTypeScript will infer what the `this` should be in a function via code flow analysis, for example in the following:\n\nts\n\n`   const user = {    id: 123,    admin: false,    becomeAdmin: function () {      this.admin = true;    },  };   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwLACgYwCWAJgFwwCMATAMwA0eeBAhsQLaFjkBmzANkgb4YAI0Sg2iAILtOPOGGBRC4GAAoAlFiYEYUABaEIAOlYcw6PcjiIA3DoC+Qh7aA)\n\nTypeScript understands that the function `user.becomeAdmin` has a corresponding `this` which is the outer object `user`. `this`, _heh_, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object `this` represents. The JavaScript specification states that you cannot have a parameter called `this`, and so TypeScript uses that syntax space to let you declare the type for `this` in the function body.\n\nts\n\n`   interface DB {    filterUsers(filter: (this: User) => boolean): User[];  }  const db = getDB();  const admins = db.filterUsers(function (this: User) {    return this.admin;  });   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4FgBQyywAJgFzIgCuAtgEbQDcBRcJNoFdA9twDYQ4IZvgC+BEhAR84UFAm4h0YZAHMIYACIAhCgAoAlMgC8APmQ6RAeivIAtA4RUwDuwVCRYiFDpwtkMMB8nhjQ6HqBwdD6YAAWwOgUoVBGZsg8-IIgBkmYUADaALoi4vgECkoqJHQmaho6hiIVyshsHEq11QB0kSF54TBUIAhgwIrIenEJudBGeITIcmBUUCDIU+hdbaAlBoxAA)\n\nThis pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use `function` and not arrow functions to get this behavior:\n\nts\n\n`  interface DB {    filterUsers(filter: (this: User) => boolean): User[];  }  const db = getDB();  const admins = db.filterUsers(() => this.admin);  The containing arrow function captures the global value of 'this'.   Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.7041   7017The containing arrow function captures the global value of 'this'.   Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYAsBGdGc0BYAKAEsA7AFxgDMBDAY0lAFVEZQBvU0UMgCaoKAVwC2AIxgBuXqHoCxlVBLhwANpHoVZJAL6kBkRuvrQWjOBURVQAc0hUAIgCFUACgCUoALwA+UFddEFAAWnDGESpw0NJKGmgGZkCXbjlaMnUE9hhEdwysmA8qAAsyFDYOaG9-UFUNLQpPVBzoAG0AXV0DElJLa1sBCV97R1cvXX6beUVKRBGhgDoC7Kq8r18A0vLFhSUm6SA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#other-types-to-know-about)\nOther Types to Know About\n---------------------------------------------------------------------------------------------------------------------\n\nThere are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)\n`void`\n\n`void` represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any `return` statements, or doesn’t return any explicit value from those return statements:\n\nts\n\n`   // The inferred return type is void  function noop() {    return;  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQSwHYDNoCdXQCagwFwK6oKi4CeADrHAM6gBuA9nJgLABQS+CAxrnA8QQMG5ABQBKUAG92oHNAJEA3OwC+QA)\n\nIn JavaScript, a function that doesn’t return any value will implicitly return the value `undefined`. However, `void` and `undefined` are not the same thing in TypeScript. There are further details at the end of this chapter.\n\n> `void` is not the same as `undefined`.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#object)\n`object`\n\nThe special type `object` refers to any value that isn’t a primitive (`string`, `number`, `bigint`, `boolean`, `symbol`, `null`, or `undefined`). This is different from the _empty object type_ `{ }`, and also different from the global type `Object`. It’s very likely you will never use `Object`.\n\n> `object` is not `Object`. **Always** use `object`!\n\nNote that in JavaScript, function values are objects: They have properties, have `Object.prototype` in their prototype chain, are `instanceof Object`, you can call `Object.keys` on them, and so on. For this reason, function types are considered to be `object`s in TypeScript.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown)\n`unknown`\n\nThe `unknown` type represents _any_ value. This is similar to the `any` type, but is safer because it’s not legal to do anything with an `unknown` value:\n\nts\n\n`   function f1(a: any) {    a.b(); // OK  }  function f2(a: unknown) {    a.b();  'a' is of type 'unknown'.18046'a' is of type 'unknown'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AWACgAzAVwDsBjAFwEs4HQacAKAQ1T8GATwCUoAN7VQofgDoARrzEBuUCFAB5ANLUAvtXrN2nbmgGpGAawZwA7gwnSqshcrUGgA)\n\nThis is useful when describing function types because you can describe functions that accept any value without having `any` values in your function body.\n\nConversely, you can describe a function that returns a value of unknown type:\n\nts\n\n`   function safeParse(s: string): unknown {    return JSON.parse(s);  }  // Need to be careful with 'obj'!  const obj = safeParse(someRandomString);   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEASlCsHgMoYwCWKA5gFzaU20DcAsAFAD038AtILABXDIP5cAZsJRgMVVNiiSQABVhoQACjSNM1OgEpGMgNYokAdxTwA3l3jw4GYTBsApMgHkAcgDoABw1tNEMOTgBfLi5eeB8QEGB4DCR4ACMEMFgQaQh4SyoMAAt4AHIkNIArUoBCLmR0LArK+ABeJRV1GE0dPEJiUlwKA1owoA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#never)\n`never`\n\nSome functions _never_ return a value:\n\nts\n\n`   function fail(msg: string): never {    throw new Error(msg);  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAhjANgCgLYGcDmAXIrlAE4xj4CUxYApgG71mIDeAsAFCKJQAWZOAHdEDUQFEyQsjgLUA3NwC+QA)\n\nThe `never` type represents values which are _never_ observed. In a return type, this means that the function throws an exception or terminates execution of the program.\n\n`never` also appears when TypeScript determines there’s nothing left in a union.\n\nts\n\n`   function fn(x: string | number) {    if (typeof x === \"string\") {      // do something    } else if (typeof x === \"number\") {      // do something else    } else {      x; // has type 'never'!    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMMAKAHgLkQZygJxjAHNEAfRMEAWwCMBTfASkQG8BYAKEURmEVRQAngAd6cfukQBeWYgBEeQiXksO3HogD0WxABM4uONXpQAFkWJceAX0T0ANjnq9+g0eMky58qnUaqbNaaOvqGOMamFiT2TvTBdo7OQRo86ADc2rpmAIY4iMJiiADkYPQAbozFAIQJXDZAA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#function)\n`Function`\n\nThe global type `Function` describes properties like `bind`, `call`, `apply`, and others present on all function values in JavaScript. It also has the special property that values of type `Function` can always be called; these calls return `any`:\n\nts\n\n`   function doSomething(f: Function) {    return f(1, 2, 3);  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFMAFyIBi408YAlIgN4CwAUIogE64jdJgJAIwAaRACZxAZgYBuDgF8gA)\n\nThis is an _untyped function call_ and is generally best avoided because of the unsafe `any` return type.\n\nIf you need to accept an arbitrary function but don’t intend to call it, the type `() => void` is generally safer.\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters-and-arguments)\nRest Parameters and Arguments\n-----------------------------------------------------------------------------------------------------------------------------\n\n> Background Reading:  \n> [Rest Parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)\n>   \n> [Spread Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)\n>   \n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters)\nRest Parameters\n\nIn addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an _unbounded_ number of arguments using _rest parameters_.\n\nA rest parameter appears after all other parameters, and uses the `...` syntax:\n\nts\n\n`   function multiply(n: number, ...m: number[]) {    return m.map((x) => n * x);  }  // 'a' gets value [10, 20, 30, 40]  const a = multiply(10, 1, 2, 3, 4);   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwBRgBciYIyARgKYBOANIgHRPLGkU0DaAugJSIDeAWABQiRNUpQQ1JMgbIAhpjx4AHnwC8APhKIAVInUBuEQF8RAeguIA5ApuIA5pIDOiAG4K0ISog4BGAAZ6ACZgxABmcIAWQK4RCAQXKEQFRA0UdCxcPCD6f1D6CPponiMgA)\n\nIn TypeScript, the type annotation on these parameters is implicitly `any[]` instead of `any`, and any type annotation given must be of the form `Array<T>` or `T[]`, or a tuple type (which we’ll learn about later).\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-arguments)\nRest Arguments\n\nConversely, we can _provide_ a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the `push` method of arrays takes any number of arguments:\n\nts\n\n`   const arr1 = [1, 2, 3];  const arr2 = [4, 5, 6];  arr1.push(...arr2);   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAhgJwQRhgXhgbWQGhgJjwGYBdAbgFgAoUSWRBfdLAFjwFY8A2c6h5AHQAHAK4QAFgAoBMhvgCUZIA)\n\nNote that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:\n\nts\n\n`  // Inferred type is number[] -- \"an array with zero or more numbers\",  // not specifically two numbers  const args = [8, 5];  const angle = Math.atan2(...args);  A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMDYCwAoEUASQDsAzGaSAE1ABcBPAB0lAEtFRSBXAWwBGMANoBdUAFoJoAEQBDUqDmw5jUAHd29ABagAXjDigEoPgja9BMRDIA0BIqTj1QiVgGN25du7kAbPzV6dSNLISQCdzhSRBdlAHMuAF5QYQAOW1AMUQBuSOjYpVJ4vzYUgFk5HQA6KoU0AApq5oTEAEocoA)\n\nThe best fix for this situation depends a bit on your code, but in general a `const` context is the most straightforward solution:\n\nts\n\n`   // Inferred as 2-length tuple  const args = [8, 5] as const;  // OK  const angle = Math.atan2(...args);   `[Try](https://www.typescriptlang.org/play/#code/PTAEEkDsDMFMCd6wCagIYGdQCYC0AbWSAcwBcALUUgVwAdCBYAKAGMB7SDU9eYrAXlABtABwAaUAFYAuuiztOpANzMQoAPIBpZgq7oShUIICyaCgDozaSNgAU5h2l4YAlEqA)\n\nUsing rest arguments may require turning on [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration)\n when targeting older runtimes.\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#parameter-destructuring)\nParameter Destructuring\n-----------------------------------------------------------------------------------------------------------------\n\n> Background Reading:  \n> [Destructuring Assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n>   \n\nYou can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:\n\njs\n\n`   function sum({ a, b, c }) {    console.log(a + b + c);  }  sum({ a: 10, b: 3, c: 9 });   `\n\nThe type annotation for the object goes after the destructuring syntax:\n\nts\n\n`   function sum({ a, b, c }: { a: number; b: number; c: number }) {    console.log(a + b + c);  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZxAWwBQG9EEMA0iARoRIgL4BciOu1Y6RApgE4Dcx9jrHEXazFhQCUNALAAoRIggJkcADZMAdArgBzDLkQBqYrpnC2k8kA)\n\nThis can look a bit verbose, but you can use a named type here as well:\n\nts\n\n`   // Same as prior example  type ABC = { a: number; b: number; c: number };  function sum({ a, b, c }: ABC) {    console.log(a + b + c);  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEGUEMFsFNUgZ1ABwE4EsD2bSwB4woA2sAsAFAAuAnivAIIBCAwqALygDeCAXKADsArtABGsNAG5Qo-sLETpAYzkjxuAL6TKAMyEClVbANCIRACh6QANDNtLQG-sxYBKbpVCglWAYiykAHTEWADm5pCgANQy0d6u2hQaQA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/functions.html#assignability-of-functions)\nAssignability of Functions\n-----------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/2/functions.html#return-type-void)\nReturn type `void`\n\nThe `void` return type for functions can produce some unusual, but expected behavior.\n\nContextual typing with a return type of `void` does **not** force functions to **not** return something. Another way to say this is a contextual function type with a `void` return type (`type voidFunc = () => void`), when implemented, can return _any_ other value, but it will be ignored.\n\nThus, the following implementations of the type `() => void` are valid:\n\nts\n\n`   type voidFunc = () => void;  const f1: voidFunc = () => {    return true;  };  const f2: voidFunc = () => true;  const f3: voidFunc = function () {    return true;  };   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOkA)\n\nAnd when the return value of one of these functions is assigned to another variable, it will retain the type of `void`:\n\nts\n\n`   const v1 = f1();  const v2 = f2();  const v3 = f3();   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOvQA9NFQALSJWGjAifEOBjBcwtzEunRMjrCGOYZ59gX67DDOOc55QA)\n\nThis behavior exists so that the following code is valid even though `Array.prototype.push` returns a number and the `Array.prototype.forEach` method expects a function with a return type of `void`.\n\nts\n\n`   const src = [1, 2, 3];  const dst = [0];  src.forEach((el) => dst.push(el));   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBBBOwYF4YG0CMAaGAmHAzALoDcAsAFCiSwAm0K6ADKZZQsAHQBmI8AogENgACwAUYgKYAbAJQoAfDHpROABwCuEcTNmySQA)\n\nThere is one other special case to be aware of, when a literal function definition has a `void` return type, that function must **not** return anything.\n\nts\n\n`   function f2(): void {    // @ts-expect-error    return true;  }  const f3 = function (): void {    // @ts-expect-error    return true;  };   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMATACgJQC5EDc4wAmiA3gLABQiiA9DYgAJQDOAtAKYAeADu9BwCcBcAZWoD2UEAKRQBIdgG5KAX0qUICZlGQBmRAF5k4aPCSYc+IqTG16TNl1792QkbYlSZiOQuUUVRSA)\n\nFor more on `void` please refer to these other documentation entries:\n\n*   [FAQ - “Why are functions returning non-void assignable to function returning void?”](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)\n    \n\n[### Narrowing\\\n\\\nUnderstand how TypeScript uses JavaScript knowledge to reduce the amount of type syntax in your projects.](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)\n\n[### Object Types\\\n\\\nHow TypeScript describes the shapes of JavaScript objects.](https://www.typescriptlang.org/docs/handbook/2/objects.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/More%20on%20Functions.md)\n ❤\n\nContributors to this page:  \n\nRC![Ryan Cavanaugh  (56)](https://gravatar.com/avatar/b58b1520745cd2abf1e669bb63537180cabe29a17be2773ca10160d7970a6a5d?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nHA![Hossein Ahmadian-Yazdi  (4)](https://gravatar.com/avatar/badbb0b7582edd51c9ff8e37038becd49986e1af6f1c5dbf200eddbc20d1da7e?s=32&&d=blank)\n\nJW![Joseph Wynn  (3)](https://gravatar.com/avatar/c5c2c72d8dabdc7f75a5b5a9f825403f4161889414828649c8dbe561210c61da?s=32&&d=blank)\n\nSB![Siarhei Bobryk  (2)](https://gravatar.com/avatar/4660d4b2ddaaa85219ef02fa5e815dd88cd34d6c97fa96de46cfd9a03ef94733?s=32&&d=blank)\n\n38+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","language":"en","description":"Learn about how Functions work in TypeScript.","og:description":"Learn about how Functions work in TypeScript.","ogDescription":"Learn about how Functions work in TypeScript.","title":"TypeScript: Documentation - More on Functions","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","twitter:site":"typescriptlang","og:title":"Documentation - More on Functions","generator":"Gatsby 5.13.5","ogTitle":"Documentation - More on Functions","scrapeId":"48580665-3190-4a21-99b4-3f80f58728cf","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/functions.html","url":"https://www.typescriptlang.org/docs/handbook/2/functions.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nCreating Types from Types\n=========================\n\nTypeScript’s type system is very powerful because it allows expressing types _in terms of other types_.\n\nThe simplest form of this idea is generics. Additionally, we have a wide variety of _type operators_ available to use. It’s also possible to express types in terms of _values_ that we already have.\n\nBy combining various type operators, we can express complex operations and values in a succinct, maintainable way. In this section we’ll cover ways to express a new type in terms of an existing type or value.\n\n*   [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)\n     - Types which take parameters\n*   [Keyof Type Operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)\n     - Using the `keyof` operator to create new types\n*   [Typeof Type Operator](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)\n     - Using the `typeof` operator to create new types\n*   [Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)\n     - Using `Type['a']` syntax to access a subset of a type\n*   [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)\n     - Types which act like if statements in the type system\n*   [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)\n     - Creating types by mapping each property in an existing type\n*   [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)\n     - Mapped types which change properties via template literal strings\n\n[### Generics\\\n\\\nTypes which take parameters](https://www.typescriptlang.org/docs/handbook/2/generics.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/_Creating%20Types%20from%20Types.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (6)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nGF![Graham Fisher  (1)](https://gravatar.com/avatar/17f72e3d32dca8852e79c078e2f3459819bc0e07e1c5f755d06fc6dc0aa0ce35?s=32&&d=blank)\n\nAP![Alexander Pepper  (1)](https://gravatar.com/avatar/850df7f9663dde77d709c17712433aa445507f474424d2f8991b54be74263d8d?s=32&&d=blank)\n\nPC![Pradeep Chauhan  (1)](https://gravatar.com/avatar/f696ff36977e958e37feabb1d420ef73f97f886c12fbefa2a6e1eb1c0f4f4d0f?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"twitter:site":"typescriptlang","description":"An overview of the ways in which you can create more types from existing types.","ogDescription":"An overview of the ways in which you can create more types from existing types.","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","generator":"Gatsby 5.13.5","ogTitle":"Documentation - Creating Types from Types","title":"TypeScript: Documentation - Creating Types from Types","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","language":"en","og:title":"Documentation - Creating Types from Types","og:description":"An overview of the ways in which you can create more types from existing types.","scrapeId":"55dbee80-d1df-477b-bf9a-7ce7ac2e483c","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/types-from-types.html","url":"https://www.typescriptlang.org/docs/handbook/2/types-from-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeof Type Operator\n====================\n\n[](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html#the-typeof-type-operator)\nThe `typeof` type operator\n------------------------------------------------------------------------------------------------------------------------\n\nJavaScript already has a `typeof` operator you can use in an _expression_ context:\n\nts\n\n`   // Prints \"string\"  console.log(typeof \"Hello world\");   `[Try](https://www.typescriptlang.org/play/#code/PTAEAUCcEsDsBcDOoBEj41gcxQKAMYD2sihANgKYB0ZhWAFPAJ4AOFhAZqgBIVm2gA7oUhkAJigCUAbiA)\n\nTypeScript adds a `typeof` operator you can use in a _type_ context to refer to the _type_ of a variable or property:\n\nts\n\n`   let s = \"hello\";  let n: typeof s;       let n: string   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAzhC8ECIAWJjAPYINwChSQDsAuCMATwAcR0AzaXAegYggD0B+IA)\n\nThis isn’t very useful for basic types, but combined with other type operators, you can use `typeof` to conveniently express many patterns. For an example, let’s start by looking at the predefined type `ReturnType<T>`. It takes a _function type_ and produces its return type:\n\nts\n\n`   type Predicate = (x: unknown) => boolean;  type K = ReturnType<Predicate>;        type K = boolean   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgThAJgSwMYENjQLxQBQAeAXFAK4B2A1uQPYDu5AlFNgHxQBGNNANhOuQDcAKFCQoAaRZQAShGCk45ACrgIAHnhI0mCKxEB6A1BMA9APxA)\n\nIf we try to use `ReturnType` on a function name, we see an instructive error:\n\nts\n\n`  function f() {    return { x: 10, y: 3 };  }  type P = ReturnType<f>;  'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?2749'f' refers to a value, but is being used as a type here. Did you mean 'typeof f'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYAsBOAUAGYCuAdgMYAuAlnCaAQBQCUoA3nqKNJBUdHa1AAPVAEYADABpQAT1QBmUAF8A3HiV4KMgA6RQABVABeUACUefEgBUdkADwEAfCqA)\n\nRemember that _values_ and _types_ aren’t the same thing. To refer to the _type_ that the _value `f`_ has, we use `typeof`:\n\nts\n\n`   function f() {    return { x: 10, y: 3 };  }  type P = ReturnType<typeof f>;        type P = {     x: number;     y: number; }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFASkQbwFCMQJwFMoR8lNEAPALkQEYAGAGkQE9aBmRAXwG5tu2KKwAOhRAAVEAXkQAlYqTAAVUYQA8wsXGDIAfPwD0hvIgB6AfiA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html#limitations)\nLimitations\n\nTypeScript intentionally limits the sorts of expressions you can use `typeof` on.\n\nSpecifically, it’s only legal to use `typeof` on identifiers (i.e. variable names) or their properties. This helps avoid the confusing trap of writing code you think is executing, but isn’t:\n\nts\n\n`  // Meant to use = ReturnType<typeof msgbox>  let shouldContinue: typeof msgbox(\"Are you sure you want to continue?\");  ',' expected.1005',' expected.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYMFYBQATSAYwBsBDaSUIuAO0QBdQBbRAcwCM4APVACgAO8ZgIapG0AJa02ASlABeAHygucEpDK0A3LhCgGATwFVWnHotBbDu-QFoHRAK4MHdvWACym2kwZxQJ0QqBVAAJUgGJ2haABVjSAAeIxM4ADMWdi5uJVwNJkQACzgnEnwAYToGaSdIVBTIdMzzbj4AIgBBSlBDEtBEaKpep1AAdy0-AJpfGsgAfjbZbSA)\n\n[### Keyof Type Operator\\\n\\\nUsing the keyof operator in type contexts.](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)\n\n[### Indexed Access Types\\\n\\\nUsing Type\\['a'\\] syntax to access a subset of a type.](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/Typeof%20Type%20Operator.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (4)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nJL![Jimmy Liao  (1)](https://gravatar.com/avatar/8c59c4db936a9403aa7d7db331c932f0de8a81c84e215a502dfac1288d37b2ea?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"theme-color":"#3178C6","description":"Using the typeof operator in type contexts.","og:title":"Documentation - Typeof Type Operator","og:description":"Using the typeof operator in type contexts.","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"Using the typeof operator in type contexts.","title":"TypeScript: Documentation - Typeof Type Operator","ogTitle":"Documentation - Typeof Type Operator","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","scrapeId":"06526980-199f-4fbe-ae0b-92e49b336005","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/typeof-types.html","url":"https://www.typescriptlang.org/docs/handbook/2/typeof-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nGenerics\n========\n\nA major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.\n\nIn languages like C# and Java, one of the main tools in the toolbox for creating reusable components is _generics_, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.\n\n[](https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics)\nHello World of Generics\n----------------------------------------------------------------------------------------------------------------\n\nTo start off, let’s do the “hello world” of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the `echo` command.\n\nWithout generics, we would either have to give the identity function a specific type:\n\nts\n\n`   function identity(arg: number): number {    return arg;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkTBAFsAjNQgSnMtvsQG8AoRRQtKEISRFiAbk4BfIA)\n\nOr, we could describe the identity function using the `any` type:\n\nts\n\n`   function identity(arg: any): any {    return arg;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkXzGwEpzLtEBvAKEUULShEKSOIG5mAXyA)\n\nWhile using `any` is certainly generic in that it will cause the function to accept any and all types for the type of `arg`, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.\n\nInstead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a _type variable_, a special kind of variable that works on types rather than values.\n\nts\n\n`   function identity<Type>(arg: Type): Type {    return arg;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA)\n\nWe’ve now added a type variable `Type` to the identity function. This `Type` allows us to capture the type the user provides (e.g. `number`), so that we can use that information later. Here, we use `Type` again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.\n\nWe say that this version of the `identity` function is generic, as it works over a range of types. Unlike using `any`, it’s also just as precise (i.e., it doesn’t lose any information) as the first `identity` function that used numbers for the argument and return type.\n\nOnce we’ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:\n\nts\n\n`   let output = identity<string>(\"myString\");          let output: string   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwcuAM5RqMMLQoAiALbYAyvce0XLKQV+YP4APQB+IA)\n\nHere we explicitly set `Type` to be `string` as one of the arguments to the function call, denoted using the `<>` around the arguments rather than `()`.\n\nThe second way is also perhaps the most common. Here we use _type argument inference_ — that is, we want the compiler to set the value of `Type` for us automatically based on the type of the argument we pass in:\n\nts\n\n`   let output = identity(\"myString\");          let output: string   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwc5AEQBbbAGUo1GGFo2WUhf1-8AegD8QA)\n\nNotice that we didn’t have to explicitly pass the type in the angle brackets (`<>`); the compiler just looked at the value `\"myString\"`, and set `Type` to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.\n\n[](https://www.typescriptlang.org/docs/handbook/2/generics.html#working-with-generic-type-variables)\nWorking with Generic Type Variables\n----------------------------------------------------------------------------------------------------------------------------------------\n\nWhen you begin to use generics, you’ll notice that when you create generic functions like `identity`, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.\n\nLet’s take our `identity` function from earlier:\n\nts\n\n`   function identity<Type>(arg: Type): Type {    return arg;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA)\n\nWhat if we want to also log the length of the argument `arg` to the console with each call? We might be tempted to write this:\n\nts\n\n`   function loggingIdentity<Type>(arg: Type): Type {    console.log(arg.length);  Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.    return arg;  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA)\n\nWhen we do, the compiler will give us an error that we’re using the `.length` member of `arg`, but nowhere have we said that `arg` has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a `number` instead, which does not have a `.length` member.\n\nLet’s say that we’ve actually intended this function to work on arrays of `Type` rather than `Type` directly. Since we’re working with arrays, the `.length` member should be available. We can describe this just like we would create arrays of other types:\n\nts\n\n`   function loggingIdentity<Type>(arg: Type[]): Type[] {    console.log(arg.length);    return arg;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkWroG0BdAJRceBAYgDeAKESIICAM5xkBAHSo0LduqJooAC0EBuGYlYEoIVkjZoTAXyA)\n\nYou can read the type of `loggingIdentity` as “the generic function `loggingIdentity` takes a type parameter `Type`, and an argument `arg` which is an array of `Type`s, and returns an array of `Type`s.” If we passed in an array of numbers, we’d get an array of numbers back out, as `Type` would bind to `number`. This allows us to use our generic type variable `Type` as part of the types we’re working with, rather than the whole type, giving us greater flexibility.\n\nWe can alternatively write the sample example this way:\n\nts\n\n`   function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {    console.log(arg.length); // Array has a .length, so no more error    return arg;  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkQEFXXmK1OvQCUXXv0G0GiAN4AoRIggIAznGQEAdKjQt2OomigALEQG5EAeis8+AxCearEzRIeymANInWIwcIgAtnCsBIgEfKGKiGFQIKxIbGjm8gC+QA)\n\nYou may already be familiar with this style of type from other languages. In the next section, we’ll cover how you can create your own generic types like `Array<Type>`.\n\n[](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-types)\nGeneric Types\n--------------------------------------------------------------------------------------------\n\nIn previous sections, we created generic identity functions that worked over a range of types. In this section, we’ll explore the type of the functions themselves and how to create generic interfaces.\n\nThe type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:\n\nts\n\n`   function identity<Type>(arg: Type): Type {    return arg;  }  let myIdentity: <Type>(arg: Type) => Type = identity;   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIwLEyVOu30tEAXlJN955JqzYJQA)\n\nWe could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.\n\nts\n\n`   function identity<Type>(arg: Type): Type {    return arg;  }  let myIdentity: <Input>(arg: Input) => Input = identity;   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHI1xqwREFArjG+w1BaIAvKUTmjN5JqzYJQA)\n\nWe can also write the generic type as a call signature of an object literal type:\n\nts\n\n`   function identity<Type>(arg: Type): Type {    return arg;  }  let myIdentity: { <Type>(arg: Type): Type } = identity;   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIy6ICxMlTrtDbJocTTEAXmSas2CUA)\n\nWhich leads us to writing our first generic interface. Let’s take the object literal from the previous example and move it to an interface:\n\nts\n\n`   interface GenericIdentityFn {    <Type>(arg: Type): Type;  }  function identity<Type>(arg: Type): Type {    return arg;  }  let myIdentity: GenericIdentityFn = identity;   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDERkBvAKGWQB4AVEgBwgD4AKOKAcwBcyFuwCUQkRADcNAL40aMAK4gERAPaVgBcMRLM2nHvwmHxww9TrIoEMEqiVefGfJoAbO8gC2JfIT0hdEwobH9dUgpkAF5kbQDSKSA)\n\nIn a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we’re generic over (e.g. `Dictionary<string>` rather than just `Dictionary`). This makes the type parameter visible to all the other members of the interface.\n\nts\n\n`   interface GenericIdentityFn<Type> {    (arg: Type): Type;  }  function identity<Type>(arg: Type): Type {    return arg;  }  let myIdentity: GenericIdentityFn<number> = identity;   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDEQAeAFRIAcIA+ZAbwChlkAKOKAcwBcyWgwCUQkRADcbAL5s2MAK4gERAPYhkwAuGIka9Jj34Sj44UdYdkUCGCVQtvPjPlsANveQBbEvkJ9IXRMKGwAvVIKShAlHwAjaGYAXm1dIlIpIA)\n\nNotice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use `GenericIdentityFn`, we now will also need to specify the corresponding type argument (here: `number`), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.\n\nIn addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.\n\n[](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-classes)\nGeneric Classes\n------------------------------------------------------------------------------------------------\n\nA generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (`<>`) following the name of the class.\n\nts\n\n`   class GenericNumber<NumType> {    zeroValue: NumType;    add: (x: NumType, y: NumType) => NumType;  }  let myGenericNumber = new GenericNumber<number>();  myGenericNumber.zeroValue = 0;  myGenericNumber.add = function (x, y) {    return x + y;  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAgWw8aFAWfipaeh4OWHdQWgB3Sho6JCiualZokWNnHVDwlMZMugA6OVglFTxYgAY8sOTI4tgSg31Y9CZqZHh5alAzW35XSWlYIKZYftNQAGo7Xy0gA)\n\nThis is a pretty literal use of the `GenericNumber` class, but you may have noticed that nothing is restricting it to only use the `number` type. We could have instead used `string` or even more complex objects.\n\nts\n\n`   let stringNumeric = new GenericNumber<string>();  stringNumeric.zeroValue = \"\";  stringNumeric.add = function (x, y) {    return x + y;  };  console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAiFAAWmDEJmhgwIJsPGhQGARqAHMeOiR3UFoAd0oaVMZWDlhOePgkkWNnHRKklPoAOjlYJRU8dIAiNqq4UuTWPLqDfXT0JmpkeHlqUDNbfldJaVgYplgp01AAajtfHSJJyHlouux5RONq3pZ+wfPumr76xubsVVs26DwYNudKoA)\n\nJust as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.\n\nAs we cover in [our section on classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)\n, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter.\n\n[](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)\nGeneric Constraints\n--------------------------------------------------------------------------------------------------------\n\nIf you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have _some_ knowledge about what capabilities that set of types will have. In our `loggingIdentity` example, we wanted to be able to access the `.length` property of `arg`, but the compiler could not prove that every type had a `.length` property, so it warns us that we can’t make this assumption.\n\nts\n\n`   function loggingIdentity<Type>(arg: Type): Type {    console.log(arg.length);  Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.    return arg;  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA)\n\nInstead of working with any and all types, we’d like to constrain this function to work with any and all types that _also_  have the `.length` property. As long as the type has this member, we’ll allow it, but it’s required to have at least this member. To do so, we must list our requirement as a constraint on what `Type` can be.\n\nTo do so, we’ll create an interface that describes our constraint. Here, we’ll create an interface that has a single `.length` property and then we’ll use this interface and the `extends` keyword to denote our constraint:\n\nts\n\n`   interface Lengthwise {    length: number;  }  function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {    console.log(arg.length); // Now we know it has a .length property, so no more error    return arg;  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHcuZAB6eOQAOXE8ZDwUAGsQNORgMGQcOAs4ZCisXGQ9KHEDKA0AGmRApnFkVnEoQyhaqF9usGYoKSdMHl4gA)\n\nBecause the generic function is now constrained, it will no longer work over any and all types:\n\nts\n\n`  loggingIdentity(3);  Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKADKREDmJAFgO4GJ0DeeoUABsmrNqiIBXALYAjGAG48AXzx5ykotRIE4RYXGbNizAJIATJjpIBPADwAVGwAc6kAB5ki5xA1HsuHgA+AApKaGZUJ1cASiiXPgFQaj1EOBEAOiFDMIis-zYYpUFoSBJJaH1w5iVVEFAAWibqSRImhrxsoxMLKwJbEIwioA)\n\nInstead, we need to pass in values whose type has all the required properties:\n\nts\n\n`   loggingIdentity({ length: 10, value: 3 });   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHceSigIMGYoKSdMHn4AekzkAFp8hGYwfNyyMNl5ZVVgDXsSamjGAEYABgAaZAA3OCpmCEYAZmReWKA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints)\nUsing Type Parameters in Generic Constraints\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nYou can declare a type parameter that is constrained by another type parameter. For example, here we’d like to get a property from an object given its name. We’d like to ensure that we’re not accidentally grabbing a property that does not exist on the `obj`, so we’ll place a constraint between the two types:\n\nts\n\n`  function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {    return obj[key];  }  let x = { a: 1, b: 2, c: 3, d: 4 };  getProperty(x, \"a\");  getProperty(x, \"m\");  Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAOaQUAK8ADjBQJ4A8AKlw4AaUAGlIXUJAAeFSCQAmiUAGsJcAqAEcAfAAo4AIwBWqbZBFquqcVwCUoAN55QoaEyLQ6R4wG0rALoA3HgAvnh4ADZMoNKgALxOoACGqACMIoaoaCJkqBgiCqhYoKEheIws7JxcetIiAETJDXYhlaxwHNDcdY0Ati1BQA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-class-types-in-generics)\nUsing Class Types in Generics\n----------------------------------------------------------------------------------------------------------------------------\n\nWhen creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,\n\nts\n\n`   function create<Type>(c: { new (): Type }): Type {    return new c();  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBATgUwIZTQHgCoCeADmgHwAUEAXIgN6JhoDui5AlDYSYgL4eJc0dAFCJE6KCBRJGLCOwDcwnkA)\n\nA more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.\n\nts\n\n`   class BeeKeeper {    hasMask: boolean = true;  }  class ZooKeeper {    nametag: string = \"Mikle\";  }  class Animal {    numLegs: number = 4;  }  class Bee extends Animal {    numLegs = 6;    keeper: BeeKeeper = new BeeKeeper();  }  class Lion extends Animal {    keeper: ZooKeeper = new ZooKeeper();  }  function createInstance<A extends Animal>(c: new () => A): A {    return new c();  }  createInstance(Lion).keeper.nametag;  createInstance(Bee).keeper.hasMask;   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgBCeeA0tQA56ygDeBooAFqQLKkDWaAEYB7EdjyYAdqAC8oOAFc8AbgIBfAkRJlQALTF08jZmw5TMAWzzRMAczQwEUu3NAAiHvH4T3azdqk5ACCUvCWOKzsoFKKlgAyeHaQaLGWQkxuACz+WsRBlNSgeAAe0HhSACYhYRHYUeZxicluAGxqHPwMTGhUtN3M8lJ4AO6F-cZMABQAlLmBuvHwIjKl5VU14ZFmoF2TsGgGIkYmbsNjRyfTcxpa6IpSyMsyiLCS5QCSUjDSiHgAPMFimUKtVQKEttgAHxTRCpUagWZyKHgmZoIE7N7QRSwGTnUCIWbzV7vPBfH6PPBTJYrGYAOj2JjpFmstjsahJmE+31slKmfXpjKYdO4kD4kH4KiAA)\n\nThis pattern is used to power the [mixins](https://www.typescriptlang.org/docs/handbook/mixins.html)\n design pattern.\n\n[](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-parameter-defaults)\nGeneric Parameter Defaults\n----------------------------------------------------------------------------------------------------------------------\n\nBy declaring a default for a generic type parameter, you make it optional to specify the corresponding type argument. For example, a function which creates a new `HTMLElement`. Calling the function with no arguments generates a `HTMLDivElement`; calling the function with an element as the first argument generates an element of the argument’s type. You can optionally pass a list of children as well. Previously you would have to define the function as:\n\nts\n\n`   declare function create(): Container<HTMLDivElement, HTMLDivElement[]>;  declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;  declare function create<T extends HTMLElement, U extends HTMLElement>(    element: T,    children: U[]  ): Container<T, U[]>;   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQAFAEou8JGgw4AErgBZABkAEVQANwBRZjYkQn9gsKiY9mAAbQBdEj4DIxNoCysbOwEHJzwGAA8nBDEAZygEoOjWVJJnJlbObndYRBR0LDxCXEzs-UNjU0LrWwR7CEcICohq9nrGwOaUuOIqmo2mltjgdv5Ok64CfmFRCSliTJpezwGfYcesniA)\n\nWith generic parameter defaults we can reduce it to:\n\nts\n\n`   declare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(    element?: T,    children?: U  ): Container<T, U>;  const div = create();          const div: Container<HTMLDivElement, HTMLDivElement[]>  const p = create(new HTMLParagraphElement());         const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQ8DAB5OEYgM5QAErgBZABkAUWY2JAo-QKCAEVQANzDWdmBCIjcPb2jg5IjgAG0AXSjcYpIACn4mFKQAfi4CfmFRCXYG4hoASi54JDQMHAJiEgUBRC9gKDFEqIEHJwquvmV6egA9OpoacYRJqDA5hYgKjAB3HKCABRNkAHNMZDAhPNSl5aUVNc2gA)\n\nA generic parameter default follows the following rules:\n\n*   A type parameter is deemed optional if it has a default.\n*   Required type parameters must not follow optional type parameters.\n*   Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.\n*   When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.\n*   If a default type is specified and inference cannot choose a candidate, the default type is inferred.\n*   A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.\n*   A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.\n\n[](https://www.typescriptlang.org/docs/handbook/2/generics.html#variance-annotations)\nVariance Annotations\n----------------------------------------------------------------------------------------------------------\n\n> This is an advanced feature for solving a very specific problem, and should only be used in situations where you’ve identified a reason to use it\n\n[Covariance and contravariance](https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science))\n are type theory terms that describe what the relationship between two generic types is. Here’s a brief primer on the concept.\n\nFor example, if you have an interface representing an object that can `make` a certain type:\n\nts\n\n`   interface Producer<T> {    make(): T;  }   `\n\nWe can use a `Producer<Cat>` where a `Producer<Animal>` is expected, because a `Cat` is an `Animal`. This relationship is called _covariance_: the relationship from `Producer<T>` to `Producer<U>` is the same as the relationship from `T` to `U`.\n\nConversely, if you have an interface that can `consume` a certain type:\n\nts\n\n`   interface Consumer<T> {    consume: (arg: T) => void;  }   `\n\nThen we can use a `Consumer<Animal>` where a `Consumer<Cat>` is expected, because any function that is capable of accepting an `Animal` must also be capable of accepting a `Cat`. This relationship is called _contravariance_: the relationship from `Consumer<T>` to `Consumer<U>` is the same as the relationship from `U` to `T`. Note the reversal of direction as compared to covariance! This is why contravariance “cancels itself out” but covariance doesn’t.\n\nIn a structural type system like TypeScript’s, covariance and contravariance are naturally emergent behaviors that follow from the definition of types. Even in the absence of generics, we would see covariant (and contravariant) relationships:\n\nts\n\n`   interface AnimalProducer {    make(): Animal;  }  // A CatProducer can be used anywhere an  // Animal producer is expected  interface CatProducer {    make(): Cat;  }   `\n\nTypeScript has a structural type system, so when comparing two types, e.g. to see if a `Producer<Cat>` can be used where a `Producer<Animal>` is expected, the usual algorithm would be structurally expand both of those definitions, and compare their structures. However, variance allows for an extremely useful optimization: if `Producer<T>` is covariant on `T`, then we can simply check `Cat` and `Animal` instead, as we know they’ll have the same relationship as `Producer<Cat>` and `Producer<Animal>`.\n\nNote that this logic can only be used when we’re examining two instantiations of the same type. If we have a `Producer<T>` and a `FastProducer<U>`, there’s no guarantee that `T` and `U` necessarily refer to the same positions in these types, so this check will always be performed structurally.\n\nBecause variance is a naturally emergent property of structural types, TypeScript automatically _infers_ the variance of every generic type. **In extremely rare cases** involving certain kinds of circular types, this measurement can be inaccurate. If this happens, you can add a variance annotation to a type parameter to force a particular variance:\n\nts\n\n`   // Contravariant annotation  interface Consumer<in T> {    consume: (arg: T) => void;  }  // Covariant annotation  interface Producer<out T> {    make(): T;  }  // Invariant annotation  interface ProducerConsumer<in out T> {    consume: (arg: T) => void;    make(): T;  }   `\n\nOnly do this if you are writing the same variance that _should_ occur structurally.\n\n> Never write a variance annotation that doesn’t match the structural variance!\n\nIt’s critical to reinforce that variance annotations are only in effect during an instantiation-based comparison. They have no effect during a structural comparison. For example, you can’t use variance annotations to “force” a type to be actually invariant:\n\nts\n\n`   // DON'T DO THIS - variance annotation  // does not match structural behavior  interface Producer<in out T> {    make(): T;  }  // Not a type error -- this is a structural  // comparison, so variance annotations are  // not in effect  const p: Producer<string | number> = {      make(): number {          return 42;      }  }   `\n\nHere, the object literal’s `make` function returns `number`, which we might expect to cause an error because `number` isn’t `string | number`. However, this isn’t an instantiation-based comparison, because the object literal is an anonymous type, not a `Producer<string | number>`.\n\n> Variance annotations don’t change structural behavior and are only consulted in specific situations\n\nIt’s very important to only write variance annotations if you absolutely know why you’re doing it, what their limitations are, and when they aren’t in effect. Whether TypeScript uses an instantiation-based comparison or structural comparison is not a specified behavior and may change from version to version for correctness or performance reasons, so you should only ever write variance annotations when they match the structural behavior of a type. Don’t use variance annotations to try to “force” a particular variance; this will cause unpredictable behavior in your code.\n\n> Do NOT write variance annotations unless they match the structural behavior of a type\n\nRemember, TypeScript can automatically infer variance from your generic types. It’s almost never necessary to write a variance annotation, and you should only do so when you’ve identified a specific need. Variance annotations _do not_ change the structural behavior of a type, and depending on the situation, you might see a structural comparison made when you expected an instantiation-based comparison. Variance annotations can’t be used to modify how types behave in these structural contexts, and shouldn’t be written unless the annotation is the same as the structural definition. Because this is difficult to get right, and TypeScript can correctly infer variance in the vast majority of cases, you should not find yourself writing variance annotations in normal code.\n\n> Don’t try to use variance annotations to change typechecking behavior; this is not what they are for\n\nYou _may_ find temporary variance annotations useful in a “type debugging” situation, because variance annotations are checked. TypeScript will issue an error if the annotated variance is identifiably wrong:\n\nts\n\n`   // Error, this interface is definitely contravariant on T  interface Foo<out T> {    consume: (arg: T) => void;  }   `\n\nHowever, variance annotations are allowed to be stricter (e.g. `in out` is valid if the actual variance is covariant). Be sure to remove your variance annotations once you’re done debugging.\n\nLastly, if you’re trying to maximize your typechecking performance, _and_ have run a profiler, _and_ have identified a specific type that’s slow, _and_ have identified variance inference specifically is slow, _and_ have carefully validated the variance annotation you want to write, you _may_ see a small performance benefit in extraordinarily complex types by adding variance annotations.\n\n> Don’t try to use variance annotations to change typechecking behavior; this is not what they are for\n\n[### Creating Types from Types\\\n\\\nAn overview of the ways in which you can create more types from existing types.](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)\n\n[### Keyof Type Operator\\\n\\\nUsing the keyof operator in type contexts.](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/Generics.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (26)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nNK![Navneet Karnani  (2)](https://gravatar.com/avatar/0b697a0312ce289ae410387f99206a1b6cd5d1a58a99a63a3b794a64ea9959da?s=32&&d=blank)\n\nDGM![Dr. Galambos Máté  (1)](https://gravatar.com/avatar/f446b49616e35108eac10efe6b5bf8a43415e59353f9c33a528dc9bffe986e91?s=32&&d=blank)\n\nSP![Santiago Palladino  (1)](https://gravatar.com/avatar/82b03e2999216673fab521886007f660d24275bb331ce9acb747698a0f875f44?s=32&&d=blank)\n\nP![PanosMagic32  (1)](https://gravatar.com/avatar/2a170eb792b176610cde87a80f9c4b0b8cf026789ef6d5fb89239e5baaf2523c?s=32&&d=blank)\n\n12+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - Generics","ogDescription":"Types which take parameters","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:title":"Documentation - Generics","og:description":"Types which take parameters","twitter:site":"typescriptlang","language":"en","theme-color":"#3178C6","description":"Types which take parameters","title":"TypeScript: Documentation - Generics","generator":"Gatsby 5.13.5","scrapeId":"b9038015-ca6b-47de-aa78-2ef58a91a415","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/generics.html","url":"https://www.typescriptlang.org/docs/handbook/2/generics.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nIndexed Access Types\n====================\n\nWe can use an _indexed access type_ to look up a specific property on another type:\n\nts\n\n`   type Person = { age: number; name: string; alive: boolean };  type Age = Person[\"age\"];         type Age = number   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUKEhQAgkUywEKVAG0ARIQi6AuvID0pqJYB6AfiA)\n\nThe indexing type is itself a type, so we can use unions, `keyof`, or other types entirely:\n\nts\n\n`   type I1 = Person[\"age\" | \"name\"];         type I1 = string | number  type I2 = Person[keyof Person];         type I2 = string | number | boolean  type AliveOrName = \"alive\" | \"name\";  type I3 = Person[AliveOrName];         type I3 = string | boolean   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBJAIyZYCFKgDaAIkIQbUAD5QbqJg4C68pVD8A9AH45PXBoQwAmMzgkNCsAawgQZAAzc1jUb0VlAODQgwBBAWEAeXgAOQ8zO2KHZ1d3Zht5fXCAZmiLOKKhCDLK5izfXKA)\n\nYou’ll even see an error if you try to index a property that doesn’t exist:\n\nts\n\n`  type I1 = Person[\"alve\"];  Property 'alve' does not exist on type 'Person'.2339Property 'alve' does not exist on type 'Person'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAXATwAdJQAFGROAO1AF5QBvUAQwHNJUaBXAWwBGMANygarPl1CJ80AJY12o1gBs5ANykC4cFZFZ0AvsNwhQAWksBjHvkvmCJMgEkAjAwpVaAbQBEqzV8AXWEgA)\n\nAnother example of indexing with an arbitrary type is using `number` to get the type of an array’s elements. We can combine this with `typeof` to conveniently capture the element type of an array literal:\n\nts\n\n`   const MyArray = [    { name: \"Alice\", age: 15 },    { name: \"Bob\", age: 23 },    { name: \"Eve\", age: 38 },  ];  type Person = typeof MyArray[number];           type Person = {     name: string;     age: number; }  type Age = typeof MyArray[number][\"age\"];         type Age = number  // Or  type Age2 = Person[\"age\"];          type Age2 = number   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAsgTwIICcUEMEwLwwNoBQMMA3jGOgLYCmAXDAERIA2AlsNQwDQzoDmdGAEYArDAC+XIqXJVBDAEIgARt14D6AJgDMEqcTIUa9BgFEAbpx79B2gBx6CAXQDcBAlAQAHajAAK1CgQ4Dgwnj4gAGbwyGiYeGAArpTKga4EAPQZxDAAegD8Ht6+SAKh4dRRMagYCAnJqShOeAw2DOlZOQWZ2QDyKEU+MKXUmqEBQeAtbR3ZxAVAA)\n\nYou can only use types when indexing, meaning you can’t use a `const` to make a variable reference:\n\nts\n\n`  const key = \"age\";  type Age = Person[key];  Type 'key' cannot be used as an index type.   'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?2538   2749Type 'key' cannot be used as an index type.   'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMAOdB2AFgE4AoAFwE8AHSUABRkTgDtQBeUAb1AEMBzSKhYBXALYAjGAG5QLXmKGhE5aAEsW-WbwA2agG5KJcODsi82AX2mkQoALSOAxiPKP7pJ6xWgA1pEoOUAAiAUhgmypaUABBQSDGJFYAbX9KAF1pIA)\n\nHowever, you can use a type alias for a similar style of refactor:\n\nts\n\n`   type key = \"age\";  type Age = Person[key];   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBrCCExQARIQjn5+6AEEiZuEjQBtYyAC6dIA)\n\n[### Typeof Type Operator\\\n\\\nUsing the typeof operator in type contexts.](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)\n\n[### Conditional Types\\\n\\\nCreate types which act like if statements in the type system.](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/Indexed%20Access%20Types.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (5)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - Indexed Access Types","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"Using Type['a'] syntax to access a subset of a type.","description":"Using Type['a'] syntax to access a subset of a type.","theme-color":"#3178C6","og:description":"Using Type['a'] syntax to access a subset of a type.","twitter:site":"typescriptlang","generator":"Gatsby 5.13.5","language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","og:title":"Documentation - Indexed Access Types","ogTitle":"Documentation - Indexed Access Types","scrapeId":"c0a99f23-5320-4876-b0fb-d9c01e2a8260","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html","url":"https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nKeyof Type Operator\n===================\n\n[](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#the-keyof-type-operator)\nThe `keyof` type operator\n---------------------------------------------------------------------------------------------------------------------\n\nThe `keyof` operator takes an object type and produces a string or numeric literal union of its keys. The following type `P` is the same type as `type P = \"x\" | \"y\"`:\n\nts\n\n`   type Point = { x: number; y: number };  type P = keyof Point;        type P = keyof Point   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbygDwFxRICuAtgEYQBOA3FCAceVVAL7UBQoks6UA1hBBwAZrEQoOAeklRZAPQD8QA)\n\nIf the type has a `string` or `number` index signature, `keyof` will return those types instead:\n\nts\n\n`   type Arrayish = { [n: number]: unknown };  type A = keyof Arrayish;        type A = number  type Mapish = { [k: string]: boolean };  type M = keyof Mapish;        type M = string | number   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnAhiAlgZwBZQLxQN5QDaAdgFxTECuAtgEYRwC65lxA1sQPYDuxUAvgG4AUKEiwcUNhBCcAZrATJ0GEQHo1ULQD0A-MNHhoAWURgVkgoTbk0wOCmIBzZlFqdOAGwiI+Qw+LGktKyCqbmmOqaOrpAA)\n\nNote that in this example, `M` is `string | number` — this is because JavaScript object keys are always coerced to a string, so `obj[0]` is always the same as `obj[\"0\"]`.\n\n`keyof` types become especially useful when combined with mapped types, which we’ll learn more about later.\n\n[### Generics\\\n\\\nTypes which take parameters](https://www.typescriptlang.org/docs/handbook/2/generics.html)\n\n[### Typeof Type Operator\\\n\\\nUsing the typeof operator in type contexts.](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/Keyof%20Type%20Operator.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (3)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nRM![Roman Mahotskyi  (1)](https://gravatar.com/avatar/9fc6be1e7979f236d91d5cab8bc8b9e1f368d3e1883ce814b9c26c6c0f467230?s=32&&d=blank)\n\nMM![Masashi Miyazaki  (1)](https://gravatar.com/avatar/a8e503d907b24698d2730471024b9d63d1c0fcd9761020957a45ccc8dee60d60?s=32&&d=blank)\n\nS![suica  (1)](https://gravatar.com/avatar/9586efba9706e1ac318402527b273c2e9206a8ac8ffbb789c8f70b451c33c974?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","theme-color":"#3178C6","og:title":"Documentation - Keyof Type Operator","ogTitle":"Documentation - Keyof Type Operator","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"Using the keyof operator in type contexts.","og:description":"Using the keyof operator in type contexts.","twitter:site":"typescriptlang","title":"TypeScript: Documentation - Keyof Type Operator","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"Using the keyof operator in type contexts.","generator":"Gatsby 5.13.5","scrapeId":"fa7a99c7-f73e-49a2-b528-f67fdd5e7d64","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/keyof-types.html","url":"https://www.typescriptlang.org/docs/handbook/2/keyof-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nConditional Types\n=================\n\nAt the heart of most useful programs, we have to make decisions based on input. JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. _Conditional types_ help describe the relation between the types of inputs and outputs.\n\nts\n\n`   interface Animal {    live(): void;  }  interface Dog extends Animal {    woof(): void;  }  type Example1 = Dog extends Animal ? number : string;            type Example1 = number  type Example2 = RegExp extends Animal ? number : string;            type Example2 = string   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwChlkdgA3CACgEoAuZcge2ABMBuQgX0NElkQoAIkwDmyCAA9IIVgGc0GbHiIkA7kyYxaDZm049CYAJ4AHFAFFJcTKZwQAjMgC8yEeKkz5irLmQB+ZBAAV0wAI2hkBjkwKFBRTgB6RJJkAD1-QiMzS2tbewAmF2QAJQhRK1MJaQhZBXRfPECQ8Mjo2PiklJIMoA)\n\nConditional types take a form that looks a little like conditional expressions (`condition ? trueExpression : falseExpression`) in JavaScript:\n\nts\n\n  `SomeType extends OtherType ? TrueType : FalseType;`[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgChRIoB5YACwgCdVTNcDi0pkaBXFVxvIk6ADEsAGwDO3Btj4tSMYBwBmiqOkJQoAek1QAtPoDGHYPt3rYiSdAgAPYBBwATMeSq160APxtOVqAC4oYXErfCA)\n\nWhen the type on the left of the `extends` is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).\n\nFrom the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not `Dog extends Animal` and pick `number` or `string`! But the power of conditional types comes from using them with generics.\n\nFor example, let’s take the following `createLabel` function:\n\nts\n\n`   interface IdLabel {    id: number /* some fields */;  }  interface NameLabel {    name: string /* other fields */;  }  function createLabel(id: number): IdLabel;  function createLabel(name: string): NameLabel;  function createLabel(nameOrId: string | number): IdLabel | NameLabel;  function createLabel(nameOrId: string | number): IdLabel | NameLabel {    throw \"unimplemented\";  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbJIw6IBGGA8QyBFAg4SA0CAApKGnomaABKGgwQ-Ck3Dy8fPwCgiETQ3X4DI1M45FV1XAJk909vX39A4PL8XL0AeSgMAuMQMwAfWkZmYoTG5D7S7MbK1JqM+onNZv42ju5C7tH+6KghrBGxvUTiMmRrKB4Ad2QAIndgBgAHfAh+cAh0K+cgA)\n\nThese overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:\n\n1.  If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.\n2.  We have to create three overloads: one for each case when we’re _sure_ of the type (one for `string` and one for `number`), and one for the most general case (taking a `string | number`). For every new type `createLabel` can handle, the number of overloads grows exponentially.\n\nInstead, we can encode that logic in a conditional type:\n\nts\n\n`   type NameOrId<T extends number | string> = T extends number    ? IdLabel    : NameLabel;   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbNatkAWk8I6YT+5JgAJ4ADip6APJQGAA8ACrIEAAekCAitIzMyAA+3EamAHzIALzI8UkpafRM0GTIAPxoWLgEtTSq6s34EkA)\n\nWe can then use that conditional type to simplify our overloads down to a single function with no overloads.\n\nts\n\n`   function createLabel<T extends number | string>(idOrName: T): NameOrId<T> {    throw \"unimplemented\";  }  let a = createLabel(\"typescript\");       let a: NameLabel  let b = createLabel(2.8);       let b: IdLabel  let c = createLabel(Math.random() ? \"hello\" : 42);  let c: NameLabel | IdLabel   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgJIBMAycBGEA2yA3gFDLLDoBcyIArgLZ5TID0AVMgM4D2DKMYAXRdk7VgG4SAXxKhIsRCgBycftjyFS5EGog0uYKKADmbTjzAALaMkHDR4qbLABPAA4q9AeSgYAPAAqyBAAHpAgIrSMzMgAPtxGpgB8yAC8yMFhEVH0TNBkyAD8aFi4BIU0qurl+FKsrMgAtC0IdGAtTSQwdCAIYMA8IMgIUBBwkBoEQSHhEJGiebEJhsYgJskAFJS+1fqZAJRVPn7oQanayNZQPADuyABEvcAM7vgQ-OAQ6A-OJCTvMDIODpEZjCYQKb4TYPNyeLijYDuMAPA71RrIAB6RX+gOQOFBo3Gk1qmwATAA6AAcaJIDXI2NxECBCEJ4JJmk2AFkJlYKVA4JE+JsDsVHjZ8PgeA9kDQACxk2n0rFFIA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#conditional-type-constraints)\nConditional Type Constraints\n\nOften, the checks in a conditional type will provide us with some new information. Just like narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against.\n\nFor example, let’s take the following:\n\nts\n\n`  type MessageOf<T> = T[\"message\"];  Type '\"message\"' cannot be used to index type 'T'.2536Type '\"message\"' cannot be used to index type 'T'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMA2AUAC4CeADpKALKSKICGA5pAPIBmAPACoB8oAvKBwDaAIgC21Oo2EBdANxA)\n\nIn this example, TypeScript errors because `T` isn’t known to have a property called `message`. We could constrain `T`, and TypeScript would no longer complain:\n\nts\n\n`   type MessageOf<T extends { message: unknown }> = T[\"message\"];  interface Email {    message: string;  }  type EmailMessageContents = MessageOf<Email>;                  type EmailMessageContents = string   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshDO8CGBzCB5AZgHgCpQgA9gIA7AE3igG8oBbBZNALigFdSBrUgewHdSUAL4A+KAF4ouANoAiBolQRZAXQDcAKA0BLUiQBOmJAGNoAUTpJtAGxoao9Rktbxg+3Sk1CtoSFAtW1nCKaADCPHpkwFSSwUwYOAE2IpoA9KkOUAB6APxAA)\n\nHowever, what if we wanted `MessageOf` to take any type, and default to something like `never` if a `message` property isn’t available? We can do this by moving the constraint out and introducing a conditional type:\n\nts\n\n`   type MessageOf<T> = T extends { message: unknown } ? T[\"message\"] : never;  interface Email {    message: string;  }  interface Dog {    bark(): void;  }  type EmailMessageContents = MessageOf<Email>;                  type EmailMessageContents = string  type DogMessageContents = MessageOf<Dog>;                 type DogMessageContents = never   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAshDO8CGBzCB5AZgHgCoD4oBeKXKCAD2AgDsATeKAbygFsFk0AuKAVxoDWNAPYB3GlAC+UAPykA2gCJ2iVBEUBdKDxoQAbhABOAbgBQpgJY1qhzEgDG0AKKskFgDbNTUNhzU94YEMrFDNJcysbO0coABFhFC8fACMkQwEACgBKHj1hCzow81BIKBc3dzhVNABhYWtaYEYSKs4MHHKPfDMAeh6fKAA9GWLwaHiUVrU6hutm2D80LGwJ7tM+geGgA)\n\nWithin the true branch, TypeScript knows that `T` _will_ have a `message` property.\n\nAs another example, we could also write a type called `Flatten` that flattens array types to their element types, but leaves them alone otherwise:\n\nts\n\n`   type Flatten<T> = T extends any[] ? T[number] : T;  // Extracts out the element type.  type Str = Flatten<string[]>;         type Str = string  // Leaves the type alone.  type Num = Flatten<number>;         type Num = number   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYgNgQ2MCA7APAFQHxQLxSZQQAeKqAJgM5QKogDaAulAPyEOoCuAtgEYQATiwBchANwAoSQHoZUAKJlBCAMbAaAey7AowABbQIcCDzS7QkAHSTL0AMrBB+WImRp0VJwEtUAc2ZsKTkoUIA9VmkQgBkIBAA3CBoDaDtaOE1UCBs0gDleF3gkcnRufiEg2Xlw1iA)\n\nWhen `Flatten` is given an array type, it uses an indexed access with `number` to fetch out `string[]`’s element type. Otherwise, it just returns the type it was given.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)\nInferring Within Conditional Types\n\nWe just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.\n\nConditional types provide us with a way to infer from types we compare against in the true branch using the `infer` keyword. For example, we could have inferred the element type in `Flatten` instead of fetching it out “manually” with an indexed access type:\n\nts\n\n`   type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAYgNgQ2MCA7APAFXBAfFAXim0iggA8VUATAZygEEAnJhEdAS1QDMImoAkigC2+APyCRUAFzEcAbiA)\n\nHere, we used the `infer` keyword to declaratively introduce a new generic type variable named `Item` instead of specifying how to retrieve the element type of `Type` within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.\n\nWe can write some useful helper type aliases using the `infer` keyword. For example, for simple cases, we can extract the return type out from function types:\n\nts\n\n`   type GetReturnType<Type> = Type extends (...args: never[]) => infer Return    ? Return    : never;  type Num = GetReturnType<() => number>;         type Num = number  type Str = GetReturnType<(x: string) => string>;         type Str = string  type Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]>;          type Bools = boolean[]   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hwCV4FcBOA7AKuCAebkAfFALxQHQQAewE6AJgM5QAUAdBwIaoDmjAXFHQQAbhFQBtALoBKUsQCW6AGbioSYGnQAoKFAD86lBl1RBwsagDc27aEhQAcsgC2pWPA1aKuFnJLE6K4ARuKENgD0EXpQAHr6tvbQAMrAqO5wiMZYOL5UgoxpSjz+xIWoxeHaUTHxiThQAEIA9s0ANsxkmV4YPiycgsGtbRCc6AA0UMGDw6PopVOzY9JVNXrxQA)\n\nWhen inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the _last_ signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.\n\nts\n\n`   declare function stringOrNum(x: string): number;  declare function stringOrNum(x: number): string;  declare function stringOrNum(x: string | number): string | number;  type T1 = ReturnType<typeof stringOrNum>;         type T1 = string | number   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwGcMYtUBzAeRgDlkBbACgA8AuQ40sgSjdXoCMQMANwAoUJFgIU6bHnYlyVWo1bw+dQTB4LOYidDhI0mXPiKLKNeszYXO8AD7qBQnffJOXmoWNEYATwAHBAAVAEZ4AF54ACUQDGQYVFDgkAAeQJCcRF0lazoAPjEAehL4CoA9AH4gA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)\nDistributive Conditional Types\n---------------------------------------------------------------------------------------------------------------------------------------\n\nWhen conditional types act on a generic type, they become _distributive_ when given a union type. For example, take the following:\n\nts\n\n`   type ToArray<Type> = Type extends any ? Type[] : never;   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcQA)\n\nIf we plug a union type into `ToArray`, then the conditional type will be applied to each member of that union.\n\nts\n\n`   type ToArray<Type> = Type extends any ? Type[] : never;  type StrArrOrNumArr = ToArray<string | number>;               type StrArrOrNumArr = string[] | number[]   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcAKEmhIUAMrAkyJAHkkAOQCuAWxWFYiFOgx0lASyoBzKAB9BugEZjcUgPRuoXgHqsgA)\n\nWhat happens here is that `ToArray` distributes on:\n\nts\n\n  `string | number;`[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBBe8Dy8ByBXAts+UAvAFBRQD05UAtLQMZbC3WlQDOCAlgHYDmUAHyjdcAIwjwA3EA)\n\nand maps over each member type of the union, to what is effectively:\n\nts\n\n  `ToArray<string> | ToArray<number>;`[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgDw3BAfFAXlhyggA9gIA7AEwGcpUqQoB+YyAbQF0oAuKFQgA3CEgDcAKFCQoAZWBJkSAPJIAcgFcAtssKSoUAPRGoAWgsBjTcAtmDsRCnQY6igJZUA5vgA+j5RcqHQAjMVxxIA)\n\nwhich leaves us with:\n\nts\n\n  `string[] | number[];`[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBBe8Dy8ByBXAts+UAvAFBRQD05UAtLQMZbC3WlQDOCAlgHYDmA2gF0oAHyjdcAIwjwhAbiA)\n\nTypically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the `extends` keyword with square brackets.\n\nts\n\n`   type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;  // 'ArrOfStrOrNum' is no longer a union.  type ArrOfStrOrNum = ToArrayNonDist<string | number>;              type ArrOfStrOrNum = (string | number)[]   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKg9gQQE5IIYgHJwHYBECWAzsADwzgQB8UAvFANrmQC6UEAHsBNgCaEOpsIVgH5YFeqwBcUbBABuEJAG4AUKoD0GqAHJkSAPIAzAMrBDSDAFcAtjqhFZcKABscAcyVRUUK9nw4AHSqoJBQ+sZmFtY2tLCIKOhYeESkxEj42O5QAD6ytgBGSpRqWlDlAHoiQA)\n\n[### Indexed Access Types\\\n\\\nUsing Type\\['a'\\] syntax to access a subset of a type.](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)\n\n[### Mapped Types\\\n\\\nGenerating types by re-using an existing type.](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/Conditional%20Types.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (10)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nBK![Benedikt König  (1)](https://gravatar.com/avatar/617858d12f0f8fff5df2ac0b8b72da2a9314a651e3eaba381217274133e0ce37?s=32&&d=blank)\n\nGF![George Flinn  (1)](https://gravatar.com/avatar/8c0a84b063728dfaae111d46396b88817bd339a3b67784e446f0b9839d312713?s=32&&d=blank)\n\nSF![Shinya Fujino  (1)](https://gravatar.com/avatar/1820714c7b464d87937b6d63073002cffe11cbdf39df45400a9e49650603b48b?s=32&&d=blank)\n\nNM![Nicolás Montone  (1)](https://gravatar.com/avatar/8aab40d5666d4171c6fc9d263a34152116c817c6ddd0c8c51b9c59ebb28ff5a0?s=32&&d=blank)\n\n9+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:title":"Documentation - Conditional Types","theme-color":"#3178C6","generator":"Gatsby 5.13.5","language":"en","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"Create types which act like if statements in the type system.","ogTitle":"Documentation - Conditional Types","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"Create types which act like if statements in the type system.","og:description":"Create types which act like if statements in the type system.","twitter:site":"typescriptlang","title":"TypeScript: Documentation - Conditional Types","scrapeId":"ec20f5cb-d7a7-4e9b-9e21-eefb7d4f51af","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/conditional-types.html","url":"https://www.typescriptlang.org/docs/handbook/2/conditional-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nMapped Types\n============\n\nWhen you don’t want to repeat yourself, sometimes a type needs to be based on another type.\n\nMapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time:\n\nts\n\n`   type OnlyBoolsAndHorses = {    [key: string]: boolean | Horse;  };  const conforms: OnlyBoolsAndHorses = {    del: true,    rodney: false,  };   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAEg9gJwM7QLxQN4F8DcAoAegKgFoyBjAV2DJL1EigHkA7AGxACE442kBBFgBN4yCEijoMeKFADaAawggAXFCTAEASxYBzALpqARjzYQAhiygAfWIhT5cePOTgsNUVywBmiALZIaqwc3LwCwqIoElIyUEIQbGqalBAANLEIcEIsymre5nxpeLhAA)\n\nA mapped type is a generic type which uses a union of `PropertyKey`s (frequently created [via a `keyof`](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)\n) to iterate through keys to create a type:\n\nts\n\n`   type OptionsFlags<Type> = {    [Property in keyof Type]: boolean;  };   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+GoA)\n\nIn this example, `OptionsFlags` will take all the properties from the type `Type` and change their values to be a boolean.\n\nts\n\n`   type Features = {    darkMode: () => void;    newUserProfile: () => void;  };  type FeatureOptions = OptionsFlags<Features>;               type FeatureOptions = {     darkMode: boolean;     newUserProfile: boolean; }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+WgPR6oAWhMBjAK7ATR+qEhQMa4OfYQ01OoygATHO0EAskjeEPIAFACU1JQAbkgI3lpMKBAA7gCqaBDsHOIIquFRVLHxiTpatmQOTi4QcIio7jT1yOjY+ESOOM6uaOT6hkwAegD8QA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers)\nMapping Modifiers\n\nThere are two additional modifiers which can be applied during mapping: `readonly` and `?` which affect mutability and optionality respectively.\n\nYou can remove or add these modifiers by prefixing with `-` or `+`. If you don’t add a prefix, then `+` is assumed.\n\nts\n\n`   // Removes 'readonly' attributes from a type's properties  type CreateMutable<Type> = {    -readonly [Property in keyof Type]: Type[Property];  };  type LockedAccount = {    readonly id: string;    readonly name: string;  };  type UnlockedAccount = CreateMutable<LockedAccount>;               type UnlockedAccount = {     id: string;     name: string; }   `[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHIBOkCGATWA7AGwE9VQsAXC9ASwCMBXC5UAM3VmnNAuIAdIqFHw4D0FGsgBQvAaADCmSpACyTLHUKQAPABV+kAHygAvKADeU0KAC0SvEWKgA2gAVRkcU5r5QAa0hiWFZQfQEAXQAuUIM3Dy9wgG4pAF9kmQNQABlYAGMAnABBXNzYBnwKUwsrUHsCElAaHGikah8Ac2TrOsdQfCxoSBa2-E7U9NlIUABVIjyC4tLyyrNFbGY1Cg0tbRz8yCKSsorDZJBrUAA9AH4gA)\n\nts\n\n`   // Removes 'optional' attributes from a type's properties  type Concrete<Type> = {    [Property in keyof Type]-?: Type[Property];  };  type MaybeUser = {    id: string;    name?: string;    age?: number;  };  type User = Concrete<MaybeUser>;          type User = {     id: string;     name: string;     age: number; }   `[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHJYAcAuBLWA7AQwBtVRCssAnHAIwFctlQAzK2ac0LATw0lQoM7flVzIAUL36gAwgQDGVSEwA8AFT6QAfKAC8oAN4TQoANoAFEZDE9QOfKADWkHrBahN-ALoBaAPwAXJ5alta23gDcEgC+0VJaoACyhDy0kACqSDb6Rib2ACbBSNQOAObRpkTQkEGgJTT4FfmEZbXB+PTQ6VTRcRIJMlk5BvL4SiqQqilpmdlU2tEgpqAAev5AA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)\nKey Remapping via `as`\n----------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 4.1 and onwards, you can re-map keys in mapped types with an `as` clause in a mapped type:\n\nts\n\n`   type MappedTypeWithNewProperties<Type> = {      [Properties in keyof Type as NewKeyType]: Type[Properties]  }   `\n\nYou can leverage features like [template literal types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)\n to create new property names from prior ones:\n\nts\n\n``   type Getters<Type> = {      [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]  };  interface Person {      name: string;      age: number;      location: string;  }  type LazyPerson = Getters<Person>;             type LazyPerson = {     getName: () => string;     getAge: () => number;     getLocation: () => string; }   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hzAgJwM4B4Aq4ID4oF4oBvAKCnKgG0AFJAe0iVCgEsA7KAawhDoDMoWSFACGKKAAMA5vAAkRAMIiwLYCIA2LAF4Q0KYEnZSoAMii0GyUDgC+EgLoAuKAAoAlATxCINeo1D2JDYA3CQk7IhIfCIAxtDUyCh0HKQUUGwiALYQzvqGbFKhaSIyzmwArpkARshFFOp0MSLALMm5BkahNmGgwgAyIlogCajJBLDwkegjSWw4oQD0CxQAegD8QA)\n\nYou can filter out keys by producing `never` via a conditional type:\n\nts\n\n`   // Remove the 'kind' property  type RemoveKindField<Type> = {      [Property in keyof Type as Exclude<Property, \"kind\">]: Type[Property]  };  interface Circle {      kind: \"circle\";      radius: number;  }  type KindlessCircle = RemoveKindField<Circle>;               type KindlessCircle = {     radius: number; }   `[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdKgC4AskHIDWBLAdgCYagAOATrCZGcgJ4BQdVEMCkA0vgQGI6QA2BADwAVWlQB8oALygA3vVBLQAbQAKFKjVqh8oLJFqwAZqDHMAhgGdQAUQAeAY34BXApCEbK1OgBpQAES4hAESALoAXGbikOqaPrRh9AC+ANz09PjI1MYWjkgAwjhkzkgKyvpcUQGOxaUB6RVkFgQ4LlZReC7QAEbU6ckZTEichPyQVlZFJeMyLHCIozx8gkLTpRLpIMoAegD8QA)\n\nYou can map over arbitrary unions, not just unions of `string | number | symbol`, but unions of any type:\n\nts\n\n`   type EventConfig<Events extends { kind: string }> = {      [E in Events as E[\"kind\"]]: (event: E) => void;  }  type SquareEvent = { kind: \"square\", x: number, y: number };  type CircleEvent = { kind: \"circle\", radius: number };  type Config = EventConfig<SquareEvent | CircleEvent>           type Config = {     square: (event: SquareEvent) => void;     circle: (event: CircleEvent) => void; }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogbhAdsAwge0QMwJYHMA88SwAzlBAB7BIAmZA3lANbaI0BcUJwATq7lAC+APigBeKPQBQUWVADaMKK1gJkZAIZkY8gEQs2ugLpHOACghrgnGAEpxouGmw0A3FMFSpoSFADKAI4Arho8EETI4pLMrBxQuiTBoRC6ADRQFJyIQQC2AEYQPOkgWbkFPELuPtAo2DwAxgA24VZRjAZxuvV1TSnpPBo02EEkpfmFlV7VUOhYeFERqBg4BIEhYYtQAD4zPc2LwlIA9EdyAHoA-EA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#further-exploration)\nFurther Exploration\n\nMapped types work well with other features in this type manipulation section, for example here is [a mapped type using a conditional type](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)\n which returns either a `true` or `false` depending on whether an object has the property `pii` set to the literal `true`:\n\nts\n\n`   type ExtractPII<Type> = {    [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;  };  type DBFields = {    id: { format: \"incrementing\" };    name: { type: string; pii: true };  };  type ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;                     type ObjectsNeedingGDPRDeletion = {     id: false;     name: true; }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogHsATgQwMbAAoEksB4Aq4EAfFALxQDeAUFFANoaID2kioUAlgHZQDWEEMwBmUQpAC6ALjFFGLNqAlQICCNwAmAZypQwnTjKQBXaAF8oAfignoM4cgA2WiAG5qZ99VCQoAEQAhADFOCEdtcipaLg0ZSihhZkQAW2RgGQAiHlRECGT1YB4AcwyoT2juZHy4myIZLSRi1z0DI0RTMvdy7yIoAHkAIwArCHQtADkICA1igHE-DAAlPzCIQuZeCngkNEwcXECQsO1idwB6M7ooAD1LIA)\n\n[### Conditional Types\\\n\\\nCreate types which act like if statements in the type system.](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)\n\n[### Template Literal Types\\\n\\\nGenerating mapping types which change properties via template literal strings.](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/Mapped%20Types.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (7)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nSF![Sergey Falinsky  (2)](https://gravatar.com/avatar/5d9c75b281592131230095bf81dcbf654a69e1ca47af5c275f0687e5da571d36?s=32&&d=blank)\n\nL![Luke  (1)](https://gravatar.com/avatar/1778698e15015967ad965a26b75d42e60fa3663ca5aac74bde74e0368f512f84?s=32&&d=blank)\n\nW![webstrand  (1)](https://gravatar.com/avatar/3da8825d4970df9c88573b8b96aee80257783f6e6088d54228bb6e4023287190?s=32&&d=blank)\n\nSGH![Steven G. Harms  (1)](https://gravatar.com/avatar/707f428bf9077bef7087dd3237e2df39f1853397977155a59c0cec4b3c2d21e9?s=32&&d=blank)\n\n5+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"Generating types by re-using an existing type.","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","generator":"Gatsby 5.13.5","og:title":"Documentation - Mapped Types","ogTitle":"Documentation - Mapped Types","og:description":"Generating types by re-using an existing type.","twitter:site":"typescriptlang","title":"TypeScript: Documentation - Mapped Types","language":"en","description":"Generating types by re-using an existing type.","scrapeId":"8b71761c-8585-4b89-b0c8-5fd832583a48","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/mapped-types.html","url":"https://www.typescriptlang.org/docs/handbook/2/mapped-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTemplate Literal Types\n======================\n\nTemplate literal types build on [string literal types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)\n, and have the ability to expand into many strings via unions.\n\nThey have the same syntax as [template literal strings in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)\n, but are used in type positions. When used with concrete literal types, a template literal produces a new string literal type by concatenating the contents.\n\nts\n\n``   type World = \"world\";  type Greeting = `hello ${World}`;            type Greeting = \"hello world\"   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6g9gJwDYBMoF4oCIDujVYDcAUMaJFAOIIQTACWAdgOYZQAGAFhEknFABIA3vGQoAvuxIB6aVHkA9APxA)\n\nWhen a union is used in the interpolated position, the type is the set of every possible string literal that could be represented by each union member:\n\nts\n\n``   type EmailLocaleIDs = \"welcome_email\" | \"email_heading\";  type FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\";  type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;              type AllLocaleIDs = \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\"   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnzF4aAEEUdGxcAhJyKAADABIAb3h+XVCDblVHHRD9EgBfZiRRSIUAeiKoMoA9AH4gA)\n\nFor each interpolated position in the template literal, the unions are cross multiplied:\n\nts\n\n``   type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;  type Lang = \"en\" | \"ja\" | \"pt\";  type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;                type LocaleMessageIDs = \"en_welcome_email_id\" | \"en_email_heading_id\" | \"en_footer_title_id\" | \"en_footer_sendoff_id\" | \"ja_welcome_email_id\" | \"ja_email_heading_id\" | \"ja_footer_title_id\" | \"ja_footer_sendoff_id\" | \"pt_welcome_email_id\" | \"pt_email_heading_id\" | \"pt_footer_title_id\" | \"pt_footer_sendoff_id\"   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnyA9D6gAtEFYAK7AQQGK4NAAgijo2LgEJORQAAYAJADe8Py6SQbcqo46ifokAL7MSKJpCkrQaAjSqZSudlQAVggdlGDA3lHK+XgAshDExAhSyYbp2U3SVdlxCXqzFXW+-lBQAHoA-EA)\n\nWe generally recommend that people use ahead-of-time generation for large string unions, but this is useful in smaller cases.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#string-unions-in-types)\nString Unions in Types\n\nThe power in template literals comes when defining a new string based on information inside a type.\n\nConsider the case where a function (`makeWatchedObject`) adds a new function called `on()` to a passed object. In JavaScript, its call might look like: `makeWatchedObject(baseObject)`. We can imagine the base object as looking like:\n\nts\n\n`   const passedObject = {    firstName: \"Saoirse\",    lastName: \"Ronan\",    age: 26,  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AA4CGKKApgCYDyARgFZkb4C8oA3mqKAGYCWquAHJEAtmQBcoAEQBlItH7kpAGk6gANiSGiJ0gErYikFWqIBzXQCYAbKoC+AbiA)\n\nThe `on` function that will be added to the base object expects two arguments, an `eventName` (a `string`) and a `callback` (a `function`).\n\nThe `eventName` should be of the form `attributeInThePassedObject + \"Changed\"`; thus, `firstNameChanged` as derived from the attribute `firstName` in the base object.\n\nThe `callback` function, when called:\n\n*   Should be passed a value of the type associated with the name `attributeInThePassedObject`; thus, since `firstName` is typed as `string`, the callback for the `firstNameChanged` event expects a `string` to be passed to it at call time. Similarly events associated with `age` should expect to be called with a `number` argument\n*   Should have `void` return type (for simplicity of demonstration)\n\nThe naive function signature of `on()` might thus be: `on(eventName: string, callback: (newValue: any) => void)`. However, in the preceding description, we identified important type constraints that we’d like to document in our code. Template Literal types let us bring these constraints into our code.\n\nts\n\n``   const person = makeWatchedObject({    firstName: \"Saoirse\",    lastName: \"Ronan\",    age: 26,  });  // makeWatchedObject has added `on` to the anonymous Object  person.on(\"firstNameChanged\", (newValue) => {    console.log(`firstName was changed to ${newValue}!`);  });   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABMCmBjANgIbxagBmArpDgC4CW0koAtgQNZYDqB1OAFlhgDyAIwBWuagApoYgFygCkAJ4BKeYqUBuNCFABaAznLUDetDgYpqoAA5ZUDUAF5mbTtz4CR4mpIDeaKBktKjUAHIETFjyAEQAygTQIShYMQA0gaCEVhFRsQBKDIrpmQQA5tGgAEwAbBkAviraOmAs7Fw8-EJiEqC8BCgKGNgYoAAGDGOg1NDT-AowykzQ5IPeEmhodg6QAHQMkjGkyeGRWADC-ZAVGOmgkpBYAO4AagR45FgqzgB8oAFBCyQFDQPBYXZ4aBlSRjY6hXIkJ4DUB8RQ3aazAAkfker3en3qAEIxk00I1NEA)\n\nNotice that `on` listens on the event `\"firstNameChanged\"`, not just `\"firstName\"`. Our naive specification of `on()` could be made more robust if we were to ensure that the set of eligible event names was constrained by the union of attribute names in the watched object with “Changed” added at the end. While we are comfortable with doing such a calculation in JavaScript i.e. ``Object.keys(passedObject).map(x => `${x}Changed`)``, template literals _inside the type system_ provide a similar approach to string manipulation:\n\nts\n\n``   type PropEventSource<Type> = {      on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;  };  /// Create a \"watched object\" with an `on` method  /// so that you can watch for changes to properties.  declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGAFBOlgHIBDALYQAXFAAGAEgYBnYHACWGAOZQAZFADWEEAgBmUCpAC+AYQAWA1RAAmEgDRRCAgDauARgMJbxnDBAA7gBqbnhiUNYgAJR0NKgIirbR4glJANxMJplMAPT5UGZwEALA0AJQAESBpYQWduweAFYQhMCVUIGKwBaRGJIcElAiPQi2eQWyCFA9pVB6eM7WnbW9+ghwzlY2sjPTYIiQcMCKELIAdEy2ra4CxVD6eBhtihzDAjoA6qt2APLNrWA5EoVE4CGa4mMEBSRkoGlghzQmBw+CIpChVHSQA)\n\nWith this, we can build something that errors when given the wrong property:\n\nts\n\n`  const person = makeWatchedObject({    firstName: \"Saoirse\",    lastName: \"Ronan\",    age: 26  });  person.on(\"firstNameChanged\", () => {});  // Prevent easy human error (using the key instead of the event name)  person.on(\"firstName\", () => {});  Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.2345Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.  // It's typo-resistant  person.on(\"frstNameChanged\", () => {});  Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.2345Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"lastNameChanged\" | \"ageChanged\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAArwkCiAbpAHYEDKcArtAMaQA8AKqUgA+UAF5QAbzyhZoOIwAUkBswByAQwC2kVAAMAJJMQFoAS0YBzUADJQAa0hE4AM1CCyAXwDCACw1WkAAmegA0oFwaADZRAEYaXPaoioyQAO4AatHsuqABRACU4qJ0cGZBBail5QDceJ51eEGQXFEa0OQu7IxcBGYKoFoajgDqGgRcvsEA8rEAVi0EAsKKcPOo-JXutpTU9EysHNx8-MJ1IKAAtNdc7ATXl3hcCiagZEgDEkOj45Mz84tFNJZC4zEgCJodKgAEQsDRlJCQaGhGSgNomSG5aEAJQUAWRqI0llyaAAbPUCo13ogFAA6BSKaGg8GYvwBYlBZGgRRFMSiSSeSl4PAXKgqA6gSAaRBEUC+dhDRiS2AIbnsRAWawEKYOJygCwmKVBeRubXkcXMUCMbSQAp4al0hlMsEYm1cnnFKSCxoXACSBAA5IhQMQSHBLh0NSYAgR7TAaYx6UomSybWzApzwh6+V7KUA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#inference-with-template-literals)\nInference with Template Literals\n\nNotice that we did not benefit from all the information provided in the original passed object. Given change of a `firstName` (i.e. a `firstNameChanged` event), we should expect that the callback will receive an argument of type `string`. Similarly, the callback for a change to `age` should receive a `number` argument. We’re naively using `any` to type the `callback`’s argument. Again, template literal types make it possible to ensure an attribute’s data type will be the same type as that attribute’s callback’s first argument.\n\nThe key insight that makes this possible is this: we can use a function with a generic such that:\n\n1.  The literal used in the first argument is captured as a literal type\n2.  That literal type can be validated as being in the union of valid attributes in the generic\n3.  The type of the validated attribute can be looked up in the generic’s structure using Indexed Access\n4.  This typing information can _then_ be applied to ensure the argument to the callback function is of the same type\n\nts\n\n``   type PropEventSource<Type> = {      on<Key extends string & keyof Type>          (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void): void;  };  declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;  const person = makeWatchedObject({    firstName: \"Saoirse\",    lastName: \"Ronan\",    age: 26  });  person.on(\"firstNameChanged\", newName => {                                    (parameter) newName: string      console.log(`new name is ${newName.toUpperCase()}`);  });  person.on(\"ageChanged\", newAge => {                              (parameter) newAge: number      if (newAge < 0) {          console.warn(\"warning! negative age\");      }  })   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGJA0hCFBAA9gmACYBnKGOBwAlhgDmUAGRQA1rwQAzKBUhUWbQwAoI6LADkAhgFsIALigADACQMeIAL4BhABaWFECKOADRQhJYANhEARpaEqg5GGBAA7gBqkXj2OpQA2u4AugCUdDSoCDIiRQ7llQDcTB4NTCIQhBGWcNCaeBiEwDIcUNaW6gDqlsCEPoEA8tEAVm3A5JRURgiLDroQ1TmQyrCIKGY4+ESkO1TNhBxSUJBwYkP0I+OT03OLy0bMrJoyJ7AKy2BwAImwlgqTwgYOCBg6UhB2TBACUOP44QZLPJsgAmABsjSKzUezwwADoOEYwQCgcjfP5cSI4VBkilkaVGAZWAB6XmGQVC4WsAB6AH4eWE7ggIhAKREEPIjI52WybNAZBJXOzkRTgAgAKpgR5eSxiCBGIoeRwk4mkiBPDhUjA0nEQRkBFmhdkAQVxXL+bH5ItDUAlUpk2iSqX90BIUAADCUg0LbhhnnKKSlOq6wTm4Bg5PIAIRsiDySYydBQd1gu2GDzEoA)\n\nHere we made `on` into a generic method.\n\nWhen a user calls with the string `\"firstNameChanged\"`, TypeScript will try to infer the right type for `Key`. To do that, it will match `Key` against the content before `\"Changed\"` and infer the string `\"firstName\"`. Once TypeScript figures that out, the `on` method can fetch the type of `firstName` on the original object, which is `string` in this case. Similarly, when called with `\"ageChanged\"`, TypeScript finds the type for the property `age` which is `number`.\n\nInference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways.\n\n[](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#intrinsic-string-manipulation-types)\nIntrinsic String Manipulation Types\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTo help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and can’t be found in the `.d.ts` files included with TypeScript.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uppercasestringtype)\n`Uppercase<StringType>`\n\nConverts each character in the string to the uppercase version.\n\n##### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#example)\nExample\n\nts\n\n``   type Greeting = \"Hello, world\"  type ShoutyGreeting = Uppercase<Greeting>               type ShoutyGreeting = \"HELLO, WORLD\"  type ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}`  type MainID = ASCIICacheKey<\"my_app\">           type MainID = \"ID-MY_APP\"   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigGUALUgV1HkQoM2KAFUwkOAGMAhgGcIAHgFI06AHxMA9Fqh6AegH4mLcNACC7AMIBJG1ZlTOEANIQQi9sDhQIAD2AIVHo5KDlvNXURAAMbABEAWgASAG9xSVkFT291AF9o0zYAWRk0eJFLW3tHZzcPXABbEAB9GQlcTR09KCMgA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#lowercasestringtype)\n`Lowercase<StringType>`\n\nConverts each character in the string to the lowercase equivalent.\n\n##### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#example-1)\nExample\n\nts\n\n``   type Greeting = \"Hello, world\"  type QuietGreeting = Lowercase<Greeting>              type QuietGreeting = \"hello, world\"  type ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}`  type MainID = ASCIICacheKey<\"MY_APP\">           type MainID = \"id-my_app\"   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigEUBXZJeRFDNigAZUlQhwAxgEMAzhAA8fJGnQA+JgHpNUXQD0A-ExbhoAQQDKAYQCSNq9MkALCAGkIIBReBwoEAB7AEKj0slCyPqpqQgAGyPQAtAAkAN6i4lJyit5wagC+MSZsALLSaDYAIkKWtvaOLu6euMUAmgD6ZgAKnbga2rpQhkA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#capitalizestringtype)\n`Capitalize<StringType>`\n\nConverts the first character in the string to an uppercase equivalent.\n\n##### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#example-2)\nExample\n\nts\n\n`   type LowercaseGreeting = \"hello, world\";  type Greeting = Capitalize<LowercaseGreeting>;            type Greeting = \"Hello, world\"   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAMg9gdwgJwMYEMDOEDiyITACWAdgOZQC8UARABYQA2jcANFAnMowCY0DcAKFCQoeAsXJUoAYXRgiwdIyIAvCAB54SNFlz5CpMgD4hAejNQrAPQD8QA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uncapitalizestringtype)\n`Uncapitalize<StringType>`\n\nConverts the first character in the string to a lowercase equivalent.\n\n##### [](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#example-3)\nExample\n\nts\n\n`   type UppercaseGreeting = \"HELLO WORLD\";  type UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;                  type UncomfortableGreeting = \"hELLO WORLD\"   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAqmkCcDGBDAzhA4giFgEsA7AcygF4oAiACQFEAZegeSgHUmAlegEUoG4AUKEixCSAPYBbAGbiEwFACMANlhx4ipCjDEow+BcvwAvCAB44iVBmy4CJAHyCA9M6juAegH4gA)\n\nTechnical details on the intrinsic string manipulation types\n\nThe code, as of TypeScript 4.1, for these intrinsic functions uses the JavaScript string runtime functions directly for manipulation and are not locale aware.\n\n`   function applyStringMapping(symbol: Symbol, str: string) {     switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {         case IntrinsicTypeKind.Uppercase: return str.toUpperCase();         case IntrinsicTypeKind.Lowercase: return str.toLowerCase();         case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);         case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);     }     return str; }   `\n\n[### Mapped Types\\\n\\\nGenerating types by re-using an existing type.](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Type%20Manipulation/Template%20Literal%20Types.md)\n ❤\n\nContributors to this page:  \n\nSH![Steven Harms  (6)](https://gravatar.com/avatar/95b8ef1e80eeb07c829a50497d2545656a678aea68e1d2425af2375efa7a48ff?s=32&&d=blank)\n\nOT![Orta Therox  (4)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nSGH![Steven G. Harms  (3)](https://gravatar.com/avatar/707f428bf9077bef7087dd3237e2df39f1853397977155a59c0cec4b3c2d21e9?s=32&&d=blank)\n\nSP![Seol Park  (1)](https://gravatar.com/avatar/f8ac3d2d31ed188289717ea900f9bb238e1d030d7d2748574b090a2d8e5dc13b?s=32&&d=blank)\n\nP![Penchy  (1)](https://gravatar.com/avatar/cf0b2509a6918bad894e4a4a9ea941e6e3e76941ea8078bca02ea75aff07e940?s=32&&d=blank)\n\n6+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","ogDescription":"Generating mapping types which change properties via template literal strings.","ogTitle":"Documentation - Template Literal Types","theme-color":"#3178C6","title":"TypeScript: Documentation - Template Literal Types","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"Generating mapping types which change properties via template literal strings.","og:title":"Documentation - Template Literal Types","og:description":"Generating mapping types which change properties via template literal strings.","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","generator":"Gatsby 5.13.5","scrapeId":"e8870b3a-f521-4b3d-8695-9477dec9bebd","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html","url":"https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nClasses\n=======\n\n> Background Reading:  \n> [Classes (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)\n\nTypeScript offers full support for the `class` keyword introduced in ES2015.\n\nAs with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types.\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#class-members)\nClass Members\n-------------------------------------------------------------------------------------------\n\nHere’s the most basic class - an empty one:\n\nts\n\n`   class Point {}   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwL5A)\n\nThis class isn’t very useful yet, so let’s start adding some members.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#fields)\nFields\n\nA field declaration creates a public writeable property on a class:\n\nts\n\n`   class Point {    x: number;    y: number;  }  const pt = new Point();  pt.x = 0;  pt.y = 0;   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQKdPGLRQAbz6hQAD1bEArgFsARrgDcc0PmXqtsXbwC+fPoiYxQmKQF5QxbAHdR4yQAoAlKfsAdAqgTgAM-tAB+CGg4UA)\n\nAs with other locations, the type annotation is optional, but will be an implicit `any` if not specified.\n\nFields can also have _initializers_; these will run automatically when the class is instantiated:\n\nts\n\n``   class Point {    x = 0;    y = 0;  }  const pt = new Point();  // Prints 0, 0  console.log(`${pt.x}, ${pt.y}`);   ``[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaABgG5d8BPE8qnAX112HmQnQAd1TkApgHc4SNAAoAlIwD0MuACcUqGGQA05NhwjwQAgHQh4Ac3EADACQZe+gkw1WbNJmelA)\n\nJust like with `const`, `let`, and `var`, the initializer of a class property will be used to infer its type:\n\nts\n\n`  const pt = new Point();  pt.x = \"0\";  Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgBjAGwENFFQAFOASwDsAXUAb31FAA9QBeUABgDcbUAE8e-IXgC++EKAC0iggFcGi+fgJw6iJgAcmvOpADuVWowAUASkkGAdF14AiPs4FA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#--strictpropertyinitialization)\n`--strictPropertyInitialization`\n\nThe [`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization)\n setting controls whether class fields need to be initialized in the constructor.\n\nts\n\n`   class BadGreeter {    name: string;  Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYBsAWAsAFADGANgIaKKgBCZAJgOLSSQAuMoA3oaKAHZkAtpFSJW0AJZ8A5gG5CAXyA)\n\nts\n\n`   class GoodGreeter {    name: string;    constructor() {      this.name = \"hello\";    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiD28AmsBOBTdAXdroG8BYAKGmgDswBbdALmgi1QEtyBzAbhJLOHnMaoArsCzxUACgCUBHmWhYAFswgA6SjWgBeaACJF6ECHi6upaAF8SFoA)\n\nNote that the field needs to be initialized _in the constructor itself_. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members.\n\nIf you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the _definite assignment assertion operator_, `!`:\n\nts\n\n`   class OKGreeter {    // Not initialized, but no error    name!: string;  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDyDSBxATgU1QF1c6BvAsAFDTQD0p0AcgPYbQCWAdvRvWCPQF6oAmANNABGAVzqNq0bMmrIiJRmAC2qAIQAuaBAzImAcwDcRAL5A)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#readonly)\n`readonly`\n\nFields may be prefixed with the `readonly` modifier. This prevents assignments to the field outside of the constructor.\n\nts\n\n`  class Greeter {    readonly name: string = \"world\";    constructor(otherName?: string) {      if (otherName !== undefined) {        this.name = otherName;      }    }    err() {      this.name = \"not ok\";  Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.    }  }  const g = new Greeter();  g.name = \"also not ok\";  Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGd2cBYAKAGMAbAQ0UVAHFpJIAXGUAbxNFEcoBM4AO3IBPUIMoBbSKkTNoAS0EBzUAF5QAIgDuCcn00BuEl1Ckhc6AFdSzBAAo4zABYwAclMgB+WfKXKASg5TbgUAM1BHF3dPUABCNQ0rQT5IMKVIPiDOYm480BcFRAA6CWl1UCdXaA9pY1y8gF9TZuJTGGh7bJCC5yLS2I1NQSdKgGsjFpJW80E5UFUNQUhtekYWGC765QHyocpyRDhxUbgJwyA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors)\nConstructors\n\n> Background Reading:  \n> [Constructor (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor)\n>   \n\nClass constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads:\n\nts\n\n`   class Point {    x: number;    y: number;    // Normal signature with defaults    constructor(x = 0, y = 0) {      this.x = x;      this.y = y;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCcBuXfATxPOvqZ2egHo+0AHLw6FMCGgREAc2RhUZOjWgB3RKgAW0ACY0AZmDIhUEXsHjIIqOmWCpRACgLQAvNAAMAGmgs3ngEpMXnwtRAgAOhd3Am58UM1wiL93FjjoAF9cDKA)\n\nts\n\n`   class Point {    x: number = 0;    y: number = 0;    // Constructor overloads    constructor(x: number, y: number);    constructor(xy: string);    constructor(x: string | number, y: number = 0) {      // Code logic here    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCdoBeaABgG5d8BPE86+pqw45O0APRjoAYXjIIqOmWCp4DeADd6IeGAAmEUcFnzFy1QApipSrToAaaD2v86ASmH4jchUpV1LTiYoAObuhsY+Zv5WQcjB0AA+zrYOTny2giyumKL4EtLwujTQ2sGIwNAAFvQ0ogC+uHVAA)\n\nThere are just a few differences between class constructor signatures and function signatures:\n\n*   Constructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later\n*   Constructors can’t have return type annotations - the class instance type is always what’s returned\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#super-calls)\nSuper Calls\n\nJust as in JavaScript, if you have a base class, you’ll need to call `super();` in your constructor body before using any `this.` members:\n\nts\n\n`   class Base {    k = 4;  }  class Derived extends Base {    constructor() {      // Prints a wrong value in ES5; throws exception in ES6      console.log(this.k);  'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class.      super();    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwHYAMWCcBYAKAGMAbAQ0UVACFLJQBvI0UAa1AF5QAWAbiIBfIkTKVqAERgBLAG6QAJqEgAPAC6QAdgup1EDZoVbE4mxGugBXYmoQAKAJRMWrUCFAAFaNM1rq5UAB3eE0Ac1BZclJLBh9QAFEAZQBWPlA1AAt4QOpVYkgABzVpU1A4pIA2F2NTRDhSSAA6UjhQu0zpREa2BwEjV0RLAphHPtZhQkEgA)\n\nForgetting to call `super` is an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#methods)\nMethods\n\n> Background Reading:  \n> [Method definitions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions)\n>   \n\nA function property on a class is called a _method_. Methods can use all the same type annotations as functions and constructors:\n\nts\n\n`   class Point {    x = 10;    y = 10;    scale(n: number): void {      this.x *= n;      this.y *= n;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaARgAYBuXfATxPOt1ugmDBAFMAKZALmjIArgFsARlwBOASkEA3JABNMrfKgAWiCADoiAKlLIaefNE3adDQ0JP4AvrntA)\n\nOther than the standard type annotations, TypeScript doesn’t add anything else new to methods.\n\nNote that inside a method body, it is still mandatory to access fields and other methods via `this.`. An unqualified name in a method body will always refer to something in the enclosing scope:\n\nts\n\n`   let x: number = 0;  class C {    x: string = \"hello\";    m() {      // This is trying to modify 'x' from line 1, not the class property      x = \"world\";  Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UA7AVwFsAjGUAXlAAYBuffAYwIENEiUAGFQAb3yhyqRMWgBLSgHMWoAEQALSAQJx1XPFNC0AFAEoJx6SFAAVTQuFPQ8gJ5LVxOCbgATBQAzN1AAcjJQ0ED4WlACJUhQAEYAGlBKOFJibVA+QWEAB3gCmGI3a3I1dQB3BAI-A2MAX3wmoA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#getters--setters)\nGetters / Setters\n\nClasses can also have _accessors_:\n\nts\n\n`   class C {    _length = 0;    get length() {      return this._length;    }    set length(value) {      this._length = value;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8CwAoa0D6ICmA7A5gC4AW0AvNAAwDcq6+2h0OBJAFAJSJ3rQBOjAK59c0EgEsIAOix4ixWmmgBfHhEbM57AG5gQg7F2RL0E6bNakKu-dkXpVKZUA)\n\n> Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript. It’s fine to expose public fields if you don’t need to add additional logic during the get/set operations.\n\nTypeScript has some special inference rules for accessors:\n\n*   If `get` exists but no `set`, the property is automatically `readonly`\n*   If the type of the setter parameter is not specified, it is inferred from the return type of the getter\n\nSince [TypeScript 4.3](https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/)\n, it is possible to have accessors with different types for getting and setting.\n\nts\n\n`   class Thing {    _size = 0;    get size(): number {      return this._size;    }    set size(value: string | number | boolean) {      let num = Number(value);      // Don't allow NaN, Infinity, etc      if (!Number.isFinite(num)) {        this._size = 0;        return;      }      this._size = num;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwLAChrQH0JEAvAU2gF5oAGAbl131TIBdpjyAKASgC5oyAK4BbAEZkATpib5oktkMnJorJBAB0RUmQZ5oAX0b6IbDjq4A3MCCFkBEVpJToAPoNETp7sQHtfIGRgyDwy+viB7MIiVNAAcp5SVjZ2PHqy+AD0mdAAIr7IAOTsNiC+AO7xYHEANNAAksgAZiiIrACedWzAxnLQiE3QXACECeJSGogQAGKtrGRc0Tyh2OFyalNanBTU9BlyCqxKyHp9Rjj7G5ra5LHRp4a4BkA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#index-signatures)\nIndex Signatures\n\nClasses can declare index signatures; these work the same as [Index Signatures for other object types](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)\n:\n\nts\n\n`   class MyClass {    [s: string]: boolean | ((s: string) => boolean);    check(s: string) {      return this[s] as boolean;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0DaEAXNBAC4BOAlgHYDmAusQEYD2LIApmNdAD7QAKAURIUatAJTQAvAD5ordl2oSA3Nmy5gACw7AA1sOJkqdKZhy5o5DqQCu5HqW2UIBetEgK2nbussAvtgBQA)\n\nBecause the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types. Generally it’s better to store indexed data in another place instead of on the class instance itself.\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#class-heritage)\nClass Heritage\n---------------------------------------------------------------------------------------------\n\nLike other languages with object-oriented features, classes in JavaScript can inherit from base classes.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#implements-clauses)\n`implements` Clauses\n\nYou can use an `implements` clause to check that a class satisfies a particular `interface`. An error will be issued if a class fails to correctly implement it:\n\nts\n\n`   interface Pingable {    ping(): void;  }  class Sonar implements Pingable {    ping() {      console.log(\"ping!\");    }  }  class Ball implements Pingable {  Class 'Ball' incorrectly implements interface 'Pingable'.   Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'.   Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.    pong() {      console.log(\"pong!\");    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBY0AYCwAoASwDsAXGAMwEMBjSUABRIHMqAjAG3oG8DRQADiwAUASlQA3OIQAmAbgIBfAgRocqiRKADKcYlWihCAWwFdjkMlqbFWnHn0EjRoXvn78aexHC4A6DjhmYQAiIVsAQhDRBXdQZXwE1XVNUAAhKg4OI1NzS1JrFnYuV0cBPWCXNw9QL2Iff0DgsIqomMcExSA)\n\nClasses may also implement multiple interfaces, e.g. `class C implements A, B {`.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#cautions)\nCautions\n\nIt’s important to understand that an `implements` clause is only a check that the class can be treated as the interface type. It doesn’t change the type of the class or its methods _at all_. A common source of error is to assume that an `implements` clause will change the class type - it doesn’t!\n\nts\n\n`   interface Checkable {    check(name: string): boolean;  }  class NameChecker implements Checkable {    check(s) {  Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.      // Notice no error here      return s.toLowerCase() === \"ok\";                     any    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYMDYCwAoASwDsAXGAMwEMBjSUAYQAtIaBrKgIwBt6BvAqFA0W7ABTEqAW0ipEpaCQDmASlSc4cXlWIBuAgF8CBGtyqJEoAHLTIzVmxihCUgA68ZZS-fZdeoAXwhEQcxRBUAwSFQEGs4UkI6UGI4UBh4aFAWaEgooRzSAFdoYlBEADpSOAAZOAB3GAZzSDEIgF4O0AAiODYu-SDo2OiR0AA9AH4oo3wDIA)\n\nIn this example, we perhaps expected that `s`’s type would be influenced by the `name: string` parameter of `check`. It is not - `implements` clauses don’t change how the class body is checked or its type inferred.\n\nSimilarly, implementing an interface with an optional property doesn’t create that property:\n\nts\n\n`  interface A {    x: number;    y?: number;  }  class C implements A {    x = 0;  }  const c = new C();  c.y = 10;  Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoASwDsAXGAMwEMBjSUAQVAG8DRQAPVYgVwFsARjADcbUAE8A-N35Doo-AF8CNADZVEiUAGFQhPgAdVkPpDJamrfOw6gAvKAAMC5fhpxiiUqBr3QxSAB3HQAKAEoFGgA6cT8ARmcgA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#extends-clauses)\n`extends` Clauses\n\n> Background Reading:  \n> [extends keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends)\n>   \n\nClasses may `extend` from a base class. A derived class has all the properties and methods of its base class, and can also define additional members.\n\nts\n\n`   class Animal {    move() {      console.log(\"Moving along!\");    }  }  class Dog extends Animal {    woof(times: number) {      for (let i = 0; i < times; i++) {        console.log(\"woof!\");      }    }  }  const d = new Dog();  // Base class method  d.move();  // Derived class method  d.woof(3);   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeBYAUNayA9gG4CmAFAJSa777CHwSEikB0IhA5uQEQCyJRPC7Q0jLgEJelANy1oAX1zKcuUJBgARbtFIAPAC6l4AExgIUaGnmgB3QoQBm5QylIQAXNHgBXZABGpABO1Ni2+E6EwdDkrIbQiNAAvNAADLKJ0AA80G7IHpmIANTFYQp00AxMLOycPLwOztJyFUoKqqrqjBAJpik+pHbQOjytOAD0E9AAQpCkVeBQBKSGABaEprimbERkVPKT01ohiGT9GssF65vbbE0uAMxyQA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#overriding-methods)\nOverriding Methods\n\n> Background Reading:  \n> [super keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super)\n>   \n\nA derived class can also override a base class field or property. You can use the `super.` syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a “super field”.\n\nTypeScript enforces that a derived class is always a subtype of its base class.\n\nFor example, here’s a legal way to override a method:\n\nts\n\n``   class Base {    greet() {      console.log(\"Hello, world!\");    }  }  class Derived extends Base {    greet(name?: string) {      if (name === undefined) {        super.greet();      } else {        console.log(`Hello, ${name.toUpperCase()}`);      }    }  }  const d = new Derived();  d.greet();  d.greet(\"reader\");   ``[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvQZQkGABEEuAJYA3BJOgIAHoQR1JMeBCRpMOfEWJ0wAWwQB+AFzQEISGdNjkzlTQBgBm0B7eSAC8KdAArrYIMQZ0phFKURBpAA76LHgEJAoFKuYgjhQuUbQMTKzsnAAGfAI0wgAkyJ4+LIQ0AKrFpbgAwohkyp3VTSpK6uqa9MHQZknQuSLQeoYmkmSK6JLlblUXVxXuXPhgkvpy8kA)\n\nIt’s important that a derived class follow its base class contract. Remember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:\n\nts\n\n`   // Alias the derived instance through a base class reference  const b: Base = d;  // No problem  b.greet();   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvShIMACIJcASwBuCSdAQAPQgjqSY8CEmTraDQtFMBeaHQQjoug2NJMkV0AHow6ABaGOAAV0IYqIwI6ABBEH1IaEIACyRJPSMTaH1XMDpgJDzcGjjsXOgwaAAjRGhNKGh8ADM9ayqMFwg3FoAuOHavSVDUgDkaaAAHWpbmAFsMFpY8AhIFIA)\n\nWhat if `Derived` didn’t follow `Base`’s contract?\n\nts\n\n``   class Base {    greet() {      console.log(\"Hello, world!\");    }  }  class Derived extends Base {    // Make this parameter required    greet(name: string) {  Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.   Type '(name: string) => void' is not assignable to type '() => void'.     Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.   Type '(name: string) => void' is not assignable to type '() => void'.     Target signature provides too few arguments. Expected 1 or more, but got 0.      console.log(`Hello, ${name.toUpperCase()}`);    }  }   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMA2AsAFADGANgIaKKgBCFkoA3oaKAObSSQAuAFAJSNmLUETgA7RHBKQAdCTiseAIgASkEvIA0oAO4ISAEwCESvgG4hAX0LWChUhSoARGAEsAbpAOhIADy6QYgZUtIj0TAQsIKAAsmQA1vRcABauVAAOZNBkALbcMKAcAI4Arq4cBkLsnLxiuZCoiFzQrmKsAhHCIuKS0nIKPAAGahpw2gAkDHV5MlxwAKrp6TAAwnT8loPmVjZAA)\n\nIf we compiled this code despite the error, this sample would then crash:\n\nts\n\n`   const b: Base = new Derived();  // Crashes because \"name\" will be undefined  b.greet();   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEkoGdnwEIoQbwLACh54BzOEAFwAoBKALngDcB7AS2AG4CBfA0JORNFTwAIiBgsGIYPBAAPciAB2wNJmQ4e+APTb4AWkNgAruUP6CYJkuTl4AI3rqEAXnhKQAd1HjJ0mpw6egDCMCgAFiBo9uBQxhrwAERKUAC2IInwniwQEA4IxiogAGYsHsAE9gB0pCAUAUA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#type-only-field-declarations)\nType-only Field Declarations\n\nWhen `target >= ES2022` or [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n is `true`, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write `declare` to indicate to TypeScript that there should be no runtime effect for this field declaration.\n\nts\n\n`   interface Animal {    dateOfBirth: any;  }  interface Dog extends Animal {    breed: any;  }  class AnimalHouse {    resident: Animal;    constructor(animal: Animal) {      this.resident = animal;    }  }  class DogHouse extends AnimalHouse {    // Does not emit JavaScript code,    // only ensures the types are correct    declare resident: Dog;    constructor(dog: Dog) {      super(dog);    }  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwFgAoZZAEzkgHkYAhYKMACwC5k4QBPAbhIF8SJUJFiIUAEQD2Ac2QQAHpBDkAzmgzY8RUsgBGUCBHLtOvAUOIIccVevRZcACSkBXVSh1lDq4OQjg7A5afLoIUiCqYFCuCGBSUAAUnI44QZq4AJQEJGRkLMCqAHQ+fgFgyAC8HBk4oWSCxI0k1rbq0jIu7iiKymoaqV0eOboA9KPI0hDqIFIVEJjAFQBScABucADKCFDAAA4V4f4ANLnI48gROFzyka4+yCwoYFx70xyGyOFQhnFn-q1PqV-IFJrJ6l8IlEYnEEolyLJ2B1sl48qpXG8kgiZJkIY1+EA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#initialization-order)\nInitialization Order\n\nThe order that JavaScript classes initialize can be surprising in some cases. Let’s consider this code:\n\nts\n\n`   class Base {    name = \"base\";    constructor() {      console.log(\"My name is \" + this.name);    }  }  class Derived extends Base {    name = \"derived\";  }  // Prints \"base\", not \"derived\"  const d = new Derived();   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0B2YC2SAvNAEQBGiJA3BlsAPbYQAuATgK7DP2sAUAlClpZoDJvRAIAdCHoBzXiQCyATxz4kASxgloAamjMAFtqm4C-GpmgBfDHfQZQkGABEErTQDcEAE2gIAB7MCNi+MPAQSGjW5kSkvh7eftT2GBgA9BnQAAqe2Mw6FFEkADQ49MwJST6+JE6MLND+xNgIAO7Q7p61AlRAA)\n\nWhat happened here?\n\nThe order of class initialization, as defined by JavaScript, is:\n\n*   The base class fields are initialized\n*   The base class constructor runs\n*   The derived class fields are initialized\n*   The derived class constructor runs\n\nThis means that the base class constructor saw its own value for `name` during its own constructor, because the derived class field initializations hadn’t run yet.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#inheriting-built-in-types)\nInheriting Built-in Types\n\n> Note: If you don’t plan to inherit from built-in types like `Array`, `Error`, `Map`, etc. or your compilation target is explicitly set to `ES6`/`ES2015` or above, you may skip this section\n\nIn ES2015, constructors which return an object implicitly substitute the value of `this` for any callers of `super(...)`. It is necessary for generated constructor code to capture any potential return value of `super(...)` and replace it with `this`.\n\nAs a result, subclassing `Error`, `Array`, and others may no longer work as expected. This is due to the fact that constructor functions for `Error`, `Array`, and the like use ECMAScript 6’s `new.target` to adjust the prototype chain; however, there is no way to ensure a value for `new.target` when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default.\n\nFor a subclass like the following:\n\nts\n\n`   class MsgError extends Error {    constructor(m: string) {      super(m);    }    sayHello() {      return \"hello \" + this.message;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9RgF9tIsAE8AEthAh0vGXIXQU2fBxRFoAIgAWZi2+gBqaPjuYhAAdPzYUGAI2FryenQ6QA)\n\nyou may find that:\n\n*   methods may be `undefined` on objects returned by constructing these subclasses, so calling `sayHello` will result in an error.\n*   `instanceof` will be broken between instances of the subclass and their instances, so `(new MsgError()) instanceof MsgError` will return `false`.\n\nAs a recommendation, you can manually adjust the prototype immediately after any `super(...)` calls.\n\nts\n\n`   class MsgError extends Error {    constructor(m: string) {      super(m);      // Set the prototype explicitly.      Object.setPrototypeOf(this, MsgError.prototype);    }    sayHello() {      return \"hello \" + this.message;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9egugB6PdADK2fNHwALbNCUYe+AJ4qcuJSDHAx+EA4B0OhQB5ACMAK2xuXwhTAAU7dEcVQIAzXksxCAAaOEQKTF9bBISnbE0AgF9teQgwBwAJbBAQdF4ZOV0UUw4UImgAIism9H7oAGpzCwzffmwoMARsLXlKunKgA)\n\nHowever, any subclass of `MsgError` will have to manually set the prototype as well. For runtimes that don’t support [`Object.setPrototypeOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)\n, you may instead be able to use [`__proto__`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)\n.\n\nUnfortunately, [these workarounds will not work on Internet Explorer 10 and prior](https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx)\n. One can manually copy methods from the prototype onto the instance itself (i.e. `MsgError.prototype` onto `this`), but the prototype chain itself cannot be fixed.\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#member-visibility)\nMember Visibility\n---------------------------------------------------------------------------------------------------\n\nYou can use TypeScript to control whether certain methods or properties are visible to code outside the class.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#public)\n`public`\n\nThe default visibility of class members is `public`. A `public` member can be accessed anywhere:\n\nts\n\n`   class Greeter {    public greet() {      console.log(\"hi!\");    }  }  const g = new Greeter();  g.greet();   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8CwAoa0ADgK4BGIAlsNAOZKoAUAlFngQcAPYB2EnIiAHQhONBgCIAFhQCE4pgG420AL541uLrxS1oAXmjdEAdzj008Zktw1BdZCitA)\n\nBecause `public` is already the default visibility modifier, you don’t ever _need_ to write it on a class member, but might choose to do so for style/readability reasons.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#protected)\n`protected`\n\n`protected` members are only visible to subclasses of the class they’re declared in.\n\nts\n\n`  class Greeter {    public greet() {      console.log(\"Hello, \" + this.getName());    }    protected getName() {      return \"hi\";    }  }  class SpecialGreeter extends Greeter {    public howdy() {      // OK to access protected member here      console.log(\"Howdy, \" + this.getName());    }  }  const g = new SpecialGreeter();  g.greet(); // OK  g.getName();  Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMFYCwAoAYwBsBDRRUAcWkkgBcZQBvA0UABwFcAjYgS0KgA5rQYAKAJQs27UITgA7RHGKQAdMTjDxAIgASkYloA0oXaADUoegAt+idcIYA5UgFtIUyQG5ZAX1kOeEZCRgATEVcPL2lWfDlQWnouaEVze10-BNBA-DyCEnJKAGUOSEJ+UmIaOkZoUEgAD0ZFcMpahiZ49m4+QVBbOAB3cIBPKRkc9hBQAHkAaRs4UFJCQkgKThCKiNBPdx4mWxhIWXYFZVUNLR0DEfGzC2s7Bydoz29sxNnEv-+AXIAHog0FgsEBAh5S6IegiUAAXlAikgw1AZQqVRqYnqUmywicOLxoFmiwIBOc9Dcn18QA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#exposure-of-protected-members)\nExposure of `protected` members\n\nDerived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making `protected` members `public`:\n\nts\n\n`   class Base {    protected m = 10;  }  class Derived extends Base {    // No modifier, so default is 'public'    m = 15;  }  const d = new Derived();  console.log(d.m); // OK   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0AOAnA9gC4LDEAm0AttALzQCMADANwYC+GokMAIgrgEsAbggoIAHsQB2ZGPAhI0maAHoV0AHL4q+MgIBmA-gBpoEbWQT6wAVxCFoAmAHJsNgEYgBwZxizU6egBWVnQOdGB8KQgHCjopBAB3aD5BETIACgBKUMjo-BAEADoQfABzDLIiyhzVdQB5AGkgA)\n\nNote that `Derived` was already able to freely read and write `m`, so this doesn’t meaningfully alter the “security” of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the `protected` modifier if this exposure isn’t intentional.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#cross-hierarchy-protected-access)\nCross-hierarchy `protected` access\n\nTypeScript doesn’t allow accessing `protected` members of a sibling class in a class hierarchy:\n\nts\n\n`   class Base {    protected x: number = 1;  }  class Derived1 extends Base {    protected x: number = 5;  }  class Derived2 extends Base {    f1(other: Derived2) {      other.x = 10;    }    f2(other: Derived1) {      other.x = 10;  Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMDYCwAoAYwBsBDRRUAIXMlAG8DRQAHeAF0kM4BNQAPVADsArgFsARjFABeUAEYA3AQC+BEuUoARGAEsAbpB7zQkfpyE9KNRHUb5mbOJ25GBw8VOizQAVmX4akRkFKA60AZGaKbmkJbWtAxMoABm8gAUzgAWMKjhkTxoAJRJDsyg2TAAdPw+8gAMAcxBzClomew50Hl6hsYl9uUVndW1cg1NoEEqQA)\n\nThis is because accessing `x` in `Derived2` should only be legal from `Derived2`’s subclasses, and `Derived1` isn’t one of them. Moreover, if accessing `x` through a `Derived1` reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.\n\nSee also [Why Can’t I Access A Protected Member From A Derived Class?](https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/)\n which explains more of C#‘s reasoning on the same topic.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#private)\n`private`\n\n`private` is like `protected`, but doesn’t allow access to the member even from subclasses:\n\nts\n\n`  class Base {    private x = 0;  }  const b = new Base();  // Can't access from outside the class  console.log(b.x);  Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EicAHaJeoAEYjQCyAHcadABQBKKQRCgAwmQUByFWSJFIlUADN4AW1BwArr0QcAE3peAAt6UgpEOUVEOBJIADoSOABzfVUEgWMgA)\n\nts\n\n`   class Derived extends Base {    showX() {      // Can't access in subclasses      console.log(this.x);  Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EQoALRKiAV15KFhUhSoARGN0gATUJAH8Adkaq1E9JgRaIAFnADuADQAUASkbMWUHkAYTILAHJeUDIiIkhKUA4LUEQVACNtSniAliI4C0Q4EkgAOhI4AHMvXmcORBKBHylHUFkCaSA)\n\nBecause `private` members aren’t visible to derived classes, a derived class can’t increase their visibility:\n\nts\n\n`   class Base {    private x = 0;  }  class Derived extends Base {  Class 'Derived' incorrectly extends base class 'Base'.   Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'.   Property 'x' is private in type 'Base' but not in type 'Derived'.    x = 1;  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBWAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6FSFKgBEY3SABNQkAfwB2aqrUT0mBFkNFYpBaUA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#cross-instance-private-access)\nCross-instance `private` access\n\nDifferent OOP languages disagree about whether different instances of the same class may access each others’ `private` members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.\n\nTypeScript does allow cross-instance `private` access:\n\nts\n\n`   class A {    private x = 10;    public sameAs(other: A) {      // No error      return other.x === this.x;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECC0G8CwAoa0AOAnAlgNzABcBTaAD2gF5oBGABgG5VV0MBXAIxB2GgjAC2xWBAAUAe0IALYlgBccAJSIW6aAHp10AHLjosrOKyr0WYoTZYAdtEkysAOgqUX0aTghOmaaAF9UvkA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#caveats)\nCaveats\n\nLike other aspects of TypeScript’s type system, `private` and `protected` [are only enforced during type checking](https://www.typescriptlang.org/play?removeComments=true&target=99&ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA)\n.\n\nThis means that JavaScript runtime constructs like `in` or simple property lookup can still access a `private` or `protected` member:\n\nts\n\n`   class MySafe {    private secretKey = 12345;  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBlMAzAptA3gWAFDWgAcAnASwDcwAXDCNYYtKgaTXmgF5oBGAJgGYALAFYA3HgC+QA)\n\njs\n\n`   // In a JavaScript file...  const s = new MySafe();  // Will print 12345  console.log(s.secretKey);   `\n\n`private` also allows access using bracket notation during type checking. This makes `private`\\-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are _soft private_ and don’t strictly enforce privacy.\n\nts\n\n`   class MySafe {    private secretKey = 12345;  }  const s = new MySafe();  // Not allowed during type checking  console.log(s.secretKey);  Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'.  // OK  console.log(s[\"secretKey\"]);   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMpkBmkoA3oaKAA7QCWANzIAXVokhFokYQGlItUAF5QOTFgCsAbkIBfQoSJwAdomGgqyo5ADuNBs0gAKAJTaChEKABycM2RIkcNaQACagIQCu-EYA5qDCtNysRAAWEgDWfLEGxohwJJAAdIExjoiF4pLScrSu+gSeAPIyOSb5RSVlANoARJVSsvI9ALquQA)\n\nUnlike TypeScripts’s `private`, JavaScript’s [private fields](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields)\n (`#`) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them _hard private_.\n\nts\n\n`   class Dog {    #barkAmount = 0;    personality = \"happy\";    constructor() {}  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAiD2BzaBvAsAKGtAxAIzACcBrAQQFt4BXAOwBdoBeaABgG5NsAHAU0Ing0wIAJZ0Ank2gAiABZguXcdI4ZO0YIIh1CVYHXiEAFAEpUAX0zmgA)\n\nts\n\n`\"use strict\";  class Dog {      #barkAmount = 0;      personality = \"happy\";      constructor() { }  }` [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcB2iAekBYAKBAgwAsB7AdwFEBbAS0KIGMAbaDDUAEUvigA3sVCgAxACM4AawCC9SgFcskUAF5QABgDco0AAdEsDJSzR2zAJ4bQAInLQDBq3b1F9rMxkiwlrSEpYAAoASmEAX2IIoA)\n\nWhen compiling to ES2021 or less, TypeScript will use WeakMaps in place of `#`.\n\nts\n\n`\"use strict\";  var _Dog_barkAmount;  class Dog {      constructor() {          _Dog_barkAmount.set(this, 0);          this.personality = \"happy\";      }  }  _Dog_barkAmount = new WeakMap();` [Try](https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGAjAKwCwAUCBBgBYD2A7gKIC2AlpKQMYA20GGoAItXigA3qVCgAxACM4AawCCjagFcAdpFABeUDgDc40AAdEsDNTXROrAJ7bQAIkrQjRmw4MlD7CxkiwVdkhqWAAKAEpRAF9SKKA)\n\nIf you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members)\nStatic Members\n---------------------------------------------------------------------------------------------\n\n> Background Reading:  \n> [Static Members (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static)\n>   \n\nClasses may have `static` members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself:\n\nts\n\n`   class MyClass {    static x = 0;    static printX() {      console.log(MyClass.x);    }  }  console.log(MyClass.x);  MyClass.printX();   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0IBcx8BLYaAD2gF5oAGAbm1wKNOgAcAnYgO3wA0AFAEp0TXNGAB7HhCkgApgDoQUgOaCEySBCXlhjHNAC+2U1mmz5y1Rq0pd+w-Z1KuvASPpA)\n\nStatic members can also use the same `public`, `protected`, and `private` visibility modifiers:\n\nts\n\n`  class MyClass {    private static x = 0;  }  console.log(MyClass.x);  Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMLmWgDehooADtAJYBuZAC6RQiQUJ5FQAD1ABeUAAYA3IQC+hInAB2iOCUgA6EnADmACjqMKiQ9ICUyoA)\n\nStatic members are also inherited:\n\nts\n\n`   class Base {    static getGreeting() {      return \"Hello world\";    }  }  class Derived extends Base {    myGreeting = Derived.getGreeting();  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0IBcw4EthoBzBHAcQCcFyCA7EgCgEoUMssacBXK+6ACIAEghAgA9tADuEqiAAmggNwdoAXwyb0oSDAAiCKgQBuCBdAQAPHAnoKY8CEjSZoAWwCe1WoUbQAXmhDYzMFADoySho6RlZVdHUgA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#special-static-names)\nSpecial Static Names\n\nIt’s generally not safe/possible to overwrite properties from the `Function` prototype. Because classes are themselves functions that can be invoked with `new`, certain `static` names can’t be used. Function properties like `name`, `length`, and `call` aren’t valid to define as `static` members:\n\nts\n\n`   class S {    static name = \"S!\";  Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcWCwAoAYwBsBDRRUAZVAG8DRREAXU5gS0NADtSBbSKAC8oAERUAhKIDcBAL5A)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#why-no-static-classes)\nWhy No Static Classes?\n\nTypeScript (and JavaScript) don’t have a construct called `static class` the same way as, for example, C# does.\n\nThose constructs _only_ exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. A class with only a single instance is typically just represented as a normal _object_ in JavaScript/TypeScript.\n\nFor example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:\n\nts\n\n`   // Unnecessary \"static\" class  class MyStaticClass {    static doSomething() {}  }  // Preferred (alternative 1)  function doSomething() {}  // Preferred (alternative 2)  const MyHelperObject = {    dosomething() {},  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEFUDtIUwYxgZ0QQwE4E9QCJEBcU8BLObUOAGxWQFgAoS6xUAWQwGUDi4BhK5UAG96oUPkIlQAEwD27GQFsYeABZFIAcwAUASiEBfeobr0QoAApoYAMxhorU0FpQU8dyBIBuMUAEYd9NYArpBwxDKQ0nKKymqaugb0pmCWNnYOTi5uaB7E3qAATAEMEfisGAASMBQADnYA8gBGAFbweKAAvEIiUYgxquraeoL6ADRGANxAA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#static-blocks-in-classes)\n`static` Blocks in Classes\n-------------------------------------------------------------------------------------------------------------------\n\nStatic blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.\n\nts\n\n`   class Foo {      static #count = 0;      get count() {          return Foo.#count;      }      static {          try {              const lastInstances = loadLastInstances();              Foo.#count += lastInstances.length;          }          catch {}      }  }   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwhymABkoBnDASVUqnRHIAoBKALnnoE8BtAXQCwAKAD0I+AFopYZBikThkCuXgAxHDngBvYfD3w62MPADEYHGgzwAvPAAMAbmG79AcxBXzl1tpf79cBjIMPjqOAB0ZhaoGE5C-gC+zvH6hljGOin+ehgwXL5Z2f7mtFbQlDR0DCq2hMRkFaX0YIyscUVFYZFeMfAA1LUU1E3V4RAgqK4YABbtHUmFxVAYYNPaC4nCCUA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#generic-classes)\nGeneric Classes\n-----------------------------------------------------------------------------------------------\n\nClasses, much like interfaces, can be generic. When a generic class is instantiated with `new`, its type parameters are inferred the same way as in a function call:\n\nts\n\n`   class Box<Type> {    contents: Type;    constructor(value: Type) {      this.contents = value;    }  }  const b = new Box(\"hello!\");         const b: Box<string>   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQJ4AcCmA+aA3gLABQ00w8AdgC7a0QBc0GOA3KeZVRDQE4BXYDXh8AFADcwIAdmatsASkKdy0GgAsAlhAB03Og2gBeaFJnYOZaAF9SdkqW69oAIxPQq2AO5wkYgCINbBAQeABCAMUrAHoYtWgAPQB+IA)\n\nClasses can use generic constraints and defaults the same way as interfaces.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#type-parameters-in-static-members)\nType Parameters in Static Members\n\nThis code isn’t legal, and it may not be obvious why:\n\nts\n\n`   class Box<Type> {    static defaultValue: Type;  Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMaCwAoAYwBsBDRRUAITgA8AeAFQE8AHSAPlAG8DRREAF1KCAloVAATSADNSAV2KCAaqWLzIqFuwDcBAL5A)\n\nRemember that types are always fully erased! At runtime, there’s only _one_ `Box.defaultValue` property slot. This means that setting `Box<string>.defaultValue` (if that were possible) would _also_ change `Box<number>.defaultValue` - not good. The `static` members of a generic class can never refer to the class’s type parameters.\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-at-runtime-in-classes)\n`this` at Runtime in Classes\n-----------------------------------------------------------------------------------------------------------------------\n\n> Background Reading:  \n> [this keyword (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)\n>   \n\nIt’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.\n\nJavaScript’s handling of `this` is indeed unusual:\n\nts\n\n`   class MyClass {    name = \"MyClass\";    getName() {      return this.name;    }  }  const c = new MyClass();  const obj = {    name: \"obj\",    getName: c.getName,  };  // Prints \"obj\", not \"MyClass\"  console.log(obj.getName());   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJHEAUAlOma5oAJw4BXUXmjsAFgEsIAOgIkmOaAF9sOrMAD2eCO2jBy+YgHc4SFBAEbDx0wYBGAKwuZNa4gC4qdw9KABphNi4eQOBlSO4ScKwtDWwAejToAAVRBTx2GEpgsPwDU2o7OkpsZwgDEGJlEAMWXmC4jgS+fn4GIA)\n\nLong story short, by default, the value of `this` inside a function depends on _how the function was called_. In this example, because the function was called through the `obj` reference, its value of `this` was `obj` rather than the class instance.\n\nThis is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#arrow-functions)\nArrow Functions\n\n> Background Reading:  \n> [Arrow functions (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n>   \n\nIf you have a function that will often be called in a way that loses its `this` context, it can make sense to use an arrow function property instead of a method definition:\n\nts\n\n`   class MyClass {    name = \"MyClass\";    getName = () => {      return this.name;    };  }  const c = new MyClass();  const g = c.getName;  // Prints \"MyClass\" instead of crashing  console.log(g());   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJGkUAUASnIA+dM1zQAThwCukvNHYALAJYQAdARJMc0AL4692YAHs8EdtGDl8xAO5wkKCIJ2nzlljeDq2XHjoA9IHQAAqSKnjsMNROdJTQkRbEYAAm0CYAZlaSkKp4LMZmECYgxOogJix81QICDEA)\n\nThis has some trade-offs:\n\n*   The `this` value is guaranteed to be correct at runtime, even for code not checked with TypeScript\n*   This will use more memory, because each class instance will have its own copy of each function defined this way\n*   You can’t use `super.getName` in a derived class, because there’s no entry in the prototype chain to fetch the base class method from\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-parameters)\n`this` parameters\n\nIn a method or function definition, an initial parameter named `this` has special meaning in TypeScript. These parameters are erased during compilation:\n\nts\n\n`   // TypeScript input with 'this' parameter  function fn(this: SomeType, x: number) {    /* ... */  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgFgAoAelKgFpqBjAV2GspPKlUhhoCcBLMYKDxxgGUAO49gACygByaTwDOsqGCxcsSYBC4kAZnRw1gPODih6cACgWKAXLEQo0AGigAPBzjoIARjoBKKABvEigoUgAqKAA6OKhI0hIAXyA)\n\njs\n\n`   // JavaScript output  function fn(x) {    /* ... */  }   `\n\nTypeScript checks that calling a function with a `this` parameter is done so with a correct context. Instead of using an arrow function, we can add a `this` parameter to method definitions to statically enforce that the method is called correctly:\n\nts\n\n`  class MyClass {    name = \"MyClass\";    getName(this: MyClass) {      return this.name;    }  }  const c = new MyClass();  // OK  c.getName();  // Error, would crash  const g = c.getName;  console.log(g());  The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYAcAWAsAFADGANgIaKKgCyAngMLmWgDehooAdmQLaSgBeUACI6jComEBudqADmkAC4A5XpAAUigBYBLFDQZNEASlayO0JQFdonUNr0A6bnxkEOAX0JficTokVQIkEuSAB3A3FKdWM3EFAAeQBpQiJHBRU1GLdCeIBRWAQAGlAwuCsSABMg6AotVL8A+RC0jNVXBv84EkhHEjg5dUHjWKA)\n\nThis method makes the opposite trade-offs of the arrow function approach:\n\n*   JavaScript callers might still use the class method incorrectly without realizing it\n*   Only one function per class definition gets allocated, rather than one per class instance\n*   Base method definitions can still be called via `super`.\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-types)\n`this` Types\n---------------------------------------------------------------------------------------\n\nIn classes, a special type called `this` refers _dynamically_ to the type of the current class. Let’s see how this is useful:\n\nts\n\n`   class Box {    contents: string = \"\";    set(value: string) {      (method) Box.set(value: string): this      this.contents = value;      return this;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVJgD0i7AD0A-D2zQCAC1oQAdLkIkCMViPFFuWbdX5jqeHfoi3sAX0yegA)\n\nHere, TypeScript inferred the return type of `set` to be `this`, rather than `Box`. Now let’s make a subclass of `Box`:\n\nts\n\n`   class ClearableBox extends Box {    clear() {      this.contents = \"\";    }  }  const a = new ClearableBox();  const b = a.set(\"hello\");         const b: ClearableBox   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVD2zQCAC1oQAdLkIkCMViPFFuWJdX5jqeZWognsAX0xOMAelfQAtN+BiC3z0xQSBgAYRAiMGowACMIhGQiRGI8ABMYBIVTUEjqAXl0U2xVdS18FL0Wdi5FFxcg-CpoMCq8IgB3aHDc2PikfJNtJpiqsA0+QTYVIhAQeDZZE3claAA9AH4gA)\n\nYou can also use `this` in a parameter type annotation:\n\nts\n\n`   class Box {    content: string = \"\";    sameAs(other: this) {      return other.content === this.content;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEBc0EBATgJZ4Dm0AvNAESsDcm2EYAtkQCCEABTwCACyJVykmhACUqbtmhUiBAK5U80cVKoA6XIRIFmTFnIjH8xQlyzQAvpmdA)\n\nThis is different from writing `other: Box` — if you have a derived class, its `sameAs` method will now only accept other instances of that same derived class:\n\nts\n\n`  class Box {    content: string = \"\";    sameAs(other: this) {      return other.content === this.content;    }  }  class DerivedBox extends Box {    otherContent: string = \"?\";  }  const base = new Box();  const derived = new DerivedBox();  derived.sameAs(base);  Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.   Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.   Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFADGANgIaKKgBCcAHqAN6GihFwB2ALpN6ol2gBLDgHNQAXlAAiaQG4WoRGQC2kAIKIAFHC4ALGKn1DEASiaLW0SFwCu0DqF0HoAOnbdeXSRKnHE7pw83AoErAC+hJEEhKQUVAAiMEIAbpAAJrQMkHTB6VRZFmFO+jAAwkFe-IIi4lLSAPzyUYSxnAKgAEYUkJKgHJAA7jT0WqahHh3pyWnpfQPDScKzWWOh08sZrspqmlrdiJDjQA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-based-type-guards)\n`this`\\-based type guards\n\nYou can use `this is Type` in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. `if` statements) the type of the target object would be narrowed to the specified `Type`.\n\nts\n\n`   class FileSystemObject {    isFile(): this is FileRep {      return this instanceof FileRep;    }    isDirectory(): this is Directory {      return this instanceof Directory;    }    isNetworked(): this is Networked & this {      return this.networked;    }    constructor(public path: string, private networked: boolean) {}  }  class FileRep extends FileSystemObject {    constructor(path: string, public content: string) {      super(path, false);    }  }  class Directory extends FileSystemObject {    children: FileSystemObject[];  }  interface Networked {    host: string;  }  const fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\");  if (fso.isFile()) {    fso.content;      const fso: FileRep  } else if (fso.isDirectory()) {    fso.children;      const fso: Directory  } else if (fso.isNetworked()) {    fso.host;      const fso: Networked & FileSystemObject  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQAMXhVsAZXwxsAWwDyAIwBW2ZKADefUKHiRxkgBQBKVtAAWB-SKPYAStkzbde0LGzQArrGKgrG3hiGApiRGx0NjEJR2cAbjcAXzcDABF4T2R0WHwzC2sRGwys6Bz8V153Dy9ff0CikOgwiKjQEo0y3MSq0BTegwA5LwB3HIBrbAATfIDC21Bh6DHYSanQADI5mx1evU8fP23IADpiUYnpnr1+vUQmGFhvbNhjTG9lGkRQTAZLVkewQA5gAaH4IABuDGwoHOy0uU1YynQ6EkYVM2n6-T4AiEdliThc2AAHtBsMQpvjJDI5Eo1J1KncHnBnl03n8AXBgWD3p8kKB7sQyULOQhiECMbtqpBvDhXr8rGCOFQuKZrn0+Nj+IJhO1Mp1yqAScLKTFqbIyXT1JopQLrFQpp4WGbpBaFCprdAANoAXR6WuCZNgHAiiwuq2mjNAlnQMFFwP9fBxzPYkHQrHsNMtHoZAF5YdgRi7CcYAERsFHAZQUWAnaCk0tg8so0tqpO8eDRYxsNMnAz2MyStw99AnQXC6A9ECgAB6AH5NUaVTDO6Bu730vqXnlTEPeiOx-bHeSp2B54vsMv9F2D0Nw2tB1GDzGYKfZwveEkgA)\n\nA common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an `undefined` from the value held inside box when `hasValue` has been verified to be true:\n\nts\n\n`   class Box<T> {    value?: T;    hasValue(): this is { value: T } {      return this.value !== undefined;    }  }  const box = new Box<string>();  box.value = \"Gameboy\";  box.value;         (property) Box<string>.value?: string  if (box.hasValue()) {    box.value;           (property) value: string  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQHzQN4FgBQ00AbmCAK4CmA-AFzSoDc++hAFpAGqmUAUAlHQAurAJYwx2Ytwp1U0AL7YWhaACcKgsqoB20YWIB0JchWgBCALwXoZbQBMKAMxHaKdpgQX55zPMHjaEILQAEZI0NauAO5wSMhBqi4A5uj8HmGIRtIR0ABEAOJgALYUYQCeuR74GVkmHgD09YQAelS+Io7QPDXsEFwm-HxKnjXGlB6EjS1tePJAA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties)\nParameter Properties\n---------------------------------------------------------------------------------------------------------\n\nTypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called _parameter properties_ and are created by prefixing a constructor argument with one of the visibility modifiers `public`, `private`, `protected`, or `readonly`. The resulting field gets those modifier(s):\n\nts\n\n`  class Params {    constructor(      public readonly x: number,      protected y: number,      private z: number    ) {      // No body necessary    }  }  const a = new Params(1, 2, 3);  console.log(a.x);                 (property) Params.x: number  console.log(a.z);  Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgAKZ0ZAtlQN6GihFwB2iALtAFcivBAAo27UAAcBAIxIBLIqGiQyAE24kAnqAAeqLgIayYAGgnsp8XpGGR1obYeOnoFgpOnQFANzK2oABeLiYwEgCUoKyekiCgAHJwoLJw6rpcdpCUdNoSAL6EhcTcfKBkoAC8oJkA7jR0jIiiOGbobRgRANyEnDxwJJAAdCRwAOaiZEN63YTxXgvsAHoA-L2lA8OjE1NB3UA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#class-expressions)\nClass Expressions\n---------------------------------------------------------------------------------------------------\n\n> Background Reading:  \n> [Class expressions (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class)\n>   \n\nClass expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:\n\nts\n\n`   const someClass = class<Type> {    content: Type;    constructor(value: Type) {      this.content = value;    }  };  const m = new someClass(\"Hello, world\");         const m: someClass<string>   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBBIFsCmBhANgQwhGBeGwm2APACoCeADkgHwwDeAsAFAwHhRJhQBcMF1ANws2oSFABOAV2BQQEgBQA3DGilI+ApAEoGItjCgALAJYQAdGM7c8MFWqTDWMAL4sXTlmOgwEtsEgA7nCIqEQQCgBEABJIaGggADQwgfJoACaR2k4A9DkGMAB6APxAA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#constructor-signatures)\nConstructor Signatures\n-------------------------------------------------------------------------------------------------------------\n\nJavaScript classes are instantiated with the `new` operator. Given the type of a class itself, the [InstanceType](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype)\n utility type models this operation.\n\nts\n\n`   class Point {    createdAt: number;    x: number;    y: number    constructor(x: number, y: number) {      this.createdAt = Date.now()      this.x = x;      this.y = y;    }  }  type PointInstance = InstanceType<typeof Point>  function moveRight(point: PointInstance) {    point.x += 5;  }  const point = new Point(3, 4);  moveRight(point);  point.x; // => 8   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrWACcBTMVYgEwEFUAuaZAVwFsAjYwgbl3wA96mbDtzzQAngJbtCPAvGQRUhRsFTxCACn4MpHADTjJQwgEpMs-KgAWiCADoipctXQBeaABEyxO8ngB3DRMLaGtbO15od14RfEsbezEo8VjoAF9cDJxUMQAHYjgkNABJBVQwZGAC91LFCqqAFTziAB4c-PgAM0KUVAA+XFxOxkrURHloZngAN2IAJUQAcytUDVyiuh6SsvriM2xRdd6I6ABqdwBWESzcYHlFaCO0ZORify3VgGYDABYTESmswWy1WT1Q-1wYIinGgAHpYVE+tAABxAA)\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members)\n`abstract` Classes and Members\n---------------------------------------------------------------------------------------------------------------------------\n\nClasses, methods, and fields in TypeScript may be _abstract_.\n\nAn _abstract method_ or _abstract field_ is one that hasn’t had an implementation provided. These members must exist inside an _abstract class_, which cannot be directly instantiated.\n\nThe role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be _concrete_.\n\nLet’s look at an example:\n\nts\n\n`  abstract class Base {    abstract getName(): string;    printName() {      console.log(\"Hello, \" + this.getName());    }  }  const b = new Base();  Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3AV6gADtHWSZ8hd118qcNYjj1IAOnpwRcgEQAJSPWcAaUG6gANSgZAAWKogOYsayigra+HwAvgSp+ARWNrTEoAC8oGqQAO5sHIqaQA)\n\nWe can’t instantiate `Base` with `new` because it’s abstract. Instead, we need to make a derived class and implement the abstract members:\n\nts\n\n`   class Derived extends Base {    getName() {      return \"world\";    }  }  const d = new Derived();  d.printName();   `[Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgQmgpgg3gLABQCCokM8CA5jhAHLAC2OAFAJQBcClAlgDsaAbhJkADlEGMW7DgQC+JJcQD0qhAFptsAK4RtmkijQYAIjikA3HABMEOAB4QcA2xmxg8RUrXpNWTgIxMgQoel0oAQQAIgB3AHsoZFsY0V8VFWMEgUgEewBeBAEcOIQLaztOdNsAOklpALlhIA)\n\nNotice that if we forget to implement the base class’s abstract members, we’ll get an error:\n\nts\n\n`   class Derived extends Base {  Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.    // forgot to do anything  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMGCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-CFABae1QCuZe7YIMmLACIwVAN0gAE1BIAA8ySDVAlnZETh58PhsAMwQROFoyOFBA7MI1AE8yAAt1EUsgA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-construct-signatures)\nAbstract Construct Signatures\n\nSometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.\n\nFor example, you might want to write this code:\n\nts\n\n`   function greet(ctor: typeof Base) {    const instance = new ctor();  Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.    instance.printName();  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-AyYsAIjBUA3SABNQkAB5lIa1y3ZETh58PjEjWUVuHT5ocQBXaDVQACIU7VDQKysQUABaAqp4sgK8ggAzeLUaFThkkTjxORoEVDIAT11IOHK2DlMQvio68lB1ckJqzgBeUDVIAHc6MgRFDL5xskmqSAA6fUMpSIUMsyA)\n\nTypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of `greet`, it’s perfectly legal to write this code, which would end up constructing an abstract class:\n\nts\n\n`   // Bad!  greet(Base);   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3gcziDAXPFCgJ4A08AQlGiESaQNwCwAUAPQfwC0fYAVwx8e7LtSjAAhO1wh8AChp0AlEyA)\n\nInstead, you want to write a function that accepts something with a construct signature:\n\nts\n\n`  function greet(ctor: new () => Base) {    const instance = new ctor();    instance.printName();  }  greet(Derived);  greet(Base);  Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.   Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.   Cannot assign an abstract constructor type to a non-abstract constructor type.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACGARogC7REDG5o1ANkYoqAELOSgDehoopClVqgA5pHIA5IgFtIACgCUqIQEsAdqIDcfUAAdoGqbIWKeAX0KWCjZqwAiMVQDdIAE1CQAHuUjq3rByIXLwE-OLGcko8uvzQEgCu0OqgAESpOmGg1tYgoAC0hdQJ5IX5hABmCeq0qnApovES8rQIqOqQAO6g0QC8AHzsnGah-NT1FKAaFEQ1XL2gHd2t0EqZ-NPks9SQAHQGRtJRipnWjZDNjoaubieE581BkCdAA)\n\nNow TypeScript correctly tells you about which class constructor functions can be invoked - `Derived` can because it’s concrete, but `Base` cannot.\n\n[](https://www.typescriptlang.org/docs/handbook/2/classes.html#relationships-between-classes)\nRelationships Between Classes\n---------------------------------------------------------------------------------------------------------------------------\n\nIn most cases, classes in TypeScript are compared structurally, the same as other types.\n\nFor example, these two classes can be used in place of each other because they’re identical:\n\nts\n\n`   class Point1 {    x = 0;    y = 0;  }  class Point2 {    x = 0;    y = 0;  }  // OK  const p: Point1 = new Point2();   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgFwIzQN4FgBQ00AHtALzQAMA3PoQJ5mU14C+++okMCKqATNlrFG1IQ3KjW7PAHoZ0APIBpDvGQRU0AA4AuOEjSZyyAKYB3fbz4AKAJRUgA)\n\nSimilarly, subtype relationships between classes exist even if there’s no explicit inheritance:\n\nts\n\n`   class Person {    name: string;    age: number;  }  class Employee {    name: string;    age: number;    salary: number;  }  // OK  const p: Person = new Employee();   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgLABQi2mkkoACnrJAPYB2oA3saKI5gLZ5owJGAcwDc7UJiF9OAV24AjWmKIBfYsVLlKAUW4AHbPQCeePK3Fde-OPGHKOk6YzmLY90JByZYRtM4VKxGpExCCgAPIA0hpMMKB6aDR0TKAAvJx4AO6gugbGpgAUAJQiQA)\n\nThis sounds straightforward, but there are a few cases that seem stranger than others.\n\nEmpty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:\n\nts\n\n`   class Empty {}  function fn(x: Empty) {    // can't do anything with 'x', so I won't  }  // All OK!  fn(window);  fn({});  fn(fn);   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4FgBQ+AZgK4B2wyAlgPanSGkAUAHgFxxJoCUm+00AegHRgYUgHJk0ACbVoY1MgAWlUgHNoAd0rLo45uIA00CHICSW2pPy4CeIdACCIENADyAaQCERJttKymlwA3L6M2CFhDCFAA)\n\n[### Modules\\\n\\\nHow JavaScript handles communicating across file boundaries.](https://www.typescriptlang.org/docs/handbook/2/modules.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Classes.md)\n ❤\n\nContributors to this page:  \n\nRC![Ryan Cavanaugh  (60)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nHA![Hossein Ahmadian-Yazdi  (6)](https://gravatar.com/avatar/badbb0b7582edd51c9ff8e37038becd49986e1af6f1c5dbf200eddbc20d1da7e?s=32&&d=blank)\n\nMR![Maxim R  (3)](https://gravatar.com/avatar/a4b5d7ccc7c1416eb9f38ef4f98407c3b8e24c6ab973a44ad74779ce1d993d0b?s=32&&d=blank)\n\nU![uid11  (2)](https://gravatar.com/avatar/8ca8283e12f542400e5da7a69017fbbec149732f9a7ca0b8190065fe0317831d?s=32&&d=blank)\n\n23+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - Classes","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","ogTitle":"Documentation - Classes","generator":"Gatsby 5.13.5","og:title":"Documentation - Classes","twitter:site":"typescriptlang","theme-color":"#3178C6","ogDescription":"How classes work in TypeScript","description":"How classes work in TypeScript","og:description":"How classes work in TypeScript","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","scrapeId":"a0909621-dfb0-45de-87a5-3297383d9540","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/classes.html","url":"https://www.typescriptlang.org/docs/handbook/2/classes.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModules\n=======\n\nJavaScript has a long history of different ways to handle modularizing code. Having been around since 2012, TypeScript has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as the `import`/`export` syntax.\n\nES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes.\n\nFor focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJS `module.exports =` syntax, and you can find information about the other module patterns in the reference section under [Modules](https://www.typescriptlang.org/docs/handbook/modules.html)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined)\nHow JavaScript Modules are Defined\n-------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript, just as in ECMAScript 2015, any file containing a top-level `import` or `export` is considered a module.\n\nConversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).\n\nModules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms.\n\n[](https://www.typescriptlang.org/docs/handbook/2/modules.html#non-modules)\nNon-modules\n---------------------------------------------------------------------------------------\n\nBefore we start, it’s important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an `import` declaration, `export`, or top-level `await` should be considered a script and not a module.\n\nInside a script file variables and types are declared to be in the shared global scope, and it’s assumed that you’ll either use the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)\n compiler option to join multiple input files into one output file, or use multiple `<script>` tags in your HTML to load these files (in the correct order!).\n\nIf you have a file that doesn’t currently have any `import`s or `export`s, but you want to be treated as a module, add the line:\n\nts\n\n`   export {};   `[Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAbwL4G4g)\n\nwhich will change the file to be a module exporting nothing. This syntax works regardless of your module target.\n\n[](https://www.typescriptlang.org/docs/handbook/2/modules.html#modules-in-typescript)\nModules in TypeScript\n-----------------------------------------------------------------------------------------------------------\n\n> Additional Reading:  \n> [Impatient JS (Modules)](https://exploringjs.com/impatient-js/ch_modules.html#overview-syntax-of-ecmascript-modules)\n>   \n> [MDN: JavaScript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)\n>   \n\nThere are three main things to consider when writing module-based code in TypeScript:\n\n*   **Syntax**: What syntax do I want to use to import and export things?\n*   **Module Resolution**: What is the relationship between module names (or paths) and files on disk?\n*   **Module Output Target**: What should my emitted JavaScript module look like?\n\n### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#es-module-syntax)\nES Module Syntax\n\nA file can declare a main export via `export default`:\n\nts\n\n`   // @filename: hello.ts  export default function helloWorld() {    console.log(\"Hello, world!\");  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvkA)\n\nThis is then imported via:\n\nts\n\n`   import helloWorld from \"./hello.js\";  helloWorld();   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvtRAQYCFOhY0IgctKSUVD4AtDFC3CQxUdTQqIwskvgEskzyoJBMBKigJkTAuJlEAFZkJu5U5TIOyq5AA)\n\nIn addition to the default export, you can have more than one export of variables and functions via the `export` by omitting `default`:\n\nts\n\n`   // @filename: maths.ts  export var pi = 3.14;  export let squareTwo = 1.41;  export const phi = 1.61;  export class RandomNumberGenerator {}  export function absolute(num: number) {    if (num < 0) return num * -1;    return num;  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNyLsZIUKgAJWREABMGVAA5FVQAI3gmAHEkeLxmUABvAF93U1lWSBVEC1xoa1BkGMIGWBVceAAKRGisJtj4gEoMqlBQaEhQRujQAB5QAAZOpnhcFSZEUFbQACpQAFo3Sh6pmbmF6JNMoA)\n\nThese can be used in another file via the `import` syntax:\n\nts\n\n`   import { pi, phi, absolute } from \"./maths.js\";  console.log(pi);  const absPhi = absolute(phi);            const absPhi: number   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsx6WbkXYyQoVAAlZEQAEwZUADkVVAAjeCYAcSQ4vGZQAG8AX3dZVkgVRAtcaGtQZGjCBlgVXHgACkQorAaYuIBKdKpQUGhIUHqo0AAeUAAGdqZ4XBUmRFBm0AAqUABaN0ouiamZuaiTLMoQCBgEFHQsZDo6UgoDsGX7i2r75apoVBz07mgAGm4HX7KFSqNVAGVAkCYYVAACJiMAcAQSAArQjQkxUKw2SrwYiwBgAc1qPFaJkxtlK5QACg49IDKtU6vZoCSqIcuqAAHoAfiAA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#additional-import-syntax)\nAdditional Import Syntax\n\nAn import can be renamed using a format like `import {old as new}`:\n\nts\n\n`   import { pi as π } from \"./maths.js\";  console.log(π);               (alias) var π: number import π   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qICDAQp0WZHTqkKlGQFptAYwCuubZqrRUjFqADe3XskKhAA8CgAvqEhMGqUACJiwHAQkAFaE3lKUVDoMiIQMCMSwDADmABQOAJThMqA5ubkAegD8QA)\n\nYou can mix and match the above syntax into a single `import`:\n\nts\n\n`   // @filename: maths.ts  export const pi = 3.14;  export default class RandomNumberGenerator {}  // @filename: app.ts  import RandomNumberGenerator, { pi as π } from \"./maths.js\";  RandomNumberGenerator;             (alias) class RandomNumberGenerator import RandomNumberGenerator  console.log(π);               (alias) const π: 3.14 import π   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQBjBxQ1u6UAXlABmYgEYALAG4qtRi1AATeJGQBXWKzaxkhQqABKyRAoaoAcqtQAjeEwDiSW3magA3gF8qVEBBgIU6FjIdHSkFJTQqHKshsamFta2DohOuMwANG6gvKA6oIADwKDuoJBMpqAARMTAOAQkAFaEFdKUVLEm5pY29o5MzkwtPgB6APxelBxcDAjEsAwA5gAU+QCUg2Cgm1tbo0A)\n\nYou can take all of the exported objects and put them into a single namespace using `* as name`:\n\nts\n\n`   // @filename: app.ts  import * as math from \"./maths.js\";  console.log(math.pi);  const positivePhi = math.absolute(math.phi);              const positivePhi: number   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNzIKxBdzRrUGQAI0IGWBVceAAKRBVULDjUYPgmAEpQAG8qUFBoSFBY+NAAHlAABgymeFwVJkRQJNAAKlAAWjdKXOra+sb4kwBfKhB2traLSPG2kbAoOCQ0TCC6OlIKSmhUWVZW5EJsPHxQSCYGVFAAImJgHAISACtCS5MqKxtw+GJYBgBzaLu+GIPDSJnetm4DEI0H8bHgAAUHHpAcQQmEIlEAUdgQ5QbNcrkAHoAfiAA)\n\nYou can import a file and _not_ include any variables into your current module via `import \"./file\"`:\n\nts\n\n`   // @filename: app.ts  import \"./maths.js\";  console.log(\"3.14\");   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qIUAFp5AYwCuuebOlgocJGkyhkdOqQqVoqRi1AAiYsBwESAK0JWplKgoaJCDBMVgMAOYAFFbC4lYAlBJAA)\n\nIn this case, the `import` does nothing. However, all of the code in `maths.ts` was evaluated, which could trigger side-effects which affect other objects.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#typescript-specific-es-module-syntax)\nTypeScript Specific ES Module Syntax\n\nTypes can be exported and imported using the same syntax as JavaScript values:\n\nts\n\n`   // @filename: animal.ts  export type Cat = { breed: string; yearOfBirth: number };  export interface Dog {    breeds: string[];    yearOfBirth: number;  }  // @filename: app.ts  import { Cat, Dog } from \"./animal.js\";  type Animals = Cat | Dog;   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVKrUYtQS4jcjIAxtwAiDMoiVKDikjKkcgpKygDaALqOlGGa2nqGJmaW1kzJdk6UIBAwCCjoWMh0dCQUlHiurKJ8xAA0oIHBdqCQTAyooABEhMA4eASEAFakg8kcXKAAgrj4sKSgQi2gAD4dQapAA)\n\nTypeScript has extended the `import` syntax with two concepts for declaring an import of a type:\n\n###### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#import-type)\n`import type`\n\nWhich is an import statement which can _only_ import types:\n\nts\n\n`  // @filename: animal.ts  export type Cat = { breed: string; yearOfBirth: number };  export type Dog = { breeds: string[]; yearOfBirth: number };  export const createCatName = () => \"fluffy\";  // @filename: valid.ts  import type { Cat, Dog } from \"./animal.js\";  export type Animals = Cat | Dog;  // @filename: app.ts  import type { createCatName } from \"./animal.js\";  const name = createCatName();  'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlFQgEDAIKOhYAG4E0NIkFJR4LqwcXCK8-AA0oF4+dqCQTAyoLYTAOHgEhABWpD3pC27LAIK4+LCkvqusAD6b3r39YFA4EhKlhkHQ6DN-hAbPsmMFQABGADMADYEVR5pl7txRIUtMQSvwKuh7Lt9odmsdTi9Ltdejk8qwRlUCkUCaVifA6qogA)\n\n###### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#inline-type-imports)\nInline `type` imports\n\nTypeScript 4.5 also allows for individual imports to be prefixed with `type` to indicate that the imported reference is a type:\n\nts\n\n`   // @filename: app.ts  import { createCatName, type Cat, type Dog } from \"./animal.js\";  export type Animals = Cat | Dog;  const name = createCatName();   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlCCgALRDWebEQwNU-VBwSJVYyHR0JBSUeC6sooVaxCX8FegANG5cvPxHHCdePnagkEwMqC2EwDh4BIQAVqQ9VOnrx9wAIK4fCwUi+U6sAA+oCuvRyeVYKHQEK2xVK+3gdVUQA)\n\nTogether these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#es-module-syntax-with-commonjs-behavior)\nES Module Syntax with CommonJS Behavior\n\nTypeScript has ES Module syntax which _directly_ correlates to a CommonJS and AMD `require`. Imports using ES Module are _for most cases_ the same as the `require` from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:\n\nts\n\n`   import fs = require(\"fs\");  const code = fs.readFileSync(\"hello.ts\", \"utf8\");   `[Try](https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAAQFsKBXAG2gC5QyUmw6IAVniZgAtLOSd0s6UwCWbbKUjpQsPKAKgYAR04qYACiK6iASgDcTIYjzahlfTrwA6GAENyAGIqvADKmCiWABbQ3NykXuh4RAA0oEQKsAActnZAA)\n\nYou can learn more about this syntax in the [modules reference page](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/2/modules.html#commonjs-syntax)\nCommonJS Syntax\n-----------------------------------------------------------------------------------------------\n\nCommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier.\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#exporting)\nExporting\n\nIdentifiers are exported via setting the `exports` property on a global called `module`.\n\nts\n\n`   function absolute(num: number) {    if (num < 0) return num * -1;    return num;  }  module.exports = {    pi: 3.14,    squareTwo: 1.41,    phi: 1.61,    absolute,  };   `[Try](https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAWjeQFd02WnYOU6AJalEoAIYAjPKQA2XaAApEHALYAuUCtWSEASlABvJqFBDYoZWoigADAZjoOkMdtAAqUCwCMAbhOgjs6uav6MAL5MTKoUHLLQAHTQAB7YpJDoeKAERgHYQpoAzAneACwANAF4AI4c4jAAKgDupJreCaXelYym2AAWBaDtAGxdAVIy8ujQ3eG+QA)\n\nThen these files can be imported via a `require` statement:\n\nts\n\n`   const maths = require(\"./maths\");  maths.pi;          any   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgsdhcdqFZCTaiiJxqbjAVicQhqHxleFcbjdS5gYKgAB6AH4gA)\n\nOr you can simplify a bit using the destructuring feature in JavaScript:\n\nts\n\n`   const { squareTwo } = require(\"./maths\");  squareTwo;       const squareTwo: any   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgBUATKazBagcrtQrISbUURONTcYCsTiENQ+Mog6bIebQS5gAB6AH4gA)\n\n### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#commonjs-and-es-modules-interop)\nCommonJS and ES Modules interop\n\nThere is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/2/modules.html#typescripts-module-resolution-options)\nTypeScript’s Module Resolution Options\n--------------------------------------------------------------------------------------------------------------------------------------------\n\nModule resolution is the process of taking a string from the `import` or `require` statement, and determining what file that string refers to.\n\nTypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option [`module`](https://www.typescriptlang.org/tsconfig#module)\n is not `commonjs`, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for `.ts` and `.d.ts`.\n\nThere are many TSConfig flags which influence the module strategy within TypeScript: [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution)\n, [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl)\n, [`paths`](https://www.typescriptlang.org/tsconfig#paths)\n, [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs)\n.\n\nFor the full details on how these strategies work, you can consult the [Module Resolution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#the-moduleresolution-compiler-option)\n reference page.\n\n[](https://www.typescriptlang.org/docs/handbook/2/modules.html#typescripts-module-output-options)\nTypeScript’s Module Output Options\n------------------------------------------------------------------------------------------------------------------------------------\n\nThere are two options which affect the emitted JavaScript output:\n\n*   [`target`](https://www.typescriptlang.org/tsconfig#target)\n     which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact\n*   [`module`](https://www.typescriptlang.org/tsconfig#module)\n     which determines what code is used for modules to interact with each other\n\nWhich [`target`](https://www.typescriptlang.org/tsconfig#target)\n you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.\n\nAll communication between modules happens via a module loader, the compiler option [`module`](https://www.typescriptlang.org/tsconfig#module)\n determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.\n\nFor example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for [`module`](https://www.typescriptlang.org/tsconfig#module)\n:\n\nts\n\n`   import { valueOfPi } from \"./constants.js\";  export const twoPi = valueOfPi * 2;   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxge0QM4AuyiRBAdOQLABQ8AHgA64BORO+xoAbsrAFd4AeUgAFaKAC8oAMwUAjABYATAG46ICDAQp0WaIgAmjKgU1gAtNewCi1y3WioW7UAG9e-IaImgAvqCQrLiooABEFMB4hCRklABWBOEatHSMrhwx3EQA7rh+MnyCIuKSAFSg6kA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#es2020)\n`ES2020`\n\nts\n\n`import { valueOfPi } from \"./constants.js\";  export const twoPi = valueOfPi * 2;` [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBco5kATAAyM57gB2siATl7F5DlTIADn3SgA3qABuAQ1LFyAeQBmABVSgAvqBW9koAEQA6YAGNYbSOllt0kYwCtIhgNw4c5AB6iu4i1bi6PCwGqAAvDLyiqphAFSgdK5AA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#commonjs)\n`CommonJS`\n\nts\n\n`\"use strict\";  Object.defineProperty(exports, \"__esModule\", { value: true });  exports.twoPi = void 0;  const constants_js_1 = require(\"./constants.js\");  exports.twoPi = constants_js_1.valueOfPi * 2;` [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoAxrMgQHYBWkOe4jsiATj7DzbZUyAA4D0oAN6gAbgENSxcgHkAZgAVUoAL6g1-ZKABEAOmB1GkdPMbpIp1sYDcOHOQAe4npMvXQ6PCwWqAAvHKKyuohAFSgAEzOQA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/2/modules.html#umd)\n`UMD`\n\nts\n\n`(function (factory) {      if (typeof module === \"object\" && typeof module.exports === \"object\") {          var v = factory(require, exports);          if (v !== undefined) module.exports = v;      }      else if (typeof define === \"function\" && define.amd) {          define([\"require\", \"exports\", \"./constants.js\"], factory);      }  })(function (require, exports) {      \"use strict\";      Object.defineProperty(exports, \"__esModule\", { value: true });      exports.twoPi = void 0;      const constants_js_1 = require(\"./constants.js\");      exports.twoPi = constants_js_1.valueOfPi * 2;  });` [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoxyhOe4AdrIgE5uxuQ6rIAOXdKADeoAG4BDUsXIB5AGYAFVKAC+oBZ2SgARADpgAY1hNI6SU3SR9AK0i6A3DhzkAHoLbCTZ4eniwKqAAvBLSsopBAFSgAEyOQA)\n\n> Note that ES2020 is effectively the same as the original `index.ts`.\n\nYou can see all of the available options and what their emitted JavaScript code looks like in the [TSConfig Reference for `module`](https://www.typescriptlang.org/tsconfig#module)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/2/modules.html#typescript-namespaces)\nTypeScript namespaces\n-----------------------------------------------------------------------------------------------------------\n\nTypeScript has its own module format called `namespaces` which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use [in DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)\n. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces in [the namespaces reference page](https://www.typescriptlang.org/docs/handbook/namespaces.html)\n.\n\n[### Classes\\\n\\\nHow classes work in TypeScript](https://www.typescriptlang.org/docs/handbook/2/classes.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/handbook-v2/Modules.md)\n ❤\n\nContributors to this page:  \n\nRC![Ryan Cavanaugh  (52)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nOT![Orta Therox  (7)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nM![Myo  (3)](https://gravatar.com/avatar/365f6f64e334274439a7438580a4f6eb29b7666c4c178c7c26a4a9c9935b0d3b?s=32&&d=blank)\n\nAB![Andrew Branch  (2)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nHA![Hossein Ahmadian-Yazdi  (2)](https://gravatar.com/avatar/badbb0b7582edd51c9ff8e37038becd49986e1af6f1c5dbf200eddbc20d1da7e?s=32&&d=blank)\n\n18+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - Modules","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"How JavaScript handles communicating across file boundaries.","theme-color":"#3178C6","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"How JavaScript handles communicating across file boundaries.","og:description":"How JavaScript handles communicating across file boundaries.","language":"en","generator":"Gatsby 5.13.5","og:title":"Documentation - Modules","title":"TypeScript: Documentation - Modules","twitter:site":"typescriptlang","scrapeId":"481773c7-873c-461c-b8a6-0ec2e812707d","sourceURL":"https://www.typescriptlang.org/docs/handbook/2/modules.html","url":"https://www.typescriptlang.org/docs/handbook/2/modules.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nUtility Types\n=============\n\nTypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#awaitedtype)\n`Awaited<Type>`\n-----------------------------------------------------------------------------------------------\n\n> Released: [4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#the-awaited-type-and-promise-improvements)\n\nThis type is meant to model operations like `await` in `async` functions, or the `.then()` method on `Promise`s - specifically, the way that they recursively unwrap `Promise`s.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example)\nExample\n\nts\n\n`   type A = Awaited<Promise<string>>;        type A = string  type B = Awaited<Promise<Promise<number>>>;        type B = number  type C = Awaited<boolean | Promise<number>>;        type C = number | boolean   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAglC8sDuBDAlsCATAPABQCcB7AWzQGcIdzgC0A7AcwD5mBuAKAHouo+A9APwcOoSFABCCZOky5CpClQVlKOegFcSAIwgFW7brwHDR4aAGFpMVBmw5tRIgBsIKelAA+UFUvVbdfUMePighIA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\n`Partial<Type>`\n-----------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type with all properties of `Type` set to optional. This utility will return a type that represents all subsets of a given type.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-1)\nExample\n\nts\n\n`   interface Todo {    title: string;    description: string;  }  function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {    return { ...todo, ...fieldsToUpdate };  }  const todo1 = {    title: \"organize desk\",    description: \"clear clutter\",  };  const todo2 = updateTodo(todo1, {    description: \"throw out trash\",  });   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgW+AL758MAK4gE-EMhk9McSBmwAKMFnTVN6ADTIYwCGUw0MAVVXqqyAApwoJOGQA8hgHwBKPDYoCDAZKCVcZAA6GN1sExioswsrW3tIZHFWSXwEATpiPQBGZABeQKISckcAInQoRjgQYAAvFA4aAGsaozYO7mA+YAFqGoQKV2RxmTBIKB6JVlz8sELsACYy5XSIQx1ikwIift5FUbAACyh0AHdkdBniKDgaC4XxP2YgA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype)\n`Required<Type>`\n-------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#improved-control-over-mapped-type-modifiers)\n\nConstructs a type consisting of all properties of `Type` set to required. The opposite of [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\n.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-2)\nExample\n\nts\n\n`  interface Props {    a?: number;    b?: string;  }  const obj: Props = { a: 5 };  const obj2: Required<Props> = { a: 5 };  Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.2741Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYAsBGAUAJYB2ALjAGYCGAxpKAArwAOioA3nqKJQPypEBXALYAjGAG5OoEX1CIS0YgHNJAXzx5qcIvNBwRAK1SM4LUAF523VAFZQqyZu279BtKgBKkAI4CC0SAATAB4TFgA+CytKW3txIA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)\n`Readonly<Type>`\n-------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type with all properties of `Type` set to `readonly`, meaning the properties of the constructed type cannot be reassigned.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-3)\nExample\n\nts\n\n`  interface Todo {    title: string;  }  const todo: Readonly<Todo> = {    title: \"Delete inactive users\",  };  todo.title = \"Hello\";  Cannot assign to 'title' because it is a read-only property.2540Cannot assign to 'title' because it is a read-only property.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKACpwAmcoA3nqKCQSQDaRUiEtGIBzANx4AvnjzU4RYd2ZxUAJUiUWRPgE8APIxYA+UAF52nbrwGoARABFIAsqGI0eANzoBXRDCI9gA0MlJ4JKoAdDz8dJb2ABIufHD2EkA)\n\nThis utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a [frozen object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n).\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#objectfreeze)\n`Object.freeze`\n\nts\n\n`   function freeze<Type>(obj: Type): Readonly<Type>;   `\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)\n`Record<Keys, Type>`\n--------------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs an object type whose property keys are `Keys` and whose property values are `Type`. This utility can be used to map the properties of a type to another type.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-4)\nExample\n\nts\n\n`   type CatName = \"miffy\" | \"boris\" | \"mordred\";  interface CatInfo {    age: number;    breed: string;  }  const cats: Record<CatName, CatInfo> = {    miffy: { age: 10, breed: \"Persian\" },    boris: { age: 5, breed: \"Maine Coon\" },    mordred: { age: 16, breed: \"British Shorthair\" },  };  cats.boris;     const cats: Record<CatName, CatInfo>   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwghsAcnAttAvFARCglgM3xCygB9sAjAewCdcBnE8nWgExolawG4AoX3ADtgEGvjgBjaPGABJQfipQA3ryhQ4AcwgAuKIICuKCqL7qKHTnvrA6gzXwC+-CVUE2oEhPT0AlCK40rAA8MshoADSwCPKKAHxQmKrqeIQgesoa2noAjAAMURYQVtgACqL0uHCCJI4RalDUdD4qWbpQAKyFlqx6WACycELSVG619SlsHL2tWu05AGzdxTNYAEJ0wAwAFlAAytu0wNtDNOO8jny8XsD0AHRNDHwA9M9QAHoA-EA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys)\n`Pick<Type, Keys>`\n----------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#partial-readonly-record-and-pick)\n\nConstructs a type by picking the set of properties `Keys` (string literal or union of string literals) from `Type`.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-5)\nExample\n\nts\n\n`   interface Todo {    title: string;    description: string;    completed: boolean;  }  type TodoPreview = Pick<Todo, \"title\" | \"completed\">;  const todo: TodoPreview = {    title: \"Clean room\",    completed: false,  };  todo;     const todo: TodoPreview   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVgF98+MAE8eKDNgAKUCADdgEAO7IAvMmPAEAawA8R9ABpkAIhLkEL7IAD5+EtKyEJi+AHys+BIgdMRY6NSephZWtg4ERAEU1L4AwqogyFDKkr5e4lIyEHLU8GQ0EHUaCWBprAD0fcgAegD8QA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys)\n`Omit<Type, Keys>`\n----------------------------------------------------------------------------------------------------\n\n> Released:  \n> [3.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type)\n\nConstructs a type by picking all properties from `Type` and then removing `Keys` (string literal or union of string literals). The opposite of [`Pick`](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys)\n.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-6)\nExample\n\nts\n\n`   interface Todo {    title: string;    description: string;    completed: boolean;    createdAt: number;  }  type TodoPreview = Omit<Todo, \"description\">;  const todo: TodoPreview = {    title: \"Clean room\",    completed: false,    createdAt: 1615544252770,  };  todo;     const todo: TodoPreview  type TodoInfo = Omit<Todo, \"completed\" | \"createdAt\">;  const todoInfo: TodoInfo = {    title: \"Pick up kids\",    description: \"Kindergarten closes at 5pm\",  };  todoInfo;       const todoInfo: TodoInfo   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVkW4Q4cgIJhqIAK6SF0VgF98+MAE8eKDNgAKUCADdgEAO7IAvMgA8pKkADxO6AA0yABEHFy8-CAxAHys+BIgdMRY6NQRrh5evgEERCTkVLEAwqogyFDKkjGR4lIyEHLU8GQ0EK2abjoQmPrUAIwAbOMArDMALPMATDNLAOxrAAytFulguawA9IfIAHoA-NZ2Dmi5AJIgMDgBwWER0TES0rIjMcgAPrEtMNRmBUulMtl9tgHk98vdHs88GwKhRqDFnMAEABrZBGHjIbHATA0FpseLcYB8YACdEAaVAHCgjDgUEg9QQZHQfRoyB0yBmPGaOz2CKeRxOFyAA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers)\n`Exclude<UnionType, ExcludedMembers>`\n------------------------------------------------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by excluding from `UnionType` all union members that are assignable to `ExcludedMembers`.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-7)\nExample\n\nts\n\n`   type T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;         type T0 = \"b\" | \"c\"  type T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">;         type T1 = \"c\"  type T2 = Exclude<string | number | (() => void), Function>;         type T2 = string | number  type Shape =    | { kind: \"circle\"; radius: number }    | { kind: \"square\"; x: number }    | { kind: \"triangle\"; x: number; y: number };  type T3 = Exclude<Shape, { kind: \"circle\" }>         type T3 = {     kind: \"square\";     x: number; } | {     kind: \"triangle\";     x: number;     y: number; }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAogDwMYBsCuATCAHgCIBDYqAHymICMLriNiAaG8gPgG4AoAej5QhUAHoB+HqEiwAjElSZcBEuSo16apq3YN1xbv0HDxk8NBgAmeemz4iAZ2AAnAJYA7AOZq3OALa0IJzUACmCASiQOKAA3AHsXPDC2ADEcNwxgF1i3AwFhUQlTaQBlAAtSaUQeIWoAbygAa3c8AC4aDBcnbAhiLignUjwXHHs2n39AqABfarV6prdWmnsARxxSJx6+tDG-AKCZmqh55rbiZxdSTywtqB2ocf2+kF2Jg94i8wBma0U7QjKFQgbBOizOHS6NwoUw4hny4iAA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union)\n`Extract<Type, Union>`\n------------------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by extracting from `Type` all union members that are assignable to `Union`.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-8)\nExample\n\nts\n\n`   type T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">;         type T0 = \"a\"  type T1 = Extract<string | number | (() => void), Function>;         type T1 = () => void  type Shape =    | { kind: \"circle\"; radius: number }    | { kind: \"square\"; x: number }    | { kind: \"triangle\"; x: number; y: number };  type T2 = Extract<Shape, { kind: \"circle\" }>         type T2 = {     kind: \"circle\";     radius: number; }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAogD2AJwIYGNgA8ARNkVAD5REBGZlRuRANFaRVQGZEB8A3AFAB6QVFFQAegH5+oSLACMSVBhz4CAZywBLAHYBzdjoCuAW2oRM7ABRWAlEm5QAbgHstAE1ssAYkZ34tFx0+IRExKX4ZcGgAZQALbDlEflFKAG8oAGtddwAuKlwtTFwAGwgiXigcdy0jdXzjMwsoAF8U9gzsnTyqdQBHI2xMcsq0BtNzSzbUqE6c-KJtbH0yiqgxqEbJypBxpqmBKLkYACYldCw8QnjEiBY57oXC4tXW7lCxCUkgA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype)\n`NonNullable<Type>`\n-------------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type by excluding `null` and `undefined` from `Type`.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-9)\nExample\n\nts\n\n`   type T0 = NonNullable<string | number | undefined>;         type T0 = string | number  type T1 = NonNullable<string[] | null | undefined>;         type T1 = string[]   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAKgDFAvFAcgewHYoK4BtcCGARrhADwDOwATgJYYDmUAPlBtgLZETUtTYYAJhABm9CIIB8AbgBQAenlRlUAHoB+WaEiwAjElSYc+YqUo16DANoBdPu3x8BwsRgkyFSlRqA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)\n`Parameters<Type>`\n-----------------------------------------------------------------------------------------------------\n\n> Released:  \n> [3.1](https://github.com/microsoft/TypeScript/pull/26243)\n\nConstructs a tuple type from the types used in the parameters of a function type `Type`.\n\nFor overloaded functions, this will be the parameters of the _last_ signature; see [Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)\n.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-10)\nExample\n\nts\n\n`   declare function f1(arg: { a: number; b: string }): void;  type T0 = Parameters<() => string>;         type T0 = []  type T1 = Parameters<(s: string) => void>;         type T1 = [s: string]  type T2 = Parameters<<T>(arg: T) => T>;         type T2 = [arg: unknown]  type T3 = Parameters<typeof f1>;         type T3 = [arg: {     a: number;     b: string; }]  type T4 = Parameters<any>;         type T4 = unknown[]  type T5 = Parameters<never>;         type T5 = never  type T6 = Parameters<string>;  Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.         type T6 = never  type T7 = Parameters<Function>;  Type 'Function' does not satisfy the constraint '(...args: any) => any'.   Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.   Type 'Function' provides no match for the signature '(...args: any): any'.         type T7 = never   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQATSAYwBsBDaSUAMwFcA7IgFwEs56aBGACgoHNUAb1BlU9WgFsARjADcoKakRNoLen1ABfAJSoAbnBb5ZuXEwCeAByoAVAAygAvKAAKFMhMhMYiADzdtJwA+UGVVdSCTEFAY0AA9AH4zK1tOJ1d3T28kfxRQlTU+QMcQgyNI3GjYxOTrUBs0dLdoDy8fX18bIN5oAXrikK6osGqkizqbDCbMtpzxyDhqLgqqmJr5+qxplqz2snpzFZG1sZT6gFZt1uy-ekg9GCPY+NOJgDYr3ZywwqfR2tsAHZPrM-AAxBjMNj0P4nIA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#constructorparameterstype)\n`ConstructorParameters<Type>`\n---------------------------------------------------------------------------------------------------------------------------\n\n> Released:  \n> [3.1](https://github.com/microsoft/TypeScript/pull/26243)\n\nConstructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type `never` if `Type` is not a function).\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-11)\nExample\n\nts\n\n`   type T0 = ConstructorParameters<ErrorConstructor>;         type T0 = [message?: string]  type T1 = ConstructorParameters<FunctionConstructor>;         type T1 = string[]  type T2 = ConstructorParameters<RegExpConstructor>;         type T2 = [pattern: string | RegExp, flags?: string]  class C {    constructor(a: number, b: string) {}  }  type T3 = ConstructorParameters<typeof C>;         type T3 = [a: number, b: string]  type T4 = ConstructorParameters<any>;         type T4 = unknown[]  type T5 = ConstructorParameters<Function>;  Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.   Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.   Type 'Function' provides no match for the signature 'new (...args: any): any'.         type T5 = never   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQIJEAXaASwGMjUAzAQwBtFJciBPAB0lABUAGUALygAwnAB2xaAFdKCAAq1otALaQiMRAB4AorASiJJGUQQA+ANz4woGwD0A-Cw5duARkEjxk4-MUq1GpoAYlJilKTiBt6y0BZWNnaObJw8aB5RRjEKSqrqSJoASpAA5toAHuwZ0jFxBAkOuOT0tIiIIqAA3rg25F6ZJtAAFLSoYlLKAEYwADSgE6iSpGLFAJSdAL64m8kuGOl91QPZ-nlaO3DUIrXWiU4p3Fj7hoe+OQH5tGKs1wmgDXcuACsT2iRz8uUCITCRAiYh+9XsQA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype)\n`ReturnType<Type>`\n-----------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type consisting of the return type of function `Type`.\n\nFor overloaded functions, this will be the return type of the _last_ signature; see [Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)\n.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-12)\nExample\n\nts\n\n`   declare function f1(): { a: number; b: string };  type T0 = ReturnType<() => string>;         type T0 = string  type T1 = ReturnType<(s: string) => void>;         type T1 = void  type T2 = ReturnType<<T>() => T>;         type T2 = unknown  type T3 = ReturnType<<T extends U, U extends number[]>() => T>;         type T3 = number[]  type T4 = ReturnType<typeof f1>;         type T4 = {     a: number;     b: string; }  type T5 = ReturnType<any>;         type T5 = any  type T6 = ReturnType<never>;         type T6 = never  type T7 = ReturnType<string>;  Type 'string' does not satisfy the constraint '(...args: any) => any'.2344Type 'string' does not satisfy the constraint '(...args: any) => any'.         type T7 = any  type T8 = ReturnType<Function>;  Type 'Function' does not satisfy the constraint '(...args: any) => any'.   Type 'Function' provides no match for the signature '(...args: any): any'.2344Type 'Function' does not satisfy the constraint '(...args: any) => any'.   Type 'Function' provides no match for the signature '(...args: any): any'.         type T8 = any   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsX3awFAAmkAxgDYCG0koAZgK4B2pALgJZxP0CMAFAEpUAb1CVUTBgFsARjADcoGakSto7JgHNQAX3kECrAJ4AHWgBUADKAC8oAEqRWDaE3OnIAHkG2AfKFV1LV99EFBw0AA9AH5DD1BzHlsHJxc3D28UALUNTQE-UAA3OHYiEIIwiJi4swS0ZMdnV3czT09zXx8bfw7QsCrY41rzDAbU5oz20EgAD1ZIJiJEUABVABpV6bmFpdBJWRgAbQBdTvzuhPLK8Oqhi1w7RrSWrzu4Ol4r-pvB+PMAVjGTXSrUoTCMXwiUV+wwAbEDnhkmJBCjBIQMahYAOwIiatQK5dE-TEJAAcuJBXgAYsw2JwmEToUA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype)\n`InstanceType<Type>`\n---------------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#predefined-conditional-types)\n\nConstructs a type consisting of the instance type of a constructor function in `Type`.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-13)\nExample\n\nts\n\n`   class C {    x = 0;    y = 0;  }  type T0 = InstanceType<typeof C>;         type T0 = C  type T1 = InstanceType<any>;         type T1 = any  type T2 = InstanceType<never>;         type T2 = never  type T3 = InstanceType<string>;  Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.2344Type 'string' does not satisfy the constraint 'abstract new (...args: any) => any'.         type T3 = any  type T4 = InstanceType<Function>;  Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.   Type 'Function' provides no match for the signature 'new (...args: any): any'.2344Type 'Function' does not satisfy the constraint 'abstract new (...args: any) => any'.   Type 'Function' provides no match for the signature 'new (...args: any): any'.         type T4 = any   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsX3awFAgSIAu0AlgMamoBmAhgDaKQFVMOKKgDCoAbwKhQAD1ABeUAAYA3MNABPSTPkBfAgVKKADpFAAVaSoCSAOzIMzVSAd2QAPNr1w6fAHzziI0AD0A-Fr2hgCMphakVjZ2eg5Wip5EYD4BQXqGaOGW1rb2DmaQAG4wid4iqc76BhhZkTkxjmSUZgDmpcnlgZWGuFLm2dF5AGIArtakFHBm7T5+-kA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#noinfertype)\n`NoInfer<Type>`\n-----------------------------------------------------------------------------------------------\n\n> Released:  \n> [5.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#the-noinfer-utility-type)\n\nBlocks inferences to the contained type. Other than blocking inferences, `NoInfer<Type>` is identical to `Type`.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-14)\nExample\n\nts\n\n`   function createStreetLight<C extends string>(    colors: C[],    defaultColor?: NoInfer<C>,  ) {    // ...  }  createStreetLight([\"red\", \"yellow\", \"green\"], \"red\");  // OK  createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");  // Error   `\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#thisparametertypetype)\n`ThisParameterType<Type>`\n-------------------------------------------------------------------------------------------------------------------\n\n> Released:  \n> [3.3](https://github.com/microsoft/TypeScript/pull/28920)\n\nExtracts the type of the [this](https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters)\n parameter for a function type, or [unknown](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type)\n if the function type has no `this` parameter.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-15)\nExample\n\nts\n\n`   function toHex(this: Number) {    return this.toString(16);  }  function numberToString(n: ThisParameterType<typeof toHex>) {    return toHex.apply(n);  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFOAJApgDwBRQBYwDOAXIgHIgC2ARugE4CUiA3gFCKJ3pQh1L5EAdCgDKUOjDABzbAEYAbAwDcrAL6tWoSLASIwVWnQAqcMROnYwpIwUIAFAIZ0HlbvSMBPAA7oAPFG90OGBkNCwAPiY2Di4ePlCMTEEHLy8AGw9LZTUgA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#omitthisparametertype)\n`OmitThisParameter<Type>`\n-------------------------------------------------------------------------------------------------------------------\n\n> Released:  \n> [3.3](https://github.com/microsoft/TypeScript/pull/28920)\n\nRemoves the [`this`](https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters)\n parameter from `Type`. If `Type` has no explicitly declared `this` parameter, the result is simply `Type`. Otherwise, a new function type with no `this` parameter is created from `Type`. Generics are erased and only the last overload signature is propagated into the new function type.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-16)\nExample\n\nts\n\n`   function toHex(this: Number) {    return this.toString(16);  }  const fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);  console.log(fiveToHex());   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFOAJApgDwBRQBYwDOAXIgHIgC2ARugE4CUiA3gFCKJ3pQh1L5EAdCgDKUOjDABzbAEYAbAwDcrAL6tWEBISiJgMAG7oAKmiykA8pRhRjBQgAUAhnSeVu9ADxQAngAd0OGBkM0wAPkQAXhCMTEFqSQATbABWZQ0tMEI4ABt0QRy4GX0jU1jsBmUgA)\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#thistypetype)\n`ThisType<Type>`\n-------------------------------------------------------------------------------------------------\n\n> Released:  \n> [2.3](https://github.com/microsoft/TypeScript/pull/14141)\n\nThis utility does not return a transformed type. Instead, it serves as a marker for a contextual [`this`](https://www.typescriptlang.org/docs/handbook/functions.html#this)\n type. Note that the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis)\n flag must be enabled to use this utility.\n\n##### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#example-17)\nExample\n\nts\n\n`   type ObjectDescriptor<D, M> = {    data?: D;    methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M  };  function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {    let data: object = desc.data || {};    let methods: object = desc.methods || {};    return { ...data, ...methods } as D & M;  }  let obj = makeObject({    data: { x: 0, y: 0 },    methods: {      moveBy(dx: number, dy: number) {        this.x += dx; // Strongly typed this        this.y += dy; // Strongly typed this      },    },  });  obj.x = 10;  obj.y = 20;  obj.moveBy(5, 5);   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwCoAtUBnALlCwCcBXAUwCgsBPRa0AeQCMAra9LAEWqF05VIizRyAHj4AaUAFkAfKAC8oAN61QoACYBDLHoD8pPgG4toeNSx5oOwiYWgAZKHxEcTatNcLFZqAg7t6g0ABmoADktkRRoKiQVjZ2DgmEoHx+8rQAvha04ZSQvKjQSfB6ANbUHNy80nJKABQ6guikdTz87SJiEo3+AJSm2RqWyDa6Bnqk0FzdqrrtAHT6hqAAPpsa+RNT1rb2JGELvEttQiuHqRnbuxba5DaU5EnqoCtf63pyX9cpY6gXKgPQZLJueQWXK0WiTLCnThLSo1Lq8ZqabQ-UgfAAepAADHIGITgTJLDdjjjLNp4NAAG7UABCDFa+NAkEo8HY1HIch0JI5XJ55CG420ErIBEIK1xoAA1GodLjAsEAMoUcoAc2QDDI3h0UqINIlsRlesVugYqrAGvI2t1+uYhrNJty5O07ryQwK804sqWAEYCRY-Ss9WoAEwh2hhumMlnNACsciTPqAA)\n\nIn the example above, the `methods` object in the argument to `makeObject` has a contextual type that includes `ThisType<D & M>` and therefore the type of [this](https://www.typescriptlang.org/docs/handbook/functions.html#this)\n in methods within the `methods` object is `{ x: number, y: number } & { moveBy(dx: number, dy: number): void }`. Notice how the type of the `methods` property simultaneously is an inference target and a source for the `this` type in methods.\n\nThe `ThisType<T>` marker interface is simply an empty interface declared in `lib.d.ts`. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.\n\n[](https://www.typescriptlang.org/docs/handbook/utility-types.html#intrinsic-string-manipulation-types)\nIntrinsic String Manipulation Types\n-------------------------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#uppercasestringtype)\n`Uppercase<StringType>`\n\n### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#lowercasestringtype)\n`Lowercase<StringType>`\n\n### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#capitalizestringtype)\n`Capitalize<StringType>`\n\n### [](https://www.typescriptlang.org/docs/handbook/utility-types.html#uncapitalizestringtype)\n`Uncapitalize<StringType>`\n\nTo help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uppercasestringtype)\n documentation.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Utility%20Types.md)\n ❤\n\nContributors to this page:  \n\nC![christian  (54)](https://gravatar.com/avatar/1f58f226873fbbebcb8d4741b56fc99c?s=32&&d=blank)\n\nOT![Orta Therox  (23)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nB![bob1983  (4)](https://gravatar.com/avatar/e0bb00ef33c5e6bb0e870142dab2e933ff59e37a35507771615de059e77e359a?s=32&&d=blank)\n\nJB![Jack Bates  (3)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nHX![Hong Xu  (2)](https://gravatar.com/avatar/7619e02c6acd87bfef3e32a066e4aaf76dd318a03e53233f2988eae0587c829c?s=32&&d=blank)\n\n34+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","ogDescription":"Types which are globally included in TypeScript","title":"TypeScript: Documentation - Utility Types","language":"en","description":"Types which are globally included in TypeScript","og:title":"Documentation - Utility Types","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:description":"Types which are globally included in TypeScript","ogTitle":"Documentation - Utility Types","twitter:site":"typescriptlang","generator":"Gatsby 5.13.5","scrapeId":"652eeefe-4660-47c3-9e3e-f57358c3cf8a","sourceURL":"https://www.typescriptlang.org/docs/handbook/utility-types.html","url":"https://www.typescriptlang.org/docs/handbook/utility-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nDecorators\n==========\n\n> NOTE  This document refers to an experimental stage 2 decorators implementation. Stage 3 decorator support is available since Typescript 5.0. See: [Decorators in Typescript 5.0](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators)\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#introduction)\nIntroduction\n------------------------------------------------------------------------------------------\n\nWith the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members.\n\n> Further Reading (stage 2): [A Complete Guide to TypeScript Decorators](https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/)\n\nTo enable experimental support for decorators, you must enable the [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators)\n compiler option either on the command line or in your `tsconfig.json`:\n\n**Command Line**:\n\nshell\n\n`   tsc --target ES5 --experimentalDecorators   `\n\n**tsconfig.json**:\n\n`   {    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"ES5\",      \"[experimentalDecorators](https://www.typescriptlang.org/tsconfig#experimentalDecorators) \": true    }  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#decorators)\nDecorators\n--------------------------------------------------------------------------------------\n\nA _Decorator_ is a special kind of declaration that can be attached to a [class declaration](https://www.typescriptlang.org/docs/handbook/decorators.html#class-decorators)\n, [method](https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators)\n, [accessor](https://www.typescriptlang.org/docs/handbook/decorators.html#accessor-decorators)\n, [property](https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators)\n, or [parameter](https://www.typescriptlang.org/docs/handbook/decorators.html#parameter-decorators)\n. Decorators use the form `@expression`, where `expression` must evaluate to a function that will be called at runtime with information about the decorated declaration.\n\nFor example, given the decorator `@sealed` we might write the `sealed` function as follows:\n\nts\n\n`   function sealed(target) {    // do something with 'target' ...  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)\nDecorator Factories\n--------------------------------------------------------------------------------------------------------\n\nIf we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A _Decorator Factory_ is simply a function that returns the expression that will be called by the decorator at runtime.\n\nWe can write a decorator factory in the following fashion:\n\nts\n\n`   function color(value: string) {    // this is the decorator factory, it sets up    // the returned decorator function    return function (target) {      // this is the decorator      // do something with 'target' and 'value'...    };  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-composition)\nDecorator Composition\n------------------------------------------------------------------------------------------------------------\n\nMultiple decorators can be applied to a declaration, for example on a single line:\n\nts\n\n`   @f @g x   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIE6JAoggtTQGYCu6RmSJdKA4AKAJSgA3gF9OPPgKEBzcVNn0AtFqJdMWjTXAcIS0NCA)\n\nOn multiple lines:\n\nts\n\n`   @f  @g  x   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIE6JAoggtTQGYCu6RmSJdKA4AKAJSgA3gF9OPPgKEBzcVNn0AtFqJdMWjTXAdDSmtCA)\n\nWhen multiple decorators apply to a single declaration, their evaluation is similar to [function composition in mathematics](https://wikipedia.org/wiki/Function_composition)\n. In this model, when composing functions _f_ and _g_, the resulting composite (_f_ ∘ _g_)(_x_) is equivalent to _f_(_g_(_x_)).\n\nAs such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:\n\n1.  The expressions for each decorator are evaluated top-to-bottom.\n2.  The results are then called as functions from bottom-to-top.\n\nIf we were to use [decorator factories](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)\n, we can observe this evaluation order with the following example:\n\nts\n\n`   function first() {    console.log(\"first(): factory evaluated\");    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {      console.log(\"first(): called\");    };  }  function second() {    console.log(\"second(): factory evaluated\");    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {      console.log(\"second(): called\");    };  }  class ExampleClass {    @first()    @second()    method() {}  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqh1IJWYAUASlABvGqFCl0VErkgA6XCQDmfAERce-AQC5O2FmQCeoSADc8DCpAAmqgQG4xoBJEwMEHRs1btQfHAhKrrrY6IYANKCwCCTwCJiGANKQhrq8yOhKkdaQVETIsJQIugAKMXEJhHkFRUKi4uKS0rIKymoavIK6RHiytg5OAL6OgzT0TCxsHFTE7NaCIk5NMvKKKqozkvM6egYIxmYWVv2O4i5uHpwTPhz+2IHBoKERUeWICcmpoOlImdm5+SQhTIpTe8UMVUBwIQdScjXYzVWbQ2s3Q226vRsdlOoGGNFGNCIuGwVCooAAotBsChYLIAMLE0mLcTgDpaJzgTZzQRONCYAAWJG2IlGgyAA)\n\nWhich would print this output to the console:\n\nshell\n\n`   first(): factory evaluated  second(): factory evaluated  second(): called  first(): called   `\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-evaluation)\nDecorator Evaluation\n----------------------------------------------------------------------------------------------------------\n\nThere is a well defined order to how decorators applied to various declarations inside of a class are applied:\n\n1.  _Parameter Decorators_, followed by _Method_, _Accessor_, or _Property Decorators_ are applied for each instance member.\n2.  _Parameter Decorators_, followed by _Method_, _Accessor_, or _Property Decorators_ are applied for each static member.\n3.  _Parameter Decorators_ are applied for the constructor.\n4.  _Class Decorators_ are applied for the class.\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#class-decorators)\nClass Decorators\n--------------------------------------------------------------------------------------------------\n\nA _Class Decorator_ is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a `declare` class).\n\nThe expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.\n\nIf the class decorator returns a value, it will replace the class declaration with the provided constructor function.\n\n> NOTE  Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will **not** do this for you.\n\nThe following is an example of a class decorator (`@sealed`) applied to a `BugReport` class:\n\nts\n\n`   @sealed  class BugReport {    type = \"report\";    title: string;    constructor(t: string) {      this.title = t;    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqhWR6QAmAFKXRVMCBizIAuUADEmLNugCUoAN41QoAPIAjAFbFMAOi55B7EWIkIlAbg3b9hk91znho8ZQRHYCEpSYAJ7wdjQAvjQgoAC0cUQMmHExNOCmuHw0RLjYVFSgAEIMAOYASpCwZJhqDsHwoAC8oABECBVVzfaarJgZ0pZI6MX2DkKWXmT8mP2ig8Uq6prdABZIVEY9GY2gmF2gkeFAA)\n\nWe can define the `@sealed` decorator using the following function declaration:\n\nts\n\n`   function sealed(constructor: Function) {    Object.seal(constructor);    Object.seal(constructor.prototype);  }   `\n\nWhen `@sealed` is executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessing `BugReport.prototype` or by defining properties on `BugReport` itself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator does **not** prevent classes from sub-classing `BugReport`.\n\nNext we have an example of how to override the constructor to set new defaults.\n\nts\n\n``  function reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {    return class extends constructor {      reportingURL = \"http://www...\";    };  }  @reportableClassDecorator  class BugReport {    type = \"report\";    title: string;    constructor(t: string) {      this.title = t;    }  }  const bug = new BugReport(\"Needs dark mode\");  console.log(bug.title); // Prints \"Needs dark mode\"  console.log(bug.type); // Prints \"report\"  // Note that the decorator _does not_ change the TypeScript type  // and so the new property `reportingURL` is not known  // to the type system:  bug.reportingURL;  Property 'reportingURL' does not exist on type 'BugReport'.2339Property 'reportingURL' does not exist on type 'BugReport'.``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQIJIAPABxgEsBbSAOwBcBDAGwBFIBjBBuhRXAMwCuNdnXJwaoaJBIJGAIyaQAwkwaJEbTtG4IAPABVQxOrQAmiUAG9QNSAHdQACgB0bhtADmKUAxoBPAG0AXQBKVCsAX1BIgD4nThpEOmhBUQRUA1DrXFApSDpBaEl2NQ1jIlMaC1BE5NT06By8vOlZaDEaTwBVACUAGVAAXlAAIgALOjoSZBB7ebcXUYBuXJjVyNxccDa5BkUVMs0OLh5oXFL1SwAhQU9emTlm0Dp-MmGx3Y6VtbE6JVQ9XIXVWazqKTSZycdEBKWBnmyVjWeTo43IiBcfyUHzoqzym02FwkyVA8juHzsjlu90eHScowAcpBIDUzB4ANagShwMyQUahVZ1OBKFxMOCeJxkzyY8j-SAC0AEAAK0GBdEsjOZrI5XJ5fKJSWFkFF4sld0xb3ly0VYBVao1Xzooy2BAZcFML3G3E9kFAvO0uiaAH0zHBIJYaO6g7UvV1fajfQZLQBldiqkh0F6W-BgPxmUCIOA+2wOUAkeBkDr+UAAA0d8L6-RroHRtndoHZkfsNBzLyLCaz70Q-mSkEoyFwUpc9a6jeWQA)\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators)\nMethod Decorators\n----------------------------------------------------------------------------------------------------\n\nA _Method Decorator_ is declared just before a method declaration. The decorator is applied to the _Property Descriptor_ for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the method decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The _Property Descriptor_ for the member.\n\n> NOTE  The _Property Descriptor_ will be `undefined` if your script target is less than `ES5`.\n\nIf the method decorator returns a value, it will be used as the _Property Descriptor_ for the method.\n\n> NOTE  The return value is ignored if your script target is less than `ES5`.\n\nThe following is an example of a method decorator (`@enumerable`) applied to a method on the `Greeter` class:\n\nts\n\n`   class Greeter {    greeting: string;    constructor(message: string) {      this.greeting = message;    }    @enumerable(false)    greet() {      return \"Hello, \" + this.greeting;    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgYNrkBGukABQA3PA0gAuULxIkB2dAEpQAbxqhQCSJgYIOjZq3ahBOBAHNtUhQE8ANLAQl4CTDYDSkG1KqZk6czsAE0gqImRYSgQpAAUnFzdCMIio5TUNDRDkpEiyADouHmx+SFAAXlBRXHEAbnVQAF86hpoQUABaTqIGTE72miJcbCoqUABxLW1EVXrzSdYAnz8kALqNUnRfBAYWMkE0EexLJf9zNPqNTAALJCo8uchtFfNy0AOqI8g1xpp6qHRuIhigJBHQ8FRIIpZvNBOcMpptLoOAAiAASkFwuBIdlAyNAAGpQNdbvd5s9vi0GkA)\n\nWe can define the `@enumerable` decorator using the following function declaration:\n\nts\n\n`   function enumerable(value: boolean) {    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {      descriptor.enumerable = value;    };  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUzCAtsgTgQwEYA2yAFAG44EjIBcieccROYAlIgN4BQiiWyUILElCRYCRMSg4sAc361mATwA0iAA5Y4a7FEUBpZItoBnKFhhgZqgCbJjEc2qhwstAAqbtWXQBE7DmCcXNi4eHlt7R2csADpUDGx8IkQAXkRySmQAbm5EAF8cvKA)\n\nThe `@enumerable(false)` decorator here is a [decorator factory](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)\n. When the `@enumerable(false)` decorator is called, it modifies the `enumerable` property of the property descriptor.\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#accessor-decorators)\nAccessor Decorators\n--------------------------------------------------------------------------------------------------------\n\nAn _Accessor Decorator_ is declared just before an accessor declaration. The accessor decorator is applied to the _Property Descriptor_ for the accessor and can be used to observe, modify, or replace an accessor’s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a `declare` class).\n\n> NOTE  TypeScript disallows decorating both the `get` and `set` accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a _Property Descriptor_, which combines both the `get` and `set` accessor, not each declaration separately.\n\nThe expression for the accessor decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The _Property Descriptor_ for the member.\n\n> NOTE  The _Property Descriptor_ will be `undefined` if your script target is less than `ES5`.\n\nIf the accessor decorator returns a value, it will be used as the _Property Descriptor_ for the member.\n\n> NOTE  The return value is ignored if your script target is less than `ES5`.\n\nThe following is an example of an accessor decorator (`@configurable`) applied to a member of the `Point` class:\n\nts\n\n`   class Point {    private _x: number;    private _y: number;    constructor(x: number, y: number) {      this._x = x;      this._y = y;    }    @configurable(false)    get x() {      return this._x;    }    @configurable(false)    get y() {      return this._y;    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqinp1IDmD5AEa5IACgBueBpABcoQSRIjs6AJSgA3jVCgEkTAI6NmrdqFHadoHAl765KgJ4AaSztgIS8BJkcBpSEc5KkxkdF5XK1AAE0gqImRYSgQ5AAVPb19CeMTky3UtKNicpCSyADouHn4hEVAAXlBJXGkAbksAX3aOmhBQAFpBogZMQf6aIlxsKipQVJIkLE1LDyRJTEhQAH1oOXQGFEFEdvdkdc2toNB9w+PLLhCEBhYyUV3rg6OEZ1Arm6+Cm5rAALJBUco7BqgaAnKyYUHgy5QxywnqWcBVPgCbDCMR0PBUSCqSx2TDQ0SAqJ6AwIDjwsEQmGdGjozE1HEiUT43CE4k6Um-CnLKn6QwghmXVE0DpAA)\n\nWe can define the `@configurable` decorator using the following function declaration:\n\nts\n\n`   function configurable(value: boolean) {    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {      descriptor.configurable = value;    };  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators)\nProperty Decorators\n--------------------------------------------------------------------------------------------------------\n\nA _Property Decorator_ is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the property decorator will be called as a function at runtime, with the following two arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n\n> NOTE  A _Property Descriptor_ is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.\n\nWe can use this information to record metadata about the property, as in the following example:\n\nts\n\n`   class Greeter {    @format(\"Hello, %s\")    greeting: string;    constructor(message: string) {      this.greeting = message;    }    greet() {      let formatString = getFormat(this, \"greeting\");      return formatString.replace(\"%s\", this.greeting);    }  }   `\n\nWe can then define the `@format` decorator and `getFormat` functions using the following function declarations:\n\nts\n\n`   import \"reflect-metadata\";  const formatMetadataKey = Symbol(\"format\");  function format(formatString: string) {    return Reflect.metadata(formatMetadataKey, formatString);  }  function getFormat(target: any, propertyKey: string) {    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);  }   `\n\nThe `@format(\"Hello, %s\")` decorator here is a [decorator factory](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)\n. When `@format(\"Hello, %s\")` is called, it adds a metadata entry for the property using the `Reflect.metadata` function from the `reflect-metadata` library. When `getFormat` is called, it reads the metadata value for the format.\n\n> NOTE  This example requires the `reflect-metadata` library. See [Metadata](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata)\n>  for more information about the `reflect-metadata` library.\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#parameter-decorators)\nParameter Decorators\n----------------------------------------------------------------------------------------------------------\n\nA _Parameter Decorator_ is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a `declare` class).\n\nThe expression for the parameter decorator will be called as a function at runtime, with the following three arguments:\n\n1.  Either the constructor function of the class for a static member, or the prototype of the class for an instance member.\n2.  The name of the member.\n3.  The ordinal index of the parameter in the function’s parameter list.\n\n> NOTE  A parameter decorator can only be used to observe that a parameter has been declared on a method.\n\nThe return value of the parameter decorator is ignored.\n\nThe following is an example of a parameter decorator (`@required`) applied to parameter of a member of the `BugReport` class:\n\nts\n\n``   class BugReport {    type = \"report\";    title: string;    constructor(t: string) {      this.title = t;    }    @validate    print(@required verbose: boolean) {      if (verbose) {        return `type: ${this.type}\\ntitle: ${this.title}`;      } else {       return this.title;       }    }  }   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQAZgK7pGZInqgBueSAJhZAAUOBAHNImAFyhs6AJ4AaULAQl4CTHIBy2NNKqZk6UUt6QqRZLEoJpAFTnxeABVXrNhC1ZsAeWXIA+AEpQAG8AX3omFjYOBEgARwYkeN5hbDEJaQB5ACMAK2JMJRU1RE0AaUg5fUMkY1AAH1AqORRcklwSjN0JRABJdDNoaXQGdsQQiJoQUABaBaIGTAW5miJcbCoqUAAhBlEAJUhYMkwwmlBQTXhQAF5QACJ4041HgG5L66RMXEhaoyiT5fUjoAwIBgsMjCAH1URTL5XTAACyQVAAdKxfpB7tdPldIl9wNxcHwBF8VPVMIJwPEkilILwuIgOlR-qAOp1ILIEVcrkg6KBBJwWSQ2by+Vd4pgGAgOAADG7sgAkoRRaMxjkg4QAOlgfn9pKr1RisX9wvL8XzwqBILg2RdJaBpbKOCbMQbIO9QIjQJECTRwkA)\n\nWe can then define the `@required` and `@validate` decorators using the following function declarations:\n\nts\n\n`   import \"reflect-metadata\";  const requiredMetadataKey = Symbol(\"required\");  function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {    let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];    existingRequiredParameters.push(parameterIndex);    Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);  }  function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {    let method = descriptor.value!;    descriptor.value = function () {      let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);      if (requiredParameters) {        for (let parameterIndex of requiredParameters) {          if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {            throw new Error(\"Missing required argument.\");          }        }      }      return method.apply(this, arguments);    };  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEkKSmhp5lCAspDgCYXYaqWGUygARAkgAzXMUwBaNHwHiA3DVLoqYqQEcArkim9uKnAGlIAT1ABeUAGVrKAEYlcACkmRDxyLziAJQaNNIG6ESYSCTooPpGJp44CADmPABcoADyrgBW8gA0oLAIJPAImNZW1lk6yOipoAA+oFQu7rjFsNjkyogAkui8MFnoBm6IQaAA3jSgoHJiMEg6SI0ASr6JAQAKvdj9CFRjE66IANoAuvagW7LyAHTpmNkA7uhm2Pw4ngn+ph43wENWKKRe3TKFSqNWmzVa1w0CxWa022wB+z6PEQVEesAMVAAFp4eljMINhjAQvM7jI5FFHiNpOtIF8fthPPF0SY2SCbMUUdE0X4TJjDtjjmDehCSlDEDCbNSAL40MIRKIxOIANzwSB+kGS0syoGw6GskPK8usADlxXVMA1UsURlQiMhYBwsgAVazwXi7OWVayEV3ujgAHgAYurorEAHzTOYLJagZSEki8W4ut1ID1kR463AGSAAQlCC2zYfzheLt3CkVjcU8iZpyZ4XJFewORxOoHGkwQ11u93pmGePHenyB7L+3ICvMs-NA4J4FuhNvF1IWCyQ0lAs87-u7EqoLe32+kZH3KdJ4vJCCGI2goBIe-+ouP99Ps1b59Au-3W8jkfGBQDjBxpQmDBMFxORGkwQkWlaSC0CwKgLiAiUQOgG47Dw0AIiZFleDPP9zwQso3j7SAqIAUQQMoEG8ThViodYmnfAITTSKCsEeYIkTI0AVTIkTtzEhYpEwAwEDiNMM0ebBYFgXBrGSQlVmKFDoNPQSlQ0JUgA)\n\nThe `@required` decorator adds a metadata entry that marks the parameter as required. The `@validate` decorator then wraps the existing `print` method in a function that validates the arguments before invoking the original method.\n\n> NOTE  This example requires the `reflect-metadata` library. See [Metadata](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata)\n>  for more information about the `reflect-metadata` library.\n\n[](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata)\nMetadata\n----------------------------------------------------------------------------------\n\nSome examples use the `reflect-metadata` library which adds a polyfill for an [experimental metadata API](https://github.com/rbuckton/ReflectDecorators)\n. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.\n\nYou can install this library via npm:\n\nshell\n\n`   npm i reflect-metadata --save   `\n\nTypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the [`emitDecoratorMetadata`](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata)\n compiler option either on the command line or in your `tsconfig.json`:\n\n**Command Line**:\n\nshell\n\n`   tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata   `\n\n**tsconfig.json**:\n\n`   {    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"ES5\",      \"[experimentalDecorators](https://www.typescriptlang.org/tsconfig#experimentalDecorators) \": true,      \"[emitDecoratorMetadata](https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata) \": true    }  }   `\n\nWhen enabled, as long as the `reflect-metadata` library has been imported, additional design-time type information will be exposed at runtime.\n\nWe can see this in action in the following example:\n\nts\n\n``import \"reflect-metadata\";  class Point {    constructor(public x: number, public y: number) {}  }  class Line {    private _start: Point;    private _end: Point;    @validate    set start(value: Point) {      this._start = value;    }    get start() {      return this._start;    }    @validate    set end(value: Point) {      this._end = value;    }    get end() {      return this._end;    }  }  function validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {    let set = descriptor.set!;    descriptor.set = function (value: T) {      let type = Reflect.getMetadata(\"design:type\", target, propertyKey);      if (!(value instanceof type)) {        throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);      }      set.call(this, value);    };  }  const line = new Line()  line.start = new Point(0, 0)  // @ts-ignore  // line.end = {}  // Fails at runtime with:  // > Invalid type, got object not Point`` [Try](https://www.typescriptlang.org/play/#code/PTAEAEFMFsEsBcAikDGB7ATgQ3pgspPFgCY5YBQIEkAHgA6QazSQB2RANsutrhgM6Uw4fvCYp4ABQxoGGeAE8AkqwSwsHWAC8csNKwBcoAGYb+kcszqZ4oAEQZIxjqngBaFkVJE7AbnLkKBxY-Pygkmiw7KAA3uSgoOisohgArhKYABR0qQBGmiigNEasqdC5jAA0oDn5sIUKJWUVGACUsQC+5F2BwaGgADJRkLHxNUwAbjgjAPqiWPJGEVHw-gl0k9OgM2zES5Hs-mPgU5reFgnmtvPymaepkPsr7XEJCfAAFrD8AHRzRPJQABeUD3SBrUA9BIAc0IoBu8EyLzGCUc8FSGFYoE+3z+CIhUIgp1g5zGV1AuzuGgeT3YyLe2K+vx2rGIwNB1PBY0JsNslPpbzRGKxOOZuwJ3QCxlSrAkeixxPOAB4ACoAPkyAN5RiwrAU1Q2skYigA0pBGvCxFFodViJB+CgmHQ+EYVQoGMRpEb5ApkA6nXxVWqBS5rnCQXb-bBnZgflcAIQQsaRx3Rvhx8MmGVy-SgKkcGmgFUChKh7HukYggBKThcEh+vIIXjImTskdg0MMigYdmqWsIBpkclN5taRwZsGMefj+YeoCi81lkDQU+7kFaJbenxkAHdQKxIHu3QwAKIYGQYTIAAxUivLDGq0LQtgAJDE1yuOQXIB198-QG+a4-KwWAsB0PxXmOKKQgEDJXD8KAaBwmpMtUYJQQkHT+D0SSiKAmgHuyB57kMB5IuQBGQHGAK2CCxHhAciIAAzVExrQBFQ4DwPwbgdqwmAWFQlE-Ls7IxD0VAAGJYLAHBhDgoBpOwzAjDuCAfAYQigGqoC3hoJL3pAj7-mguQAFauH+tjLOw5BAA)\n\nThe TypeScript compiler will inject design-time type information using the `@Reflect.metadata` decorator. You could consider it the equivalent of the following TypeScript:\n\nts\n\n`   class Line {    private _start: Point;    private _end: Point;    @validate    @Reflect.metadata(\"design:type\", Point)    set start(value: Point) {      this._start = value;    }    get start() {      return this._start;    }    @validate    @Reflect.metadata(\"design:type\", Point)    set end(value: Point) {      this._end = value;    }    get end() {      return this._end;    }  }   `\n\n> NOTE  Decorator metadata is an experimental feature and may introduce breaking changes in future releases.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Decorators.md)\n ❤\n\nContributors to this page:  \n\nRB![Ron Buckton  (54)](https://gravatar.com/avatar/745f702d55c379fb824f5a03e0651e78?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nMH![Mohamed Hegazy  (3)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nDR![Dinanjanan Ravindran  (2)](https://gravatar.com/avatar/0e5a4755309012c3e0a470b8f441ba5d90a5556b96ab8ddd5c76c40e7c0bc9d0?s=32&&d=blank)\n\nHA![Hossein Ahmadian-Yazdi  (2)](https://gravatar.com/avatar/badbb0b7582edd51c9ff8e37038becd49986e1af6f1c5dbf200eddbc20d1da7e?s=32&&d=blank)\n\n22+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:title":"Documentation - Decorators","language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","twitter:site":"typescriptlang","ogDescription":"TypeScript Decorators overview","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:description":"TypeScript Decorators overview","description":"TypeScript Decorators overview","ogTitle":"Documentation - Decorators","theme-color":"#3178C6","title":"TypeScript: Documentation - Decorators","scrapeId":"2a11d5f8-9d90-4926-9f1a-e5f7bf12e48b","sourceURL":"https://www.typescriptlang.org/docs/handbook/decorators.html","url":"https://www.typescriptlang.org/docs/handbook/decorators.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nEnums\n=====\n\nEnums are one of the few features TypeScript has which is not a type-level extension of JavaScript.\n\nEnums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.\n\n[](https://www.typescriptlang.org/docs/handbook/enums.html#numeric-enums)\nNumeric enums\n---------------------------------------------------------------------------------------\n\nWe’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages. An enum can be defined using the `enum` keyword.\n\nts\n\n`   enum Direction {    Up = 1,    Down,    Left,    Right,  }   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQCMANAbBgO4h2EAywAZqq1AEpwA5gAseeAL5A)\n\nAbove, we have a numeric enum where `Up` is initialized with `1`. All of the following members are auto-incremented from that point on. In other words, `Direction.Up` has the value `1`, `Down` has `2`, `Left` has `3`, and `Right` has `4`.\n\nIf we wanted, we could leave off the initializers entirely:\n\nts\n\n`   enum Direction {    Up,    Down,    Left,    Right,  }   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADgDQGwYDuIFhAMsAGar1QBKcA5gBZt4AvkA)\n\nHere, `Up` would have the value `0`, `Down` would have `1`, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.\n\nUsing an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:\n\nts\n\n`   enum UserResponse {    No = 0,    Yes = 1,  }  function respond(recipient: string, message: UserResponse): void {    // ...  }  respond(\"Princess Caroline\", UserResponse.Yes);   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAqgzsATgJWHADgexAqBvAKCigDlMoBeKABgBoioBNNSqARnoF8CCAzMEAGMALgEtsURGiwgAJgAopg0elGhhALihxhiUSADmtKBDRwAhgeBb4SVBmwIAlFoBumUbPwMA9D6gAdEEE3ARSDnLyAEQACnpCZlAAwuaImAA2+sBRxrYo0o7AAcxwTgDcQA)\n\nNumeric enums can be mixed in [computed and constant members (see below)](https://www.typescriptlang.org/docs/handbook/enums.html#computed-and-constant-members)\n. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn’t allowed:\n\nts\n\n`   enum E {    A = getSomeValue(),    B,  Enum member must have initializer.1061Enum member must have initializer.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYBsaBQBjOAO0QBdQBzSUgZTgFtIA1AQwBsBXSUAXlAAoAlLwB8oAEwBmANy4QoALRL8HUkoW5IRDvVABRUAG9coUAEFelanUatOkIQBoToAELOAvkA)\n\n[](https://www.typescriptlang.org/docs/handbook/enums.html#string-enums)\nString enums\n-------------------------------------------------------------------------------------\n\nString enums are a similar concept, but have some subtle [runtime differences](https://www.typescriptlang.org/docs/handbook/enums.html#enums-at-runtime)\n as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.\n\nts\n\n`   enum Direction {    Up = \"UP\",    Down = \"DOWN\",    Left = \"LEFT\",    Right = \"RIGHT\",  }   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQBERAClQDQGwYDu2lVMA8gOoByjZgBlgAM1QVqwgKIAxACpDCAJTgBzABaTOKgJIBxABJKmAXyA)\n\nWhile string enums don’t have auto-incrementing behavior, string enums have the benefit that they “serialize” well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn’t convey any useful meaning on its own (though [reverse mapping](https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings)\n can often help). String enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.\n\n[](https://www.typescriptlang.org/docs/handbook/enums.html#heterogeneous-enums)\nHeterogeneous enums\n---------------------------------------------------------------------------------------------------\n\nTechnically enums can be mixed with string and numeric members, but it’s not clear why you would ever want to do so:\n\nts\n\n`   enum BooleanLikeHeterogeneousEnum {    No = 0,    Yes = \"YES\",  }   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAQg9nANsAhiAMgSwNbABLAAuwATnAOajBxgDOAouNAN4BQUUAcnFALxQAGADTsoATWC0+UAERj6AZRkiAvkA)\n\nUnless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this.\n\n[](https://www.typescriptlang.org/docs/handbook/enums.html#computed-and-constant-members)\nComputed and constant members\n-----------------------------------------------------------------------------------------------------------------------\n\nEach enum member has a value associated with it which can be either _constant_ or _computed_. An enum member is considered constant if:\n\n*   It is the first member in the enum and it has no initializer, in which case it’s assigned the value `0`:\n    \n    ts\n    \n    `   // E.X is constant:  enum E {    X,  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEFEDoA1QSwM6gMYHsB2CAuBDdWAuAKAFN0BXAWwlAG8jRRoAaIgXyA)\n    \n*   It does not have an initializer and the preceding enum member was a _numeric_ constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.\n    \n    ts\n    \n    `   // All enum members in 'E1' and 'E2' are constant.  enum E1 {    X,    Y,    Z,  }  enum E2 {    A = 1,    B,    C,  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEEEBtNBTA7ArgW1M2yBGsBOBnUAS3lAHIBRARlNAEN4ATM8gJhtp1lAGMB7ePABd6ggHQAocQhSgqoAN7jQoABoAaJaACaG5QC0NAX0nTUrBZvCgAvKEq7QAIQcBhI0A)\n    \n*   The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:\n    \n    1.  a literal enum expression (basically a string literal or a numeric literal)\n    2.  a reference to previously defined constant enum member (which can originate from a different enum)\n    3.  a parenthesized constant enum expression\n    4.  one of the `+`, `-`, `~` unary operators applied to constant enum expression\n    5.  `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` binary operators with constant enum expressions as operands\n    \n    It is a compile time error for constant enum expressions to be evaluated to `NaN` or `Infinity`.\n    \n\nIn all other cases enum member is considered computed.\n\nts\n\n`   enum FileAccess {    // constant members    None,    Read = 1 << 1,    Write = 1 << 2,    ReadWrite = Read | Write,    // computed member    G = \"123\".length,  }   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAYglgG2AQQMauAZ01A3gKCigHpipUB7ETAFwEMQaoJgIAjYAJ00KgDkqwADS8ASsDoATKAF4oARigAeJQpFEA6pzg1gshctUAmdVHFStOvXPPSAPlEu7TpchQgAHMLukt2XXgBxfQAieSMAZhCAOiQQAHMaAAsRAF8gA)\n\n[](https://www.typescriptlang.org/docs/handbook/enums.html#union-enums-and-enum-member-types)\nUnion enums and enum member types\n-------------------------------------------------------------------------------------------------------------------------------\n\nThere is a special subset of constant enum members that aren’t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to\n\n*   any string literal (e.g. `\"foo\"`, `\"bar\"`, `\"baz\"`)\n*   any numeric literal (e.g. `1`, `100`)\n*   a unary minus applied to any numeric literal (e.g. `-1`, `-100`)\n\nWhen all members in an enum have literal enum values, some special semantics come into play.\n\nThe first is that enum members also become types as well! For example, we can say that certain members can _only_ have the value of an enum member:\n\nts\n\n`   enum ShapeKind {    Circle,    Square,  }  interface Circle {    kind: ShapeKind.Circle;    radius: number;  }  interface Square {    kind: ShapeKind.Square;    sideLength: number;  }  let c: Circle = {    kind: ShapeKind.Square,  Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.2322Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.    radius: 100,  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFCQHYCuAtqAMoAWAhgA6QDSAlvgCagDeOooAwo9AGMANpAA0XcgEdCVaGJwBfHDmYAXGADMqAyL37DdnbgGtmLVJVoMzAOj6CRAbgnQqLRoRSgixAEYxnJRV8dWgtHSkZOQ4JU1YLajomVhsyaVlIZ25ERhZIABkCAHNVClQff2hA5RFVUAFUewNQAF4YkzMEq2SWVPS5cW5Xd09UAEYABgnxBUcgA)\n\nThe other change is that enum types themselves effectively become a _union_ of each enum member. With union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch bugs where we might be comparing values incorrectly. For example:\n\nts\n\n`   enum E {    Foo,    Bar,  }  function f(x: E) {    if (x !== E.Foo || x !== E.Bar) {  This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.2367This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.      //    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUJAHYCuAtqAKKgDeeooAYnHADR2gBCAhtGwL548AM2KEAxgBcAlnEKghACgAeqCgEoa7KUNDLQAQgC8hygDomcUAB8roJQeNnu0DbXr0Q7AXyA)\n\nIn that example, we first checked whether `x` was _not_ `E.Foo`. If that check succeeds, then our `||` will short-circuit, and the body of the ‘if’ will run. However, if the check didn’t succeed, then `x` can _only_ be `E.Foo`, so it doesn’t make sense to see whether it’s _not_ equal to `E.Bar`.\n\n[](https://www.typescriptlang.org/docs/handbook/enums.html#enums-at-runtime)\nEnums at runtime\n---------------------------------------------------------------------------------------------\n\nEnums are real objects that exist at runtime. For example, the following enum\n\nts\n\n`   enum E {    X,    Y,    Z,  }   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfIA)\n\ncan actually be passed around to functions\n\nts\n\n`   enum E {    X,    Y,    Z,  }  function f(obj: { X: number }) {    return obj.X;  }  // Works, since 'E' has a property named 'X' which is a number.  f(E);   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfRRAMzBAGMAXASwHsQoyAKBgIwCsAuBNPuAgdgAJyhEAlAiyjgNMKOacuAOlQBuRCUQB6XVADqDUQGsAzuijm61YFADkMB1AAWAQ3NR3UAA6iGXzEaAE8oEHcIYAATR1QXAHdXOipXKDovHyERUVVyVhhJDSA)\n\n[](https://www.typescriptlang.org/docs/handbook/enums.html#enums-at-compile-time)\nEnums at compile time\n-------------------------------------------------------------------------------------------------------\n\nEven though Enums are real objects that exist at runtime, the `keyof` keyword works differently than you might expect for typical objects. Instead, use `keyof typeof` to get a Type that represents all Enum keys as strings.\n\nts\n\n`   enum LogLevel {    ERROR,    WARN,    INFO,    DEBUG,  }  /**   * This is equivalent to:   * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';   */  type LogLevelStrings = keyof typeof LogLevel;  function printImportant(key: LogLevelStrings, message: string) {    const num = LogLevel[key];    if (num <= LogLevel.WARN) {      console.log(\"Log level key is:\", key);      console.log(\"Log level value is:\", num);      console.log(\"Log level message is:\", message);    }  }  printImportant(\"ERROR\", \"This is a message\");   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAMg9gcxsAbsANlA3gKClAUQCUiB5IgGjygHUBBIgOSvwElGAxUlqAEQIBCAVQDiVAL44cAegBUsvLKgAVABYBLAM5QtUYAEcw6lAEN0oAC5QLcAFyLrATwAOwWImRp0AZQsAndRAEbQBeKAByYjIicKgAHwj6JliE8PYuFIj+YRFwgG5FaRwLFzd4JFQMXwCg0KgAa2BHOAAzJ1dW9wqvApwWsBAAYwt1OBAoZxqLVghnOD8LExALAApGx1suzyr-QOCKKAhgTU0TBGBNzV2ggEpsakGxq6hwaDDy7fQAbXWAXQL8Oo2itXlAADzvDyVdAAOiSjDuuHw+EeIE0cHMMPQiBWACJylBzF4Gk0dJpbLiDusbgDkaj0ZjsQg8QSiRgoKZ0GA3FoKQdXjTqCinhjgFicfjEIToYdjqdzmS+bKTmdgIL8JJJJNAtNZvNFss8VFyJSoLi1LpdCZlfLgLiaUA)\n\n### [](https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings)\nReverse mappings\n\nIn addition to creating an object with property names for members, numeric enums members also get a _reverse mapping_ from enum values to enum names. For example, in this example:\n\nts\n\n`   enum Enum {    A,  }  let a = Enum.A;  let nameOfA = Enum[a]; // \"A\"   `[Try](https://www.typescriptlang.org/play/#code/KYOwrgtgBAou0G8BQUoEEA0SC+SkBtgAXKAQygF5Z4A6NAbgOKhFImAHkAzNS6yANqkAuvSgB6cVABEaaUA)\n\nTypeScript compiles this down to the following JavaScript:\n\nts\n\n`\"use strict\";  var Enum;  (function (Enum) {      Enum[Enum[\"A\"] = 0] = \"A\";  })(Enum || (Enum = {}));  let a = Enum.A;  let nameOfA = Enum[a]; // \"A\"` [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAFMB2BXZURAogb01FAEEAaTAX00wBtt1QBDUAXmNIB01ANyt2oXJ2TYA8gDNqvfoQDanALrDQIUACJquoA)\n\nIn this generated code, an enum is compiled into an object that stores both forward (`name` -> `value`) and reverse (`value` -> `name`) mappings. References to other enum members are always emitted as property accesses and never inlined.\n\nKeep in mind that string enum members _do not_ get a reverse mapping generated at all.\n\n### [](https://www.typescriptlang.org/docs/handbook/enums.html#const-enums)\n`const` enums\n\nIn most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use `const` enums. Const enums are defined using the `const` modifier on our enums:\n\nts\n\n`   const enum Enum {    A = 1,    B = A * 2,  }   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUSag3gKBjAQRgF4YBGAGjxgCETCYAqGAJioF8g)\n\nConst enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.\n\nts\n\n`   const enum Direction {    Up,    Down,    Left,    Right,  }  let directions = [    Direction.Up,    Direction.Down,    Direction.Left,    Direction.Right,  ];   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgEQJYCc7Ch8GAbwCgYYBVABwBoz0QB3MO8gGTgDMpWYAlDAHMAFjxIBfEiQA2cWABNsufOAgwAvDADa9TDjwEwAOmq89yw0bRMWupQfBGO3M-ZXGBIsQF0A3EA)\n\nin generated code will become\n\nts\n\n`\"use strict\";  let directions = [      0 /* Direction.Up */,      1 /* Direction.Down */,      2 /* Direction.Left */,      3 /* Direction.Right */,  ];` [Try](https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1QBTPAV2VABFUAnY7dVfUAb01FAFUAHAGg7UEeAZwAyxAGbpRoAEqoA5tBmYAvpkwAbYkQAmdBk3yRQAXlABtQTXqNmeAHS9Ztow8dVhrw-fyOJaR87YycFZVUAXQBuIA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/enums.html#const-enum-pitfalls)\nConst enum pitfalls\n\nInlining enum values is straightforward at first, but comes with subtle implications. These pitfalls pertain to _ambient_ const enums only (basically const enums in `.d.ts` files) and sharing them between projects, but if you are publishing or consuming `.d.ts` files, these pitfalls likely apply to you, because `tsc --declaration` transforms `.ts` files into `.d.ts` files.\n\n1.  For the reasons laid out in the [`isolatedModules` documentation](https://www.typescriptlang.org/tsconfig#references-to-const-enum-members)\n    , that mode is fundamentally incompatible with ambient const enums. This means if you publish ambient const enums, downstream consumers will not be able to use [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules)\n     and those enum values at the same time.\n2.  You can easily inline values from version A of a dependency at compile time, and import version B at runtime. Version A and B’s enums can have different values, if you are not very careful, resulting in [surprising bugs](https://github.com/microsoft/TypeScript/issues/5219#issue-110947903)\n    , like taking the wrong branches of `if` statements. These bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.\n3.  [`importsNotUsedAsValues: \"preserve\"`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)\n     will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime `.js` files exist. The unresolvable imports cause errors at runtime. The usual way to unambiguously elide imports, [type-only imports](https://www.typescriptlang.org/docs/handbook/modules/reference.html#type-only-imports-and-exports)\n    , [does not allow const enum values](https://github.com/microsoft/TypeScript/issues/40344)\n    , currently.\n\nHere are two approaches to avoiding these pitfalls:\n\n1.  Do not use const enums at all. You can easily [ban const enums](https://typescript-eslint.io/linting/troubleshooting#how-can-i-ban-specific-language-feature)\n     with the help of a linter. Obviously this avoids any issues with const enums, but prevents your project from inlining its own enums. Unlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications.\n    \n2.  Do not publish ambient const enums, by deconstifying them with the help of [`preserveConstEnums`](https://www.typescriptlang.org/tsconfig#preserveConstEnums)\n    . This is the approach taken internally by the [TypeScript project itself](https://github.com/microsoft/TypeScript/pull/5422)\n    . [`preserveConstEnums`](https://www.typescriptlang.org/tsconfig#preserveConstEnums)\n     emits the same JavaScript for const enums as plain enums. You can then safely strip the `const` modifier from `.d.ts` files [in a build step](https://github.com/microsoft/TypeScript/blob/1a981d1df1810c868a66b3828497f049a944951c/Gulpfile.js#L144)\n    .\n    \n    This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely.\n    \n\n[](https://www.typescriptlang.org/docs/handbook/enums.html#ambient-enums)\nAmbient enums\n---------------------------------------------------------------------------------------\n\nAmbient enums are used to describe the shape of already existing enum types.\n\nts\n\n`   declare enum Enum {    A = 1,    B,    C = 2,  }   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEIB2BXAtvAoqjBvAUPPAILwC88AjADSHwBCtRAwufAEy0C+QA)\n\nOne important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer will be considered constant if its preceding enum member is considered constant. By contrast, an ambient (and non-const) enum member that does not have an initializer is _always_ considered computed.\n\n[](https://www.typescriptlang.org/docs/handbook/enums.html#objects-vs-enums)\nObjects vs Enums\n---------------------------------------------------------------------------------------------\n\nIn modern TypeScript, you may not need an enum when an object with `as const` could suffice:\n\nts\n\n`   const enum EDirection {    Up,    Down,    Left,    Right,  }  const ODirection = {    Up: 0,    Down: 1,    Left: 2,    Right: 3,  } as const;  EDirection.Up;               (enum member) EDirection.Up = 0  ODirection.Up;               (property) Up: 0  // Using the enum as a parameter  function walk(dir: EDirection) {}  // It requires an extra line to pull out the values  type Direction = typeof ODirection[keyof typeof ODirection];  function run(dir: Direction) {}  walk(EDirection.Left);  run(ODirection.Right);   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUQCIEsBOdhRbgwDeAUDDAKoAOANBTBiAO5gOUAycAZlBzABKWAOYALfmQC+ZMqEiwA8tjwEiYGAF5SjWgC4YABgHM2BgIwDufAwCYBw8VAMBmBlJgBDCDHnQA3LKYuPiE4AB0tIEA9NGU8QkAegD8ssohahFRZLEJeSmyuVQQWGAiMFBicPBIqN5eMDSeOJ7IcFBwOGQ8iGCZGiyeADYA1gAUACa4BsGqYWAAlKQyOXEAkrB4AI6IIT6eGnAAHlAtMEOl1VAgjYhDQzAgiLCV1QBuw4hwEGRQAJ40aoqULqLQVAFwEA8GDpObqADaIzgfyh4MBqNhIPAAF1Aj0+vMYDhepNpkwMvMliQVoNRmNZliwOFrFAFoFiWAxpj+uFHBI2UA)\n\nThe biggest argument in favour of this format over TypeScript’s `enum` is that it keeps your codebase aligned with the state of JavaScript, and [when/if](https://github.com/rbuckton/proposal-enum)\n enums are added to JavaScript then you can move to the additional syntax.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Enums.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (17)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nAG![Attila Gonda  (1)](https://gravatar.com/avatar/c7b7a9ff648489553a4467e2c1d812012a31a965f7d2c3359de0a11e0e856012?s=32&&d=blank)\n\nFDG-S![Frank de Groot - Schouten  (1)](https://gravatar.com/avatar/db794a621c26a10f0d9edad6a0f0cc450b52d6a9ef32b978fa9c05b91872f585?s=32&&d=blank)\n\nG![green961  (1)](https://gravatar.com/avatar/b80ebcac5ae48d7a0574fa5336f149e0baaaa4598ed7e8c3d0f45bd3dde505bc?s=32&&d=blank)\n\nTA![Tex Andersen  (1)](https://gravatar.com/avatar/c9373d60f866769c00b43eac3b4673cb67a73b1c435e2366740da1fb208bd177?s=32&&d=blank)\n\n11+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"generator":"Gatsby 5.13.5","og:description":"How TypeScript enums work","ogDescription":"How TypeScript enums work","language":"en","twitter:site":"typescriptlang","theme-color":"#3178C6","description":"How TypeScript enums work","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:title":"Handbook - Enums","ogTitle":"Handbook - Enums","title":"TypeScript: Handbook - Enums","scrapeId":"8b5c9a6e-d911-4c42-ba64-b55d93a41833","sourceURL":"https://www.typescriptlang.org/docs/handbook/enums.html","url":"https://www.typescriptlang.org/docs/handbook/enums.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nDeclaration Merging\n===================\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#introduction)\nIntroduction\n---------------------------------------------------------------------------------------------------\n\nSome of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of ‘declaration merging’. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.\n\nFor the purposes of this article, “declaration merging” means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it’s not limited to just two declarations.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#basic-concepts)\nBasic Concepts\n-------------------------------------------------------------------------------------------------------\n\nIn TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.\n\n| Declaration Type | Namespace | Type | Value |\n| --- | --- | --- | --- |\n| Namespace | X   |     | X   |\n| Class |     | X   | X   |\n| Enum |     | X   | X   |\n| Interface |     | X   |     |\n| Type Alias |     | X   |     |\n| Function |     |     | X   |\n| Variable |     |     | X   |\n\nUnderstanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces)\nMerging Interfaces\n---------------------------------------------------------------------------------------------------------------\n\nThe simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.\n\nts\n\n`   interface Box {    height: number;    width: number;  }  interface Box {    scale: number;  }  let box: Box = { height: 5, width: 6, scale: 10 };   `\n\nNon-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.\n\nFor function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface `A` merging with later interface `A`, the second interface will have a higher precedence than the first.\n\nThat is, in the example:\n\nts\n\n`   interface Cloner {    clone(animal: Animal): Animal;  }  interface Cloner {    clone(animal: Sheep): Sheep;  }  interface Cloner {    clone(animal: Dog): Dog;    clone(animal: Cat): Cat;  }   `\n\nThe three interfaces will merge to create a single declaration as so:\n\nts\n\n`   interface Cloner {    clone(animal: Dog): Dog;    clone(animal: Cat): Cat;    clone(animal: Sheep): Sheep;    clone(animal: Animal): Animal;  }   `\n\nNotice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.\n\nOne exception to this rule is specialized signatures. If a signature has a parameter whose type is a _single_ string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.\n\nFor instance, the following interfaces will merge together:\n\nts\n\n`   interface Document {    createElement(tagName: any): Element;  }  interface Document {    createElement(tagName: \"div\"): HTMLDivElement;    createElement(tagName: \"span\"): HTMLSpanElement;  }  interface Document {    createElement(tagName: string): HTMLElement;    createElement(tagName: \"canvas\"): HTMLCanvasElement;  }   `\n\nThe resulting merged declaration of `Document` will be the following:\n\nts\n\n`   interface Document {    createElement(tagName: \"canvas\"): HTMLCanvasElement;    createElement(tagName: \"div\"): HTMLDivElement;    createElement(tagName: \"span\"): HTMLSpanElement;    createElement(tagName: string): HTMLElement;    createElement(tagName: any): Element;  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces)\nMerging Namespaces\n---------------------------------------------------------------------------------------------------------------\n\nSimilarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.\n\nTo merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.\n\nTo merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.\n\nThe declaration merge of `Animals` in this example:\n\nts\n\n`   namespace Animals {    export class Zebra {}  }  namespace Animals {    export interface Legged {      numberOfLegs: number;    }    export class Dog {}  }   `\n\nis equivalent to:\n\nts\n\n`   namespace Animals {    export interface Legged {      numberOfLegs: number;    }    export class Zebra {}    export class Dog {}  }   `\n\nThis model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.\n\nWe can see this more clearly in this example:\n\nts\n\n`   namespace Animal {    let haveMuscles = true;    export function animalsHaveMuscles() {      return haveMuscles;    }  }  namespace Animal {    export function doAnimalsHaveMuscles() {      return haveMuscles; // Error, because haveMuscles is not accessible here    }  }   `\n\nBecause `haveMuscles` is not exported, only the `animalsHaveMuscles` function that shares the same un-merged namespace can see the symbol. The `doAnimalsHaveMuscles` function, even though it’s part of the merged `Animal` namespace can not see this un-exported member.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces-with-classes-functions-and-enums)\nMerging Namespaces with Classes, Functions, and Enums\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nNamespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces-with-classes)\nMerging Namespaces with Classes\n\nThis gives the user a way of describing inner classes.\n\nts\n\n`   class Album {    label: Album.AlbumLabel;  }  namespace Album {    export class AlbumLabel {}  }   `\n\nThe visibility rules for merged members is the same as described in the [Merging Namespaces](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces)\n section, so we must export the `AlbumLabel` class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.\n\nIn addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.\n\nts\n\n`   function buildLabel(name: string): string {    return buildLabel.prefix + name + buildLabel.suffix;  }  namespace buildLabel {    export let suffix = \"\";    export let prefix = \"Hello, \";  }  console.log(buildLabel(\"Sam Smith\"));   `\n\nSimilarly, namespaces can be used to extend enums with static members:\n\nts\n\n`   enum Color {    red = 1,    green = 2,    blue = 4,  }  namespace Color {    export function mixColor(colorName: string) {      if (colorName == \"yellow\") {        return Color.red + Color.green;      } else if (colorName == \"white\") {        return Color.red + Color.green + Color.blue;      } else if (colorName == \"magenta\") {        return Color.red + Color.blue;      } else if (colorName == \"cyan\") {        return Color.green + Color.blue;      }    }  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#disallowed-merges)\nDisallowed Merges\n-------------------------------------------------------------------------------------------------------------\n\nNot all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the [Mixins in TypeScript](https://www.typescriptlang.org/docs/handbook/mixins.html)\n section.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)\nModule Augmentation\n-----------------------------------------------------------------------------------------------------------------\n\nAlthough JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let’s look at a toy Observable example:\n\nts\n\n`   // observable.ts  export class Observable<T> {    // ... implementation left as an exercise for the reader ...  }  // map.ts  import { Observable } from \"./observable\";  Observable.prototype.map = function (f) {    // ... another exercise for the reader  };   `\n\nThis works fine in TypeScript too, but the compiler doesn’t know about `Observable.prototype.map`. You can use module augmentation to tell the compiler about it:\n\nts\n\n`   // observable.ts  export class Observable<T> {    // ... implementation left as an exercise for the reader ...  }  // map.ts  import { Observable } from \"./observable\";  declare module \"./observable\" {    interface Observable<T> {      map<U>(f: (x: T) => U): Observable<U>;    }  }  Observable.prototype.map = function (f) {    // ... another exercise for the reader  };  // consumer.ts  import { Observable } from \"./observable\";  import \"./map\";  let o: Observable<number>;  o.map((x) => x.toFixed());   `\n\nThe module name is resolved the same way as module specifiers in `import`/`export`. See [Modules](https://www.typescriptlang.org/docs/handbook/modules.html)\n for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.\n\nHowever, there are two limitations to keep in mind:\n\n1.  You can’t declare new top-level declarations in the augmentation — just patches to existing declarations.\n2.  Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and `default` is a reserved word - see [#14080](https://github.com/Microsoft/TypeScript/issues/14080)\n     for details)\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation)\nGlobal augmentation\n\nYou can also add declarations to the global scope from inside a module:\n\nts\n\n`   // observable.ts  export class Observable<T> {    // ... still no implementation ...  }  declare global {    interface Array<T> {      toObservable(): Observable<T>;    }  }  Array.prototype.toObservable = function () {    // ...  };   `\n\nGlobal augmentations have the same behavior and limits as module augmentations.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Declaration%20Merging.md)\n ❤\n\nContributors to this page:  \n\nRC![Ryan Cavanaugh  (53)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (20)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)\n\nOT![Orta Therox  (16)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nNS![Nathan Shively-Sanders  (10)](https://gravatar.com/avatar/f2d3b194d100bd25842ca048ab101408?s=32&&d=blank)\n\nMF![Martin Fischer  (1)](https://gravatar.com/avatar/dc885100e48a5949f1a44bcd6fce398735ff3294f20607ddee8bb45acb29601a?s=32&&d=blank)\n\n15+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"How merging namespaces and interfaces works","generator":"Gatsby 5.13.5","theme-color":"#3178C6","ogTitle":"Documentation - Declaration Merging","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","og:title":"Documentation - Declaration Merging","title":"TypeScript: Documentation - Declaration Merging","language":"en","description":"How merging namespaces and interfaces works","og:description":"How merging namespaces and interfaces works","scrapeId":"7f34aef0-4e06-405c-be06-79c0396ddcc9","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-merging.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-merging.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nIterators and Generators\n========================\n\n[](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#iterables)\nIterables\n--------------------------------------------------------------------------------------------------\n\nAn object is deemed iterable if it has an implementation for the [`Symbol.iterator`](https://www.typescriptlang.org/docs/handbook/symbols.html#symboliterator)\n property. Some built-in types like `Array`, `Map`, `Set`, `String`, `Int32Array`, `Uint32Array`, etc. have their `Symbol.iterator` property already implemented. `Symbol.iterator` function on an object is responsible for returning the list of values to iterate on.\n\n### [](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#iterable-interface)\n`Iterable` interface\n\n`Iterable` is a type we can use if we want to take in types listed above which are iterable. Here is an example:\n\nts\n\n`   function toArray<X>(xs: Iterable<X>): X[] {    return [...xs]  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#forof-statements)\n`for..of` statements\n\n`for..of` loops over an iterable object, invoking the `Symbol.iterator` property on the object. Here is a simple `for..of` loop on an array:\n\nts\n\n`   let someArray = [1, \"string\", false];  for (let entry of someArray) {    console.log(entry); // 1, \"string\", false  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#forof-vs-forin-statements)\n`for..of` vs. `for..in` statements\n\nBoth `for..of` and `for..in` statements iterate over lists; the values iterated on are different though, `for..in` returns a list of _keys_ on the object being iterated, whereas `for..of` returns a list of _values_ of the numeric properties of the object being iterated.\n\nHere is an example that demonstrates this distinction:\n\nts\n\n`   let list = [4, 5, 6];  for (let i in list) {    console.log(i); // \"0\", \"1\", \"2\",  }  for (let i of list) {    console.log(i); // 4, 5, 6  }   `\n\nAnother distinction is that `for..in` operates on any object; it serves as a way to inspect properties on this object. `for..of` on the other hand, is mainly interested in values of iterable objects. Built-in objects like `Map` and `Set` implement `Symbol.iterator` property allowing access to stored values.\n\nts\n\n`   let pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);  pets[\"species\"] = \"mammals\";  for (let pet in pets) {    console.log(pet); // \"species\"  }  for (let pet of pets) {    console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#code-generation)\nCode generation\n\n#### [](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#targeting-es5)\nTargeting ES5\n\nWhen targeting an ES5-compliant engine, iterators are only allowed on values of `Array` type. It is an error to use `for..of` loops on non-Array values, even if these non-Array values implement the `Symbol.iterator` property.\n\nThe compiler will generate a simple `for` loop for a `for..of` loop, for instance:\n\nts\n\n`   let numbers = [1, 2, 3];  for (let num of numbers) {    console.log(num);  }   `\n\nwill be generated as:\n\njs\n\n`   var numbers = [1, 2, 3];  for (var _i = 0; _i < numbers.length; _i++) {    var num = numbers[_i];    console.log(num);  }   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#targeting-ecmascript-2015-and-higher)\nTargeting ECMAScript 2015 and higher\n\nWhen targeting an ECMAScript 2015-compliant engine, the compiler will generate `for..of` loops to target the built-in iterator implementation in the engine.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Iterators%20and%20Generators.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (57)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nGB![Gabriel Burdeti  (3)](https://gravatar.com/avatar/28ff7ada33ca80bfae575ae1321176ca?s=32&&d=blank)\n\nJB![Jake Bailey  (1)](https://gravatar.com/avatar/127e9f47eb2768eae31eb5809ae4f1ca44336bc51e45473c68ebb9648608f590?s=32&&d=blank)\n\nNS![Nick Schonning  (1)](https://gravatar.com/avatar/a490b76edb21047df004539971c9258a6c3bd8da6bc3ca94c89da3e6398ef08e?s=32&&d=blank)\n\n12+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"theme-color":"#3178C6","og:description":"How Iterators and Generators work in TypeScript","ogDescription":"How Iterators and Generators work in TypeScript","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogTitle":"Documentation - Iterators and Generators","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","title":"TypeScript: Documentation - Iterators and Generators","og:title":"Documentation - Iterators and Generators","twitter:site":"typescriptlang","description":"How Iterators and Generators work in TypeScript","scrapeId":"b36d156d-1d69-49f6-b097-98d8a1f29755","sourceURL":"https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html","url":"https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nJSX\n===\n\n[JSX](https://facebook.github.io/jsx/)\n is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the [React](https://reactjs.org/)\n framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.\n\n[](https://www.typescriptlang.org/docs/handbook/jsx.html#basic-usage)\nBasic usage\n---------------------------------------------------------------------------------\n\nIn order to use JSX you must do two things.\n\n1.  Name your files with a `.tsx` extension\n2.  Enable the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)\n     option\n\nTypeScript ships with several JSX modes: `preserve`, `react` (classic runtime), `react-jsx` (automatic runtime), `react-jsxdev` (automatic development runtime), and `react-native`. The `preserve` mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. [Babel](https://babeljs.io/)\n). Additionally the output will have a `.jsx` file extension. The `react` mode will emit `React.createElement`, does not need to go through a JSX transformation before use, and the output will have a `.js` file extension. The `react-native` mode is the equivalent of `preserve` in that it keeps all JSX, but the output will instead have a `.js` file extension.\n\n| Mode | Input | Output | Output File Extension |\n| --- | --- | --- | --- |\n| `preserve` | `<div />` | `<div />` | `.jsx` |\n| `react` | `<div />` | `React.createElement(\"div\")` | `.js` |\n| `react-native` | `<div />` | `<div />` | `.js` |\n| `react-jsx` | `<div />` | `_jsx(\"div\", {}, void 0);` | `.js` |\n| `react-jsxdev` | `<div />` | `_jsxDEV(\"div\", {}, void 0, false, {...}, this);` | `.js` |\n\nYou can specify this mode using either the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)\n command line flag or the corresponding option [`jsx` in your tsconfig.json](https://www.typescriptlang.org/tsconfig#jsx)\n file.\n\n> \\*Note: You can specify the JSX factory function to use when targeting react JSX emit with [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n>  option (defaults to `React.createElement`)\n\n[](https://www.typescriptlang.org/docs/handbook/jsx.html#the-as-operator)\nThe `as` operator\n-------------------------------------------------------------------------------------------\n\nRecall how to write a type assertion:\n\nts\n\n`   const foo = <Foo>bar;   `\n\nThis asserts the variable `bar` to have the type `Foo`. Since TypeScript also uses angle brackets for type assertions, combining it with JSX’s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in `.tsx` files.\n\nSince the above syntax cannot be used in `.tsx` files, an alternate type assertion operator should be used: `as`. The example can easily be rewritten with the `as` operator.\n\nts\n\n`   const foo = bar as Foo;   `\n\nThe `as` operator is available in both `.ts` and `.tsx` files, and is identical in behavior to the angle-bracket type assertion style.\n\n[](https://www.typescriptlang.org/docs/handbook/jsx.html#type-checking)\nType Checking\n-------------------------------------------------------------------------------------\n\nIn order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression `<expr />`, `expr` may either refer to something intrinsic to the environment (e.g. a `div` or `span` in a DOM environment) or to a custom component that you’ve created. This is important for two reasons:\n\n1.  For React, intrinsic elements are emitted as strings (`React.createElement(\"div\")`), whereas a component you’ve created is not (`React.createElement(MyComponent)`).\n2.  The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known _intrinsically_ whereas components will likely want to specify their own set of attributes.\n\nTypeScript uses the [same convention that React does](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components)\n for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsx.html#the-jsx-namespace)\nThe `JSX` namespace\n\nJSX in TypeScript is typed by the `JSX` namespace. The `JSX` namespace may be defined in various places, depending on the `jsx` compiler option.\n\nThe `jsx` options `preserve`, `react`, and `react-native` use the type definitions for classic runtime. This means a variable needs to be in scope that’s determined by the `jsxFactory` compiler option. The `JSX` namespace should be specified on the top-most identifier of the JSX factory. For example, React uses the default factory `React.createElement`. This means its `JSX` namespace should be defined as `React.JSX`.\n\nts\n\n`   export function createElement(): any;  export namespace JSX {    // …  }   `\n\nAnd the user should always import React as `React`.\n\nts\n\n`   import * as React from 'react';   `\n\nPreact uses the JSX factory `h`. That means its types should be defined as the `h.JSX`.\n\nts\n\n`   export function h(props: any): any;  export namespace h.JSX {    // …  }   `\n\nThe user should use a named import to import `h`.\n\nts\n\n`   import { h } from 'preact';   `\n\nFor the `jsx` options `react-jsx` and `react-jsxdev`, the `JSX` namespace should be exported from the matching entry points. For `react-jsx` this is `${jsxImportSource}/jsx-runtime`. For `react-jsxdev`, this is `${jsxImportSource}/jsx-dev-runtime`. Since these don’t use a file extension, you must use the [`exports`](https://nodejs.org/api/packages.html#exports)\n field in `package.json` map in order to support ESM users.\n\njson\n\n`   {    \"exports\": {      \"./jsx-runtime\": \"./jsx-runtime.js\",      \"./jsx-dev-runtime\": \"./jsx-dev-runtime.js\",    }  }   `\n\nThen in `jsx-runtime.d.ts` and `jsx-dev-runtime.d.ts`:\n\nts\n\n`   export namespace JSX {    // …  }   `\n\nNote that while exporting the `JSX` namespace is sufficient for type checking, the production runtime needs the `jsx`, `jsxs`, and `Fragment` exports at runtime, and the development runtime needs `jsxDEV` and `Fragment`. Ideally you add types for those too.\n\nIf the `JSX` namespace isn’t available in the appropriate location, both the classic and the automatic runtime fall back to the global `JSX` namespace.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsx.html#intrinsic-elements)\nIntrinsic elements\n\nIntrinsic elements are looked up on the special interface `JSX.IntrinsicElements`. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface _is_ present, then the name of the intrinsic element is looked up as a property on the `JSX.IntrinsicElements` interface. For example:\n\ntsx\n\n`   declare namespace JSX {    interface IntrinsicElements {      foo: any;    }  }  <foo />; // ok  <bar />; // error   `\n\nIn the above example, `<foo />` will work fine but `<bar />` will result in an error since it has not been specified on `JSX.IntrinsicElements`.\n\n> Note: You can also specify a catch-all string indexer on `JSX.IntrinsicElements` as follows:\n\nts\n\n`   declare namespace JSX {    interface IntrinsicElements {      [elemName: string]: any;    }  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/jsx.html#value-based-elements)\nValue-based elements\n\nValue-based elements are simply looked up by identifiers that are in scope.\n\ntsx\n\n`   import MyComponent from \"./myComponent\";  <MyComponent />; // ok  <SomeOtherComponent />; // error   `\n\nThere are two ways to define a value-based element:\n\n1.  Function Component (FC)\n2.  Class Component\n\nBecause these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.\n\n#### [](https://www.typescriptlang.org/docs/handbook/jsx.html#function-component)\nFunction Component\n\nAs the name suggests, the component is defined as a JavaScript function where its first argument is a `props` object. TS enforces that its return type must be assignable to `JSX.Element`.\n\ntsx\n\n`   interface FooProp {    name: string;    X: number;    Y: number;  }  declare function AnotherComponent(prop: { name: string });  function ComponentFoo(prop: FooProp) {    return <AnotherComponent name={prop.name} />;  }  const Button = (prop: { value: string }, context: { color: string }) => (    <button />  );   `\n\nBecause a Function Component is simply a JavaScript function, function overloads may be used here as well:\n\nts\n\n`   interface ClickableProps {    children: JSX.Element[] | JSX.Element;  }  interface HomeProps extends ClickableProps {    home: JSX.Element;  }  interface SideProps extends ClickableProps {    side: JSX.Element | string;  }  function MainButton(prop: HomeProps): JSX.Element;  function MainButton(prop: SideProps): JSX.Element;  function MainButton(prop: ClickableProps): JSX.Element {    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABMCmBjANgIbxagC20GArniQFIDKAGqAN5qigCWkALlvADMCOErBqksvVgF92XXvyEjQASV7xuKTjjFYJvFKzkcA2igBcoFDw2QA5gF1LBSAE8A3HNmyQoALQBOJQ8AX5o3HyCwiQAwnjaANYEAEY0AApIAA6GbBw4ABaceBjEkJYMjAB0uvo8Jg6gAD6gFdXikjyesuEKUcoAEtASGdDZoFgAHnyQGIZxiSnpWTly+UNY5Uxteh1daD2RSiT0nNgjY5PTs6DzOEmpWOcrHFrYm1U1HU1WNtx2e2gBJRIDgeJxoJBQABZAjcABCwR4EIAFJkspZBsNlgBKd7bWqeIEgsEQ6GwyAInhIyCo9GgE5nHF4z68QnA0HgyEw+GIlFo0aWW73JajFC4lpbFk8IwcXyVeVoaRAA)\n\n> Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type `SFC` and its alias `StatelessComponent` were deprecated.\n\n#### [](https://www.typescriptlang.org/docs/handbook/jsx.html#class-component)\nClass Component\n\nIt is possible to define the type of a class component. However, to do so it is best to understand two new terms: the _element class type_ and the _element instance type_.\n\nGiven `<Expr />`, the _element class type_ is the type of `Expr`. So in the example above, if `MyComponent` was an ES6 class the class type would be that class’s constructor and statics. If `MyComponent` was a factory function, the class type would be that function.\n\nOnce the class type is established, the instance type is determined by the union of the return types of the class type’s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.\n\nts\n\n`   class MyComponent {    render() {}  }  // use a construct signature  const myComponent = new MyComponent();  // element class type => MyComponent  // element instance type => { render: () => void }  function MyFactoryFunction() {    return {      render: () => {},    };  }  // use a call signature  const myComponent = MyFactoryFunction();  // element class type => MyFactoryFunction  // element instance type => { render: () => void }   `\n\nThe element instance type is interesting because it must be assignable to `JSX.ElementClass` or it will result in an error. By default `JSX.ElementClass` is `{}`, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.\n\ntsx\n\n`   declare namespace JSX {    interface ElementClass {      render: any;    }  }  class MyComponent {    render() {}  }  function MyFactoryFunction() {    return { render: () => {} };  }  <MyComponent />; // ok  <MyFactoryFunction />; // ok  class NotAValidComponent {}  function NotAValidFactoryFunction() {    return {};  }  <NotAValidComponent />; // error  <NotAValidFactoryFunction />; // error   `\n\n### [](https://www.typescriptlang.org/docs/handbook/jsx.html#attribute-type-checking)\nAttribute type checking\n\nThe first step to type checking attributes is to determine the _element attributes type_. This is slightly different between intrinsic and value-based elements.\n\nFor intrinsic elements, it is the type of the property on `JSX.IntrinsicElements`\n\ntsx\n\n`   declare namespace JSX {    interface IntrinsicElements {      foo: { bar?: boolean };    }  }  // element attributes type for 'foo' is '{bar?: boolean}'  <foo bar />;   `\n\nFor value-based elements, it is a bit more complex. It is determined by the type of a property on the _element instance type_ that was previously determined. Which property to use is determined by `JSX.ElementAttributesProperty`. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if `JSX.ElementAttributesProperty` is not provided, the type of first parameter of the class element’s constructor or Function Component’s call will be used instead.\n\ntsx\n\n`   declare namespace JSX {    interface ElementAttributesProperty {      props; // specify the property name to use    }  }  class MyComponent {    // specify the property on the element instance type    props: {      foo?: string;    };  }  // element attributes type for 'MyComponent' is '{foo?: string}'  <MyComponent foo=\"bar\" />;   `\n\nThe element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.\n\ntsx\n\n`   declare namespace JSX {    interface IntrinsicElements {      foo: { requiredProp: string; optionalProp?: number };    }  }  <foo requiredProp=\"bar\" />; // ok  <foo requiredProp=\"bar\" optionalProp={0} />; // ok  <foo />; // error, requiredProp is missing  <foo requiredProp={0} />; // error, requiredProp should be a string  <foo requiredProp=\"bar\" unknownProp />; // error, unknownProp does not exist  <foo requiredProp=\"bar\" some-unknown-prop />; // ok, because 'some-unknown-prop' is not a valid identifier   `\n\n> Note: If an attribute name is not a valid JS identifier (like a `data-*` attribute), it is not considered to be an error if it is not found in the element attributes type.\n\nAdditionally, the `JSX.IntrinsicAttributes` interface can be used to specify extra properties used by the JSX framework which are not generally used by the components’ props or arguments - for instance `key` in React. Specializing further, the generic `JSX.IntrinsicClassAttributes<T>` type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the `ref` attribute of type `Ref<T>`. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.\n\nThe spread operator also works:\n\ntsx\n\n`   const props = { requiredProp: \"bar\" };  <foo {...props} />; // ok  const badProps = {};  <foo {...badProps} />; // error   `\n\n### [](https://www.typescriptlang.org/docs/handbook/jsx.html#children-type-checking)\nChildren Type Checking\n\nIn TypeScript 2.3, TS introduced type checking of _children_. _children_ is a special property in an _element attributes type_ where child _JSXExpression_s are taken to be inserted into the attributes. Similar to how TS uses `JSX.ElementAttributesProperty` to determine the name of _props_, TS uses `JSX.ElementChildrenAttribute` to determine the name of _children_ within those props. `JSX.ElementChildrenAttribute` should be declared with a single property.\n\nts\n\n`   declare namespace JSX {    interface ElementChildrenAttribute {      children: {}; // specify children name to use    }  }   `\n\ntsx\n\n`   <div>    <h1>Hello</h1>  </div>;  <div>    <h1>Hello</h1>    World  </div>;  const CustomComp = (props) => <div>{props.children}</div>  <CustomComp>    <div>Hello World</div>    {\"This is just a JS expression...\" + 1000}  </CustomComp>   `\n\nYou can specify the type of _children_ like any other attribute. This will override the default type from, e.g. the [React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)\n if you use them.\n\ntsx\n\n`   interface PropsType {    children: JSX.Element    name: string  }  class Component extends React.Component<PropsType, {}> {    render() {      return (        <h2>          {this.props.children}        </h2>      )    }  }  // OK  <Component name=\"foo\">    <h1>Hello World</h1>  </Component>  // Error: children is of type JSX.Element not array of JSX.Element  <Component name=\"bar\">    <h1>Hello World</h1>    <h2>Hello World</h2>  </Component>  // Error: children is of type JSX.Element not array of JSX.Element or string.  <Component name=\"baz\">    <h1>Hello</h1>    World  </Component>   `\n\n[](https://www.typescriptlang.org/docs/handbook/jsx.html#the-jsx-result-type)\nThe JSX result type\n-------------------------------------------------------------------------------------------------\n\nBy default the result of a JSX expression is typed as `any`. You can customize the type by specifying the `JSX.Element` interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.\n\n[](https://www.typescriptlang.org/docs/handbook/jsx.html#the-jsx-function-return-type)\nThe JSX function return type\n-------------------------------------------------------------------------------------------------------------------\n\nBy default, function components must return `JSX.Element | null`. However, this doesn’t always represent runtime behaviour. As of TypeScript 5.1, you can specify `JSX.ElementType` to override what is a valid JSX component type. Note that this doesn’t define what props are valid. The type of props is always defined by the first argument of the component that’s passed. The default looks something like this:\n\nts\n\n`   namespace JSX {      export type ElementType =          // All the valid lowercase tags          | keyof IntrinsicElements          // Function components          | (props: any) => Element          // Class components          | new (props: any) => ElementClass;      export interface IntrinsicAttributes extends /*...*/ {}      export type Element = /*...*/;      export type ElementClass = /*...*/;  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/jsx.html#embedding-expressions)\nEmbedding Expressions\n-----------------------------------------------------------------------------------------------------\n\nJSX allows you to embed expressions between tags by surrounding the expressions with curly braces (`{ }`).\n\ntsx\n\n`   const a = (    <div>      {[\"foo\", \"bar\"].map((i) => (        <span>{i / 2}</span>      ))}    </div>  );   `\n\nThe above code will result in an error since you cannot divide a string by a number. The output, when using the `preserve` option, looks like:\n\ntsx\n\n`   const a = (    <div>      {[\"foo\", \"bar\"].map(function (i) {        return <span>{i / 2}</span>;      })}    </div>  );   `\n\n[](https://www.typescriptlang.org/docs/handbook/jsx.html#react-integration)\nReact integration\n---------------------------------------------------------------------------------------------\n\nTo use JSX with React you should use the [React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)\n. These typings define the `JSX` namespace appropriately for use with React.\n\ntsx\n\n`   /// <reference path=\"react.d.ts\" />  interface Props {    foo: string;  }  class MyComponent extends React.Component<Props, {}> {    render() {      return <span>{this.props.foo}</span>;    }  }  <MyComponent foo=\"bar\" />; // ok  <MyComponent foo={0} />; // error   `\n\n### [](https://www.typescriptlang.org/docs/handbook/jsx.html#configuring-jsx)\nConfiguring JSX\n\nThere are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:\n\n*   [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n    \n*   [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n    \n*   [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/JSX.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (55)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (20)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nRC![Ryan Cavanaugh  (6)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nDZ![David Zulaica  (3)](https://gravatar.com/avatar/da0a821c09edbd8369777d622b446cc2?s=32&&d=blank)\n\nKT![Kanchalai Tanglertsampan  (3)](https://gravatar.com/avatar/c8404f96910ba93ddc3e881b4bff24a4?s=32&&d=blank)\n\n35+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","ogDescription":"Using JSX with TypeScript","generator":"Gatsby 5.13.5","theme-color":"#3178C6","og:description":"Using JSX with TypeScript","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","description":"Using JSX with TypeScript","ogTitle":"Documentation - JSX","og:title":"Documentation - JSX","twitter:site":"typescriptlang","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","title":"TypeScript: Documentation - JSX","scrapeId":"10d00b1d-f890-4d44-9560-96a3a47b1ab0","sourceURL":"https://www.typescriptlang.org/docs/handbook/jsx.html","url":"https://www.typescriptlang.org/docs/handbook/jsx.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nMixins\n======\n\nAlong with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.\n\n[](https://www.typescriptlang.org/docs/handbook/mixins.html#how-does-a-mixin-work)\nHow Does A Mixin Work?\n---------------------------------------------------------------------------------------------------------\n\nThe pattern relies on using generics with class inheritance to extend a base class. TypeScript’s best mixin support is done via the class expression pattern. You can read more about how this pattern works in JavaScript [here](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/)\n.\n\nTo get started, we’ll need a class which will have the mixins applied on top of:\n\nts\n\n`   class Sprite {    name = \"\";    x = 0;    y = 0;    constructor(name: string) {      this.name = name;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAOAnAlgFwKbQN4ChrQDswBbTAXmgCJKBuPaAD2goAY78BPZ6Nne4APYEIqRAFdgqAYgAURUgC5oIlAQDmASmz18qABbIIAOnnlCJdO2gBfHNaA)\n\nThen you need a type and a factory function which returns a class expression extending the base class.\n\nts\n\n`   // To get started, we need a type which we'll use to extend  // other classes from. The main responsibility is to declare  // that the type being passed in is a class.  type Constructor = new (...args: any[]) => {};  // This mixin adds a scale property, with getters and setters  // for changing it with an encapsulated private property:  function Scale<TBase extends Constructor>(Base: TBase) {    return class Scaling extends Base {      // Mixins may not declare private/protected properties      // however, you can use ES2020 private fields      _scale = 1;      setScale(scale: number) {        this._scale = scale;      }      get scale(): number {        return this._scale;      }    };  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEBUHtQcwUwC6gM4IIYCcFwCYBpQB3OUAOzl1DVAQE8AHEwgCwEsBjZouAcgBs+oAK7ISCaHAAe2UjgBQIUJATM4GUOz5pko5KABmGSAFsAdBFWhjaVqVAY4yepFLJWAI1Z9WdUKz3ioDhwmphwCmAqaEgqYgwk7nC2MKD02qI4fnb+VBpaOqZycnSMoADCLqgYQuzi6gC8ZHCEoAAUph2YMMgAXFSktADaALoAlKD1AHygAN4AvgDcRYrgbHrGrJK2VDg4etTI7Gh8JPRGjFi0BIQ+XPAI2Bj7siiIj8gRBpDqnGikMMk-Egbip+qA4KQjvRkEItNhMmdWAA3aKnc5qOg9Ir6ISQhCsFygADKRxOAB5wAAhbQkKQyPblSoIaq1b6TVrU0R9Kk08YzOSgeyIIQYOyhHTE0mAukQhmckj8wWCxQAWU2tnWaFoZGUQRCWgcqQwyNRwDOyhC8KNkAu+McAqVimYkGISLUBFokCEGj+wlEoAAokSAEwABjDRpN2AMrDgfD2DsFAH1DscSI0AIxLROvBAktOtVMnPqkITGRIYPk5wUqfymFOk9MoRtLJWgOZFNv3ZsF0YlssV2bVoUIEV2WvIetFuCtpUdwWLORzIA)\n\nWith these all set up, then you can create a class which represents the base class with mixins applied:\n\nts\n\n`   // Compose a new class from the Sprite class,  // with the Mixin Scale applier:  const EightBitSprite = Scale(Sprite);  const flappySprite = new EightBitSprite(\"Bird\");  flappySprite.setScale(0.8);  console.log(flappySprite.scale);   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKAOAnAlgFwKbQN4ChrQDswBbTAXmgCJKBuPaAD2goAY78BPZ6Nne4APYEIqRAFdgqAYgAURUgC5oIlAQDmASmz18qABbIIAOnnlCJdO2gBfHLdQd4mAMJCVEqYm4F0Ad2gyRkFgiGoQSmAEHADaALpaZAB82NZ0AGZiBJLIQnDAYCDoADwAKgBCkJjoDBgEACYwrsKiHtKJMhUQ6ErllVq4+IjoqGKIBNCgkDCw+SDI6tDVtQ3QnZgD+NAA9FvQALLIDPMwxGBcBAKo0HXok0PQSMgAbmAYW0iXtxh1D4gCTohUMh0BAdNtdnoBL50E90IgADTQDgCMQTSLQMRdaAAUVgACYWATfs9Xpg0sCQA0wQB9CCzMwARjoYK6qBmBXQMjpHKUBDExAARnD+mDdAZjLT6dxuYUrPhbGC1MNlPSZBpefyhV4NptoEMRmNoPpDEZJRy5TZ6Kk7DgdtAALSO4BiVCO+223auYjwARYsCEPwTcBQaBpP7EI16TAIFAYINTeEe6C+NB6SOYA5HcbswrQMDweBzOEKHCCZo45BqPSoMpoGNoMw5zn1jAaZllkSh8AFjgtsw+fzYyvV2tsx4YGSUWuIOqUNs4NLd+C98foIyspsyFhGAAc847AkKRhAAjUMkX+eXffX9LbQA)\n\n[](https://www.typescriptlang.org/docs/handbook/mixins.html#constrained-mixins)\nConstrained Mixins\n--------------------------------------------------------------------------------------------------\n\nIn the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want.\n\nTo model this, we modify the original constructor type to accept a generic argument.\n\nts\n\n`   // This was our previous constructor:  type Constructor = new (...args: any[]) => {};  // Now we use a generic version which can apply a constraint on  // the class which this mixin is applied to  type GConstructor<T = {}> = new (...args: any[]) => T;   `[Try](https://www.typescriptlang.org/play/#code/PTAEBUAsEsGdQO4EN4HsCuAnUAHTBTAN2g3gGNUA7WAF03TJtUwC4AoGgTx31AGEqteo2agAvKEr4EoABQA6RUkwBzWC1BJKnANoBdAJTiAfKADeAXwDcbEKAByqGQl7pYvJKBX4pmaGVBCfExYEkpEGDJIUDItTRwcABtOTRjBOiRoShpQKlswGkheMkSUeARI6MK4UABbaAAPLNAapATE6HwAE1AmDm5eAHEBajoGJkwAHnBxcwtTCSkZBSVVdU1tfSMxU3ArIA)\n\nThis allows for creating classes which only work with constrained base classes:\n\nts\n\n`   type Positionable = GConstructor<{ setPos: (x: number, y: number) => void }>;  type Spritable = GConstructor<Sprite>;  type Loggable = GConstructor<{ print: () => void }>;   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gwgewHYGdgCcCuBjYD0A8AKlALxQDeAvgHxlRIQDuUAFAHScCG6A5igC4oXJCADaAXQCUZOkQDcAKGwAbLihRQAymHQBLYNAqKoDLgFto5AETWlpgB70ADPaggXSk1GzI0WXHxWJAsIIX89JF4ZY1NTYAALPRR2EMt6NIg3KkUcgHo8qABaEuxMYBKixVBIKAAFBBQDPWQuACMVK1hEVAwcPEIKKBQIYAbBNgchJExzNoh0ABp3adn59BlSOgA3BD0AEyhaJRroHX1gds76eD8+wMJzgwgaE-BoABkEXl4rrtvegEBgQhrpIsAhKxNjs9odjkA)\n\nThen you can create mixins which only work when you have a particular base to build on:\n\nts\n\n`   function Jumpable<TBase extends Positionable>(Base: TBase) {    return class Jumpable extends Base {      jump() {        // This mixin will only work if it is passed a base        // class which has setPos defined because of the        // Positionable constraint.        this.setPos(0, 20);      }    };  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gwgewHYGdgCcCuBjYD0A8AKlALxQDeAvgHxlRIQDuUAFAHScCG6A5igC4oXJCADaAXQCUZOkQDcAKGwAbLihRQAymHQBLYNAqKoDLgFto5AETWlpgB70ADPaggXSk1GzI0WXHxWJAsIIX89JF4ZY1NTYAALPRR2EMt6NIg3KkUc0EgoAAUEFAM9ZC4AIxUrWERUDBw8QgooFAhgYsE2ByEkTHNKiHQAGnc+gaH0GVI6ADcEPQATKFolfOgdfWAqmvp4P0bAwi2DCBp18GgAGQReXl3ag4aA5oJW3UjgIVYZ+cWVmtFAB6YFQAC0kOwmGAkPBikUADNMEhcOUkFAAFIDMCPYgAIXU0AgDkMSCWmi6ZQq1XOrEJ7SERAZEBi3nQHUw6AxqnUmmx5lxtKgJLJFKgLMo3lMACscb8pXE4qCoEQkppzHoHJEoEw9CoVFBkCoPEx8ABrKB6RFW4BWzS4jQQFZcKCVInS5Vg3kaXVJbAJKAJdRtDpdKBLCCIyLOt0QbBcTDtI02xIQT2mFVU4Dox4+Q7oLhfdgZqCJZLsdqdEqsZxjABMzikblMOVbSioQA)\n\n[](https://www.typescriptlang.org/docs/handbook/mixins.html#alternative-pattern)\nAlternative Pattern\n----------------------------------------------------------------------------------------------------\n\nPrevious versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:\n\nts\n\n`   // Each mixin is a traditional ES class  class Jumpable {    jump() {}  }  class Duckable {    duck() {}  }  // Including the base  class Sprite {    x = 0;    y = 0;  }  // Then you create an interface which merges  // the expected mixins with the same name as your base  interface Sprite extends Jumpable, Duckable {}  // Apply the mixins into the base class via  // the JS at runtime  applyMixins(Sprite, [Jumpable, Duckable]);  let player = new Sprite();  player.jump();  console.log(player.x, player.y);  // This can live anywhere in your codebase:  function applyMixins(derivedCtor: any, constructors: any[]) {    constructors.forEach((baseCtor) => {      Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {        Object.defineProperty(          derivedCtor.prototype,          name,          Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||            Object.create(null)        );      });    });  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFAigCimiAFqALbwAe8AdqPJKJqHJgCbzTwB7RjlIBlUImyZIkApOlsAUgFdqAB0wAjbHlABvAqFAArVWoAUASn0BfAnblSZoACLLEAay079h0N3cPK1t7AiIwAElGSWVeRgBzTgpdTWlCeWdRNQRoXQMjOlAAXlAABgBuPwBPYrLKh2IAFWTmKoFlCVg8TFz2ZiZc2CxEXQB3CiQqajxYeLxZYmhk0Dw6NTxkPG4aeiY2Ub4qJd1ITGnQYXPpUDblWFBU-AIBmeHdLJzdVdzGbiUzbx4AA0rkCgJCxAAgmo1NgascdgxGGwBgIkik0hInGwAG7wTDhdGgRTiHqgWDKRj8aYETAwuEAWV2yPMHz4wNAAG0VOpASC3J5AQBdSyVAg6aCgWGYKozWqMPCjUBs3JWSrS2WwAB0pnUarkQkgAh0WuwAni5g1My1dBBVu1VVFYSaEzYiEwzGw8Bxug9VXGM10TBu7XuiAE3DwjzwKAI6EpyEEzDpsKqTKRkHMkYQPu4AGFoAJYGg-SDw8i4O5C7BICXGFVOSLfEZyzAKcgi5Ategi2RKOZzNGC0XrEUAHzNoygADymmMG2gWrm0Gno0YAAVYAJ1rBoFUAHJneaDtLD7XZASFvfrSzd3vkCgDy54UcT-JToyz+fILWR9BMPBN23GY93MPwPyMbNvS2M8tQvK8qnWIFwIg59kIgqcvwXJc8BXNcgJ3PcXHmRAEDUasT3wWD4MvRCOWfawAB9GJQjCsJ-UjulVRhlGwbBLFY0AnQ-GxhNAUT6iAA)\n\nThis pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync.\n\n[](https://www.typescriptlang.org/docs/handbook/mixins.html#constraints)\nConstraints\n------------------------------------------------------------------------------------\n\nThe mixin pattern is supported natively inside the TypeScript compiler by code flow analysis. There are a few cases where you can hit the edges of the native support.\n\n#### [](https://www.typescriptlang.org/docs/handbook/mixins.html#decorators-and-mixins-4881)\nDecorators and Mixins [`#4881`](https://github.com/microsoft/TypeScript/issues/4881)\n\nYou cannot use decorators to provide mixins via code flow analysis:\n\nts\n\n`   // A decorator function which replicates the mixin pattern:  const Pausable = (target: typeof Player) => {    return class Pausable extends target {      shouldFreeze = false;    };  };  @Pausable  class Player {    x = 0;    y = 0;  }  // The Player class does not have the decorator's type merged:  const player = new Player();  player.shouldFreeze;  Property 'shouldFreeze' does not exist on type 'Player'.2339Property 'shouldFreeze' does not exist on type 'Player'.  // The runtime aspect could be manually replicated via  // type composition or interface merging.  type FreezablePlayer = Player & { shouldFreeze: boolean };  const playerTwo = (new Player() as unknown) as FreezablePlayer;  playerTwo.shouldFreeze;   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8AdIE4EsC2kB2AXAhgGwCKQDGA9gtpmQM4BQIEiC1AXKAEwDMHAnHWAIKgAJsTIUyoAGYBXdEUxIS6UAHcAFkiJrQCSLFyaKkKqExrIoFEmhJlsCpkTpmNUuiqZQABWzSq2ACNcCwBeUAAKHAQAc0hMVkwAT3gSSW9cbETEAEpQEIA+UABvGlAdOOkEZSIMqhMfP0Dg0BhHdCETKNjPErKyqjUSaVwhADFdSAAvUKk8KkgAblLQAF8ltZoacAb-IMhXWvqMrIRi5eg80AAGJbLEy5uaFc36ABVzdMzEUBrsOuESMZQOgSJ41NgAG4WMwWESkciUBAAck6yQsaBikCELjcHlA+i+pzC6EgKk+J3C2SWBJOADoBkMRuNIFNFi8wO8LAhZAo0KA-vB5D9GUJQAF0dh0NI8Lh7rp9IZHKKIUhsHxTGjhShYCQqEgFEpQBJbI4EJJsER0YhorZorSaEl4KBmVMmpAvMdvmEPYTQAAyYqgBnDMYTaasAIkEjBSWrJauJR4mmIV4qEiXcIksk+im5P6gWQAaxBKnQeZMLsmbpziGpnoQqZI9MGIcriyAA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/mixins.html#static-property-mixins-17829)\nStatic Property Mixins [`#17829`](https://github.com/microsoft/TypeScript/issues/17829)\n\nMore of a gotcha than a constraint. The class expression pattern creates singletons, so they can’t be mapped at the type system to support different variable types.\n\nYou can work around this by using functions to return your classes which differ based on a generic:\n\nts\n\n`   function base<T>() {    class Base {      static prop: T;    }    return Base;  }  function derived<T>() {    class Derived extends base<T>() {      static anotherProp: T;    }    return Derived;  }  class Spec extends derived<string>() {}  Spec.prop; // string  Spec.anotherProp; // string   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAIwIYGcCmAeAKgPgAoBKRAbwChFEIAbDdRAIQ03KusXSlVgkQAOAJzgCAXIlwBuDgF8OQzFBBCkLLDPkVQkWAkQATTEJgA3TAbxFSlanQaIAIsbMXEmAB5RMYA4zRYViTsnFw8fIioYHBQABbGAAoi4pIy1PLUisqqTi7mBpoUFPbojADKApj8nt6+jEYm+djcJmAA5tbkWhVVAHTColKIAPTDYa1tFD0QvVEx8UJJgyNjLTDtQA)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Mixins.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (16)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nGM![Gleb Maksimenko  (1)](https://gravatar.com/avatar/fe047b209eebbb5cde74932cc6768d008af6b28d6014469769b7839ef682144a?s=32&&d=blank)\n\nIO![Iván Ovejero  (1)](https://gravatar.com/avatar/295845dcef2f47d9aa1059793f23f36ceb739f1772ac1b487f11a1094e733655?s=32&&d=blank)\n\nDE![Dom Eccleston  (1)](https://gravatar.com/avatar/4e8967c01537c9fb185e0351e84551db02fa1ba27053499746da9c9bf91296ce?s=32&&d=blank)\n\nO![Oblosys  (1)](https://gravatar.com/avatar/354d6a8ab6bcbc86771aa6876cb143d0ee6a30d27c51c539bfe740a14d504548?s=32&&d=blank)\n\n5+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","twitter:site":"typescriptlang","title":"TypeScript: Documentation - Mixins","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogDescription":"Using the mixin pattern with TypeScript","description":"Using the mixin pattern with TypeScript","og:description":"Using the mixin pattern with TypeScript","generator":"Gatsby 5.13.5","theme-color":"#3178C6","ogTitle":"Documentation - Mixins","og:title":"Documentation - Mixins","scrapeId":"63d1f207-71f6-49df-b081-64b28c507a61","sourceURL":"https://www.typescriptlang.org/docs/handbook/mixins.html","url":"https://www.typescriptlang.org/docs/handbook/mixins.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nNamespaces\n==========\n\n> **A note about terminology:** It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with [ECMAScript 2015](https://www.ecma-international.org/ecma-262/6.0/)\n> ’s terminology, (namely that `module X {` is equivalent to the now-preferred `namespace X {`).\n\nThis post outlines the various ways to organize your code using namespaces (previously “internal modules”) in TypeScript. As we alluded in our note about terminology, “internal modules” are now referred to as “namespaces”. Additionally, anywhere the `module` keyword was used when declaring an internal module, the `namespace` keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces.html#first-steps)\nFirst steps\n----------------------------------------------------------------------------------------\n\nLet’s start with the program we’ll be using as our example throughout this page. We’ve written a small set of simplistic string validators, as you might write to check a user’s input on a form in a webpage or check the format of an externally-provided data file.\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces.html#validators-in-a-single-file)\nValidators in a single file\n------------------------------------------------------------------------------------------------------------------------\n\nts\n\n``   interface StringValidator {    isAcceptable(s: string): boolean;  }  let lettersRegexp = /^[A-Za-z]+$/;  let numberRegexp = /^[0-9]+$/;  class LettersOnlyValidator implements StringValidator {    isAcceptable(s: string) {      return lettersRegexp.test(s);    }  }  class ZipCodeValidator implements StringValidator {    isAcceptable(s: string) {      return s.length === 5 && numberRegexp.test(s);    }  }  // Some samples to try  let strings = [\"Hello\", \"98052\", \"101\"];  // Validators to use  let validators: { [s: string]: StringValidator } = {};  validators[\"ZIP code\"] = new ZipCodeValidator();  validators[\"Letters only\"] = new LettersOnlyValidator();  // Show whether each string passed each validator  for (let s of strings) {    for (let name in validators) {      let isMatch = validators[name].isAcceptable(s);      console.log(`'${s}' ${isMatch ? \"matches\" : \"does not match\"} '${name}'.`);    }  }   ``\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces.html#namespacing)\nNamespacing\n----------------------------------------------------------------------------------------\n\nAs we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let’s wrap up our objects into a namespace.\n\nIn this example, we’ll move all validator-related entities into a namespace called `Validation`. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with `export`. Conversely, the variables `lettersRegexp` and `numberRegexp` are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. `Validation.LettersOnlyValidator`.\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces.html#namespaced-validators)\nNamespaced Validators\n------------------------------------------------------------------------------------------------------------\n\nts\n\n``   namespace Validation {    export interface StringValidator {      isAcceptable(s: string): boolean;    }    const lettersRegexp = /^[A-Za-z]+$/;    const numberRegexp = /^[0-9]+$/;    export class LettersOnlyValidator implements StringValidator {      isAcceptable(s: string) {        return lettersRegexp.test(s);      }    }    export class ZipCodeValidator implements StringValidator {      isAcceptable(s: string) {        return s.length === 5 && numberRegexp.test(s);      }    }  }  // Some samples to try  let strings = [\"Hello\", \"98052\", \"101\"];  // Validators to use  let validators: { [s: string]: Validation.StringValidator } = {};  validators[\"ZIP code\"] = new Validation.ZipCodeValidator();  validators[\"Letters only\"] = new Validation.LettersOnlyValidator();  // Show whether each string passed each validator  for (let s of strings) {    for (let name in validators) {      console.log(        `\"${s}\" - ${          validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"        } ${name}`      );    }  }   ``\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces.html#splitting-across-files)\nSplitting Across Files\n--------------------------------------------------------------------------------------------------------------\n\nAs our application grows, we’ll want to split the code across multiple files to make it easier to maintain.\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces.html#multi-file-namespaces)\nMulti-file namespaces\n------------------------------------------------------------------------------------------------------------\n\nHere, we’ll split our `Validation` namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.\n\n##### [](https://www.typescriptlang.org/docs/handbook/namespaces.html#validationts)\nValidation.ts\n\nts\n\n`   namespace Validation {    export interface StringValidator {      isAcceptable(s: string): boolean;    }  }   `\n\n##### [](https://www.typescriptlang.org/docs/handbook/namespaces.html#lettersonlyvalidatorts)\nLettersOnlyValidator.ts\n\nts\n\n`   /// <reference path=\"Validation.ts\" />  namespace Validation {    const lettersRegexp = /^[A-Za-z]+$/;    export class LettersOnlyValidator implements StringValidator {      isAcceptable(s: string) {        return lettersRegexp.test(s);      }    }  }   `\n\n##### [](https://www.typescriptlang.org/docs/handbook/namespaces.html#zipcodevalidatorts)\nZipCodeValidator.ts\n\nts\n\n`   /// <reference path=\"Validation.ts\" />  namespace Validation {    const numberRegexp = /^[0-9]+$/;    export class ZipCodeValidator implements StringValidator {      isAcceptable(s: string) {        return s.length === 5 && numberRegexp.test(s);      }    }  }   `\n\n##### [](https://www.typescriptlang.org/docs/handbook/namespaces.html#testts)\nTest.ts\n\nts\n\n``   /// <reference path=\"Validation.ts\" />  /// <reference path=\"LettersOnlyValidator.ts\" />  /// <reference path=\"ZipCodeValidator.ts\" />  // Some samples to try  let strings = [\"Hello\", \"98052\", \"101\"];  // Validators to use  let validators: { [s: string]: Validation.StringValidator } = {};  validators[\"ZIP code\"] = new Validation.ZipCodeValidator();  validators[\"Letters only\"] = new Validation.LettersOnlyValidator();  // Show whether each string passed each validator  for (let s of strings) {    for (let name in validators) {      console.log(        `\"${s}\" - ${          validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"        } ${name}`      );    }  }   ``\n\nOnce there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.\n\nFirst, we can use concatenated output using the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)\n option to compile all of the input files into a single JavaScript output file:\n\n`tsc --outFile sample.js Test.ts`\n\nThe compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:\n\n`tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts`\n\nAlternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we’ll need to use `<script>` tags on our webpage to load each emitted file in the appropriate order, for example:\n\n##### [](https://www.typescriptlang.org/docs/handbook/namespaces.html#mytestpagehtml-excerpt)\nMyTestPage.html (excerpt)\n\nhtml\n\n`   <script src=\"Validation.js\" type=\"text/javascript\" />  <script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />  <script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />  <script src=\"Test.js\" type=\"text/javascript\" />   `\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces.html#aliases)\nAliases\n--------------------------------------------------------------------------------\n\nAnother way that you can simplify working with namespaces is to use `import q = x.y.z` to create shorter names for commonly-used objects. Not to be confused with the `import x = require(\"name\")` syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.\n\nts\n\n`   namespace Shapes {    export namespace Polygons {      export class Triangle {}      export class Square {}    }  }  import polygons = Shapes.Polygons;  let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'   `\n\nNotice that we don’t use the `require` keyword; instead we assign directly from the qualified name of the symbol we’re importing. This is similar to using `var`, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, `import` is a distinct reference from the original symbol, so changes to an aliased `var` will not be reflected in the original variable.\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces.html#working-with-other-javascript-libraries)\nWorking with Other JavaScript Libraries\n------------------------------------------------------------------------------------------------------------------------------------------------\n\nTo describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.\n\nWe call declarations that don’t define an implementation “ambient”. Typically these are defined in `.d.ts` files. If you’re familiar with C/C++, you can think of these as `.h` files. Let’s look at a few examples.\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces.html#ambient-namespaces)\nAmbient Namespaces\n------------------------------------------------------------------------------------------------------\n\nThe popular library D3 defines its functionality in a global object called `d3`. Because this library is loaded through a `<script>` tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:\n\n##### [](https://www.typescriptlang.org/docs/handbook/namespaces.html#d3dts-simplified-excerpt)\nD3.d.ts (simplified excerpt)\n\nts\n\n`   declare namespace D3 {    export interface Selectors {      select: {        (selector: string): Selection;        (element: EventTarget): Selection;      };    }    export interface Event {      x: number;      y: number;    }    export interface Base extends Selectors {      event: Event;    }  }  declare var d3: D3.Base;   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Namespaces.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (56)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nDR![Daniel Rosenwasser  (3)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)\n\nIO![Iván Ovejero  (1)](https://gravatar.com/avatar/295845dcef2f47d9aa1059793f23f36ceb739f1772ac1b487f11a1094e733655?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\n14+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - Namespaces","ogDescription":"How TypeScript namespaces work","description":"How TypeScript namespaces work","og:title":"Documentation - Namespaces","twitter:site":"typescriptlang","theme-color":"#3178C6","og:description":"How TypeScript namespaces work","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","title":"TypeScript: Documentation - Namespaces","language":"en","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","scrapeId":"e42d4afe-c47b-424d-8615-bda73bdbf03c","sourceURL":"https://www.typescriptlang.org/docs/handbook/namespaces.html","url":"https://www.typescriptlang.org/docs/handbook/namespaces.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nNamespaces and Modules\n======================\n\nThis post outlines the various ways to organize your code using modules and namespaces in TypeScript. We’ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.\n\nSee the [Modules](https://www.typescriptlang.org/docs/handbook/modules.html)\n documentation for more information about ES Modules. See the [Namespaces](https://www.typescriptlang.org/docs/handbook/namespaces.html)\n documentation for more information about TypeScript namespaces.\n\nNote: In _very_ old versions of TypeScript namespaces were called ‘Internal Modules’, these pre-date JavaScript module systems.\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#using-modules)\nUsing Modules\n--------------------------------------------------------------------------------------------------------\n\nModules can contain both code and declarations.\n\nModules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.\n\nIt is also worth noting that, for Node.js applications, modules are the default and **we recommended modules over namespaces in modern code**.\n\nStarting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#using-namespaces)\nUsing Namespaces\n--------------------------------------------------------------------------------------------------------------\n\nNamespaces are a TypeScript-specific way to organize code.  \nNamespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)\n. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as `<script>` tags in your HTML page.\n\nJust like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.\n\n[](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#pitfalls-of-namespaces-and-modules)\nPitfalls of Namespaces and Modules\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them.\n\n### [](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#-reference-ing-a-module)\n`/// <reference>`\\-ing a module\n\nA common mistake is to try to use the `/// <reference ... />` syntax to refer to a module file, rather than using an `import` statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an `import` (e.g. the `...` in `import x from \"...\";`, `import x = require(\"...\");`, etc.) path.\n\nThe compiler will try to find a `.ts`, `.tsx`, and then a `.d.ts` with the appropriate path. If a specific file could not be found, then the compiler will look for an _ambient module declaration_. Recall that these need to be declared in a `.d.ts` file.\n\n*   `myModules.d.ts`\n    \n    ts\n    \n    `   // In a .d.ts file or .ts file that is not a module:  declare module \"SomeModule\" {    export function fn(): string;  }   `\n    \n*   `myOtherModule.ts`\n    \n    ts\n    \n    `   /// <reference path=\"myModules.d.ts\" />  import * as m from \"SomeModule\";   `\n    \n\nThe reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the `node.d.ts` file that several of the TypeScript samples use is consumed.\n\n### [](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#needless-namespacing)\nNeedless Namespacing\n\nIf you’re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:\n\n*   `shapes.ts`\n    \n    ts\n    \n    `   export namespace Shapes {    export class Triangle {      /* ... */    }    export class Square {      /* ... */    }  }   `\n    \n\nThe top-level namespace here `Shapes` wraps up `Triangle` and `Square` for no reason. This is confusing and annoying for consumers of your module:\n\n*   `shapeConsumer.ts`\n    \n    ts\n    \n    `   import * as shapes from \"./shapes\";  let t = new shapes.Shapes.Triangle(); // shapes.Shapes?   `\n    \n\nA key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there’s no need to proactively wrap up the exported symbols in a namespace.\n\nTo reiterate why you shouldn’t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it’s unnecessary to use an additional module layer for exported objects.\n\nHere’s a revised example:\n\n*   `shapes.ts`\n    \n    ts\n    \n    `   export class Triangle {    /* ... */  }  export class Square {    /* ... */  }   `\n    \n*   `shapeConsumer.ts`\n    \n    ts\n    \n    `   import * as shapes from \"./shapes\";  let t = new shapes.Triangle();   `\n    \n\n### [](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#trade-offs-of-modules)\nTrade-offs of Modules\n\nJust as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it’s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can’t use the [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)\n option while targeting `commonjs` or `umd`, but with TypeScript 1.8 and later, [it’s possible](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile)\n to use [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)\n when targeting `amd` or `system`.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Namespaces%20and%20Modules.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (63)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)\n\nOT![Orta Therox  (19)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nMH![Mohamed Hegazy  (19)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nB![Bohdan  (2)](https://gravatar.com/avatar/2916a456fdc3dc7ba3cf8ec986c5b0913506db5ab2eff49b467085afc9de4d6d?s=32&&d=blank)\n\nMF![Martin Fischer  (1)](https://gravatar.com/avatar/dc885100e48a5949f1a44bcd6fce398735ff3294f20607ddee8bb45acb29601a?s=32&&d=blank)\n\n15+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"How to organize code in TypeScript via modules or namespaces","twitter:site":"typescriptlang","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","generator":"Gatsby 5.13.5","title":"TypeScript: Documentation - Namespaces and Modules","og:description":"How to organize code in TypeScript via modules or namespaces","description":"How to organize code in TypeScript via modules or namespaces","og:title":"Documentation - Namespaces and Modules","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","ogTitle":"Documentation - Namespaces and Modules","scrapeId":"1d8200b8-cc68-41c8-8be6-d0666787e188","sourceURL":"https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html","url":"https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nSymbols\n=======\n\nStarting with ECMAScript 2015, `symbol` is a primitive data type, just like `number` and `string`.\n\n`symbol` values are created by calling the `Symbol` constructor.\n\nts\n\n`   let sym1 = Symbol();  let sym2 = Symbol(\"key\"); // optional string key   `\n\nSymbols are immutable, and unique.\n\nts\n\n`   let sym2 = Symbol(\"key\");  let sym3 = Symbol(\"key\");  sym2 === sym3; // false, symbols are unique   `\n\nJust like strings, symbols can be used as keys for object properties.\n\nts\n\n`   const sym = Symbol();  let obj = {    [sym]: \"value\",  };  console.log(obj[sym]); // \"value\"   `\n\nSymbols can also be combined with computed property declarations to declare object properties and class members.\n\nts\n\n`   const getClassNameSymbol = Symbol();  class C {    [getClassNameSymbol]() {      return \"C\";    }  }  let c = new C();  let className = c[getClassNameSymbol](); // \"C\"   `\n\n[](https://www.typescriptlang.org/docs/handbook/symbols.html#unique-symbol)\n`unique symbol`\n-------------------------------------------------------------------------------------------\n\nTo enable treating symbols as unique literals a special type `unique symbol` is available. `unique symbol` is a subtype of `symbol`, and are produced only from calling `Symbol()` or `Symbol.for()`, or from explicit type annotations. This type is only allowed on `const` declarations and `readonly static` properties, and in order to reference a specific unique symbol, you’ll have to use the `typeof` operator. Each reference to a unique symbol implies a completely unique identity that’s tied to a given declaration.\n\nts\n\n`   declare const sym1: unique symbol;  // sym2 can only be a constant reference.  let sym2: unique symbol = Symbol();  A variable whose type is a 'unique symbol' type must be 'const'.1332A variable whose type is a 'unique symbol' type must be 'const'.  // Works - refers to a unique symbol, but its identity is tied to 'sym1'.  let sym3: typeof sym1 = sym1;  // Also works.  class C {    static readonly StaticSymbol: unique symbol = Symbol();  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwGYMCYBQATSAYwBsBDaSUIuAO0QBdREBPAWzVQFdaBLARy5VWbAEZwSAbly4QzdtmplaoOiRahRVMtTqNlTSgDMYkWkUgA6XCUhMR2bn0HD24kqAC8oAMpuJABQAlNKyYADqCADWiKAAtKDGMLEMcKA6PAJC8mISADSaXEy8DLG8hLQMJRq8KbyQ+KCpoADkImgt1rb27BioDCwADpBwRjloXuOhcgCCJIhpAO7RiNakZIixAMKgAN64oMwMZFVEiZBk+GoaPsenfrkkTlmuj5MP7sHSAL5AA)\n\nBecause each `unique symbol` has a completely separate identity, no two `unique symbol` types are assignable or comparable to each other.\n\nts\n\n`   const sym2 = Symbol();  const sym3 = Symbol();  if (sym2 === sym3) {  This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.2367This comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqIgJ4C2aoAvKAMq0BGcANgBQCUA3IRLlKtDIxbsufQXgCWAM1DdqdRgyaqMvUAG88oUCFAA6M3gC+QA)\n\n[](https://www.typescriptlang.org/docs/handbook/symbols.html#well-known-symbols)\nWell-known Symbols\n---------------------------------------------------------------------------------------------------\n\nIn addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.\n\nHere is a list of well-known symbols:\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symbolasynciterator)\n`Symbol.asyncIterator`\n\nA method that returns async iterator for an object, compatible to be used with for await..of loop.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symbolhasinstance)\n`Symbol.hasInstance`\n\nA method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symbolisconcatspreadable)\n`Symbol.isConcatSpreadable`\n\nA Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symboliterator)\n`Symbol.iterator`\n\nA method that returns the default iterator for an object. Called by the semantics of the for-of statement.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symbolmatch)\n`Symbol.match`\n\nA regular expression method that matches the regular expression against a string. Called by the `String.prototype.match` method.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symbolreplace)\n`Symbol.replace`\n\nA regular expression method that replaces matched substrings of a string. Called by the `String.prototype.replace` method.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symbolsearch)\n`Symbol.search`\n\nA regular expression method that returns the index within a string that matches the regular expression. Called by the `String.prototype.search` method.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symbolspecies)\n`Symbol.species`\n\nA function valued property that is the constructor function that is used to create derived objects.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symbolsplit)\n`Symbol.split`\n\nA regular expression method that splits a string at the indices that match the regular expression. Called by the `String.prototype.split` method.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symboltoprimitive)\n`Symbol.toPrimitive`\n\nA method that converts an object to a corresponding primitive value. Called by the `ToPrimitive` abstract operation.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symboltostringtag)\n`Symbol.toStringTag`\n\nA String value that is used in the creation of the default string description of an object. Called by the built-in method `Object.prototype.toString`.\n\n### [](https://www.typescriptlang.org/docs/handbook/symbols.html#symbolunscopables)\n`Symbol.unscopables`\n\nAn Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Symbols.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (52)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nGB![Gabriel Burdeti  (2)](https://gravatar.com/avatar/28ff7ada33ca80bfae575ae1321176ca?s=32&&d=blank)\n\nMF![Martin Fischer  (1)](https://gravatar.com/avatar/dc885100e48a5949f1a44bcd6fce398735ff3294f20607ddee8bb45acb29601a?s=32&&d=blank)\n\nMN![Michał Niedziółka  (1)](https://gravatar.com/avatar/a81dcd12df064679e9cac9bea9ec537be93967fb2f04b256aef9f338e97c3183?s=32&&d=blank)\n\n9+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - Symbols","ogDescription":"Using the JavaScript Symbol primitive in TypeScript","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","og:title":"Documentation - Symbols","twitter:site":"typescriptlang","og:description":"Using the JavaScript Symbol primitive in TypeScript","generator":"Gatsby 5.13.5","title":"TypeScript: Documentation - Symbols","language":"en","description":"Using the JavaScript Symbol primitive in TypeScript","scrapeId":"ce22f2ac-f4f7-432e-9f6a-e09a997c3f53","sourceURL":"https://www.typescriptlang.org/docs/handbook/symbols.html","url":"https://www.typescriptlang.org/docs/handbook/symbols.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModules - Introduction\n======================\n\nThis document is divided into four sections:\n\n1.  The first section develops the [**theory**](https://www.typescriptlang.org/docs/handbook/modules/theory.html)\n     behind how TypeScript approaches modules. If you want to be able to write the correct module-related compiler options for any situation, reason about how to integrate TypeScript with other tools, or understand how TypeScript processes dependency packages, this is the place to start. While there are guides and reference pages on these topics, building an understanding of these fundamentals will make reading the guides easier, and give you a mental framework for dealing with real-world problems not specifically covered here.\n2.  The [**guides**](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html)\n     show how to accomplish specific real-world tasks, starting with picking the right compilation settings for a new project. The guides are a good place to start both for beginners who want to get up and running as quickly as possible and for experts who already have a good grasp of the theory but want concrete guidance on a complicated task.\n3.  The [**reference**](https://www.typescriptlang.org/docs/handbook/modules/reference.html)\n     section provides a more detailed look at the syntaxes and configurations presented in previous sections.\n4.  The [**appendices**](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html)\n     cover complicated topics that deserve additional explanation in more detail than the theory or reference sections allow.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/modules-reference/Introduction.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (6)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"How TypeScript models JavaScript modules","og:title":"Documentation - Modules - Introduction","ogDescription":"How TypeScript models JavaScript modules","theme-color":"#3178C6","language":"en","og:description":"How TypeScript models JavaScript modules","twitter:site":"typescriptlang","title":"TypeScript: Documentation - Modules - Introduction","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogTitle":"Documentation - Modules - Introduction","scrapeId":"e1dca4b6-cebb-44a3-a2d0-77d8c69cdff0","sourceURL":"https://www.typescriptlang.org/docs/handbook/modules/introduction.html","url":"https://www.typescriptlang.org/docs/handbook/modules/introduction.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTriple-Slash Directives\n=======================\n\nTriple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.\n\nTriple-slash directives are **only** valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.\n\nAs of TypeScript 5.5, the compiler does not generate reference directives, and does _not_ emit handwritten triple-slash directives to output files unless those directives are marked as [`preserve=\"true\"`](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#preservetrue)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-path-)\n`/// <reference path=\"...\" />`\n-----------------------------------------------------------------------------------------------------------------------------\n\nThe `/// <reference path=\"...\" />` directive is the most common of this group. It serves as a declaration of _dependency_ between files.\n\nTriple-slash references instruct the compiler to include additional files in the compilation process.\n\nThey also serve as a method to order the output when using [`out`](https://www.typescriptlang.org/tsconfig#out)\n or [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)\n. Files are emitted to the output file location in the same order as the input after preprocessing pass.\n\n### [](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#preprocessing-input-files)\nPreprocessing input files\n\nThe compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.\n\nThe process starts with a set of _root files_; these are the file names specified on the command-line or in the [`files`](https://www.typescriptlang.org/tsconfig#files)\n list in the `tsconfig.json` file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth-first manner, in the order they have been seen in the file.\n\nA triple-slash reference path is resolved relative to the containing file, if a relative path is used.\n\n### [](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#errors)\nErrors\n\nIt is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.\n\n### [](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#using---noresolve)\nUsing `--noResolve`\n\nIf the compiler flag [`noResolve`](https://www.typescriptlang.org/tsconfig#noResolve)\n is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.\n\n[](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-types-)\n`/// <reference types=\"...\" />`\n-------------------------------------------------------------------------------------------------------------------------------\n\nSimilar to a `/// <reference path=\"...\" />` directive, which serves as a declaration of _dependency_, a `/// <reference types=\"...\" />` directive declares a dependency on a package.\n\nThe process of resolving these package names is similar to the process of resolving module names in an `import` statement. An easy way to think of triple-slash-reference-types directives are as an `import` for declaration packages.\n\nFor example, including `/// <reference types=\"node\" />` in a declaration file declares that this file uses names declared in `@types/node/index.d.ts`; and thus, this package needs to be included in the compilation along with the declaration file.\n\nFor declaring a dependency on an `@types` package in a `.ts` file, use [`types`](https://www.typescriptlang.org/tsconfig#types)\n on the command line or in your `tsconfig.json` instead. See [using `@types`, `typeRoots` and `types` in `tsconfig.json` files](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types)\n for more details.\n\n[](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-lib-)\n`/// <reference lib=\"...\" />`\n---------------------------------------------------------------------------------------------------------------------------\n\nThis directive allows a file to explicitly include an existing built-in _lib_ file.\n\nBuilt-in _lib_ files are referenced in the same fashion as the [`lib`](https://www.typescriptlang.org/tsconfig#lib)\n compiler option in _tsconfig.json_ (e.g. use `lib=\"es2015\"` and not `lib=\"lib.es2015.d.ts\"`, etc.).\n\nFor declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like `Symbol` or `Iterable`, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.\n\nFor example, adding `/// <reference lib=\"es2017.string\" />` to one of the files in a compilation is equivalent to compiling with `--lib es2017.string`.\n\nts\n\n`   /// <reference lib=\"es2017.string\" />  \"foo\".padStart(4);   `\n\n[](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-no-default-libtrue)\n`/// <reference no-default-lib=\"true\"/>`\n----------------------------------------------------------------------------------------------------------------------------------------------------\n\nThis directive marks a file as a _default library_. You will see this comment at the top of `lib.d.ts` and its different variants.\n\nThis directive instructs the compiler to _not_ include the default library (i.e. `lib.d.ts`) in the compilation. The impact here is similar to passing [`noLib`](https://www.typescriptlang.org/tsconfig#noLib)\n on the command line.\n\nAlso note that when passing [`skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig#skipDefaultLibCheck)\n, the compiler will only skip checking files with `/// <reference no-default-lib=\"true\"/>`.\n\n[](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-amd-module-)\n`/// <amd-module />`\n---------------------------------------------------------------------------------------------------------------\n\nBy default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. `r.js`).\n\nThe `amd-module` directive allows passing an optional module name to the compiler:\n\n##### [](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#amdmodulets)\namdModule.ts\n\nts\n\n`   /// <amd-module name=\"NamedModule\"/>  export class C {}   `\n\nWill result in assigning the name `NamedModule` to the module as part of calling the AMD `define`:\n\n##### [](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#amdmodulejs)\namdModule.js\n\njs\n\n`   define(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {    var C = (function () {      function C() {}      return C;    })();    exports.C = C;  });   `\n\n[](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-amd-dependency-)\n`/// <amd-dependency />`\n-----------------------------------------------------------------------------------------------------------------------\n\n> **Note**: this directive has been deprecated. Use `import \"moduleName\";` statements instead.\n\n`/// <amd-dependency path=\"x\" />` informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call.\n\nThe `amd-dependency` directive can also have an optional `name` property; this allows passing an optional name for an amd-dependency:\n\nts\n\n`   /// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>  declare var moduleA: MyType;  moduleA.callStuff();   `\n\nGenerated JS code:\n\njs\n\n`   define([\"require\", \"exports\", \"legacy/moduleA\"], function (    require,    exports,    moduleA  ) {    moduleA.callStuff();  });   `\n\n[](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#preservetrue)\n`preserve=\"true\"`\n------------------------------------------------------------------------------------------------------------\n\nTriple-slash directives can be marked with `preserve=\"true\"` to prevent the compiler from removing them from the output.\n\nFor example, these will be erased in the output:\n\nts\n\n`   /// <reference path=\"...\" />  /// <reference types=\"...\" />  /// <reference lib=\"...\" />   `\n\nBut these will be preserved:\n\nts\n\n`   /// <reference path=\"...\" preserve=\"true\" />  /// <reference types=\"...\" preserve=\"true\" />  /// <reference lib=\"...\" preserve=\"true\" />   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Triple-Slash%20Directives.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (58)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nJB![Jake Bailey  (1)](https://gravatar.com/avatar/127e9f47eb2768eae31eb5809ae4f1ca44336bc51e45473c68ebb9648608f590?s=32&&d=blank)\n\nJM![Juyeong Maing  (1)](https://gravatar.com/avatar/82b933806aef55677be868bb2b9f704baf03ff767bd90111f4626f02164d558b?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\n10+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","title":"TypeScript: Documentation - Triple-Slash Directives","description":"How to use triple slash directives in TypeScript","ogTitle":"Documentation - Triple-Slash Directives","og:title":"Documentation - Triple-Slash Directives","og:description":"How to use triple slash directives in TypeScript","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"How to use triple slash directives in TypeScript","generator":"Gatsby 5.13.5","scrapeId":"78612e9f-0fef-453b-b75a-82b1f659d8b1","sourceURL":"https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html","url":"https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModules - Choosing Compiler Options\n===================================\n\n[](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-writing-an-app)\nI’m writing an app\n-----------------------------------------------------------------------------------------------------------------------------------\n\nA single tsconfig.json can only represent a single environment, both in terms of what globals are available and in terms of how modules behave. If your app contains server code, DOM code, web worker code, test code, and code to be shared by all of those, each of those should have its own tsconfig.json, connected with [project references](https://www.typescriptlang.org/docs/handbook/project-references.html#handbook-content)\n. Then, use this guide once for each tsconfig.json. For library-like projects within an app, especially ones that need to run in multiple runtime environments, use the “[I’m writing a library](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-writing-a-library)\n” section.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-using-a-bundler)\nI’m using a bundler\n\nIn addition to adopting the following settings, it’s also recommended _not_ to set `{ \"type\": \"module\" }` or use `.mts` files in bundler projects for now. [Some bundlers](https://andrewbranch.github.io/interop-test/#synthesizing-default-exports-for-cjs-modules)\n adopt different ESM/CJS interop behavior under these circumstances, which TypeScript cannot currently analyze with `\"moduleResolution\": \"bundler\"`. See [issue #54102](https://github.com/microsoft/TypeScript/issues/54102)\n for more information.\n\njson\n\n``   {    \"compilerOptions\": {      // This is not a complete template; it only      // shows relevant module-related settings.      // Be sure to set other important options      // like `target`, `lib`, and `strict`.      // Required      \"module\": \"esnext\",      \"moduleResolution\": \"bundler\",      \"esModuleInterop\": true,      // Consult your bundler’s documentation      \"customConditions\": [\"module\"],      // Recommended      \"noEmit\": true, // or `emitDeclarationOnly`      \"allowImportingTsExtensions\": true,      \"allowArbitraryExtensions\": true,      \"verbatimModuleSyntax\": true, // or `isolatedModules`    }  }   ``\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-compiling-and-running-the-outputs-in-nodejs)\nI’m compiling and running the outputs in Node.js\n\nRemember to set `\"type\": \"module\"` or use `.mts` files if you intend to emit ES modules.\n\njson\n\n``   {    \"compilerOptions\": {      // This is not a complete template; it only      // shows relevant module-related settings.      // Be sure to set other important options      // like `target`, `lib`, and `strict`.      // Required      \"module\": \"nodenext\",      // Implied by `\"module\": \"nodenext\"`:      // \"moduleResolution\": \"nodenext\",      // \"esModuleInterop\": true,      // \"target\": \"esnext\",      // Recommended      \"verbatimModuleSyntax\": true,    }  }   ``\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-using-ts-node)\nI’m using ts-node\n\nts-node attempts to be compatible with the same code and the same tsconfig.json settings that can be used to [compile and run the JS outputs in Node.js](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-compiling-and-running-the-outputs-in-node)\n. Refer to [ts-node documentation](https://typestrong.org/ts-node/)\n for more details.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-using-tsx)\nI’m using tsx\n\nWhereas ts-node makes minimal modifications to Node.js’s module system by default, [tsx](https://github.com/esbuild-kit/tsx)\n behaves more like a bundler, allowing extensionless/index module specifiers and arbitrary mixing of ESM and CJS. Use the same settings for tsx as you [would for a bundler](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-using-a-bundler)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-writing-es-modules-for-the-browser-with-no-bundler-or-module-compiler)\nI’m writing ES modules for the browser, with no bundler or module compiler\n\nTypeScript does not currently have options dedicated to this scenario, but you can approximate them by using a combination of the `nodenext` ESM module resolution algorithm and `paths` as a substitute for URL and import map support.\n\njson\n\n``   // tsconfig.json  {    \"compilerOptions\": {      // This is not a complete template; it only      // shows relevant module-related settings.      // Be sure to set other important options      // like `target`, `lib`, and `strict`.      // Combined with `\"type\": \"module\"` in a local package.json,      // this enforces including file extensions on relative path imports.      \"module\": \"nodenext\",      \"paths\": {        // Point TS to local types for remote URLs:        \"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"],        // Optional: point bare specifier imports to an empty file        // to prohibit importing from node_modules specifiers not listed here:        \"*\": [\"./empty-file.ts\"]      }    }  }   ``\n\nThis setup allows explicitly listed HTTPS imports to use locally-installed type declaration files, while erroring on imports that would normally resolve in node\\_modules:\n\nts\n\n`   import {} from \"lodash\";  //             ^^^^^^^^  // File '/project/empty-file.ts' is not a module. ts(2306)   `\n\nAlternatively, you can use [import maps](https://github.com/WICG/import-maps)\n to explicitly map a list of bare specifiers to URLs in the browser, while relying on `nodenext`’s default node\\_modules lookups, or on `paths`, to direct TypeScript to type declaration files for those bare specifier imports:\n\nhtml\n\n`   <script type=\"importmap\">  {    \"imports\": {      \"lodash\": \"https://esm.sh/lodash@4.17.21\"    }  }  </script>   `\n\nts\n\n`   import {} from \"lodash\";  // Browser: https://esm.sh/lodash@4.17.21  // TypeScript: ./node_modules/@types/lodash/index.d.ts   `\n\n[](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#im-writing-a-library)\nI’m writing a library\n-----------------------------------------------------------------------------------------------------------------------------------------\n\nChoosing compilation settings as a library author is a fundamentally different process from choosing settings as an app author. When writing an app, settings are chosen that reflect the runtime environment or bundler—typically a single entity with known behavior. When writing a library, you would ideally check your code under _all possible_ library consumer compilation settings. Since this is impractical, you can instead use the strictest possible settings, since satisfying those tends to satisfy all others.\n\njson\n\n`   {    \"compilerOptions\": {      \"module\": \"node18\",      \"target\": \"es2020\", // set to the *lowest* target you support      \"strict\": true,      \"verbatimModuleSyntax\": true,      \"declaration\": true,      \"sourceMap\": true,      \"declarationMap\": true,      \"rootDir\": \"src\",      \"outDir\": \"dist\"    }  }   `\n\nLet’s examine why we picked each of these settings:\n\n*   **`module: \"node18\"`**. When a codebase is compatible with Node.js’s module system, it almost always works in bundlers as well. If you’re using a third-party emitter to emit ESM outputs, ensure that you set `\"type\": \"module\"` in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let’s look at what would happen if a library were to compile with `\"moduleResolution\": \"bundler\"`:\n    \n    ts\n    \n    `   export * from \"./utils\";   `\n    \n    Assuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine with this code, so `\"moduleResolution\": \"bundler\"` doesn’t complain. Compiled with `\"module\": \"esnext\"`, the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n    \n    `   Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js  Did you mean to import ./utils.js?   `\n    \n    On the other hand, if we had written:\n    \n    ts\n    \n    `   export * from \"./utils.js\";   `\n    \n    This would produce output that works both in Node.js _and_ in bundlers.\n    \n    In short, `\"moduleResolution\": \"bundler\"` is infectious, allowing code that only works in bundlers to be produced. Likewise, `\"moduleResolution\": \"nodenext\"` is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n    \n*   **`target: \"es2020\"`**. Setting this value to the _lowest_ ECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Since `target` also implies a corresponding value for `lib`, this also ensures you don’t access globals that may not be available in older environments.\n    \n*   **`strict: true`**. Without this, you may write type-level code that ends up in your output `.d.ts` files and errors when a consumer compiles with `strict` enabled. For example, this `extends` clause:\n    \n    ts\n    \n    `   export interface Super {    foo: string;  }  export interface Sub extends Super {    foo: string | undefined;  }   `\n    \n    is only an error under `strictNullChecks`. On the other hand, it’s very difficult to write code that errors only when `strict` is _disabled_, so it’s highly recommended for libraries to compile with `strict`.\n    \n*   **`verbatimModuleSyntax: true`**. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user’s value of `esModuleInterop` or `allowSyntheticDefaultImports`. Previously, it was often suggested that libraries compile without `esModuleInterop`, since its use in libraries could force users to adopt it too. However, it’s also possible to write imports that only work _without_ `esModuleInterop`, so neither value for the setting guarantees portability for libraries. `verbatimModuleSyntax` does provide such a guarantee.[1](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#fn-1)\n     Second, it prevents the use of `export default` in modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix on [ESM/CJS Interop](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#library-code-needs-special-considerations)\n     for more details.\n    \n*   **`declaration: true`** emits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information.\n    \n*   **`sourceMap: true`** and **`declarationMap: true`** emit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (`.ts`) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it’s up to you whether to include them.\n    \n*   **`rootDir: \"src\"`** and **`outDir: \"dist\"`**. Using a separate output directory is always a good idea, but it’s _necessary_ for libraries that publish their input files. Otherwise, [extension substitution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n     will cause the library’s consumers to load the library’s `.ts` files instead of `.d.ts` files, causing type errors and performance problems.\n    \n\n### [](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#considerations-for-bundling-libraries)\nConsiderations for bundling libraries\n\nIf you’re using a bundler to emit your library, then all your (non-externalized) imports will be processed by the bundler with known behavior, not by your users’ unknowable environments. In this case, you can use `\"module\": \"esnext\"` and `\"moduleResolution\": \"bundler\"`, but only with two caveats:\n\n1.  TypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it’s common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user’s environment. To model this in TypeScript, you would want to process bundled imports with `\"moduleResolution\": \"bundler\"` and externalized imports with `\"moduleResolution\": \"nodenext\"` (or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using `\"moduleResolution\": \"bundler\"` may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using `\"moduleResolution\": \"nodenext\"` may impose overly strict requirements on bundled imports.\n    \n2.  You must ensure that your declaration files get bundled as well. Recall the [first rule of declaration files](https://www.typescriptlang.org/docs/handbook/modules/theory.html#the-role-of-declaration-files)\n    : every declaration file represents exactly one JavaScript file. If you use `\"moduleResolution\": \"bundler\"` and use a bundler to emit an ESM bundle while using `tsc` to emit many individual declaration files, your declaration files may cause errors when consumed under `\"module\": \"nodenext\"`. For example, an input file like:\n    \n    ts\n    \n    `   import { Component } from \"./extensionless-relative-import\";   `\n    \n    will have its import erased by the JS bundler, but produce a declaration file with an identical import statement. That import statement, however, will contain an invalid module specifier in Node.js, since it’s missing a file extension. For Node.js users, TypeScript will error on the declaration file and infect types referencing `Component` with `any`, assuming the dependency will crash at runtime.\n    \n    If your TypeScript bundler does not produce bundled declaration files, use `\"moduleResolution\": \"nodenext\"` to ensure that the imports preserved in your declaration files will be compatible with end-users’ TypeScript settings. Even better, consider not bundling your library.\n    \n\n### [](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#notes-on-dual-emit-solutions)\nNotes on dual-emit solutions\n\nA single TypeScript compilation (whether emitting or just type checking) assumes that each input file will only produce one output file. Even if `tsc` isn’t emitting anything, the type checking it performs on imported names rely on knowledge about how the output file will behave at runtime, based on the module- and emit-related options set in the tsconfig.json. While third-party emitters are generally safe to use in combination with `tsc` type checking as long as `tsc` can be configured to understand what the other emitter will emit, any solution that emits two different sets of outputs with different module formats while only type checking once leaves (at least) one of the outputs unchecked. Because external dependencies may expose different APIs to CommonJS and ESM consumers, there’s no configuration you can use to guarantee in a single compilation that both outputs will be type-safe. In practice, most dependencies follow best practices and dual-emit outputs work. Running tests and [static analysis](https://npmjs.com/package/@arethetypeswrong/cli)\n against all output bundles before publishing significantly reduces the chance of a serious problem going unnoticed.\n\n* * *\n\n1.  `verbatimModuleSyntax` can only work when the JS emitter emits the same module kind as `tsc` would given the tsconfig.json, source file extension, and package.json `\"type\"`. The option works by enforcing that the `import`/`require` written is identical to the `import`/`require` emitted. Any configuration that produces both an ESM and a CJS output from the same source file is fundamentally incompatible with `verbatimModuleSyntax`, since its whole purpose is to prevent you from writing `import` anywhere that a `require` would be emitted. `verbatimModuleSyntax` can also be defeated by configuring a third-party emitter to emit a different module kind than `tsc` would—for example, by setting `\"module\": \"esnext\"` in tsconfig.json while configuring Babel to emit CommonJS.[↩](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html#fnref-1)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/modules-reference/guides/Choosing%20Compiler%20Options.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (8)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nTM![Tom Mrazauskas  (1)](https://gravatar.com/avatar/e6eaf9e3aa9a4ec5d2f6d2eae9d727b0012154a255795d34bc8d8d1fe7de54c0?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:description":"How to choose compiler options that reflect your module environment","language":"en","title":"TypeScript: Documentation - Modules - Choosing Compiler Options","theme-color":"#3178C6","ogDescription":"How to choose compiler options that reflect your module environment","og:title":"Documentation - Modules - Choosing Compiler Options","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","generator":"Gatsby 5.13.5","twitter:site":"typescriptlang","description":"How to choose compiler options that reflect your module environment","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogTitle":"Documentation - Modules - Choosing Compiler Options","scrapeId":"3a5b5799-cdff-4094-8972-e37800dc08d6","sourceURL":"https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html","url":"https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nType Compatibility\n==================\n\nType compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:\n\nts\n\n`   interface Pet {    name: string;  }  class Dog {    name: string;  }  let pet: Pet;  // OK, because of structural typing  pet = new Dog();   `\n\nIn nominally-typed languages like C# or Java, the equivalent code would be an error because the `Dog` class does not explicitly describe itself as being an implementer of the `Pet` interface.\n\nTypeScript’s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it’s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.\n\n[](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness)\nA Note on Soundness\n----------------------------------------------------------------------------------------------------------------\n\nTypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them.\n\n[](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#starting-out)\nStarting out\n--------------------------------------------------------------------------------------------------\n\nThe basic rule for TypeScript’s structural type system is that `x` is compatible with `y` if `y` has at least the same members as `x`. For example consider the following code involving an interface named `Pet` which has a `name` property:\n\nts\n\n`   interface Pet {    name: string;  }  let pet: Pet;  // dog's inferred type is { name: string; owner: string; }  let dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };  pet = dog;   `\n\nTo check whether `dog` can be assigned to `pet`, the compiler checks each property of `pet` to find a corresponding compatible property in `dog`. In this case, `dog` must have a member called `name` that is a string. It does, so the assignment is allowed.\n\nThe same rule for assignment is used when checking function call arguments:\n\nts\n\n`   interface Pet {    name: string;  }  let dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };  function greet(pet: Pet) {    console.log(\"Hello, \" + pet.name);  }  greet(dog); // OK   `\n\nNote that `dog` has an extra `owner` property, but this does not create an error. Only members of the target type (`Pet` in this case) are considered when checking for compatibility. This comparison process proceeds recursively, exploring the type of each member and sub-member.\n\nBe aware, however, that object literals [may only specify known properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#excess-property-checks)\n. For example, because we have explicitly specified that `dog` is of type `Pet`, the following code is invalid:\n\nts\n\n`   let dog: Pet = { name: \"Lassie\", owner: \"Rudd Weatherwax\" }; // Error   `\n\n[](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#comparing-two-functions)\nComparing two functions\n------------------------------------------------------------------------------------------------------------------------\n\nWhile comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let’s start with a basic example of two functions that differ only in their parameter lists:\n\nts\n\n`   let x = (a: number) => 0;  let y = (b: number, s: string) => 0;  y = x; // OK  x = y; // Error   `\n\nTo check if `x` is assignable to `y`, we first look at the parameter list. Each parameter in `x` must have a corresponding parameter in `y` with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of `x` has a corresponding compatible parameter in `y`, so the assignment is allowed.\n\nThe second assignment is an error, because `y` has a required second parameter that `x` does not have, so the assignment is disallowed.\n\nYou may be wondering why we allow ‘discarding’ parameters like in the example `y = x`. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, `Array#forEach` provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it’s very useful to provide a callback that only uses the first parameter:\n\nts\n\n`   let items = [1, 2, 3];  // Don't force these extra parameters  items.forEach((item, index, array) => console.log(item));  // Should be OK!  items.forEach((item) => console.log(item));   `\n\nNow let’s look at how return types are treated, using two functions that differ only by their return type:\n\nts\n\n`   let x = () => ({ name: \"Alice\" });  let y = () => ({ name: \"Alice\", location: \"Seattle\" });  x = y; // OK  y = x; // Error, because x() lacks a location property   `\n\nThe type system enforces that the source function’s return type be a subtype of the target type’s return type.\n\n### [](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#function-parameter-bivariance)\nFunction Parameter Bivariance\n\nWhen comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:\n\nts\n\n`   enum EventType {    Mouse,    Keyboard,  }  interface Event {    timestamp: number;  }  interface MyMouseEvent extends Event {    x: number;    y: number;  }  interface MyKeyEvent extends Event {    keyCode: number;  }  function listenEvent(eventType: EventType, handler: (n: Event) => void) {    /* ... */  }  // Unsound, but useful and common  listenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + \",\" + e.y));  // Undesirable alternatives in presence of soundness  listenEvent(EventType.Mouse, (e: Event) =>    console.log((e as MyMouseEvent).x + \",\" + (e as MyMouseEvent).y)  );  listenEvent(EventType.Mouse, ((e: MyMouseEvent) =>    console.log(e.x + \",\" + e.y)) as (e: Event) => void);  // Still disallowed (clear error). Type safety enforced for wholly incompatible types  listenEvent(EventType.Mouse, (e: number) => console.log(e));   `\n\nYou can have TypeScript raise errors when this happens via the compiler flag [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#optional-parameters-and-rest-parameters)\nOptional Parameters and Rest Parameters\n\nWhen comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.\n\nWhen a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.\n\nThis is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing `undefined` in that position is equivalent for most functions.\n\nThe motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:\n\nts\n\n`   function invokeLater(args: any[], callback: (...args: any[]) => void) {    /* ... Invoke callback with 'args' ... */  }  // Unsound - invokeLater \"might\" provide any number of arguments  invokeLater([1, 2], (x, y) => console.log(x + \", \" + y));  // Confusing (x and y are actually required) and undiscoverable  invokeLater([1, 2], (x?, y?) => console.log(x + \", \" + y));   `\n\n### [](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#functions-with-overloads)\nFunctions with overloads\n\nWhen a function has overloads, each overload in the target type must be matched by a compatible signature on the source type. This ensures that the source function can be called in all the same cases as the target function.\n\n[](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#enums)\nEnums\n------------------------------------------------------------------------------------\n\nEnums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,\n\nts\n\n`   enum Status {    Ready,    Waiting,  }  enum Color {    Red,    Blue,    Green,  }  let status = Status.Ready;  status = Color.Green; // Error   `\n\n[](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#classes)\nClasses\n----------------------------------------------------------------------------------------\n\nClasses work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.\n\nts\n\n`   class Animal {    feet: number;    constructor(name: string, numFeet: number) {}  }  class Size {    feet: number;    constructor(numFeet: number) {}  }  let a: Animal;  let s: Size;  a = s; // OK  s = a; // OK   `\n\n### [](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#private-and-protected-members-in-classes)\nPrivate and protected members in classes\n\nPrivate and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but _not_ with classes from a different inheritance hierarchy which otherwise have the same shape.\n\n[](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#generics)\nGenerics\n------------------------------------------------------------------------------------------\n\nBecause TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,\n\nts\n\n`   interface Empty<T> {}  let x: Empty<number>;  let y: Empty<string>;  x = y; // OK, because y matches structure of x   `\n\nIn the above, `x` and `y` are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to `Empty<T>` shows how this works:\n\nts\n\n`   interface NotEmpty<T> {    data: T;  }  let x: NotEmpty<number>;  let y: NotEmpty<string>;  x = y; // Error, because x and y are not compatible   `\n\nIn this way, a generic type that has its type arguments specified acts just like a non-generic type.\n\nFor generic types that do not have their type arguments specified, compatibility is checked by specifying `any` in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.\n\nFor example,\n\nts\n\n`   let identity = function <T>(x: T): T {    // ...  };  let reverse = function <U>(y: U): U {    // ...  };  identity = reverse; // OK, because (x: any) => any matches (y: any) => any   `\n\n[](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#advanced-topics)\nAdvanced Topics\n--------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#subtype-vs-assignment)\nSubtype vs Assignment\n\nSo far, we’ve used “compatible”, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from `any`, and to and from `enum` with corresponding numeric values.\n\nDifferent places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the `implements` and `extends` clauses.\n\n[](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#any-unknown-object-void-undefined-null-and-never-assignability)\n`any`, `unknown`, `object`, `void`, `undefined`, `null`, and `never` assignability\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThe following table summarizes assignability between some abstract types. Rows indicate what each is assignable to, columns indicate what is assignable to them. A ”✓” indicates a combination that is compatible only when [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n is off.\n\n|     | any | unknown | object | void | undefined | null | never |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| any → |     | ✓   | ✓   | ✓   | ✓   | ✓   | ✕   |\n| unknown → | ✓   |     | ✕   | ✕   | ✕   | ✕   | ✕   |\n| object → | ✓   | ✓   |     | ✕   | ✕   | ✕   | ✕   |\n| void → | ✓   | ✓   | ✕   |     | ✕   | ✕   | ✕   |\n| undefined → | ✓   | ✓   | ✓   | ✓   |     | ✓   | ✕   |\n| null → | ✓   | ✓   | ✓   | ✓   | ✓   |     | ✕   |\n| never → | ✓   | ✓   | ✓   | ✓   | ✓   | ✓   |     |\n\nReiterating [The Basics](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)\n:\n\n*   Everything is assignable to itself.\n*   `any` and `unknown` are the same in terms of what is assignable to them, different in that `unknown` is not assignable to anything except `any`.\n*   `unknown` and `never` are like inverses of each other. Everything is assignable to `unknown`, `never` is assignable to everything. Nothing is assignable to `never`, `unknown` is not assignable to anything (except `any`).\n*   `void` is not assignable to or from anything, with the following exceptions: `any`, `unknown`, `never`, `undefined`, and `null` (if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n     is off, see table for details).\n*   When [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n     is off, `null` and `undefined` are similar to `never`: assignable to most types, most types are not assignable to them. They are assignable to each other.\n*   When [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n     is on, `null` and `undefined` behave more like `void`: not assignable to or from anything, except for `any`, `unknown`, and `void` (`undefined` is always assignable to `void`).\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Type%20Compatibility.md)\n ❤\n\nContributors to this page:  \n\nRC![Ryan Cavanaugh  (51)](https://gravatar.com/avatar/b9d274ea3df40f132936da582f71b18f?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (19)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)\n\nOT![Orta Therox  (18)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nMH![Mohamed Hegazy  (4)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nJB![Jack Bates  (3)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\n26+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:title":"Documentation - Type Compatibility","description":"How type-checking works in TypeScript","og:description":"How type-checking works in TypeScript","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","title":"TypeScript: Documentation - Type Compatibility","language":"en","ogTitle":"Documentation - Type Compatibility","generator":"Gatsby 5.13.5","ogDescription":"How type-checking works in TypeScript","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","scrapeId":"21b0cf1a-b5bc-4d1d-bcdf-7c4029425d9e","sourceURL":"https://www.typescriptlang.org/docs/handbook/type-compatibility.html","url":"https://www.typescriptlang.org/docs/handbook/type-compatibility.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nType Inference\n==============\n\nIn TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code\n\nts\n\n`   let x = 3;       let x: number   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EGYDcAoA9GiEB6B+IA)\n\nThe type of the `x` variable is inferred to be `number`. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.\n\nIn most cases, type inference is straightforward. In the following sections, we’ll explore some of the nuances in how types are inferred.\n\n[](https://www.typescriptlang.org/docs/handbook/type-inference.html#best-common-type)\nBest common type\n------------------------------------------------------------------------------------------------------\n\nWhen a type inference is made from several expressions, the types of those expressions are used to calculate a “best common type”. For example,\n\nts\n\n`   let x = [0, 1, null];       let x: (number | null)[]   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EG0AMAaCBGNA7ArsYAugNwBQA9GRBAHoD8QA)\n\nTo infer the type of `x` in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: `number` and `null`. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.\n\nBecause the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:\n\nts\n\n`   let zoo = [new Rhino(), new Elephant(), new Snake()];        let zoo: (Rhino | Elephant | Snake)[]   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35BAF5QAG0qPAB3Ll4BAAoASgAaUE6e8ysbaCHR8cjo2KGAXQNixVAAPQB+IA)\n\nIdeally, we may want `zoo` to be inferred as an `Animal[]`, but because there is no object that is strictly of type `Animal` in the array, we make no inference about the array element type. To correct this, explicitly provide the type when no one type is a super type of all other candidates:\n\nts\n\n`   let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];        let zoo: Animal[]   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35+NBlXAG0AXVAAXlA2qjwAdy5eAQAKAEoAGlAB4fMrG2hJmbnI6NjJjoNixVAAPQB+IA)\n\nWhen no best common type is found, the resulting inference is the union array type, `(Rhino | Elephant | Snake)[]`.\n\n[](https://www.typescriptlang.org/docs/handbook/type-inference.html#contextual-typing)\nContextual Typing\n--------------------------------------------------------------------------------------------------------\n\nType inference also works in “the other direction” in some cases in TypeScript. This is known as “contextual typing”. Contextual typing occurs when the type of an expression is implied by its location. For example:\n\nts\n\n`   window.onmousedown = function (mouseEvent) {    console.log(mouseEvent.button);    console.log(mouseEvent.kangaroo);  Property 'kangaroo' does not exist on type 'MouseEvent'.2339Property 'kangaroo' does not exist on type 'MouseEvent'.  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQB3ASwDsATOfAOjmIFs4BXRSc-Y0AXlADMHiBjAC6EaoABT0mkAKIA3SMUEBKUAG9coUPxqI4AG0iU9cAOYTGzOQsGUARg0GCaSgNwatO-YeNnJl+YqUANYAhsQmIfBwrrgAvi5AA)\n\nHere, the TypeScript type checker used the type of the `Window.onmousedown` function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the [type](https://developer.mozilla.org/docs/Web/API/MouseEvent)\n of the `mouseEvent` parameter, which does contain a `button` property, but not a `kangaroo` property.\n\nThis works because window already has `onmousedown` declared in its type:\n\nts\n\n`   // Declares there is a global variable called 'window'  declare var window: Window & typeof globalThis;  // Which is declared as (simplified):  interface Window extends GlobalEventHandlers {    // ...  }  // Which defines a lot of known handler events  interface GlobalEventHandlers {    onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;    // ...  }   `\n\nTypeScript is smart enough to infer types in other contexts as well:\n\nts\n\n`   window.onscroll = function (uiEvent) {    console.log(uiEvent.button);  Property 'button' does not exist on type 'Event'.2339Property 'button' does not exist on type 'Event'.  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQB3ASwDsATOfAOjmMQGN4AbR0AXlADMBXYugF0I1QACi6EAogDdIxPgEpQAb1yhQdGojiNIlRnADmoidNmUARlz58acgNy4AvraA)\n\nBased on the fact that the above function is being assigned to `Window.onscroll`, TypeScript knows that `uiEvent` is a [UIEvent](https://developer.mozilla.org/docs/Web/API/UIEvent)\n, and not a [MouseEvent](https://developer.mozilla.org/docs/Web/API/MouseEvent)\n like the previous example. `UIEvent` objects contain no `button` property, and so TypeScript will throw an error.\n\nIf this function were not in a contextually typed position, the function’s argument would implicitly have type `any`, and no error would be issued (unless you are using the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n option):\n\nts\n\n`   const handler = function (uiEvent) {    console.log(uiEvent.button); // <- OK  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFDrSSVagAWZkAJstQE6gBeUgFdI6LKkagAFMNQBRAG7VIWAJSgA3rVCgGTaDwB0yaAHNZC5aqMAjYViyM1AblAhQAHgC0oAPIA0rQAvi5AA)\n\nWe can also explicitly give type information to the function’s argument to override any contextual type:\n\nts\n\n`   window.onscroll = function (uiEvent: any) {    console.log(uiEvent.button); // <- Now, no error is given  };   `[Try](https://www.typescriptlang.org/play/#code/O4SwdgJg9sB0VgM4GMBOUA2GAEBebAZgK5jIAuIC2AFESAKIBuApmGQFzYCGYAngJTYA3gChs2ZAkSZmsDFADmtBizawARkTJkE-ANzYA9IewAeALTYAcjAA02MFGzNU6VNhCJsCkKpEBfPSA)\n\nHowever, this code will log `undefined`, since `uiEvent` has no property called `button`.\n\nContextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:\n\nts\n\n`   function createZoo(): Animal[] {    return [new Rhino(), new Elephant(), new Snake()];  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCdD9keH4qUERYPEwxAC1+fgAKAEo0GVcAbQBdd0U26G0NUBGqPAB3Ll4BAYAaUEWV8ysbaE3t5cjo2IGxg2YgA)\n\nIn this example, best common type has a set of four candidates: `Animal`, `Rhino`, `Elephant`, and `Snake`. Of these, `Animal` can be chosen by the best common type algorithm.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Type%20Inference.md)\n ❤\n\nContributors to this page:  \n\nRC![Ryan Cavanaugh  (51)](https://gravatar.com/avatar/b9d274ea3df40f132936da582f71b18f?s=32&&d=blank)\n\nOT![Orta Therox  (17)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nDR![Daniel Rosenwasser  (10)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)\n\nMH![Martin Hanzel  (2)](https://gravatar.com/avatar/306526665628a202cb974484101d3bcf?s=32&&d=blank)\n\nTLAT![Think Like a Techy  (1)](https://gravatar.com/avatar/051cbd071c53edcaa19993cdcdbebc8cd51817d51ce7683ac5cab5ae6c97732d?s=32&&d=blank)\n\n12+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:title":"Documentation - Type Inference","language":"en","description":"How code flow analysis works in TypeScript","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","og:description":"How code flow analysis works in TypeScript","generator":"Gatsby 5.13.5","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","title":"TypeScript: Documentation - Type Inference","ogTitle":"Documentation - Type Inference","ogDescription":"How code flow analysis works in TypeScript","theme-color":"#3178C6","scrapeId":"602857d1-e9c5-4da5-bf47-fc646c2787f9","sourceURL":"https://www.typescriptlang.org/docs/handbook/type-inference.html","url":"https://www.typescriptlang.org/docs/handbook/type-inference.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nVariable Declaration\n====================\n\n`let` and `const` are two relatively new concepts for variable declarations in JavaScript. [As we mentioned earlier](https://www.typescriptlang.org/docs/handbook/basic-types.html#a-note-about-let)\n, `let` is similar to `var` in some respects, but allows users to avoid some of the common “gotchas” that users run into in JavaScript.\n\n`const` is an augmentation of `let` in that it prevents re-assignment to a variable.\n\nWith TypeScript being an extension of JavaScript, the language naturally supports `let` and `const`. Here we’ll elaborate more on these new declarations and why they’re preferable to `var`.\n\nIf you’ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you’re intimately familiar with all the quirks of `var` declarations in JavaScript, you might find it easier to skip ahead.\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#var-declarations)\n`var` declarations\n---------------------------------------------------------------------------------------------------------------\n\nDeclaring a variable in JavaScript has always traditionally been done with the `var` keyword.\n\nts\n\n`   var a = 10;   `\n\nAs you might’ve figured out, we just declared a variable named `a` with the value `10`.\n\nWe can also declare a variable inside of a function:\n\nts\n\n`   function f() {    var message = \"Hello, world!\";    return message;  }   `\n\nand we can also access those same variables within other functions:\n\nts\n\n`   function f() {    var a = 10;    return function g() {      var b = a + 1;      return b;    };  }  var g = f();  g(); // returns '11'   `\n\nIn this above example, `g` captured the variable `a` declared in `f`. At any point that `g` gets called, the value of `a` will be tied to the value of `a` in `f`. Even if `g` is called once `f` is done running, it will be able to access and modify `a`.\n\nts\n\n`   function f() {    var a = 1;    a = 2;    var b = g();    a = 3;    return b;    function g() {      return a;    }  }  f(); // returns '2'   `\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#scoping-rules)\nScoping rules\n\n`var` declarations have some odd scoping rules for those used to other languages. Take the following example:\n\nts\n\n`   function f(shouldInitialize: boolean) {    if (shouldInitialize) {      var x = 10;    }    return x;  }  f(true); // returns '10'  f(false); // returns 'undefined'   `\n\nSome readers might do a double-take at this example. The variable `x` was declared _within the `if` block_, and yet we were able to access it from outside that block. That’s because `var` declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block. Some people call this _`var`\\-scoping_ or _function-scoping_. Parameters are also function scoped.\n\nThese scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:\n\nts\n\n`   function sumMatrix(matrix: number[][]) {    var sum = 0;    for (var i = 0; i < matrix.length; i++) {      var currentRow = matrix[i];      for (var i = 0; i < currentRow.length; i++) {        sum += currentRow[i];      }    }    return sum;  }   `\n\nMaybe it was easy to spot out for some experienced JavaScript developers, but the inner `for`\\-loop will accidentally overwrite the variable `i` because `i` refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#variable-capturing-quirks)\nVariable capturing quirks\n\nTake a quick second to guess what the output of the following snippet is:\n\nts\n\n`   for (var i = 0; i < 10; i++) {    setTimeout(function () {      console.log(i);    }, 100 * i);  }   `\n\nFor those unfamiliar, `setTimeout` will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).\n\nReady? Take a look:\n\n`   10  10  10  10  10  10  10  10  10  10   `\n\nMany JavaScript developers are intimately familiar with this behavior, but if you’re surprised, you’re certainly not alone. Most people expect the output to be\n\n`   0  1  2  3  4  5  6  7  8  9   `\n\nRemember what we mentioned earlier about variable capturing? Every function expression we pass to `setTimeout` actually refers to the same `i` from the same scope.\n\nLet’s take a minute to consider what that means. `setTimeout` will run a function after some number of milliseconds, _but only_ after the `for` loop has stopped executing; By the time the `for` loop has stopped executing, the value of `i` is `10`. So each time the given function gets called, it will print out `10`!\n\nA common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture `i` at each iteration:\n\nts\n\n`   for (var i = 0; i < 10; i++) {    // capture the current state of 'i'    // by invoking a function with its current value    (function (i) {      setTimeout(function () {        console.log(i);      }, 100 * i);    })(i);  }   `\n\nThis odd-looking pattern is actually pretty common. The `i` in the parameter list actually shadows the `i` declared in the `for` loop, but since we named them the same, we didn’t have to modify the loop body too much.\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#let-declarations)\n`let` declarations\n---------------------------------------------------------------------------------------------------------------\n\nBy now you’ve figured out that `var` has some problems, which is precisely why `let` statements were introduced. Apart from the keyword used, `let` statements are written the same way `var` statements are.\n\nts\n\n`   let hello = \"Hello!\";   `\n\nThe key difference is not in the syntax, but in the semantics, which we’ll now dive into.\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#block-scoping)\nBlock-scoping\n\nWhen a variable is declared using `let`, it uses what some call _lexical-scoping_ or _block-scoping_. Unlike variables declared with `var` whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or `for`\\-loop.\n\nts\n\n`   function f(input: boolean) {    let a = 100;    if (input) {      // Still okay to reference 'a'      let b = a + 1;      return b;    }    // Error: 'b' doesn't exist here    return b;  }   `\n\nHere, we have two local variables `a` and `b`. `a`’s scope is limited to the body of `f` while `b`’s scope is limited to the containing `if` statement’s block.\n\nVariables declared in a `catch` clause also have similar scoping rules.\n\nts\n\n`   try {    throw \"oh no!\";  } catch (e) {    console.log(\"Oh well.\");  }  // Error: 'e' doesn't exist here  console.log(e);   `\n\nAnother property of block-scoped variables is that they can’t be read or written to before they’re actually declared. While these variables are “present” throughout their scope, all points up until their declaration are part of their _temporal dead zone_. This is just a sophisticated way of saying you can’t access them before the `let` statement, and luckily TypeScript will let you know that.\n\nts\n\n`   a++; // illegal to use 'a' before it's declared;  let a;   `\n\nSomething to note is that you can still _capture_ a block-scoped variable before it’s declared. The only catch is that it’s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won’t report this as an error.\n\nts\n\n`   function foo() {    // okay to capture 'a'    return a;  }  // illegal call 'foo' before 'a' is declared  // runtimes should throw an error here  foo();  let a;   `\n\nFor more information on temporal dead zones, see relevant content on the [Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#re-declarations-and-shadowing)\nRe-declarations and Shadowing\n\nWith `var` declarations, we mentioned that it didn’t matter how many times you declared your variables; you just got one.\n\nts\n\n`   function f(x) {    var x;    var x;    if (true) {      var x;    }  }   `\n\nIn the above example, all declarations of `x` actually refer to the _same_ `x`, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, `let` declarations are not as forgiving.\n\nts\n\n`   let x = 10;  let x = 20; // error: can't re-declare 'x' in the same scope   `\n\nThe variables don’t necessarily need to both be block-scoped for TypeScript to tell us that there’s a problem.\n\nts\n\n`   function f(x) {    let x = 100; // error: interferes with parameter declaration  }  function g() {    let x = 100;    var x = 100; // error: can't have both declarations of 'x'  }   `\n\nThat’s not to say that a block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.\n\nts\n\n`   function f(condition, x) {    if (condition) {      let x = 100;      return x;    }    return x;  }  f(false, 0); // returns '0'  f(true, 0); // returns '100'   `\n\nThe act of introducing a new name in a more nested scope is called _shadowing_. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier `sumMatrix` function using `let` variables.\n\nts\n\n`   function sumMatrix(matrix: number[][]) {    let sum = 0;    for (let i = 0; i < matrix.length; i++) {      var currentRow = matrix[i];      for (let i = 0; i < currentRow.length; i++) {        sum += currentRow[i];      }    }    return sum;  }   `\n\nThis version of the loop will actually perform the summation correctly because the inner loop’s `i` shadows `i` from the outer loop.\n\nShadowing should _usually_ be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#block-scoped-variable-capturing)\nBlock-scoped variable capturing\n\nWhen we first touched on the idea of variable capturing with `var` declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an “environment” of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.\n\nts\n\n`   function theCityThatAlwaysSleeps() {    let getCity;    if (true) {      let city = \"Seattle\";      getCity = function () {        return city;      };    }    return getCity();  }   `\n\nBecause we’ve captured `city` from within its environment, we’re still able to access it despite the fact that the `if` block finished executing.\n\nRecall that with our earlier `setTimeout` example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the `for` loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript.\n\n`let` declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope _per iteration_. Since this is what we were doing anyway with our IIFE, we can change our old `setTimeout` example to just use a `let` declaration.\n\nts\n\n`   for (let i = 0; i < 10; i++) {    setTimeout(function () {      console.log(i);    }, 100 * i);  }   `\n\nand as expected, this will print out\n\n`   0  1  2  3  4  5  6  7  8  9   `\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#const-declarations)\n`const` declarations\n-------------------------------------------------------------------------------------------------------------------\n\n`const` declarations are another way of declaring variables.\n\nts\n\n`   const numLivesForCat = 9;   `\n\nThey are like `let` declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as `let`, but you can’t re-assign to them.\n\nThis should not be confused with the idea that the values they refer to are _immutable_.\n\nts\n\n`   const numLivesForCat = 9;  const kitty = {    name: \"Aurora\",    numLives: numLivesForCat,  };  // Error  kitty = {    name: \"Danielle\",    numLives: numLivesForCat,  };  // all \"okay\"  kitty.name = \"Rory\";  kitty.name = \"Kitty\";  kitty.name = \"Cat\";  kitty.numLives--;   `\n\nUnless you take specific measures to avoid it, the internal state of a `const` variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are `readonly`. The [chapter on Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)\n has the details.\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#let-vs-const)\n`let` vs. `const`\n----------------------------------------------------------------------------------------------------------\n\nGiven that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.\n\nApplying the [principle of least privilege](https://wikipedia.org/wiki/Principle_of_least_privilege)\n, all declarations other than those you plan to modify should use `const`. The rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using `const` also makes code more predictable when reasoning about flow of data.\n\nUse your best judgement, and if applicable, consult the matter with the rest of your team.\n\nThe majority of this handbook uses `let` declarations.\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring)\nDestructuring\n-------------------------------------------------------------------------------------------------------\n\nAnother ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see [the article on the Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n. In this section, we’ll give a short overview.\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#array-destructuring)\nArray destructuring\n\nThe simplest form of destructuring is array destructuring assignment:\n\nts\n\n`   let input = [1, 2];  let [first, second] = input;  console.log(first); // outputs 1  console.log(second); // outputs 2   `\n\nThis creates two new variables named `first` and `second`. This is equivalent to using indexing, but is much more convenient:\n\nts\n\n`   first = input[0];  second = input[1];   `\n\nDestructuring works with already-declared variables as well:\n\nts\n\n`   // swap variables  [first, second] = [second, first];   `\n\nAnd with parameters to a function:\n\nts\n\n`   function f([first, second]: [number, number]) {    console.log(first);    console.log(second);  }  f([1, 2]);   `\n\nYou can create a variable for the remaining items in a list using the syntax `...`:\n\nts\n\n`   let [first, ...rest] = [1, 2, 3, 4];  console.log(first); // outputs 1  console.log(rest); // outputs [ 2, 3, 4 ]   `\n\nOf course, since this is JavaScript, you can just ignore trailing elements you don’t care about:\n\nts\n\n`   let [first] = [1, 2, 3, 4];  console.log(first); // outputs 1   `\n\nOr other elements:\n\nts\n\n`   let [, second, , fourth] = [1, 2, 3, 4];  console.log(second); // outputs 2  console.log(fourth); // outputs 4   `\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#tuple-destructuring)\nTuple destructuring\n\nTuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:\n\nts\n\n`   let tuple: [number, string, boolean] = [7, \"hello\", true];  let [a, b, c] = tuple; // a: number, b: string, c: boolean   `\n\nIt’s an error to destructure a tuple beyond the range of its elements:\n\nts\n\n`   let [a, b, c, d] = tuple; // Error, no element at index 3   `\n\nAs with arrays, you can destructure the rest of the tuple with `...`, to get a shorter tuple:\n\nts\n\n`   let [a, ...bc] = tuple; // bc: [string, boolean]  let [a, b, c, ...d] = tuple; // d: [], the empty tuple   `\n\nOr ignore trailing elements, or other elements:\n\nts\n\n`   let [a] = tuple; // a: number  let [, b] = tuple; // b: string   `\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#object-destructuring)\nObject destructuring\n\nYou can also destructure objects:\n\nts\n\n`   let o = {    a: \"foo\",    b: 12,    c: \"bar\",  };  let { a, b } = o;   `\n\nThis creates new variables `a` and `b` from `o.a` and `o.b`. Notice that you can skip `c` if you don’t need it.\n\nLike array destructuring, you can have assignment without declaration:\n\nts\n\n`   ({ a, b } = { a: \"baz\", b: 101 });   `\n\nNotice that we had to surround this statement with parentheses. JavaScript normally parses a `{` as the start of block.\n\nYou can create a variable for the remaining items in an object using the syntax `...`:\n\nts\n\n`   let { a, ...passthrough } = o;  let total = passthrough.b + passthrough.c.length;   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#property-renaming)\nProperty renaming\n\nYou can also give different names to properties:\n\nts\n\n`   let { a: newName1, b: newName2 } = o;   `\n\nHere the syntax starts to get confusing. You can read `a: newName1` as ”`a` as `newName1`”. The direction is left-to-right, as if you had written:\n\nts\n\n`   let newName1 = o.a;  let newName2 = o.b;   `\n\nConfusingly, the colon here does _not_ indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:\n\nts\n\n`   let { a: newName1, b: newName2 }: { a: string; b: number } = o;   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#default-values)\nDefault values\n\nDefault values let you specify a default value in case a property is undefined:\n\nts\n\n`   function keepWholeObject(wholeObject: { a: string; b?: number }) {    let { a, b = 1001 } = wholeObject;  }   `\n\nIn this example the `b?` indicates that `b` is optional, so it may be `undefined`. `keepWholeObject` now has a variable for `wholeObject` as well as the properties `a` and `b`, even if `b` is undefined.\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#function-declarations)\nFunction declarations\n-----------------------------------------------------------------------------------------------------------------------\n\nDestructuring also works in function declarations. For simple cases this is straightforward:\n\nts\n\n`   type C = { a: string; b?: number };  function f({ a, b }: C): void {    // ...  }   `\n\nBut specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.\n\nts\n\n`   function f({ a = \"\", b = 0 } = {}): void {    // ...  }  f();   `\n\n> The snippet above is an example of type inference, explained earlier in the handbook.\n\nThen, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that `C` was defined with `b` optional:\n\nts\n\n`   function f({ a, b = 0 } = { a: \"\" }): void {    // ...  }  f({ a: \"yes\" }); // ok, default b = 0  f(); // ok, default to { a: \"\" }, which then defaults b = 0  f({}); // error, 'a' is required if you supply an argument   `\n\nUse destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets _really_ hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#spread)\nSpread\n-----------------------------------------------------------------------------------------\n\nThe spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:\n\nts\n\n`   let first = [1, 2];  let second = [3, 4];  let bothPlus = [0, ...first, ...second, 5];   `\n\nThis gives bothPlus the value `[0, 1, 2, 3, 4, 5]`. Spreading creates a shallow copy of `first` and `second`. They are not changed by the spread.\n\nYou can also spread objects:\n\nts\n\n`   let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };  let search = { ...defaults, food: \"rich\" };   `\n\nNow `search` is `{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }`. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:\n\nts\n\n`   let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };  let search = { food: \"rich\", ...defaults };   `\n\nThen the `food` property in `defaults` overwrites `food: \"rich\"`, which is not what we want in this case.\n\nObject spread also has a couple of other surprising limits. First, it only includes an objects’ [own, enumerable properties](https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)\n. Basically, that means you lose methods when you spread instances of an object:\n\nts\n\n`   class C {    p = 12;    m() {}  }  let c = new C();  let clone = { ...c };  clone.p; // ok  clone.m(); // error!   `\n\nSecond, the TypeScript compiler doesn’t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#using-declarations)\n`using` declarations\n-------------------------------------------------------------------------------------------------------------------\n\n`using` declarations are an upcoming feature for JavaScript that are part of the [Stage 3 Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management)\n proposal. A `using` declaration is much like a `const` declaration, except that it couples the _lifetime_ of the value bound to the declaration with the _scope_ of the variable.\n\nWhen control exits the block containing a `using` declaration, the `[Symbol.dispose]()` method of the declared value is executed, which allows that value to perform cleanup:\n\nts\n\n``   function f() {    using x = new C();    doSomethingWith(x);  } // `x[Symbol.dispose]()` is called   ``\n\nAt runtime, this has an effect _roughly_ equivalent to the following:\n\nts\n\n`   function f() {    const x = new C();    try {      doSomethingWith(x);    }    finally {      x[Symbol.dispose]();    }  }   `\n\n`using` declarations are extremely useful for avoiding memory leaks when working with JavaScript objects that hold on to native references like file handles\n\nts\n\n``   {    using file = await openFile();    file.write(text);    doSomethingThatMayThrow();  } // `file` is disposed, even if an error is thrown   ``\n\nor scoped operations like tracing\n\nts\n\n`   function f() {    using activity = new TraceActivity(\"f\"); // traces entry into function    // ...  } // traces exit of function   `\n\nUnlike `var`, `let`, and `const`, `using` declarations do not support destructuring.\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#null-and-undefined)\n`null` and `undefined`\n\nIt’s important to note that the value can be `null` or `undefined`, in which case nothing is disposed at the end of the block:\n\nts\n\n`   {    using x = b ? new C() : null;    // ...  }   `\n\nwhich is _roughly_ equivalent to:\n\nts\n\n`   {    const x = b ? new C() : null;    try {      // ...    }    finally {      x?.[Symbol.dispose]();    }  }   `\n\nThis allows you to conditionally acquire resources when declaring a `using` declaration without the need for complex branching or repetition.\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#defining-a-disposable-resource)\nDefining a disposable resource\n\nYou can indicate the classes or objects you produce are disposable by implementing the `Disposable` interface:\n\nts\n\n``   // from the default lib:  interface Disposable {    [Symbol.dispose](): void;  }  // usage:  class TraceActivity implements Disposable {    readonly name: string;    constructor(name: string) {      this.name = name;      console.log(`Entering: ${name}`);    }    [Symbol.dispose](): void {      console.log(`Exiting: ${name}`);    }  }  function f() {    using _activity = new TraceActivity(\"f\");    console.log(\"Hello world!\");  }  f();  // prints:  //   Entering: f  //   Hello world!  //   Exiting: f   ``\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#await-using-declarations)\n`await using` declarations\n-------------------------------------------------------------------------------------------------------------------------------\n\nSome resources or operations may have cleanup that needs to be performed asynchronously. To accommodate this, the [Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management)\n proposal also introduces the `await using` declaration:\n\nts\n\n``   async function f() {    await using x = new C();  } // `await x[Symbol.asyncDispose]()` is invoked   ``\n\nAn `await using` declaration invokes, and _awaits_, its value’s `[Symbol.asyncDispose]()` method as control leaves the containing block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit, or a file stream flushing any pending writes to storage before it is closed.\n\nAs with `await`, `await using` can only be used in an `async` function or method, or at the top level of a module.\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#defining-an-asynchronously-disposable-resource)\nDefining an asynchronously disposable resource\n\nJust as `using` relies on objects that are `Disposable`, an `await using` relies on objects that are `AsyncDisposable`:\n\nts\n\n`   // from the default lib:  interface AsyncDisposable {    [Symbol.asyncDispose]: PromiseLike<void>;  }  // usage:  class DatabaseTransaction implements AsyncDisposable {    public success = false;    private db: Database | undefined;    private constructor(db: Database) {      this.db = db;    }    static async create(db: Database) {      await db.execAsync(\"BEGIN TRANSACTION\");      return new DatabaseTransaction(db);    }    async [Symbol.asyncDispose]() {      if (this.db) {        const db = this.db:        this.db = undefined;        if (this.success) {          await db.execAsync(\"COMMIT TRANSACTION\");        }        else {          await db.execAsync(\"ROLLBACK TRANSACTION\");        }      }    }  }  async function transfer(db: Database, account1: Account, account2: Account, amount: number) {    using tx = await DatabaseTransaction.create(db);    if (await debitAccount(db, account1, amount)) {      await creditAccount(db, account2, amount);    }    // if an exception is thrown before this line, the transaction will roll back    tx.success = true;    // now the transaction will commit  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#await-using-vs-await)\n`await using` vs `await`\n\nThe `await` keyword that is part of the `await using` declaration only indicates that the _disposal_ of the resource is `await`\\-ed. It does _not_ `await` the value itself:\n\nts\n\n``   {    await using x = getResourceSynchronously();  } // performs `await x[Symbol.asyncDispose]()`  {    await using y = await getResourceAsynchronously();  } // performs `await y[Symbol.asyncDispose]()`   ``\n\n### [](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#await-using-and-return)\n`await using` and `return`\n\nIt’s important to note that there is a small caveat with this behavior if you are using an `await using` declaration in an `async` function that returns a `Promise` without first `await`\\-ing it:\n\nts\n\n``   function g() {    return Promise.reject(\"error!\");  }  async function f() {    await using x = new C();    return g(); // missing an `await`  }   ``\n\nBecause the returned promise isn’t `await`\\-ed, it’s possible that the JavaScript runtime may report an unhandled rejection since execution pauses while `await`\\-ing the asynchronous disposal of `x`, without having subscribed to the returned promise. This is not a problem that is unique to `await using`, however, as this can also occur in an `async` function that uses `try..finally`:\n\nts\n\n`   async function f() {    try {      return g(); // also reports an unhandled rejection    }    finally {      await somethingElse();    }  }   `\n\nTo avoid this situation, it is recommended that you `await` your return value if it may be a `Promise`:\n\nts\n\n`   async function f() {    await using x = new C();    return await g();  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#using-and-await-using-in-for-and-forof-statements)\n`using` and `await using` in `for` and `for..of` statements\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBoth `using` and `await using` can be used in a `for` statement:\n\nts\n\n`   for (using x = getReader(); !x.eof; x.next()) {    // ...  }   `\n\nIn this case, the lifetime of `x` is scoped to the entire `for` statement and is only disposed when control leaves the loop due to `break`, `return`, `throw`, or when the loop condition is false.\n\nIn addition to `for` statements, both declarations can also be used in `for..of` statements:\n\nts\n\n`   function * g() {    yield createResource1();    yield createResource2();  }  for (using x of g()) {    // ...  }   `\n\nHere, `x` is disposed at the end of _each iteration of the loop_, and is then reinitialized with the next value. This is especially useful when consuming resources produced one at a time by a generator.\n\n[](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#using-and-await-using-in-older-runtimes)\n`using` and `await using` in older runtimes\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n`using` and `await using` declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for `Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in recent editions of NodeJS.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Variable%20Declarations.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (58)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)\n\nOT![Orta Therox  (20)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nNS![Nathan Shively-Sanders  (9)](https://gravatar.com/avatar/f2d3b194d100bd25842ca048ab101408?s=32&&d=blank)\n\nVR![Vimal Raghubir  (3)](https://gravatar.com/avatar/9bd70673d4a0c3ab8461871af1896215?s=32&&d=blank)\n\nBC![Brett Cannon  (3)](https://gravatar.com/avatar/962cb4064811fd8c78dfc01eb27d4871?s=32&&d=blank)\n\n24+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - Variable Declaration","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","description":"How TypeScript handles variable declaration","ogDescription":"How TypeScript handles variable declaration","theme-color":"#3178C6","title":"TypeScript: Documentation - Variable Declaration","og:title":"Documentation - Variable Declaration","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","twitter:site":"typescriptlang","og:description":"How TypeScript handles variable declaration","scrapeId":"e230e90d-3f6d-4be6-8a57-c0e7ae49aa2e","sourceURL":"https://www.typescriptlang.org/docs/handbook/variable-declarations.html","url":"https://www.typescriptlang.org/docs/handbook/variable-declarations.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModules - Theory\n================\n\n[](https://www.typescriptlang.org/docs/handbook/modules/theory.html#scripts-and-modules-in-javascript)\nScripts and modules in JavaScript\n----------------------------------------------------------------------------------------------------------------------------------------\n\nIn the early days of JavaScript, when the language only ran in browsers, there were no modules, but it was still possible to split the JavaScript for a web page into multiple files by using multiple `script` tags in HTML:\n\nhtml\n\n`   <html>    <head>      <script src=\"a.js\"></script>      <script src=\"b.js\"></script>    </head>    <body></body>  </html>   `\n\nThis approach had some downsides, especially as web pages grew larger and more complex. In particular, all scripts loaded onto the same page share the same scope—appropriately called the “global scope”—meaning the scripts had to be very careful not to overwrite each others’ variables and functions.\n\nAny system that solves this problem by giving files their own scope while still providing a way to make bits of code available to other files can be called a “module system.” (It may sound obvious to say that each file in a module system is called a “module,” but the term is often used to contrast with _script_ files, which run outside a module system, in a global scope.)\n\n> There are [many module systems](https://github.com/myshov/history-of-javascript/tree/master/4_evolution_of_js_modularity)\n> , and TypeScript [supports emitting several](https://www.typescriptlang.org/tsconfig/#module)\n> , but this documentation will focus on the two most important systems today: ECMAScript modules (ESM) and CommonJS (CJS).\n> \n> ECMAScript Modules (ESM) is the module system built into the language, supported in modern browsers and in Node.js since v12. It uses dedicated `import` and `export` syntax:\n> \n> js\n> \n> `   // a.js  export default \"Hello from a.js\";   `\n> \n> js\n> \n> `   // b.js  import a from \"./a.js\";  console.log(a); // 'Hello from a.js'   `\n> \n> CommonJS (CJS) is the module system that originally shipped in Node.js, before ESM was part of the language specification. It’s still supported in Node.js alongside ESM. It uses plain JavaScript objects and functions named `exports` and `require`:\n> \n> js\n> \n> `   // a.js  exports.message = \"Hello from a.js\";   `\n> \n> js\n> \n> `   // b.js  const a = require(\"./a\");  console.log(a.message); // 'Hello from a.js'   `\n\nAccordingly, when TypeScript detects that a file is a CommonJS or ECMAScript module, it starts by assuming that file will have its own scope. Beyond that, though, the compiler’s job gets a little more complicated.\n\n[](https://www.typescriptlang.org/docs/handbook/modules/theory.html#typescripts-job-concerning-modules)\nTypeScript’s job concerning modules\n-------------------------------------------------------------------------------------------------------------------------------------------\n\nThe TypeScript compiler’s chief goal is to prevent certain kinds of runtime errors by catching them at compile time. With or without modules involved, the compiler needs to know about the code’s intended runtime environment—what globals are available, for example. When modules are involved, there are several additional questions the compiler needs to answer in order to do its job. Let’s use a few lines of input code as an example to think about all the information needed to analyze it:\n\nts\n\n`   import sayHello from \"greetings\";  sayHello(\"world\");   `\n\nTo check this file, the compiler needs to know the type of `sayHello` (is it a function that can accept one string argument?), which opens quite a few additional questions:\n\n1.  Will the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?\n2.  What _kind_ of module does the module system expect to find, given the file name it will load and its location on disk?\n3.  If output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?\n4.  Where will the module system look to find the module specified by `\"greetings\"`? Will the lookup succeed?\n5.  What kind of module is the file resolved by that lookup?\n6.  Does the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?\n7.  Once the `\"greetings\"` module has been analyzed, what piece of that module is bound to `sayHello`?\n\nNotice that all of these questions depend on characteristics of the _host_—the system that ultimately consumes the output JavaScript (or raw TypeScript, as the case may be) to direct its module loading behavior, typically either a runtime (like Node.js) or bundler (like Webpack).\n\nThe ECMAScript specification defines how ESM imports and exports link up with each other, but it doesn’t specify how the file lookup in (4), known as _module resolution_, happens, and it doesn’t say anything about other module systems like CommonJS. So runtimes and bundlers, especially those that want to support both ESM and CJS, have a lot of freedom to design their own rules. Consequently, the way TypeScript should answer the questions above can vary dramatically depending on where the code is intended to run. There’s no single right answer, so the compiler must be told the rules through configuration options.\n\nThe other key idea to keep in mind is that TypeScript almost always thinks about these questions in terms of its _output_ JavaScript files, not its _input_ TypeScript (or JavaScript!) files. Today, some runtimes and bundlers support loading TypeScript files directly, and in those cases, it doesn’t make sense to think about separate input and output files. Most of this document discusses cases where TypeScript files are compiled to JavaScript files, which in turn are loaded by the runtime module system. Examining these cases is essential for building an understanding of the compiler’s options and behavior—it’s easier to start there and simplify when thinking about esbuild, Bun, and other [TypeScript-first runtimes and bundlers](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution-for-bundlers-typescript-runtimes-and-nodejs-loaders)\n. So for now, we can summarize TypeScript’s job when it comes to modules in terms of output files:\n\nUnderstand the **rules of the host** enough\n\n1.  to compile files into a valid **output module format**,\n2.  to ensure that imports in those **outputs** will **resolve successfully**, and\n3.  to know what **type** to assign to **imported names**.\n\n[](https://www.typescriptlang.org/docs/handbook/modules/theory.html#who-is-the-host)\nWho is the host?\n-----------------------------------------------------------------------------------------------------\n\nBefore we move on, it’s worth making sure we’re on the same page about the term _host_, because it will come up frequently. We defined it before as “the system that ultimately consumes the output code to direct its module loading behavior.” In other words, it’s the system outside of TypeScript that TypeScript’s module analysis tries to model:\n\n*   When the output code (whether produced by `tsc` or a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.\n*   When there is no “output code” because a runtime consumes TypeScript files directly, the runtime is still the host.\n*   When a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn’t know about anything that happens post-bundler.)\n*   If another transpiler, optimizer, or formatter runs on TypeScript’s outputs, it’s _not_ a host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.\n*   When loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser’s JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.\n*   The TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts.\n\n[](https://www.typescriptlang.org/docs/handbook/modules/theory.html#the-module-output-format)\nThe module output format\n----------------------------------------------------------------------------------------------------------------------\n\nIn any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match. Sometimes, the host only _supports_ one kind of module—ESM in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12 and later accepts both CJS and ES modules, but uses file extensions and `package.json` files to determine what format each file should be, and throws an error if the file’s contents don’t match the expected format.\n\nThe `module` compiler option provides this information to the compiler. Its primary purpose is to control the module format of any JavaScript that gets emitted during compilation, but it also serves to inform the compiler about how the module kind of each file should be detected, how different module kinds are allowed to import each other, and whether features like `import.meta` and top-level `await` are available. So, even if a TypeScript project is using `noEmit`, choosing the right setting for `module` still matters. As we established earlier, the compiler needs an accurate understanding of the module system so it can type check (and provide IntelliSense for) imports. See [_Choosing compiler options_](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html)\n for guidance on choosing the right `module` setting for your project.\n\nThe available `module` settings are\n\n*   [**`node16`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-node18-nodenext)\n    : Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.\n*   [**`node18`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-node18-nodenext)\n    : Reflects the module system of Node.js v18+, which adds support for import attributes.\n*   [**`nodenext`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-node18-nodenext)\n    : A moving target reflecting the latest Node.js versions as Node.js’s module system evolves. As of TypeScript 5.8, `nodenext` supports `require` of ECMAScript modules.\n*   [**`es2015`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext)\n    : Reflects the ES2015 language specification for JavaScript modules (the version that first introduced `import` and `export` to the language).\n*   [**`es2020`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext)\n    : Adds support for `import.meta` and `export * as ns from \"mod\"` to `es2015`.\n*   [**`es2022`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext)\n    : Adds support for top-level `await` to `es2020`.\n*   [**`esnext`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext)\n    : Currently identical to `es2022`, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.\n*   **[`commonjs`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#commonjs)\n    , [`system`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#system)\n    , [`amd`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#amd)\n    , and [`umd`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#umd)\n    **: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation.\n\n> Node.js’s rules for module format detection and interoperability make it incorrect to specify `module` as `esnext` or `commonjs` for projects that run in Node.js, even if all files emitted by `tsc` are ESM or CJS, respectively. The only correct `module` settings for projects that intend to run in Node.js are `node16` and `nodenext`. While the emitted JavaScript for an all-ESM Node.js project might look identical between compilations using `esnext` and `nodenext`, the type checking can differ. See the [reference section on `nodenext`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-node18-nodenext)\n>  for more details.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-format-detection)\nModule format detection\n\nNode.js understands both ES modules and CJS modules, but the format of each file is determined by its file extension and the `type` field of the first `package.json` file found in a search of the file’s directory and all ancestor directories:\n\n*   `.mjs` and `.cjs` files are always interpreted as ES modules and CJS modules, respectively.\n*   `.js` files are interpreted as ES modules if the nearest `package.json` file contains a `type` field with the value `\"module\"`. If there is no `package.json` file, or if the `type` field is missing or has any other value, `.js` files are interpreted as CJS modules.\n\nIf a file is determined to be an ES module by these rules, Node.js will not inject the CommonJS `module` and `require` objects into the file’s scope during evaluation, so a file that tries to use them will cause a crash. Conversely, if a file is determined to be a CJS module, `import` and `export` declarations in the file will cause a syntax error crash.\n\nWhen the `module` compiler option is set to `node16`, `node18`, or `nodenext`, TypeScript applies this same algorithm to the project’s _input_ files to determine the module kind of each corresponding _output_ file. Let’s look at how module formats are detected in an example project that uses `--module nodenext`:\n\n| Input file name | Contents | Output file name | Module kind | Reason |\n| --- | --- | --- | --- | --- |\n| `/package.json` | `{}` |     |     |     |\n| `/main.mts` |     | `/main.mjs` | ESM | File extension |\n| `/utils.cts` |     | `/utils.cjs` | CJS | File extension |\n| `/example.ts` |     | `/example.js` | CJS | No `\"type\": \"module\"` in `package.json` |\n| `/node_modules/pkg/package.json` | `{ \"type\": \"module\" }` |     |     |     |\n| `/node_modules/pkg/index.d.ts` |     |     | ESM | `\"type\": \"module\"` in `package.json` |\n| `/node_modules/pkg/index.d.cts` |     |     | CJS | File extension |\n\nWhen the input file extension is `.mts` or `.cts`, TypeScript knows to treat that file as an ES module or CJS module, respectively, because Node.js will treat the output `.mjs` file as an ES module or the output `.cjs` file as a CJS module. When the input file extension is `.ts`, TypeScript has to consult the nearest `package.json` file to determine the module format, because this is what Node.js will do when it encounters the output `.js` file. (Notice that the same rules apply to the `.d.cts` and `.d.ts` declaration files in the `pkg` dependency: though they will not produce an output file as part of this compilation, the presence of a `.d.ts` file _implies_ the existence of a corresponding `.js` file—perhaps created when the author of the `pkg` library ran `tsc` on an input `.ts` file of their own—which Node.js must interpret as an ES module, due to its `.js` extension and the presence of the `\"type\": \"module\"` field in `/node_modules/pkg/package.json`. Declaration files are covered in more detail in a [later section](https://www.typescriptlang.org/docs/handbook/modules/theory.html#the-role-of-declaration-files)\n.)\n\nThe detected module format of input files is used by TypeScript to ensure it emits the output syntax that Node.js expects in each output file. If TypeScript were to emit `/example.js` with `import` and `export` statements in it, Node.js would crash when parsing the file. If TypeScript were to emit `/main.mjs` with `require` calls, Node.js would crash during evaluation. Beyond emit, the module format is also used to determine rules for type checking and module resolution, which we’ll discuss in the following sections.\n\nAs of TypeScript 5.6, other `--module` modes (like `esnext` and `commonjs`) also respect format-specific file extensions (`.mts` and `.cts`) as a file-level override for the emit format. For example, a file named `main.mts` will emit ESM syntax into `main.mjs` even if `--module` is set to `commonjs`.\n\nIt’s worth mentioning again that TypeScript’s behavior in `--module node16`, `--module node18`, and `--module nodenext` is entirely motivated by Node.js’s behavior. Since TypeScript’s goal is to catch potential runtime errors at compile time, it needs a very accurate model of what will happen at runtime. This fairly complex set of rules for module kind detection is _necessary_ for checking code that will run in Node.js, but may be overly strict or just incorrect if applied to non-Node.js hosts.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/theory.html#input-module-syntax)\nInput module syntax\n\nIt’s important to note that the _input_ module syntax seen in input source files is somewhat decoupled from the output module syntax emitted to JS files. That is, a file with an ESM import:\n\nts\n\n`   import { sayHello } from \"greetings\";  sayHello(\"world\");   `\n\nmight be emitted in ESM format exactly as-is, or might be emitted as CommonJS:\n\nts\n\n`   Object.defineProperty(exports, \"__esModule\", { value: true });  const greetings_1 = require(\"greetings\");  (0, greetings_1.sayHello)(\"world\");   `\n\ndepending on the `module` compiler option (and any applicable [module format detection](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-format-detection)\n rules, if the `module` option supports more than one kind of module). In general, this means that looking at the contents of an input file isn’t enough to determine whether it’s an ES module or a CJS module.\n\n> Today, most TypeScript files are authored using ESM syntax (`import` and `export` statements) regardless of the output format. This is largely a legacy of the long road ESM has taken to widespread support. ECMAScript modules were standardized in 2015, were supported in most browsers by 2017, and landed in Node.js v12 in 2019. During much of this window, it was clear that ESM was the future of JavaScript modules, but very few runtimes could consume it. Tools like Babel made it possible for JavaScript to be authored in ESM and downleveled to another module format that could be used in Node.js or browsers. TypeScript followed suit, adding support for ES module syntax and softly discouraging the use of the original CommonJS-inspired `import fs = require(\"fs\")` syntax in [the 1.5 release](https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/)\n> .\n> \n> The upside of this “author ESM, output anything” strategy was that TypeScript could use standard JavaScript syntax, making the authoring experience familiar to newcomers, and (theoretically) making it easy for projects to start targeting ESM outputs in the future. There are three significant downsides, which became fully apparent only after ESM and CJS modules were allowed to coexist and interoperate in Node.js:\n> \n> 1.  Early assumptions about how ESM/CJS interoperability would work in Node.js turned out to be wrong, and today, interoperability rules differ between Node.js and bundlers. Consequently, the configuration space for modules in TypeScript is large.\n> 2.  When the syntax in input files all looks like ESM, it’s easy for an author or code reviewer to lose track of what kind of module a file is at runtime. And because of Node.js’s interoperability rules, what kind of module each file is became very important.\n> 3.  When input files are written in ESM, the syntax in type declaration outputs (`.d.ts` files) looks like ESM too. But because the corresponding JavaScript files could have been emitted in any module format, TypeScript can’t tell what kind of module a file is just by looking at the contents of its type declarations. And again, because of the nature of ESM/CJS interoperability, TypeScript _has_ to know what kind of module everything is in order to provide correct types and prevent imports that will crash.\n> \n> In TypeScript 5.0, a new compiler option called `verbatimModuleSyntax` was introduced to help TypeScript authors know exactly how their `import` and `export` statements will be emitted. When enabled, the flag requires imports and exports in input files to be written in the form that will undergo the least amount of transformation before emit. So if a file will be emitted as ESM, imports and exports must be written in ESM syntax; if a file will be emitted as CJS, it must be written in the CommonJS-inspired TypeScript syntax (`import fs = require(\"fs\")` and `export = {}`). This setting is particularly recommended for Node.js projects that use mostly ESM, but have a select few CJS files. It is not recommended for projects that currently target CJS, but may want to target ESM in the future.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/theory.html#esm-and-cjs-interoperability)\nESM and CJS interoperability\n\nCan an ES module `import` a CommonJS module? If so, does a default import link to `exports` or `exports.default`? Can a CommonJS module `require` an ES module? CommonJS isn’t part of the ECMAScript specification, so runtimes, bundlers, and transpilers have been free to make up their own answers to these questions since ESM was standardized in 2015, and as such no standard set of interoperability rules exist. Today, most runtimes and bundlers broadly fall into one of three categories:\n\n1.  **ESM-only.** Some runtimes, like browser engines, only support what’s actually a part of the language: ECMAScript Modules.\n2.  **Bundler-like.** Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.\n3.  **Node.js.** Until Node.js v22.12.0, CommonJS modules could not load ES modules synchronously (with `require`); they could only load them asynchronously with dynamic `import()` calls. ES modules can default-import CJS modules, which always binds to `exports`. (This means that a default import of a Babel-like CJS output with `__esModule` behaves differently between Node.js and some bundlers.)\n\nTypeScript needs to know which of these rule sets to assume in order to provide correct types on (particularly `default`) imports and to error on imports that will crash at runtime. When the `module` compiler option is set to `node16`, `node18`, or `nodenext`, Node.js’s version-specific rules are enforced.[1](https://www.typescriptlang.org/docs/handbook/modules/theory.html#fn-1)\n All other `module` settings, combined with the [`esModuleInterop`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#esModuleInterop)\n option, result in bundler-like interop in TypeScript. (While using `--module esnext` does prevent you from _writing_ CommonJS modules, it does not prevent you from _importing_ them as dependencies. There’s currently no TypeScript setting that can guard against an ES module importing a CommonJS module, as would be appropriate for direct-to-browser code.)\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-specifiers-are-not-transformed-by-default)\nModule specifiers are not transformed by default\n\nWhile the `module` compiler option can transform imports and exports in input files to different module formats in output files, the module _specifier_ (the string `from` which you `import`, or pass to `require`) is emitted as-written. For example, an input like:\n\nts\n\n`   import { add } from \"./math.mjs\";  add(1, 2);   `\n\nmight be emitted as either:\n\nts\n\n`   import { add } from \"./math.mjs\";  add(1, 2);   `\n\nor:\n\nts\n\n`   const math_1 = require(\"./math.mjs\");  math_1.add(1, 2);   `\n\ndepending on the `module` compiler option, but the module specifier will be `\"./math.mjs\"` either way. By default, module specifiers must be written in a way that works for the code’s target runtime or bundler, and it’s TypeScript’s job to understand those _output_\\-relative specifiers. The process of finding the file referenced by a module specifier is called _module resolution_.\n\n> TypeScript 5.7 introduced the [`--rewriteRelativeImportExtensions` option](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#path-rewriting-for-relative-paths)\n> , which transforms relative module specifiers with `.ts`, `.tsx`, `.mts`, or `.cts` extensions to their JavaScript equivalents in output files. This option is useful for creating TypeScript files that can be run directly in Node.js during development _and_ still be compiled to JavaScript outputs for distribution or production use.\n> \n> This documentation was written before the introduction of `--rewriteRelativeImportExtensions`, and the mental model it presents is built around modeling the behavior of the host module system operating on its input files, whether that’s a bundler operating on TypeScript files or a runtime operating on `.js` outputs. With `--rewriteRelativeImportExtensions`, the way to apply that mental model is to apply it _twice_: once to the runtime or bundler processing the TypeScript input files directly, and once again to the runtime or bundler processing the transformed outputs. Most of this documentation assumes that _only_ the input files or _only_ the output files will be loaded, but the principles it presents can be extended to the case where both are loaded.\n\n[](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution)\nModule resolution\n--------------------------------------------------------------------------------------------------------\n\nLet’s return to our [first example](https://www.typescriptlang.org/docs/handbook/modules/theory.html#typescripts-job-concerning-modules)\n and review what we’ve learned about it so far:\n\nts\n\n`   import sayHello from \"greetings\";  sayHello(\"world\");   `\n\nSo far, we’ve discussed how the host’s module system and TypeScript’s `module` compiler option might impact this code. We know that the input syntax looks like ESM, but the output format depends on the `module` compiler option, potentially the file extension, and `package.json` `\"type\"` field. We also know that what `sayHello` gets bound to, and even whether the import is even allowed, may vary depending on the module kinds of this file and the target file. But we haven’t yet discussed how to _find_ the target file.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution-is-host-defined)\nModule resolution is host-defined\n\nWhile the ECMAScript specification defines how to parse and interpret `import` and `export` statements, it leaves module resolution up to the host. If you’re creating a hot new JavaScript runtime, you’re free to create a module resolution scheme like:\n\nts\n\n`   import monkey from \"🐒\"; // Looks for './eats/bananas.js'  import cow from \"🐄\";    // Looks for './eats/grass.js'  import lion from \"🦁\";   // Looks for './eats/you.js'   `\n\nand still claim to implement “standards-compliant ESM.” Needless to say, TypeScript would have no idea what types to assign to `monkey`, `cow`, and `lion` without built-in knowledge of this runtime’s module resolution algorithm. Just as `module` informs the compiler about the host’s expected module format, `moduleResolution`, along with a few customization options, specify the algorithm the host uses to resolve module specifiers to files. This also clarifies why TypeScript doesn’t modify import specifiers during emit: the relationship between an import specifier and a file on disk (if one even exists) is host-defined, and TypeScript is not a host.\n\nThe available `moduleResolution` options are:\n\n*   [**`classic`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#classic)\n    : TypeScript’s oldest module resolution mode, this is unfortunately the default when `module` is set to anything other than `commonjs`, `node16`, or `nodenext`. It was probably made to provide best-effort resolution for a wide range of [RequireJS](https://requirejs.org/docs/api.html#packages)\n     configurations. It should not be used for new projects (or even old projects that don’t use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.\n*   [**`node10`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node10-formerly-known-as-node)\n    : Formerly known as `node`, this is the unfortunate default when `module` is set to `commonjs`. It’s a pretty good model of Node.js versions older than v12, and sometimes it’s a passable approximation of how most bundlers do module resolution. It supports looking up packages from `node_modules`, loading directory `index.js` files, and omitting `.js` extensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it’s a very bad model of modern versions of Node.js. It should not be used for new projects.\n*   [**`node16`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext-1)\n    : This is the counterpart of `--module node16` and `--module node18` and is set by default with that `module` setting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamic `import()` calls are not allowed to omit file extensions or `/index.js` suffixes, while module specifiers in `require` calls are. This module resolution mode understands and enforces this restriction where necessary, as determined by the [module format detection rules](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-format-detection)\n     instated by `--module node16`/`node18`. (For `node16` and `nodenext`, `module` and `moduleResolution` go hand-in-hand: setting one to `node16` or `nodenext` while setting the other to something else is an error.)\n*   [**`nodenext`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext-1)\n    : Currently identical to `node16`, this is the counterpart of `--module nodenext` and is set by default with that `module` setting. It’s intended to be a forward-looking mode that will support new Node.js module resolution features as they’re added.\n*   [**`bundler`**](https://www.typescriptlang.org/docs/handbook/modules/reference.html#bundler)\n    : Node.js v12 introduced some new module resolution features for importing npm packages—the `\"exports\"` and `\"imports\"` fields of `package.json`—and many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supports `package.json` `\"exports\"` and `\"imports\"` by default, but can be configured to ignore them. It requires setting `module` to `esnext`.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/theory.html#typescript-imitates-the-hosts-module-resolution-but-with-types)\nTypeScript imitates the host’s module resolution, but with types\n\nRemember the three components of TypeScript’s [job](https://www.typescriptlang.org/docs/handbook/modules/theory.html#typescripts-job-concerning-modules)\n concerning modules?\n\n1.  Compile files into a valid **output module format**\n2.  Ensure that imports in those **outputs** will **resolve successfully**\n3.  Know what **type** to assign to **imported names**.\n\nModule resolution is needed to accomplish last two. But when we spend most of our time working in input files, it can be easy to forget about (2)—that a key component of module resolution is validating that the imports or `require` calls in the output files, containing the [same module specifiers as the input files](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-specifiers-are-not-transformed)\n, will actually work at runtime. Let’s look at a new example with multiple files:\n\nts\n\n`   // @Filename: math.ts  export function add(a: number, b: number) {    return a + b;  }  // @Filename: main.ts  import { add } from \"./math\";  add(1, 2);   `\n\nWhen we see the import from `\"./math\"`, it might be tempting to think, “This is how one TypeScript file refers to another. The compiler follows this (extensionless) path in order to assign a type to `add`.”\n\n![A simple flowchart diagram. A file (rectangle node) main.ts resolves (labeled arrow) through module specifier './math' to another file math.ts.](https://www.typescriptlang.org/c858b89407a2057ead56516c9a77c783/theory.md-1.svg)\n\nThis isn’t entirely wrong, but the reality is deeper. The resolution of `\"./math\"` (and subsequently, the type of `add`) need to reflect the reality of what happens at runtime to the _output_ files. A more robust way to think about this process would look like this:\n\n![A flowchart diagram with two groups of files: Input files and Output files. main.ts (an input file) maps to output file main.js, which resolves through the module specifier \"./math\" to math.js (another output file), which maps back to the input file math.ts.](https://www.typescriptlang.org/b1f11e84a45a07707dbe1bb284b2fbff/theory.md-2.svg)\n\nThis model makes it clear that for TypeScript, module resolution is mostly a matter of accurately modeling the host’s module resolution algorithm between output files, with a little bit of remapping applied to find type information. Let’s look at another example that appears unintuitive through the lens of the simple model, but makes perfect sense with the robust model:\n\nts\n\n`   // @moduleResolution: node16  // @rootDir: src  // @outDir: dist  // @Filename: src/math.mts  export function add(a: number, b: number) {    return a + b;  }  // @Filename: src/main.mts  import { add } from \"./math.mjs\";  add(1, 2);   `\n\nNode.js ESM `import` declarations use a strict module resolution algorithm that requires relative paths to include file extensions. When we only think about input files, it’s a little strange that `\"./math.mjs\"` seems to resolve to `math.mts`. Since we’re using an `outDir` to put compiled outputs in a different directory, `math.mjs` doesn’t even exist next to `main.mts`! Why should this resolve? With our new mental model, it’s no problem:\n\n![A flowchart diagram with identical structure to the one above. There are two groups of files: Input files and Output files. src/main.mts (an input file) maps to output file dist/main.mjs, which resolves through module specifier \"./math.mjs\" to dist/math.mjs (another output file), which maps back to input file src/math.mts.](https://www.typescriptlang.org/729e81e79e38af5bf41ddf97aba453d1/theory.md-3.svg)\n\nUnderstanding this mental model may not immediately eliminate the strangeness of seeing output file extensions in input files, and it’s natural to think in terms of shortcuts: _`\"./math.mjs\"` refers to the input file `math.mts`. I have to write the output extension, but the compiler knows to look for `.mts` when I write `.mjs`._ This shortcut is even how the compiler works internally, but the more robust mental model explains _why_ module resolution in TypeScript works this way: given the constraint that the module specifier in the output file will be [the same](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-specifiers-are-not-transformed)\n as the module specifier in the input file, this is the only process that accomplishes our two goals of validating output files and assigning types.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/theory.html#the-role-of-declaration-files)\nThe role of declaration files\n\nIn the previous example, we saw the “remapping” part of module resolution working between input and output files. But what happens when we import library code? Even if the library was written in TypeScript, it may not have published its source code. If we can’t rely on mapping the library’s JavaScript files back to a TypeScript file, we can verify that our import works at runtime, but how do we accomplish our second goal of assigning types?\n\nThis is where declaration files (`.d.ts`, `.d.mts`, etc.) come into play. The best way to understand how declaration files are interpreted is to understand where they come from. When you run `tsc --declaration` on an input file, you get one output JavaScript file and one output declaration file:\n\n![A diagram showing the relationship between different file types. A .ts file (top) has two arrows labeled 'generates' flowing to a .js file (bottom left) and a .d.ts file (bottom right). Another arrow labeled 'implies' points from the .d.ts file to the .js file.](https://www.typescriptlang.org/fef70ad85e4ea4ef928cc62ddb67407b/declaration-files.svg)\n\nBecause of this relationship, the compiler _assumes_ that wherever it sees a declaration file, there is a corresponding JavaScript file that is perfectly described by the type information in the declaration file. For performance reasons, in every module resolution mode, the compiler always looks for TypeScript and declaration files first, and if it finds one, it doesn’t continue looking for the corresponding JavaScript file. If it finds a TypeScript input file, it knows a JavaScript file _will_ exist after compilation, and if it finds a declaration file, it knows a compilation (perhaps someone else’s) already happened and created a JavaScript file at the same time as the declaration file.\n\nThe declaration file tells the compiler not only that a JavaScript file exists, but also what its name and extension are:\n\n| Declaration file extension | JavaScript file extension | TypeScript file extension |\n| --- | --- | --- |\n| `.d.ts` | `.js` | `.ts` |\n| `.d.ts` | `.js` | `.tsx` |\n| `.d.mts` | `.mjs` | `.mts` |\n| `.d.cts` | `.cjs` | `.cts` |\n| `.d.*.ts` | `.*` |     |\n\nThe last row expresses that non-JS files can be typed with the `allowArbitraryExtensions` compiler option to support cases where the module system supports importing non-JS files as JavaScript objects. For example, a file named `styles.css` can be represented by a declaration file named `styles.d.css.ts`.\n\n> “But wait! Plenty of declaration files are written by hand, _not_ generated by `tsc`. Ever heard of DefinitelyTyped?” you might object. And it’s true—hand-writing declaration files, or even moving/copying/renaming them to represent outputs of an external build tool, is a dangerous, error-prone venture. DefinitelyTyped contributors and authors of typed libraries not using `tsc` to generate both JavaScript and declaration files should ensure that every JavaScript file has a sibling declaration file with the same name and matching extension. Breaking from this structure can lead to false-positive TypeScript errors for end users. The npm package [`@arethetypeswrong/cli`](https://www.npmjs.com/package/@arethetypeswrong/cli)\n>  can help catch and explain these errors before they’re published.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution-for-bundlers-typescript-runtimes-and-nodejs-loaders)\nModule resolution for bundlers, TypeScript runtimes, and Node.js loaders\n\nSo far, we’ve really emphasized the distinction between _input files_ and _output files_. Recall that when specifying a file extension on a relative module specifier, TypeScript typically [makes you use the _output_ file extension](https://www.typescriptlang.org/docs/handbook/modules/theory.html#typescript-imitates-the-hosts-module-resolution-but-with-types)\n:\n\nts\n\n`   // @Filename: src/math.ts  export function add(a: number, b: number) {    return a + b;  }  // @Filename: src/main.ts  import { add } from \"./math.ts\";  //                  ^^^^^^^^^^^  // An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled.   `\n\nThis restriction applies since TypeScript [won’t rewrite the extension](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-specifiers-are-not-transformed)\n to `.js`, and if `\"./math.ts\"` appears in an output JS file, that import won’t resolve to another JS file at runtime. TypeScript really wants to prevent you from generating an unsafe output JS file. But what if there _is_ no output JS file? What if you’re in one of these situations:\n\n*   You’re bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you’ve written to produce a bundle.\n*   You’re running this code directly in a TypeScript runtime like Deno or Bun.\n*   You’re using `ts-node`, `tsx`, or another transpiling loader for Node.\n\nIn these cases, you can turn on `noEmit` (or `emitDeclarationOnly`) and `allowImportingTsExtensions` to disable emitting unsafe JavaScript files and silence the error on `.ts`\\-extensioned imports.\n\nWith or without `allowImportingTsExtensions`, it’s still important to pick the most appropriate `moduleResolution` setting for the module resolution host. For bundlers and the Bun runtime, it’s `bundler`. These module resolvers were inspired by Node.js, but didn’t adopt the strict ESM resolution algorithm that [disables extension searching](https://www.typescriptlang.org/docs/handbook/modules/theory.html#extension-searching-and-directory-index-files)\n that Node.js applies to imports. The `bundler` module resolution setting reflects this, enabling `package.json` `\"exports\"` support like `node16`—`nodenext`, while always allowing extensionless imports. See [_Choosing compiler options_](https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html)\n for more guidance.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution-for-libraries)\nModule resolution for libraries\n\nWhen compiling an app, you choose the `moduleResolution` option for a TypeScript project based on who the module resolution [host](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution-is-host-defined)\n is. When compiling a library, you don’t know where the output code will run, but you’d like it to run in as many places as possible. Using `\"module\": \"node18\"` (along with the implied [`\"moduleResolution\": \"node16\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext-1)\n) is the best bet for maximizing the compatibility of the output JavaScript’s module specifiers, since it will force you to comply with Node.js’s stricter rules for `import` module resolution. Let’s look at what would happen if a library were to compile with `\"moduleResolution\": \"bundler\"` (or worse, `\"node10\"`):\n\nts\n\n`   export * from \"./utils\";   `\n\nAssuming `./utils.ts` (or `./utils/index.ts`) exists, a bundler would be fine with this code, so `\"moduleResolution\": \"bundler\"` doesn’t complain. Compiled with `\"module\": \"esnext\"`, the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n\n`   Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js  Did you mean to import ./utils.js?   `\n\nOn the other hand, if we had written:\n\nts\n\n`   export * from \"./utils.js\";   `\n\nThis would produce output that works both in Node.js _and_ in bundlers.\n\nIn short, `\"moduleResolution\": \"bundler\"` is infectious, allowing code that only works in bundlers to be produced. Likewise, `\"moduleResolution\": \"nodenext\"` is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n\nOf course, this guidance can only apply in cases where the library ships outputs from `tsc`. If the library is being bundled _before_ shipping, `\"moduleResolution\": \"bundler\"` may be acceptable. Any build tool that changes the module format or module specifiers to produce the final build of the library bears the responsibility of ensuring the safety and compatibility of the product’s module code, and `tsc` can no longer contribute to that task, since it can’t know what module code will exist at runtime.\n\n* * *\n\n1.  In Node.js v22.12.0 and later, a `require` of an ES module is allowed, but only if the resolved module and its top-level imports don’t use top-level `await`. TypeScript does not try to enforce this rule, as it lacks the ability to tell from a declaration file whether the corresponding JavaScript file contains top-level `await`.[↩](https://www.typescriptlang.org/docs/handbook/modules/theory.html#fnref-1)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/modules-reference/Theory.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (7)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"theme-color":"#3178C6","og:title":"Documentation - Modules - Theory","twitter:site":"typescriptlang","language":"en","og:description":"How TypeScript models JavaScript modules","title":"TypeScript: Documentation - Modules - Theory","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"How TypeScript models JavaScript modules","ogDescription":"How TypeScript models JavaScript modules","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogTitle":"Documentation - Modules - Theory","generator":"Gatsby 5.13.5","scrapeId":"4b954074-53ea-4f7e-bdb2-8114fe129747","sourceURL":"https://www.typescriptlang.org/docs/handbook/modules/theory.html","url":"https://www.typescriptlang.org/docs/handbook/modules/theory.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModules - Reference\n===================\n\n[](https://www.typescriptlang.org/docs/handbook/modules/reference.html#module-syntax)\nModule syntax\n---------------------------------------------------------------------------------------------------\n\nThe TypeScript compiler recognizes standard [ECMAScript module syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)\n in TypeScript and JavaScript files and many forms of [CommonJS syntax](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#commonjs-modules-are-supported)\n in JavaScript files.\n\nThere are also a few TypeScript-specific syntax extensions that can be used in TypeScript files and/or JSDoc comments.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#importing-and-exporting-typescript-specific-declarations)\nImporting and exporting TypeScript-specific declarations\n\nType aliases, interfaces, enums, and namespaces can be exported from a module with an `export` modifier, like any standard JavaScript declaration:\n\nts\n\n`   // Standard JavaScript syntax...  export function f() {}  // ...extended to type declarations  export type SomeType = /* ... */;  export interface SomeInterface { /* ... */ }   `\n\nThey can also be referenced in named exports, even alongside references to standard JavaScript declarations:\n\nts\n\n`   export { f, SomeType, SomeInterface };   `\n\nExported types (and other TypeScript-specific declarations) can be imported with standard ECMAScript imports:\n\nts\n\n`   import { f, SomeType, SomeInterface } from \"./module.js\";   `\n\nWhen using namespace imports or exports, exported types are available on the namespace when referenced in a type position:\n\nts\n\n`   import * as mod from \"./module.js\";  mod.f();  mod.SomeType; // Property 'SomeType' does not exist on type 'typeof import(\"./module.js\")'  let x: mod.SomeType; // Ok   `\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#type-only-imports-and-exports)\nType-only imports and exports\n\nWhen emitting imports and exports to JavaScript, by default, TypeScript automatically elides (does not emit) imports that are only used in type positions and exports that only refer to types. Type-only imports and exports can be used to force this behavior and make the elision explicit. Import declarations written with `import type`, export declarations written with `export type { ... }`, and import or export specifiers prefixed with the `type` keyword are all guaranteed to be elided from the output JavaScript.\n\nts\n\n`   // @Filename: main.ts  import { f, type SomeInterface } from \"./module.js\";  import type { SomeType } from \"./module.js\";  class C implements SomeInterface {    constructor(p: SomeType) {      f();    }  }  export type { C };  // @Filename: main.js  import { f } from \"./module.js\";  class C {    constructor(p) {      f();    }  }   `\n\nEven values can be imported with `import type`, but since they won’t exist in the output JavaScript, they can only be used in non-emitting positions:\n\nts\n\n`   import type { f } from \"./module.js\";  f(); // 'f' cannot be used as a value because it was imported using 'import type'  let otherFunction: typeof f = () => {}; // Ok   `\n\nA type-only import declaration may not declare both a default import and named bindings, since it appears ambiguous whether `type` applies to the default import or to the entire import declaration. Instead, split the import declaration into two, or use `default` as a named binding:\n\nts\n\n`   import type fs, { BigIntOptions } from \"fs\";  //          ^^^^^^^^^^^^^^^^^^^^^  // Error: A type-only import can specify a default import or named bindings, but not both.  import type { default as fs, BigIntOptions } from \"fs\"; // Ok   `\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#import-types)\n`import()` types\n\nTypeScript provides a type syntax similar to JavaScript’s dynamic `import` for referencing the type of a module without writing an import declaration:\n\nts\n\n`   // Access an exported type:  type WriteFileOptions = import(\"fs\").WriteFileOptions;  // Access the type of an exported value:  type WriteFileFunction = typeof import(\"fs\").writeFile;   `\n\nThis is especially useful in JSDoc comments in JavaScript files, where it’s not possible to import types otherwise:\n\nts\n\n`   /** @type {import(\"webpack\").Configuration} */  module.exports = {    // ...  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#export--and-import--require)\n`export =` and `import = require()`\n\nWhen emitting CommonJS modules, TypeScript files can use a direct analog of `module.exports = ...` and `const mod = require(\"...\")` JavaScript syntax:\n\nts\n\n`   // @Filename: main.ts  import fs = require(\"fs\");  export = fs.readFileSync(\"...\");  // @Filename: main.js  \"use strict\";  const fs = require(\"fs\");  module.exports = fs.readFileSync(\"...\");   `\n\nThis syntax was used over its JavaScript counterparts since variable declarations and property assignments could not refer to TypeScript types, whereas special TypeScript syntax could:\n\nts\n\n`   // @Filename: a.ts  interface Options { /* ... */ }  module.exports = Options; // Error: 'Options' only refers to a type, but is being used as a value here.  export = Options; // Ok  // @Filename: b.ts  const Options = require(\"./a\");  const options: Options = { /* ... */ }; // Error: 'Options' refers to a value, but is being used as a type here.  // @Filename: c.ts  import Options = require(\"./a\");  const options: Options = { /* ... */ }; // Ok   `\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#ambient-modules)\nAmbient modules\n\nTypeScript supports a syntax in script (non-module) files for declaring a module that exists in the runtime but has no corresponding file. These _ambient modules_ usually represent runtime-provided modules, like `\"fs\"` or `\"path\"` in Node.js:\n\nts\n\n`   declare module \"path\" {    export function normalize(p: string): string;    export function join(...paths: any[]): string;    export var sep: string;  }   `\n\nOnce an ambient module is loaded into a TypeScript program, TypeScript will recognize imports of the declared module in other files:\n\nts\n\n`   // 👇 Ensure the ambient module is loaded -  //    may be unnecessary if path.d.ts is included  //    by the project tsconfig.json somehow.  /// <reference path=\"path.d.ts\" />  import { normalize, join } from \"path\";   `\n\nAmbient module declarations are easy to confuse with [module augmentations](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)\n since they use identical syntax. This module declaration syntax becomes a module augmentation when the file is a module, meaning it has a top-level `import` or `export` statement (or is affected by [`--moduleDetection force` or `auto`](https://www.typescriptlang.org/tsconfig#moduleDetection)\n):\n\nts\n\n`   // Not an ambient module declaration anymore!  export {};  declare module \"path\" {    export function normalize(p: string): string;    export function join(...paths: any[]): string;    export var sep: string;  }   `\n\nAmbient modules may use imports inside the module declaration body to refer to other modules without turning the containing file into a module (which would make the ambient module declaration a module augmentation):\n\nts\n\n`   declare module \"m\" {    // Moving this outside \"m\" would totally change the meaning of the file!    import { SomeType } from \"other\";    export function f(): SomeType;  }   `\n\nA _pattern_ ambient module contains a single `*` wildcard character in its name, matching zero or more characters in import paths. This can be useful for declaring modules provided by custom loaders:\n\nts\n\n`   declare module \"*.html\" {    const content: string;    export default content;  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/modules/reference.html#the-module-compiler-option)\nThe `module` compiler option\n-------------------------------------------------------------------------------------------------------------------------------\n\nThis section discusses the details of each `module` compiler option value. See the [_Module output format_](https://www.typescriptlang.org/docs/handbook/modules/theory.html#the-module-output-format)\n theory section for more background on what the option is and how it fits into the overall compilation process. In brief, the `module` compiler option was historically only used to control the output module format of emitted JavaScript files. The more recent `node16`, `node18`, and `nodenext` values, however, describe a wide range of characteristics of Node.js’s module system, including what module formats are supported, how the module format of each file is determined, and how different module formats interoperate.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-node18-nodenext)\n`node16`, `node18`, `nodenext`\n\nNode.js supports both CommonJS and ECMAScript modules, with specific rules for which format each file can be and how the two formats are allowed to interoperate. `node16`, `node18`, and `nodenext` describe the full range of behavior for Node.js’s dual-format module system, and **emit files in either CommonJS or ESM format**. This is different from every other `module` option, which are runtime-agnostic and force all output files into a single format, leaving it to the user to ensure the output is valid for their runtime.\n\n> A common misconception is that `node16`—`nodenext` only emit ES modules. In reality, these modes describe versions of Node.js that _support_ ES modules, not just projects that _use_ ES modules. Both ESM and CommonJS emit are supported, based on the [detected module format](https://www.typescriptlang.org/docs/handbook/modules/reference.html#module-format-detection)\n>  of each file. Because they are the only `module` options that reflect the complexities of Node.js’s dual module system, they are the **only correct `module` options** for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.\n\nThe fixed-version `node16` and `node18` modes represent the module system behavior stabilized in their respective Node.js versions, while the `nodenext` mode changes with the latest stable versions of Node.js. The following table summarizes the current differences between the three modes:\n\n|     | `target` | `moduleResolution` | import assertions | import attributes | JSON imports | require(esm) |\n| --- | --- | --- | --- | --- | --- | --- |\n| node16 | `es2022` | `node16` | ❌   | ❌   | no restrictions | ❌   |\n| node18 | `es2022` | `node16` | ✅   | ✅   | needs `type \"json\"` | ❌   |\n| nodenext | `esnext` | `nodenext` | ❌   | ✅   | needs `type \"json\"` | ✅   |\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#module-format-detection)\nModule format detection\n\n*   `.mts`/`.mjs`/`.d.mts` files are always ES modules.\n*   `.cts`/`.cjs`/`.d.cts` files are always CommonJS modules.\n*   `.ts`/`.tsx`/`.js`/`.jsx`/`.d.ts` files are ES modules if the nearest ancestor package.json file contains `\"type\": \"module\"`, otherwise CommonJS modules.\n\nThe detected module format of input `.ts`/`.tsx`/`.mts`/`.cts` files determines the module format of the emitted JavaScript files. So, for example, a project consisting entirely of `.ts` files will emit all CommonJS modules by default under `--module nodenext`, and can be made to emit all ES modules by adding `\"type\": \"module\"` to the project package.json.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#interoperability-rules)\nInteroperability rules\n\n*   **When an ES module references a CommonJS module:**\n    *   The `module.exports` of the CommonJS module is available as a default import to the ES module.\n    *   Properties (other than `default`) of the CommonJS module’s `module.exports` may or may not be available as named imports to the ES module. Node.js attempts to make them available via [static analysis](https://github.com/nodejs/cjs-module-lexer)\n        . TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See [#54018](https://github.com/microsoft/TypeScript/issues/54018)\n         for more details.\n*   **When a CommonJS module references an ES module:**\n    *   In `node16` and `node18`, `require` cannot reference an ES module. For TypeScript, this includes `import` statements in files that are [detected](https://www.typescriptlang.org/docs/handbook/modules/reference.html#module-format-detection)\n         to be CommonJS modules, since those `import` statements will be transformed to `require` calls in the emitted JavaScript.\n    *   In `nodenext`, to reflect the behavior of Node.js v22.12.0 and later, `require` can reference an ES module. In Node.js, an error is thrown if the ES module, or any of its imported modules, uses top-level `await`. TypeScript does not attempt to detect this case and will not emit a compile-time error. The result of the `require` call is the module’s Module Namespace Object, i.e., the same as the result of an `await import()` of the same module (but without the need to `await` anything).\n    *   A dynamic `import()` call can always be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get from `import * as ns from \"./module.js\"` from another ES module).\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#emit)\nEmit\n\nThe emit format of each file is determined by the [detected module format](https://www.typescriptlang.org/docs/handbook/modules/reference.html#module-format-detection)\n of each file. ESM emit is similar to [`--module esnext`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext)\n, but has a special transformation for `import x = require(\"...\")`, which is not allowed in `--module esnext`:\n\nts\n\n`   // @Filename: main.ts  import x = require(\"mod\");   `\n\njs\n\n`   // @Filename: main.js  import { createRequire as _createRequire } from \"module\";  const __require = _createRequire(import.meta.url);  const x = __require(\"mod\");   `\n\nCommonJS emit is similar to [`--module commonjs`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#commonjs)\n, but dynamic `import()` calls are not transformed. Emit here is shown with `esModuleInterop` enabled:\n\nts\n\n`   // @Filename: main.ts  import fs from \"fs\"; // transformed  const dynamic = import(\"mod\"); // not transformed   `\n\njs\n\n`   // @Filename: main.js  \"use strict\";  var __importDefault = (this && this.__importDefault) || function (mod) {      return (mod && mod.__esModule) ? mod : { \"default\": mod };  };  Object.defineProperty(exports, \"__esModule\", { value: true });  const fs_1 = __importDefault(require(\"fs\")); // transformed  const dynamic = import(\"mod\"); // not transformed   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#implied-and-enforced-options)\nImplied and enforced options\n\n*   `--module nodenext` implies and enforces `--moduleResolution nodenext`.\n*   `--module node18` or `node16` implies and enforces `--moduleResolution node16`.\n*   `--module nodenext` implies `--target esnext`.\n*   `--module node18` or `node16` implies `--target es2022`.\n*   `--module nodenext` or `node18` or `node16` implies `--esModuleInterop`.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#summary)\nSummary\n\n*   `node16`, `node18`, and `nodenext` are the only correct `module` options for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.\n*   `node16`, `node18`, and `nodenext` emit files in either CommonJS or ESM format, based on the [detected module format](https://www.typescriptlang.org/docs/handbook/modules/reference.html#module-format-detection)\n     of each file.\n*   Node.js’s interoperability rules between ESM and CJS are reflected in type checking.\n*   ESM emit transforms `import x = require(\"...\")` to a `require` call constructed from a `createRequire` import.\n*   CommonJS emit leaves dynamic `import()` calls untransformed, so CommonJS modules can asynchronously import ES modules.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#preserve)\n`preserve`\n\nIn `--module preserve` ([added](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve)\n in TypeScript 5.4), ECMAScript imports and exports written in input files are preserved in the output, and CommonJS-style `import x = require(\"...\")` and `export = ...` statements are emitted as CommonJS `require` and `module.exports`. In other words, the format of each individual import or export statement is preserved, rather than being coerced into a single format for the whole compilation (or even a whole file).\n\nWhile it’s rare to need to mix imports and require calls in the same file, this `module` mode best reflects the capabilities of most modern bundlers, as well as the Bun runtime.\n\n> Why care about TypeScript’s `module` emit with a bundler or with Bun, where you’re likely also setting `noEmit`? TypeScript’s type checking and module resolution behavior are affected by the module format that it _would_ emit. Setting `module` gives TypeScript information about how your bundler or runtime will process imports and exports, which ensures that the types you see on imported values accurately reflect what will happen at runtime or after bundling. See [`--moduleResolution bundler`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#bundler)\n>  for more discussion.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#examples)\nExamples\n\nts\n\n`   import x, { y, z } from \"mod\";  import mod = require(\"mod\");  const dynamic = import(\"mod\");  export const e1 = 0;  export default \"default export\";   `\n\njs\n\n`   import x, { y, z } from \"mod\";  const mod = require(\"mod\");  const dynamic = import(\"mod\");  export const e1 = 0;  export default \"default export\";   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#implied-and-enforced-options-1)\nImplied and enforced options\n\n*   `--module preserve` implies `--moduleResolution bundler`.\n*   `--module preserve` implies `--esModuleInterop`.\n\n> The option `--esModuleInterop` is enabled by default in `--module preserve` only for its [type checking](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#allowsyntheticdefaultimports-and-esmoduleinterop)\n>  behavior. Since imports never transform into require calls in `--module preserve`, `--esModuleInterop` does not affect the emitted JavaScript.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext)\n`es2015`, `es2020`, `es2022`, `esnext`\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#summary-1)\nSummary\n\n*   Use `esnext` with `--moduleResolution bundler` for bundlers, Bun, and tsx.\n*   Do not use for Node.js. Use `node16`, `node18`, or `nodenext` with `\"type\": \"module\"` in package.json to emit ES modules for Node.js.\n*   `import mod = require(\"mod\")` is not allowed in non-declaration files.\n*   `es2020` adds support for `import.meta` properties.\n*   `es2022` adds support for top-level `await`.\n*   `esnext` is a moving target that may include support for Stage 3 proposals to ECMAScript modules.\n*   Emitted files are ES modules, but dependencies may be any format.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#examples-1)\nExamples\n\nts\n\n`   // @Filename: main.ts  import x, { y, z } from \"mod\";  import * as mod from \"mod\";  const dynamic = import(\"mod\");  console.log(x, y, z, mod, dynamic);  export const e1 = 0;  export default \"default export\";   `\n\njs\n\n`   // @Filename: main.js  import x, { y, z } from \"mod\";  import * as mod from \"mod\";  const dynamic = import(\"mod\");  console.log(x, y, z, mod, dynamic);  export const e1 = 0;  export default \"default export\";   `\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#commonjs)\n`commonjs`\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#summary-2)\nSummary\n\n*   You probably shouldn’t use this. Use `node16`, `node18`, or `nodenext` to emit CommonJS modules for Node.js.\n*   Emitted files are CommonJS modules, but dependencies may be any format.\n*   Dynamic `import()` is transformed to a Promise of a `require()` call.\n*   `esModuleInterop` affects the output code for default and namespace imports.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#examples-2)\nExamples\n\n> Output is shown with `esModuleInterop: false`.\n\nts\n\n`   // @Filename: main.ts  import x, { y, z } from \"mod\";  import * as mod from \"mod\";  const dynamic = import(\"mod\");  console.log(x, y, z, mod, dynamic);  export const e1 = 0;  export default \"default export\";   `\n\njs\n\n`   // @Filename: main.js  \"use strict\";  Object.defineProperty(exports, \"__esModule\", { value: true });  exports.e1 = void 0;  const mod_1 = require(\"mod\");  const mod = require(\"mod\");  const dynamic = Promise.resolve().then(() => require(\"mod\"));  console.log(mod_1.default, mod_1.y, mod_1.z, mod);  exports.e1 = 0;  exports.default = \"default export\";   `\n\nts\n\n`   // @Filename: main.ts  import mod = require(\"mod\");  console.log(mod);  export = {      p1: true,      p2: false  };   `\n\njs\n\n`   // @Filename: main.js  \"use strict\";  const mod = require(\"mod\");  console.log(mod);  module.exports = {      p1: true,      p2: false  };   `\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#system)\n`system`\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#summary-3)\nSummary\n\n*   Designed for use with the [SystemJS module loader](https://github.com/systemjs/systemjs)\n    .\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#examples-3)\nExamples\n\nts\n\n`   // @Filename: main.ts  import x, { y, z } from \"mod\";  import * as mod from \"mod\";  const dynamic = import(\"mod\");  console.log(x, y, z, mod, dynamic);  export const e1 = 0;  export default \"default export\";   `\n\njs\n\n`   // @Filename: main.js  System.register([\"mod\"], function (exports_1, context_1) {      \"use strict\";      var mod_1, mod, dynamic, e1;      var __moduleName = context_1 && context_1.id;      return {          setters: [              function (mod_1_1) {                  mod_1 = mod_1_1;                  mod = mod_1_1;              }          ],          execute: function () {              dynamic = context_1.import(\"mod\");              console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);              exports_1(\"e1\", e1 = 0);              exports_1(\"default\", \"default export\");          }      };  });   `\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#amd)\n`amd`\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#summary-4)\nSummary\n\n*   Designed for AMD loaders like RequireJS.\n*   You probably shouldn’t use this. Use a bundler instead.\n*   Emitted files are AMD modules, but dependencies may be any format.\n*   Supports `outFile`.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#examples-4)\nExamples\n\nts\n\n`   // @Filename: main.ts  import x, { y, z } from \"mod\";  import * as mod from \"mod\";  const dynamic = import(\"mod\");  console.log(x, y, z, mod, dynamic);  export const e1 = 0;  export default \"default export\";   `\n\njs\n\n`   // @Filename: main.js  define([\"require\", \"exports\", \"mod\", \"mod\"], function (require, exports, mod_1, mod) {      \"use strict\";      Object.defineProperty(exports, \"__esModule\", { value: true });      exports.e1 = void 0;      const dynamic = new Promise((resolve_1, reject_1) => { require([\"mod\"], resolve_1, reject_1); });      console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);      exports.e1 = 0;      exports.default = \"default export\";  });   `\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#umd)\n`umd`\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#summary-5)\nSummary\n\n*   Designed for AMD or CommonJS loaders.\n*   Does not expose a global variable like most other UMD wrappers.\n*   You probably shouldn’t use this. Use a bundler instead.\n*   Emitted files are UMD modules, but dependencies may be any format.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#examples-5)\nExamples\n\nts\n\n`   // @Filename: main.ts  import x, { y, z } from \"mod\";  import * as mod from \"mod\";  const dynamic = import(\"mod\");  console.log(x, y, z, mod, dynamic);  export const e1 = 0;  export default \"default export\";   `\n\njs\n\n`   // @Filename: main.js  (function (factory) {      if (typeof module === \"object\" && typeof module.exports === \"object\") {          var v = factory(require, exports);          if (v !== undefined) module.exports = v;      }      else if (typeof define === \"function\" && define.amd) {          define([\"require\", \"exports\", \"mod\", \"mod\"], factory);      }  })(function (require, exports) {      \"use strict\";      var __syncRequire = typeof module === \"object\" && typeof module.exports === \"object\";      Object.defineProperty(exports, \"__esModule\", { value: true });      exports.e1 = void 0;      const mod_1 = require(\"mod\");      const mod = require(\"mod\");      const dynamic = __syncRequire ? Promise.resolve().then(() => require(\"mod\")) : new Promise((resolve_1, reject_1) => { require([\"mod\"], resolve_1, reject_1); });      console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);      exports.e1 = 0;      exports.default = \"default export\";  });   `\n\n[](https://www.typescriptlang.org/docs/handbook/modules/reference.html#the-moduleresolution-compiler-option)\nThe `moduleResolution` compiler option\n---------------------------------------------------------------------------------------------------------------------------------------------------\n\nThis section describes module resolution features and processes shared by multiple `moduleResolution` modes, then specifies the details of each mode. See the [_Module resolution_](https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution)\n theory section for more background on what the option is and how it fits into the overall compilation process. In brief, `moduleResolution` controls how TypeScript resolves _module specifiers_ (string literals in `import`/`export`/`require` statements) to files on disk, and should be set to match the module resolver used by the target runtime or bundler.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#common-features-and-processes)\nCommon features and processes\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\nFile extension substitution\n\nTypeScript always wants to resolve internally to a file that can provide type information, while ensuring that the runtime or bundler can use the same path to resolve to a file that provides a JavaScript implementation. For any module specifier that would, according to the `moduleResolution` algorithm specified, trigger a lookup of a JavaScript file in the runtime or bundler, TypeScript will first try to find a TypeScript implementation file or type declaration file with the same name and analagous file extension.\n\n| Runtime lookup | TypeScript lookup #1 | TypeScript lookup #2 | TypeScript lookup #3 | TypeScript lookup #4 | TypeScript lookup #5 |\n| --- | --- | --- | --- | --- | --- |\n| `/mod.js` | `/mod.ts` | `/mod.tsx` | `/mod.d.ts` | `/mod.js` | `./mod.jsx` |\n| `/mod.mjs` | `/mod.mts` | `/mod.d.mts` | `/mod.mjs` |     |     |\n| `/mod.cjs` | `/mod.cts` | `/mod.d.cts` | `/mod.cjs` |     |     |\n\nNote that this behavior is independent of the actual module specifier written in the import. This means that TypeScript can resolve to a `.ts` or `.d.ts` file even if the module specifier explicitly uses a `.js` file extension:\n\nts\n\n`   import x from \"./mod.js\";  // Runtime lookup: \"./mod.js\"  // TypeScript lookup #1: \"./mod.ts\"  // TypeScript lookup #2: \"./mod.d.ts\"  // TypeScript lookup #3: \"./mod.js\"   `\n\nSee [_TypeScript imitates the host’s module resolution, but with types_](https://www.typescriptlang.org/docs/handbook/modules/theory.html#typescript-imitates-the-hosts-module-resolution-but-with-types)\n for an explanation of why TypeScript’s module resolution works this way.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#relative-file-path-resolution)\nRelative file path resolution\n\nAll of TypeScript’s `moduleResolution` algorithms support referencing a module by a relative path that includes a file extension (which will be substituted according to the [rules above](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n):\n\nts\n\n``   // @Filename: a.ts  export {};  // @Filename: b.ts  import {} from \"./a.js\"; // ✅ Works in every `moduleResolution`   ``\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#extensionless-relative-paths)\nExtensionless relative paths\n\nIn some cases, the runtime or bundler allows omitting a `.js` file extension from a relative path. TypeScript supports this behavior where the `moduleResolution` setting and the context indicate that the runtime or bundler supports it:\n\nts\n\n`   // @Filename: a.ts  export {};  // @Filename: b.ts  import {} from \"./a\";   `\n\nIf TypeScript determines that the runtime will perform a lookup for `./a.js` given the module specifier `\"./a\"`, then `./a.js` will undergo [extension substitution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n, and resolve to the file `a.ts` in this example.\n\nExtensionless relative paths are not supported in `import` paths in Node.js, and are not always supported in file paths specified in package.json files. TypeScript currently never supports omitting a `.mjs`/`.mts` or `.cjs`/`.cts` file extension, even though some runtimes and bundlers do.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#directory-modules-index-file-resolution)\nDirectory modules (index file resolution)\n\nIn some cases, a directory, rather than a file, can be referenced as a module. In the simplest and most common case, this involves the runtime or bundler looking for an `index.js` file in a directory. TypeScript supports this behavior where the `moduleResolution` setting and the context indicate that the runtime or bundler supports it:\n\nts\n\n`   // @Filename: dir/index.ts  export {};  // @Filename: b.ts  import {} from \"./dir\";   `\n\nIf TypeScript determines that the runtime will perform a lookup for `./dir/index.js` given the module specifier `\"./dir\"`, then `./dir/index.js` will undergo [extension substitution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n, and resolve to the file `dir/index.ts` in this example.\n\nDirectory modules may also contain a package.json file, where resolution of the [`\"main\"` and `\"types\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-main-and-types)\n fields are supported, and take precedence over `index.js` lookups. The [`\"typesVersions\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-typesversions)\n field is also supported in directory modules.\n\nNote that directory modules are not the same as [`node_modules` packages](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n and only support a subset of the features available to packages, and are not supported at all in some contexts. Node.js considers them a [legacy feature](https://nodejs.org/dist/latest-v20.x/docs/api/modules.html#folders-as-modules)\n.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths)\n`paths`\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#overview)\nOverview\n\nTypeScript offers a way to override the compiler’s module resolution for bare specifiers with the `paths` compiler option. While the feature was originally designed to be used with the AMD module loader (a means of running modules in the browser before ESM existed or bundlers were widely used), it still has uses today when a runtime or bundler supports module resolution features that TypeScript does not model. For example, when running Node.js with `--experimental-network-imports`, you can manually specify a local type definition file for a specific `https://` import:\n\njson\n\n`   {    \"compilerOptions\": {      \"module\": \"nodenext\",      \"paths\": {        \"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"]      }    }  }   `\n\nts\n\n``   // Typed by ./node_modules/@types/lodash/index.d.ts due to `paths` entry  import { add } from \"https://esm.sh/lodash@4.17.21\";   ``\n\nIt’s also common for apps built with bundlers to define convenience path aliases in their bundler configuration, and then inform TypeScript of those aliases with `paths`:\n\njson\n\n`   {    \"compilerOptions\": {      \"module\": \"esnext\",      \"moduleResolution\": \"bundler\",      \"paths\": {        \"@app/*\": [\"./src/*\"]      }    }  }   `\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths-does-not-affect-emit)\n`paths` does not affect emit\n\nThe `paths` option does _not_ change the import path in the code emitted by TypeScript. Consequently, it’s very easy to create path aliases that appear to work in TypeScript but will crash at runtime:\n\njson\n\n`   {    \"compilerOptions\": {      \"module\": \"nodenext\",      \"paths\": {        \"node-has-no-idea-what-this-is\": [\"./oops.ts\"]      }    }  }   `\n\nts\n\n`   // TypeScript: ✅  // Node.js: 💥  import {} from \"node-has-no-idea-what-this-is\";   `\n\nWhile it’s ok for bundled apps to set up `paths`, it’s very important that published libraries do _not_, since the emitted JavaScript will not work for consumers of the library without those users setting up the same aliases for both TypeScript and their bundler. Both libraries and apps can consider [package.json `\"imports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-imports-and-self-name-imports)\n as a standard replacement for convenience `paths` aliases.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths-should-not-point-to-monorepo-packages-or-node_modules-packages)\n`paths` should not point to monorepo packages or node\\_modules packages\n\nWhile module specifiers that match `paths` aliases are bare specifiers, once the alias is resolved, module resolution proceeds on the resolved path as a relative path. Consequently, resolution features that happen for [`node_modules` package lookups](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n, including package.json `\"exports\"` field support, do not take effect when a `paths` alias is matched. This can lead to surprising behavior if `paths` is used to point to a `node_modules` package:\n\nts\n\n`   {    \"compilerOptions\": {      \"paths\": {        \"pkg\": [\"./node_modules/pkg/dist/index.d.ts\"],        \"pkg/*\": [\"./node_modules/pkg/*\"]      }    }  }   `\n\nWhile this configuration may simulate some of the behavior of package resolution, it overrides any `main`, `types`, `exports`, and `typesVersions` the package’s `package.json` file defines, and imports from the package may fail at runtime.\n\nThe same caveat applies to packages referencing each other in a monorepo. Instead of using `paths` to make TypeScript artificially resolve `\"@my-scope/lib\"` to a sibling package, it’s best to use workspaces via [npm](https://docs.npmjs.com/cli/v7/using-npm/workspaces)\n, [yarn](https://classic.yarnpkg.com/en/docs/workspaces/)\n, or [pnpm](https://pnpm.io/workspaces)\n to symlink your packages into `node_modules`, so both TypeScript and the runtime or bundler perform real `node_modules` package lookups. This is especially important if the monorepo packages will be published to npm—the packages will reference each other via `node_modules` package lookups once installed by users, and using workspaces allows you to test that behavior during local development.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#relationship-to-baseurl)\nRelationship to `baseUrl`\n\nWhen [`baseUrl`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#baseurl)\n is provided, the values in each `paths` array are resolved relative to the `baseUrl`. Otherwise, they are resolved relative to the `tsconfig.json` file that defines them.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#wildcard-substitutions)\nWildcard substitutions\n\n`paths` patterns can contain a single `*` wildcard, which matches any string. The `*` token can then be used in the file path values to substitute the matched string:\n\njson\n\n`   {    \"compilerOptions\": {      \"paths\": {        \"@app/*\": [\"./src/*\"]      }    }  }   `\n\nWhen resolving an import of `\"@app/components/Button\"`, TypeScript will match on `@app/*`, binding `*` to `components/Button`, and then attempt to resolve the path `./src/components/Button` relative to the `tsconfig.json` path. The remainder of this lookup will follow the same rules as any other [relative path lookup](https://www.typescriptlang.org/docs/handbook/modules/reference.html#relative-file-path-resolution)\n according to the `moduleResolution` setting.\n\nWhen multiple patterns match a module specifier, the pattern with the longest matching prefix before any `*` token is used:\n\njson\n\n`   {    \"compilerOptions\": {      \"paths\": {        \"*\": [\"./src/foo/one.ts\"],        \"foo/*\": [\"./src/foo/two.ts\"],        \"foo/bar\": [\"./src/foo/three.ts\"]      }    }  }   `\n\nWhen resolving an import of `\"foo/bar\"`, all three `paths` patterns match, but the last is used because `\"foo/bar\"` is longer than `\"foo/\"` and `\"\"`.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#fallbacks)\nFallbacks\n\nMultiple file paths can be provided for a path mapping. If resolution fails for one path, the next one in the array will be attempted until resolution succeeds or the end of the array is reached.\n\njson\n\n`   {    \"compilerOptions\": {      \"paths\": {        \"*\": [\"./vendor/*\", \"./types/*\"]      }    }  }   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#baseurl)\n`baseUrl`\n\n> `baseUrl` was designed for use with AMD module loaders. If you aren’t using an AMD module loader, you probably shouldn’t use `baseUrl`. Since TypeScript 4.1, `baseUrl` is no longer required to use [`paths`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths)\n>  and should not be used just to set the directory `paths` values are resolved from.\n\nThe `baseUrl` compiler option can be combined with any `moduleResolution` mode and specifies a directory that bare specifiers (module specifiers that don’t begin with `./`, `../`, or `/`) are resolved from. `baseUrl` has a higher precedence than [`node_modules` package lookups](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n in `moduleResolution` modes that support them.\n\nWhen performing a `baseUrl` lookup, resolution proceeds with the same rules as other relative path resolutions. For example, in a `moduleResolution` mode that supports [extensionless relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#extensionless-relative-paths)\n a module specifier `\"some-file\"` may resolve to `/src/some-file.ts` if `baseUrl` is set to `/src`.\n\nResolution of relative module specifiers are never affected by the `baseUrl` option.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n`node_modules` package lookups\n\nNode.js treats module specifiers that aren’t relative paths, absolute paths, or URLs as references to packages that it looks up in `node_modules` subdirectories. Bundlers conveniently adopted this behavior to allow their users to use the same dependency management system, and often even the same dependencies, as they would in Node.js. All of TypeScript’s `moduleResolution` options except `classic` support `node_modules` lookups. (`classic` supports lookups in `node_modules/@types` when other means of resolution fail, but never looks for packages in `node_modules` directly.) Every `node_modules` package lookup has the following structure (beginning after higher precedence bare specifier rules, like `paths`, `baseUrl`, self-name imports, and package.json `\"imports\"` lookups have been exhausted):\n\n1.  For each ancestor directory of the importing file, if a `node_modules` directory exists within it:\n    1.  If a directory with the same name as the package exists within `node_modules`:\n        1.  Attempt to resolve types from the package directory.\n        2.  If a result is found, return it and stop the search.\n    2.  If a directory with the same name as the package exists within `node_modules/@types`:\n        1.  Attempt to resolve types from the `@types` package directory.\n        2.  If a result is found, return it and stop the search.\n2.  Repeat the previous search through all `node_modules` directories, but this time, allow JavaScript files as a result, and do not search in `@types` directories.\n\nAll `moduleResolution` modes (except `classic`) follow this pattern, while the details of how they resolve from a package directory, once located, differ, and are explained in the following sections.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\npackage.json `\"exports\"`\n\nWhen `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and `resolvePackageJsonExports` is not disabled, TypeScript follows Node.js’s [package.json `\"exports\"` spec](https://nodejs.org/api/packages.html#packages_package_entry_points)\n when resolving from a package directory triggered by a [bare specifier `node_modules` package lookup](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n.\n\nTypeScript’s implementation for resolving a module specifier through `\"exports\"` to a file path follows Node.js exactly. Once a file path is resolved, however, TypeScript will still [try multiple file extensions](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n in order to prioritize finding types.\n\nWhen resolving through [conditional `\"exports\"`](https://nodejs.org/api/packages.html#conditional-exports)\n, TypeScript always matches the `\"types\"` and `\"default\"` conditions if present. Additionally, TypeScript will match a versioned types condition in the form `\"types@{selector}\"` (where `{selector}` is a `\"typesVersions\"`\\-compatible version selector) according to the same version-matching rules implemented in [`\"typesVersions\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-typesversions)\n. Other non-configurable conditions are dependent on the `moduleResolution` mode and specified in the following sections. Additional conditions can be configured to match with the `customConditions` compiler option.\n\nNote that the presence of `\"exports\"` prevents any subpaths not explicitly listed or matched by a pattern in `\"exports\"` from being resolved.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-subpaths-conditions-and-extension-substitution)\nExample: subpaths, conditions, and extension substitution\n\nScenario: `\"pkg/subpath\"` is requested with conditions `[\"types\", \"node\", \"require\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\njson\n\n`   {    \"name\": \"pkg\",    \"exports\": {      \".\": {        \"import\": \"./index.mjs\",        \"require\": \"./index.cjs\"      },      \"./subpath\": {        \"import\": \"./subpath/index.mjs\",        \"require\": \"./subpath/index.cjs\"      }    }  }   `\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./subpath\"` entry? **Yes.**\n3.  The value at `exports[\"./subpath\"]` is an object—it must be specifying conditions.\n4.  Does the first condition `\"import\"` match this request? **No.**\n5.  Does the second condition `\"require\"` match this request? **Yes.**\n6.  Does the path `\"./subpath/index.cjs\"` have a recognized TypeScript file extension? **No, so use extension substitution.**\n7.  Via [extension substitution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n    , try the following paths, returning the first one that exists, or `undefined` otherwise:\n    1.  `./subpath/index.cts`\n    2.  `./subpath/index.d.cts`\n    3.  `./subpath/index.cjs`\n\nIf `./subpath/index.cts` or `./subpath.d.cts` exists, resolution is complete. Otherwise, resolution searches `node_modules/@types/pkg` and other `node_modules` directories in an attempt to resolve types, according to the [`node_modules` package lookups](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n rules. If no types are found, a second pass through all `node_modules` resolves to `./subpath/index.cjs` (assuming it exists), which counts as a successful resolution, but one that does not provide types, leading to `any`\\-typed imports and a `noImplicitAny` error if enabled.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-explicit-types-condition)\nExample: explicit `\"types\"` condition\n\nScenario: `\"pkg/subpath\"` is requested with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\njson\n\n`   {    \"name\": \"pkg\",    \"exports\": {      \"./subpath\": {        \"import\": {          \"types\": \"./types/subpath/index.d.mts\",          \"default\": \"./es/subpath/index.mjs\"        },        \"require\": {          \"types\": \"./types/subpath/index.d.cts\",          \"default\": \"./cjs/subpath/index.cjs\"        }      }    }  }   `\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./subpath\"` entry? **Yes.**\n3.  The value at `exports[\"./subpath\"]` is an object—it must be specifying conditions.\n4.  Does the first condition `\"import\"` match this request? **Yes.**\n5.  The value at `exports[\"./subpath\"].import` is an object—it must be specifying conditions.\n6.  Does the first condition `\"types\"` match this request? **Yes.**\n7.  Does the path `\"./types/subpath/index.d.mts\"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n8.  Return the path `\"./types/subpath/index.d.mts\"` if the file exists, `undefined` otherwise.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-versioned-types-condition)\nExample: versioned `\"types\"` condition\n\nScenario: using TypeScript 4.7.5, `\"pkg/subpath\"` is requested with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\njson\n\n`   {    \"name\": \"pkg\",    \"exports\": {      \"./subpath\": {        \"types@>=5.2\": \"./ts5.2/subpath/index.d.ts\",        \"types@>=4.6\": \"./ts4.6/subpath/index.d.ts\",        \"types\": \"./tsold/subpath/index.d.ts\",        \"default\": \"./dist/subpath/index.js\"      }    }  }   `\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./subpath\"` entry? **Yes.**\n3.  The value at `exports[\"./subpath\"]` is an object—it must be specifying conditions.\n4.  Does the first condition `\"types@>=5.2\"` match this request? **No, 4.7.5 is not greater than or equal to 5.2.**\n5.  Does the second condition `\"types@>=4.6\"` match this request? **Yes, 4.7.5 is greater than or equal to 4.6.**\n6.  Does the path `\"./ts4.6/subpath/index.d.ts\"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n7.  Return the path `\"./ts4.6/subpath/index.d.ts\"` if the file exists, `undefined` otherwise.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-subpath-patterns)\nExample: subpath patterns\n\nScenario: `\"pkg/wildcard.js\"` is requested with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\njson\n\n`   {    \"name\": \"pkg\",    \"type\": \"module\",    \"exports\": {      \"./*.js\": {        \"types\": \"./types/*.d.ts\",        \"default\": \"./dist/*.js\"      }    }  }   `\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  Does `\"exports\"` have a `\"./wildcard.js\"` entry? **No.**\n3.  Does any key with a `*` in it match `\"./wildcard.js\"`? **Yes, `\"./*.js\"` matches and sets `wildcard` to be the substitution.**\n4.  The value at `exports[\"./*.js\"]` is an object—it must be specifying conditions.\n5.  Does the first condition `\"types\"` match this request? **Yes.**\n6.  In `./types/*.d.ts`, replace `*` with the substitution `wildcard`. **`./types/wildcard.d.ts`**\n7.  Does the path `\"./types/wildcard.d.ts\"` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n8.  Return the path `\"./types/wildcard.d.ts\"` if the file exists, `undefined` otherwise.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-exports-block-other-subpaths)\nExample: `\"exports\"` block other subpaths\n\nScenario: `\"pkg/dist/index.js\"` is requested in a package directory with the following package.json:\n\njson\n\n`   {    \"name\": \"pkg\",    \"main\": \"./dist/index.js\",    \"exports\": \"./dist/index.js\"  }   `\n\nResolution process within the package directory:\n\n1.  Does `\"exports\"` exist? **Yes.**\n2.  The value at `exports` is a string—it must be a file path for the package root (`\".\"`).\n3.  Is the request `\"pkg/dist/index.js\"` for the package root? **No, it has a subpath `dist/index.js`.**\n4.  Resolution fails; return `undefined`.\n\nWithout `\"exports\"`, the request could have succeeded, but the presence of `\"exports\"` prevents resolving any subpaths that cannot be matched through `\"exports\"`.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-typesversions)\npackage.json `\"typesVersions\"`\n\nA [`node_modules` package](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n or [directory module](https://www.typescriptlang.org/docs/handbook/modules/reference.html#directory-modules-index-file-resolution)\n may specify a `\"typesVersions\"` field in its package.json to redirect TypeScript’s resolution process according to the TypeScript compiler version, and for `node_modules` packages, according to the subpath being resolved. This allows package authors to include new TypeScript syntax in one set of type definitions while providing another set for backward compatibility with older TypeScript versions (through a tool like [downlevel-dts](https://github.com/sandersn/downlevel-dts)\n). `\"typesVersions\"` is supported in all `moduleResolution` modes; however, the field is not read in situations when [package.json `\"exports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\n are read.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-redirect-all-requests-to-a-subdirectory)\nExample: redirect all requests to a subdirectory\n\nScenario: a module imports `\"pkg\"` using TypeScript 5.2, where `node_modules/pkg/package.json` is:\n\njson\n\n`   {    \"name\": \"pkg\",    \"version\": \"1.0.0\",    \"types\": \"./index.d.ts\",    \"typesVersions\": {      \">=3.1\": {        \"*\": [\"ts3.1/*\"]      }    }  }   `\n\nResolution process:\n\n1.  (Depending on compiler options) Does `\"exports\"` exist? **No.**\n2.  Does `\"typesVersions\"` exist? **Yes.**\n3.  Is the TypeScript version `>=3.1`? **Yes. Remember the mapping `\"*\": [\"ts3.1/*\"]`.**\n4.  Are we resolving a subpath after the package name? **No, just the root `\"pkg\"`.**\n5.  Does `\"types\"` exist? **Yes.**\n6.  Does any key in `\"typesVersions\"` match `./index.d.ts`? **Yes, `\"*\"` matches and sets `index.d.ts` to be the substitution.**\n7.  In `ts3.1/*`, replace `*` with the substitution `./index.d.ts`: **`ts3.1/index.d.ts`**.\n8.  Does the path `./ts3.1/index.d.ts` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n9.  Return the path `./ts3.1/index.d.ts` if the file exists, `undefined` otherwise.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-redirect-requests-for-a-specific-file)\nExample: redirect requests for a specific file\n\nScenario: a module imports `\"pkg\"` using TypeScript 3.9, where `node_modules/pkg/package.json` is:\n\njson\n\n`   {    \"name\": \"pkg\",    \"version\": \"1.0.0\",    \"types\": \"./index.d.ts\",    \"typesVersions\": {      \"<4.0\": { \"index.d.ts\": [\"index.v3.d.ts\"] }    }  }   `\n\nResolution process:\n\n1.  (Depending on compiler options) Does `\"exports\"` exist? **No.**\n2.  Does `\"typesVersions\"` exist? **Yes.**\n3.  Is the TypeScript version `<4.0`? **Yes. Remember the mapping `\"index.d.ts\": [\"index.v3.d.ts\"]`.**\n4.  Are we resolving a subpath after the package name? **No, just the root `\"pkg\"`.**\n5.  Does `\"types\"` exist? **Yes.**\n6.  Does any key in `\"typesVersions\"` match `./index.d.ts`? **Yes, `\"index.d.ts\"` matches.**\n7.  Does the path `./index.v3.d.ts` have a recognized TypeScript file extension? **Yes, so don’t use extension substitution.**\n8.  Return the path `./index.v3.d.ts` if the file exists, `undefined` otherwise.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-main-and-types)\npackage.json `\"main\"` and `\"types\"`\n\nIf a directory’s [package.json `\"exports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\n field is not read (either due to compiler options, or because it is not present, or because the directory is being resolved as a [directory module](https://www.typescriptlang.org/docs/handbook/modules/reference.html#directory-modules-index-file-resolution)\n instead of a [`node_modules` package](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n) and the module specifier does not have a subpath after the package name or package.json-containing directory, TypeScript will attempt to resolve from these package.json fields, in order, in an attempt to find the main module for the package or directory:\n\n*   `\"types\"`\n*   `\"typings\"` (legacy)\n*   `\"main\"`\n\nThe declaration file found at `\"types\"` is assumed to be an accurate representation of the implementation file found at `\"main\"`. If `\"types\"` and `\"typings\"` are not present or cannot be resolved, TypeScript will read the `\"main\"` field and perform [extension substitution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n to find a declaration file.\n\nWhen publishing a typed package to npm, it’s recommended to include a `\"types\"` field even if [extension substitution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n or [package.json `\"exports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\n make it unnecessary, because npm shows a TS icon on the package registry listing only if the package.json contains a `\"types\"` field.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#package-relative-file-paths)\nPackage-relative file paths\n\nIf neither [package.json `\"exports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\n nor [package.json `\"typesVersions\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-typesversions)\n apply, subpaths of a bare package specifier resolve relative to the package directory, according to applicable [relative path](https://www.typescriptlang.org/docs/handbook/modules/reference.html#relative-file-path-resolution)\n resolution rules. In modes that respect \\[package.json `\"exports\"`\\], this behavior is blocked by the mere presence of the `\"exports\"` field in the package’s package.json, even if the import fails to resolve through `\"exports\"`, as demonstrated in [an example above](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-exports-block-other-subpaths)\n. On the other hand, if the import fails to resolve through `\"typesVersions\"`, a package-relative file path resolution is attempted as a fallback.\n\nWhen package-relative paths are supported, they resolve under the same rules as any other relative path considering the `moduleResolution` mode and context. For example, in [`--moduleResolution nodenext`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext-1)\n, [directory modules](https://www.typescriptlang.org/docs/handbook/modules/reference.html#directory-modules-index-file-resolution)\n and [extensionless paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#extensionless-relative-paths)\n are only supported in `require` calls, not in `import`s:\n\nts\n\n``   // @Filename: module.mts  import \"pkg/dist/foo\";                // ❌ import, needs `.js` extension  import \"pkg/dist/foo.js\";             // ✅  import foo = require(\"pkg/dist/foo\"); // ✅ require, no extension needed   ``\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-imports-and-self-name-imports)\npackage.json `\"imports\"` and self-name imports\n\nWhen `moduleResolution` is set to `node16`, `nodenext`, or `bundler`, and `resolvePackageJsonImports` is not disabled, TypeScript will attempt to resolve import paths beginning with `#` through the `\"imports\"` field of the nearest ancestor package.json of the importing file. Similarly, when [package.json `\"exports\"` lookups](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\n are enabled, TypeScript will attempt to resolve import paths beginning with the current package name—that is, the value in the `\"name\"` field of the nearest ancestor package.json of the importing file—through the `\"exports\"` field of that package.json. Both of these features allow files in a package to import other files in the same package, replacing a relative import path.\n\nTypeScript follows Node.js’s resolution algorithm for [`\"imports\"`](https://nodejs.org/api/packages.html#subpath-imports)\n and [self references](https://nodejs.org/api/packages.html#self-referencing-a-package-using-its-name)\n exactly up until a file path is resolved. At that point, TypeScript’s resolution algorithm forks based on whether the package.json containing the `\"imports\"` or `\"exports\"` being resolved belongs to a `node_modules` dependency or the local project being compiled (i.e., its directory contains the tsconfig.json file for the project that contains the importing file):\n\n*   If the package.json is in `node_modules`, TypeScript will apply [extension substitution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n     to the file path if it doesn’t already have a recognized TypeScript file extension, and check for the existence of the resulting file paths.\n*   If the package.json is part of the local project, an additional remapping step is performed in order to find the _input_ TypeScript implementation file that will eventually produce the output JavaScript or declaration file path that was resolved from `\"imports\"`. Without this step, any compilation that resolves an `\"imports\"` path would be referencing output files from the _previous compilation_ instead of other input files that are intended to be included in the current compilation. This remapping uses the `outDir`/`declarationDir` and `rootDir` from the tsconfig.json, so using `\"imports\"` usually requires an explicit `rootDir` to be set.\n\nThis variation allows package authors to write `\"imports\"` and `\"exports\"` fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-local-project-with-conditions)\nExample: local project with conditions\n\nScenario: `\"/src/main.mts\"` imports `\"#utils\"` with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:\n\njson\n\n`   // tsconfig.json  {    \"compilerOptions\": {      \"moduleResolution\": \"node16\",      \"resolvePackageJsonImports\": true,      \"rootDir\": \"./src\",      \"outDir\": \"./dist\"    }  }   `\n\njson\n\n`   // package.json  {    \"name\": \"pkg\",    \"imports\": {      \"#utils\": {        \"import\": \"./dist/utils.d.mts\",        \"require\": \"./dist/utils.d.cts\"      }    }  }   `\n\nResolution process:\n\n1.  Import path starts with `#`, try to resolve through `\"imports\"`.\n2.  Does `\"imports\"` exist in the nearest ancestor package.json? **Yes.**\n3.  Does `\"#utils\"` exist in the `\"imports\"` object? **Yes.**\n4.  The value at `imports[\"#utils\"]` is an object—it must be specifying conditions.\n5.  Does the first condition `\"import\"` match this request? **Yes.**\n6.  Should we attempt to map the output path to an input path? **Yes, because:**\n    *   Is the package.json in `node_modules`? **No, it’s in the local project.**\n    *   Is the tsconfig.json within the package.json directory? **Yes.**\n7.  In `./dist/utils.d.mts`, replace the `outDir` prefix with `rootDir`. **`./src/utils.d.mts`**\n8.  Replace the output extension `.d.mts` with the corresponding input extension `.mts`. **`./src/utils.mts`**\n9.  Return the path `\"./src/utils.mts\"` if the file exists.\n10.  Otherwise, return the path `\"./dist/utils.d.mts\"` if the file exists.\n\n##### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#example-node_modules-dependency-with-subpath-pattern)\nExample: `node_modules` dependency with subpath pattern\n\nScenario: `\"/node_modules/pkg/main.mts\"` imports `\"#internal/utils\"` with conditions `[\"types\", \"node\", \"import\"]` (determined by `moduleResolution` setting and the context that triggered the module resolution request) with the package.json:\n\njson\n\n`   // /node_modules/pkg/package.json  {    \"name\": \"pkg\",    \"imports\": {      \"#internal/*\": {        \"import\": \"./dist/internal/*.mjs\",        \"require\": \"./dist/internal/*.cjs\"      }    }  }   `\n\nResolution process:\n\n1.  Import path starts with `#`, try to resolve through `\"imports\"`.\n2.  Does `\"imports\"` exist in the nearest ancestor package.json? **Yes.**\n3.  Does `\"#internal/utils\"` exist in the `\"imports\"` object? **No, check for pattern matches.**\n4.  Does any key with a `*` match `\"#internal/utils\"`? **Yes, `\"#internal/*\"` matches and sets `utils` to be the substitution.**\n5.  The value at `imports[\"#internal/*\"]` is an object—it must be specifying conditions.\n6.  Does the first condition `\"import\"` match this request? **Yes.**\n7.  Should we attempt to map the output path to an input path? **No, because the package.json is in `node_modules`.**\n8.  In `./dist/internal/*.mjs`, replace `*` with the substitution `utils`. **`./dist/internal/utils.mjs`**\n9.  Does the path `./dist/internal/utils.mjs` have a recognized TypeScript file extension? **No, try extension substitution.**\n10.  Via [extension substitution](https://www.typescriptlang.org/docs/handbook/modules/reference.html#file-extension-substitution)\n    , try the following paths, returning the first one that exists, or `undefined` otherwise:\n    1.  `./dist/internal/utils.mts`\n    2.  `./dist/internal/utils.d.mts`\n    3.  `./dist/internal/utils.mjs`\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-nodenext)\n`node16`, `nodenext`\n\nThese modes reflect the module resolution behavior of Node.js v12 and later. (`node16` and `nodenext` are currently identical, but if Node.js makes significant changes to its module system in the future, `node16` will be frozen while `nodenext` will be updated to reflect the new behavior.) In Node.js, the resolution algorithm for ECMAScript imports is significantly different from the algorithm for CommonJS `require` calls. For each module specifier being resolved, the syntax and the [module format of the importing file](https://www.typescriptlang.org/docs/handbook/modules/reference.html#module-format-detection)\n are first used to determine whether the module specifier will be in an `import` or `require` in the emitted JavaScript. That information is then passed into the module resolver to determine which resolution algorithm to use (and whether to use the `\"import\"` or `\"require\"` condition for package.json [`\"exports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\n or [`\"imports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-imports-and-self-name-imports)\n).\n\n> TypeScript files that are [determined to be in CommonJS format](https://www.typescriptlang.org/docs/handbook/modules/reference.html#module-format-detection)\n>  may still use `import` and `export` syntax by default, but the emitted JavaScript will use `require` and `module.exports` instead. This means that it’s common to see `import` statements that are resolved using the `require` algorithm. If this causes confusion, the `verbatimModuleSyntax` compiler option can be enabled, which prohibits the use of `import` statements that would be emitted as `require` calls.\n\nNote that dynamic `import()` calls are always resolved using the `import` algorithm, according to Node.js’s behavior. However, `import()` types are resolved according to the format of the importing file (for backward compatibility with existing CommonJS-format type declarations):\n\nts\n\n``   // @Filename: module.mts  import x from \"./mod.js\";             // `import` algorithm due to file format (emitted as-written)  import(\"./mod.js\");                   // `import` algorithm due to syntax (emitted as-written)  type Mod = typeof import(\"./mod.js\"); // `import` algorithm due to file format  import mod = require(\"./mod\");        // `require` algorithm due to syntax (emitted as `require`)  // @Filename: commonjs.cts  import x from \"./mod\";                // `require` algorithm due to file format (emitted as `require`)  import(\"./mod.js\");                   // `import` algorithm due to syntax (emitted as-written)  type Mod = typeof import(\"./mod\");    // `require` algorithm due to file format  import mod = require(\"./mod\");        // `require` algorithm due to syntax (emitted as `require`)   ``\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#implied-and-enforced-options-2)\nImplied and enforced options\n\n*   `--moduleResolution node16` and `nodenext` must be paired with [`--module node16`, `node18`, or `nodenext`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node16-node18-nodenext)\n    .\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#supported-features)\nSupported features\n\nFeatures are listed in order of precedence.\n\n|     | `import` | `require` |\n| --- | --- | --- |\n| [`paths`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths) | ✅   | ✅   |\n| [`baseUrl`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#baseurl) | ✅   | ✅   |\n| [`node_modules` package lookups](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups) | ✅   | ✅   |\n| [package.json `\"exports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports) | ✅ matches `types`, `node`, `import` | ✅ matches `types`, `node`, `require` |\n| [package.json `\"imports\"` and self-name imports](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-imports-and-self-name-imports) | ✅ matches `types`, `node`, `import` | ✅ matches `types`, `node`, `require` |\n| [package.json `\"typesVersions\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-typesversions) | ✅   | ✅   |\n| [Package-relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#package-relative-file-paths) | ✅ when `exports` not present | ✅ when `exports` not present |\n| [Full relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#relative-file-path-resolution) | ✅   | ✅   |\n| [Extensionless relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#extensionless-relative-paths) | ❌   | ✅   |\n| [Directory modules](https://www.typescriptlang.org/docs/handbook/modules/reference.html#directory-modules-index-file-resolution) | ❌   | ✅   |\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#bundler)\n`bundler`\n\n`--moduleResolution bundler` attempts to model the module resolution behavior common to most JavaScript bundlers. In short, this means supporting all the behaviors traditionally associated with Node.js’s CommonJS `require` resolution algorithm like [`node_modules` lookups](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n, [directory modules](https://www.typescriptlang.org/docs/handbook/modules/reference.html#directory-modules-index-file-resolution)\n, and [extensionless paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#extensionless-relative-paths)\n, while also supporting newer Node.js resolution features like [package.json `\"exports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\n and [package.json `\"imports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-imports-and-self-name-imports)\n.\n\nIt’s instructive to think about the similarities and differences between `--moduleResolution bundler` and `--moduleResolution nodenext`, particularly in how they decide what conditions to use when resolving package.json `\"exports\"` or `\"imports\"`. Consider an import statement in a `.ts` file:\n\nts\n\n`   // index.ts  import { foo } from \"pkg\";   `\n\nRecall that in `--module nodenext --moduleResolution nodenext`, the `--module` setting first [determines](https://www.typescriptlang.org/docs/handbook/modules/reference.html#module-format-detection)\n whether the import will be emitted to the `.js` file as an `import` or `require` call, then passes that information to TypeScript’s module resolver, which decides whether to match `\"import\"` or `\"require\"` conditions in `\"pkg\"`’s package.json `\"exports\"` accordingly. Let’s assume that there’s no package.json in scope of this file. The file extension is `.ts`, so the output file extension will be `.js`, which Node.js will interpret as CommonJS, so TypeScript will emit this `import` as a `require` call. So, the module resolver will use the `require` condition as it resolves `\"exports\"` from `\"pkg\"`.\n\nThe same process happens in `--moduleResolution bundler`, but the rules for deciding whether to emit an `import` or `require` call for this import statement will be different, since `--moduleResolution bundler` necessitates using [`--module esnext`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext)\n or [`--module preserve`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#preserve)\n. In both of those modes, ESM `import` declarations always emit as ESM `import` declarations, so TypeScript’s module resolver will receive that information and use the `\"import\"` condition as it resolves `\"exports\"` from `\"pkg\"`.\n\nThis explanation may be somewhat unintuitive, since `--moduleResolution bundler` is usually used in combination with `--noEmit`—bundlers typically process raw `.ts` files and perform module resolution on untransformed `import`s or `require`s. However, for consistency, TypeScript still uses the hypothetical emit decided by `module` to inform module resolution and type checking. This makes [`--module preserve`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#preserve)\n the best choice whenever a runtime or bundler is operating on raw `.ts` files, since it implies no transformation. Under `--module preserve --moduleResolution bundler`, you can write imports and requires in the same file that will resolve with the `import` and `require` conditions, respectively:\n\nts\n\n`   // index.ts  import pkg1 from \"pkg\";       // Resolved with \"import\" condition  import pkg2 = require(\"pkg\"); // Resolved with \"require\" condition   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#implied-and-enforced-options-3)\nImplied and enforced options\n\n*   `--moduleResolution bundler` must be paired with `--module esnext` or `--module preserve`.\n*   `--moduleResolution bundler` implies `--allowSyntheticDefaultImports`.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#supported-features-1)\nSupported features\n\n*   [`paths`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths)\n     ✅\n*   [`baseUrl`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#baseurl)\n     ✅\n*   [`node_modules` package lookups](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n     ✅\n*   [package.json `\"exports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\n     ✅ matches `types`, `import`/`require` depending on syntax\n*   [package.json `\"imports\"` and self-name imports](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-imports-and-self-name-imports)\n     ✅ matches `types`, `import`/`require` depending on syntax\n*   [package.json `\"typesVersions\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-typesversions)\n     ✅\n*   [Package-relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#package-relative-file-paths)\n     ✅ when `exports` not present\n*   [Full relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#relative-file-path-resolution)\n     ✅\n*   [Extensionless relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#extensionless-relative-paths)\n     ✅\n*   [Directory modules](https://www.typescriptlang.org/docs/handbook/modules/reference.html#directory-modules-index-file-resolution)\n     ✅\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node10-formerly-known-as-node)\n`node10` (formerly known as `node`)\n\n`--moduleResolution node` was renamed to `node10` (keeping `node` as an alias for backward compatibility) in TypeScript 5.0. It reflects the CommonJS module resolution algorithm as it existed in Node.js versions earlier than v12. It should no longer be used.\n\n#### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#supported-features-2)\nSupported features\n\n*   [`paths`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths)\n     ✅\n*   [`baseUrl`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#baseurl)\n     ✅\n*   [`node_modules` package lookups](https://www.typescriptlang.org/docs/handbook/modules/reference.html#node_modules-package-lookups)\n     ✅\n*   [package.json `\"exports\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-exports)\n     ❌\n*   [package.json `\"imports\"` and self-name imports](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-imports-and-self-name-imports)\n     ❌\n*   [package.json `\"typesVersions\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#packagejson-typesversions)\n     ✅\n*   [Package-relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#package-relative-file-paths)\n     ✅\n*   [Full relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#relative-file-path-resolution)\n     ✅\n*   [Extensionless relative paths](https://www.typescriptlang.org/docs/handbook/modules/reference.html#extensionless-relative-paths)\n     ✅\n*   [Directory modules](https://www.typescriptlang.org/docs/handbook/modules/reference.html#directory-modules-index-file-resolution)\n     ✅\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/reference.html#classic)\n`classic`\n\nDo not use `classic`.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/modules-reference/Reference.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (8)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nSF![Sean Flanigan  (1)](https://gravatar.com/avatar/71125218590a6c512f2492369c354f54613ecf108bb5a69b514c3ecdf52d5e4a?s=32&&d=blank)\n\nSF![Shane Fontaine  (1)](https://gravatar.com/avatar/8bfd4269041472a3c0fb158540fb629865cb34604738b557fc6dc23b298d38c3?s=32&&d=blank)\n\nZ![zhennann  (1)](https://gravatar.com/avatar/07ba1fb472089b8636300cd4478b7d688e18d1320cc551d105e2ba32a8c5fb9d?s=32&&d=blank)\n\nHCDC![Henrique Carvalho da Cruz  (1)](https://gravatar.com/avatar/a208b15b15d0f3466831feab57a84e128d6b4db2332791d574594c3d0356a9cc?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - Modules - Reference","language":"en","og:title":"Documentation - Modules - Reference","twitter:site":"typescriptlang","description":"Module syntax and compiler options reference","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:description":"Module syntax and compiler options reference","generator":"Gatsby 5.13.5","theme-color":"#3178C6","ogDescription":"Module syntax and compiler options reference","ogTitle":"Documentation - Modules - Reference","scrapeId":"7d744885-ff2e-4a0a-9eb2-06afd3f2da95","sourceURL":"https://www.typescriptlang.org/docs/handbook/modules/reference.html","url":"https://www.typescriptlang.org/docs/handbook/modules/reference.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nUsing Babel with TypeScript\n===========================\n\n[](https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html#babel-vs-tsc-for-typescript)\nBabel vs `tsc` for TypeScript\n-------------------------------------------------------------------------------------------------------------------------------------\n\nWhen making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript?\n\nA lot of the time the answer is _“it depends”_, or _“someone may have decided for you”_ depending on the project. If you are building your project with an existing framework like [tsdx](https://tsdx.io/)\n, [Angular](https://angular.io/)\n, [NestJS](https://nestjs.com/)\n or any framework mentioned in the [Getting Started](https://www.typescriptlang.org/docs)\n then this decision is handled for you.\n\nHowever, a useful heuristic could be:\n\n*   Is your build output mostly the same as your source input files? Use `tsc`\n*   Do you need a build pipeline with multiple potential outputs? Use `babel` for transpiling and `tsc` for type checking\n\n[](https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html#babel-for-transpiling-tsc-for-types)\nBabel for transpiling, `tsc` for types\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThis is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript.\n\nThis technique is a hybrid approach, using Babel’s [preset-typescript](https://babeljs.io/docs/en/babel-preset-typescript)\n to generate your JS files, and then using TypeScript to do type checking and `.d.ts` file generation.\n\nBy using babel’s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code.\n\n#### [](https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html#type-checking-and-dts-file-generation)\nType Checking and d.ts file generation\n\nThe downside to using babel is that you don’t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code.\n\nIn addition to that, Babel cannot create `.d.ts` files for your TypeScript which can make it harder to work with your project if it is a library.\n\nTo fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a corresponding [`tsconfig.json`](https://www.typescriptlang.org/tsconfig)\n and ensuring these flags are enabled:\n\n`   \"compilerOptions\": {    // Ensure that .d.ts files are created by tsc, but not .js files    \"[declaration](https://www.typescriptlang.org/tsconfig#declaration) \": true,    \"[emitDeclarationOnly](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly) \": true,    // Ensure that Babel can safely transpile files in the TypeScript project    \"[isolatedModules](https://www.typescriptlang.org/tsconfig#isolatedModules) \": true  }   `\n\nFor more information on these flags:\n\n*   [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules)\n    \n*   [`declaration`](https://www.typescriptlang.org/tsconfig#declaration)\n    , [`emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/tutorials/Babel%20with%20TypeScript.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nSU![Samet UCA  (1)](https://gravatar.com/avatar/f226af3f80e5142d63f4c1e03785f717ce1ce2e1f8a1fc2b9a6e83bd0d9c86a8?s=32&&d=blank)\n\nR![Rob  (1)](https://gravatar.com/avatar/19a177473e5958cea093bea7febb418e797d70f30f4e2c0f2b5f25a464b5356a?s=32&&d=blank)\n\nUS![Udayan Shevade  (1)](https://gravatar.com/avatar/3073884199081d11f216d5e514f08f916a57af1a93595b8b7421f2753184ae9d?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - Using Babel with TypeScript","ogDescription":"How to create a hybrid Babel + TypeScript project","ogTitle":"Documentation - Using Babel with TypeScript","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","og:title":"Documentation - Using Babel with TypeScript","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","twitter:site":"typescriptlang","description":"How to create a hybrid Babel + TypeScript project","og:description":"How to create a hybrid Babel + TypeScript project","scrapeId":"bf593e3a-7477-4ab6-a284-d04715691de9","sourceURL":"https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html","url":"https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nGulp\n====\n\nThis quick start guide will teach you how to build TypeScript with [gulp](https://gulpjs.com/)\n and then add [Browserify](https://browserify.org/)\n, [terser](https://terser.org/)\n, or [Watchify](https://github.com/substack/watchify)\n to the gulp pipeline. This guide also shows how to add [Babel](https://babeljs.io/)\n functionality using [Babelify](https://github.com/babel/babelify)\n.\n\nWe assume that you’re already using [Node.js](https://nodejs.org/)\n with [npm](https://www.npmjs.com/)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/gulp.html#minimal-project)\nMinimal project\n------------------------------------------------------------------------------------------\n\nLet’s start out with a new directory. We’ll name it `proj` for now, but you can change it to whatever you want.\n\nshell\n\n`   mkdir proj  cd proj   `\n\nTo start, we’re going to structure our project in the following way:\n\n`   proj/     ├─ src/     └─ dist/   `\n\nTypeScript files will start out in your `src` folder, run through the TypeScript compiler and end up in `dist`.\n\nLet’s scaffold this out:\n\nshell\n\n`   mkdir src  mkdir dist   `\n\n### [](https://www.typescriptlang.org/docs/handbook/gulp.html#initialize-the-project)\nInitialize the project\n\nNow we’ll turn this folder into an npm package.\n\nshell\n\n`   npm init   `\n\nYou’ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use `./dist/main.js`. You can always go back and change these in the `package.json` file that’s been generated for you.\n\n### [](https://www.typescriptlang.org/docs/handbook/gulp.html#install-our-dependencies)\nInstall our dependencies\n\nNow we can use `npm install` to install packages. First install `gulp-cli` globally (if you use a Unix system, you may need to prefix the `npm install` commands in this guide with `sudo`).\n\nshell\n\n`   npm install -g gulp-cli   `\n\nThen install `typescript`, `gulp` and `gulp-typescript` in your project’s dev dependencies. [Gulp-typescript](https://www.npmjs.com/package/gulp-typescript)\n is a gulp plugin for TypeScript.\n\nshell\n\n`   npm install --save-dev typescript gulp@4.0.0 gulp-typescript   `\n\n### [](https://www.typescriptlang.org/docs/handbook/gulp.html#write-a-simple-example)\nWrite a simple example\n\nLet’s write a Hello World program. In `src`, create the file `main.ts`:\n\nts\n\n``   function hello(compiler: string) {    console.log(`Hello from ${compiler}`);  }  hello(\"TypeScript\");   ``\n\nIn the project root, `proj`, create the file `tsconfig.json`:\n\n`   {    \"[files](https://www.typescriptlang.org/tsconfig#files) \": [\"src/main.ts\"],    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny) \": true,      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"es5\"    }  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/gulp.html#create-a-gulpfilejs)\nCreate a `gulpfile.js`\n\nIn the project root, create the file `gulpfile.js`:\n\njs\n\n`   var gulp = require(\"gulp\");  var ts = require(\"gulp-typescript\");  var tsProject = ts.createProject(\"tsconfig.json\");  gulp.task(\"default\", function () {    return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest(\"dist\"));  });   `\n\n### [](https://www.typescriptlang.org/docs/handbook/gulp.html#test-the-resulting-app)\nTest the resulting app\n\nshell\n\n`   gulp  node dist/main.js   `\n\nThe program should print “Hello from TypeScript!“.\n\n[](https://www.typescriptlang.org/docs/handbook/gulp.html#add-modules-to-the-code)\nAdd modules to the code\n----------------------------------------------------------------------------------------------------------\n\nBefore we get to Browserify, let’s build our code out and add modules to the mix. This is the structure you’re more likely to use for a real app.\n\nCreate a file called `src/greet.ts`:\n\nts\n\n``   export function sayHello(name: string) {    return `Hello from ${name}`;  }   ``\n\nNow change the code in `src/main.ts` to import `sayHello` from `greet.ts`:\n\nts\n\n`   import { sayHello } from \"./greet\";  console.log(sayHello(\"TypeScript\"));   `\n\nFinally, add `src/greet.ts` to `tsconfig.json`:\n\n`   {    \"[files](https://www.typescriptlang.org/tsconfig#files) \": [\"src/main.ts\", \"src/greet.ts\"],    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny) \": true,      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"es5\"    }  }   `\n\nMake sure that the modules work by running `gulp` and then testing in Node:\n\nshell\n\n`   gulp  node dist/main.js   `\n\nNotice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We’ll stick with CommonJS for this tutorial, but you could set `module` in the options object to change this.\n\n[](https://www.typescriptlang.org/docs/handbook/gulp.html#browserify)\nBrowserify\n--------------------------------------------------------------------------------\n\nNow let’s move this project from Node to the browser. To do this, we’d like to bundle all our modules into one JavaScript file. Fortunately, that’s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.\n\nFirst, install browserify, [tsify](https://www.npmjs.com/package/tsify)\n, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called [vinyl](https://github.com/gulpjs/vinyl)\n.\n\nshell\n\n`   npm install --save-dev browserify tsify vinyl-source-stream   `\n\n### [](https://www.typescriptlang.org/docs/handbook/gulp.html#create-a-page)\nCreate a page\n\nCreate a file in `src` named `index.html`:\n\nhtml\n\n`   <!DOCTYPE html>  <html>    <head>      <meta charset=\"UTF-8\" />      <title>Hello World!</title>    </head>    <body>      <p id=\"greeting\">Loading ...</p>      <script src=\"bundle.js\"></script>    </body>  </html>   `\n\nNow change `main.ts` to update the page:\n\nts\n\n`   import { sayHello } from \"./greet\";  function showHello(divName: string, name: string) {    const elt = document.getElementById(divName);    elt.innerText = sayHello(name);  }  showHello(\"greeting\", \"TypeScript\");   `\n\nCalling `showHello` calls `sayHello` to change the paragraph’s text. Now change your gulpfile to the following:\n\njs\n\n`   var gulp = require(\"gulp\");  var browserify = require(\"browserify\");  var source = require(\"vinyl-source-stream\");  var tsify = require(\"tsify\");  var paths = {    pages: [\"src/*.html\"],  };  gulp.task(\"copy-html\", function () {    return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));  });  gulp.task(    \"default\",    gulp.series(gulp.parallel(\"copy-html\"), function () {      return browserify({        basedir: \".\",        debug: true,        entries: [\"src/main.ts\"],        cache: {},        packageCache: {},      })        .plugin(tsify)        .bundle()        .pipe(source(\"bundle.js\"))        .pipe(gulp.dest(\"dist\"));    })  );   `\n\nThis adds the `copy-html` task and adds it as a dependency of `default`. That means any time `default` is run, `copy-html` has to run first. We’ve also changed `default` to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.\n\nAfter calling `bundle` we use `source` (our alias for vinyl-source-stream) to name our output bundle `bundle.js`.\n\nTest the page by running gulp and then opening `dist/index.html` in a browser. You should see “Hello from TypeScript” on the page.\n\nNotice that we specified `debug: true` to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside `main.ts`. When you refresh the page the breakpoint should pause the page and let you debug `greet.ts`.\n\n[](https://www.typescriptlang.org/docs/handbook/gulp.html#watchify-babel-and-terser)\nWatchify, Babel, and Terser\n----------------------------------------------------------------------------------------------------------------\n\nNow that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.\n\n*   Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.\n    \n*   Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn’t support.\n    \n*   Terser compacts your code so that it takes less time to download.\n    \n\n### [](https://www.typescriptlang.org/docs/handbook/gulp.html#watchify)\nWatchify\n\nWe’ll start with Watchify to provide background compilation:\n\nshell\n\n`   npm install --save-dev watchify fancy-log   `\n\nNow change your gulpfile to the following:\n\njs\n\n`   var gulp = require(\"gulp\");  var browserify = require(\"browserify\");  var source = require(\"vinyl-source-stream\");  var watchify = require(\"watchify\");  var tsify = require(\"tsify\");  var fancy_log = require(\"fancy-log\");  var paths = {    pages: [\"src/*.html\"],  };  var watchedBrowserify = watchify(    browserify({      basedir: \".\",      debug: true,      entries: [\"src/main.ts\"],      cache: {},      packageCache: {},    }).plugin(tsify)  );  gulp.task(\"copy-html\", function () {    return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));  });  function bundle() {    return watchedBrowserify      .bundle()      .on(\"error\", fancy_log)      .pipe(source(\"bundle.js\"))      .pipe(gulp.dest(\"dist\"));  }  gulp.task(\"default\", gulp.series(gulp.parallel(\"copy-html\"), bundle));  watchedBrowserify.on(\"update\", bundle);  watchedBrowserify.on(\"log\", fancy_log);   `\n\nThere are basically three changes here, but they require you to refactor your code a bit.\n\n1.  We wrapped our `browserify` instance in a call to `watchify`, and then held on to the result.\n2.  We called `watchedBrowserify.on('update', bundle);` so that Browserify will run the `bundle` function every time one of your TypeScript files changes.\n3.  We called `watchedBrowserify.on('log', fancy_log);` to log to the console.\n\nTogether (1) and (2) mean that we have to move our call to `browserify` out of the `default` task. And we have to give the function for `default` a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.\n\nNow when you run Gulp, it should start and stay running. Try changing the code for `showHello` in `main.ts` and saving it. You should see output that looks like this:\n\nshell\n\n`   proj$ gulp  [10:34:20] Using gulpfile ~/src/proj/gulpfile.js  [10:34:20] Starting 'copy-html'...  [10:34:20] Finished 'copy-html' after 26 ms  [10:34:20] Starting 'default'...  [10:34:21] 2824 bytes written (0.13 seconds)  [10:34:21] Finished 'default' after 1.36 s  [10:35:22] 2261 bytes written (0.02 seconds)  [10:35:24] 2808 bytes written (0.05 seconds)   `\n\n### [](https://www.typescriptlang.org/docs/handbook/gulp.html#terser)\nTerser\n\nFirst install Terser. Since the point of Terser is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.\n\nshell\n\n`   npm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps   `\n\nNow change your gulpfile to the following:\n\njs\n\n`   var gulp = require(\"gulp\");  var browserify = require(\"browserify\");  var source = require(\"vinyl-source-stream\");  var terser = require(\"gulp-terser\");  var tsify = require(\"tsify\");  var sourcemaps = require(\"gulp-sourcemaps\");  var buffer = require(\"vinyl-buffer\");  var paths = {    pages: [\"src/*.html\"],  };  gulp.task(\"copy-html\", function () {    return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));  });  gulp.task(    \"default\",    gulp.series(gulp.parallel(\"copy-html\"), function () {      return browserify({        basedir: \".\",        debug: true,        entries: [\"src/main.ts\"],        cache: {},        packageCache: {},      })        .plugin(tsify)        .bundle()        .pipe(source(\"bundle.js\"))        .pipe(buffer())        .pipe(sourcemaps.init({ loadMaps: true }))        .pipe(terser())        .pipe(sourcemaps.write(\"./\"))        .pipe(gulp.dest(\"dist\"));    })  );   `\n\nNotice that `terser` itself has just one call — the calls to `buffer` and `sourcemaps` exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that `bundle.js` does get minified into an unreadable mess:\n\nshell\n\n`   gulp  cat dist/bundle.js   `\n\n### [](https://www.typescriptlang.org/docs/handbook/gulp.html#babel)\nBabel\n\nFirst install Babelify and the Babel preset for ES2015. Like Terser, Babelify mangles code, so we’ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of `.js`, `.es`, `.es6` and `.jsx` so we need to add the `.ts` extension as an option to Babelify.\n\nshell\n\n`   npm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps   `\n\nNow change your gulpfile to the following:\n\njs\n\n`   var gulp = require(\"gulp\");  var browserify = require(\"browserify\");  var source = require(\"vinyl-source-stream\");  var tsify = require(\"tsify\");  var sourcemaps = require(\"gulp-sourcemaps\");  var buffer = require(\"vinyl-buffer\");  var paths = {    pages: [\"src/*.html\"],  };  gulp.task(\"copy-html\", function () {    return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));  });  gulp.task(    \"default\",    gulp.series(gulp.parallel(\"copy-html\"), function () {      return browserify({        basedir: \".\",        debug: true,        entries: [\"src/main.ts\"],        cache: {},        packageCache: {},      })        .plugin(tsify)        .transform(\"babelify\", {          presets: [\"es2015\"],          extensions: [\".ts\"],        })        .bundle()        .pipe(source(\"bundle.js\"))        .pipe(buffer())        .pipe(sourcemaps.init({ loadMaps: true }))        .pipe(sourcemaps.write(\"./\"))        .pipe(gulp.dest(\"dist\"));    })  );   `\n\nWe also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let’s modify `tsconfig.json`:\n\n`   {    \"[files](https://www.typescriptlang.org/tsconfig#files) \": [\"src/main.ts\"],    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny) \": true,      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"es2015\"    }  }   `\n\nBabel’s ES5 output should be very similar to TypeScript’s output for such a simple script.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/tutorials/Gulp.md)\n ❤\n\nContributors to this page:  \n\nBK![Bowden Kelly  (51)](https://gravatar.com/avatar/e87ecf3e2da8b667dd3a8005ac610d4a?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nDR![Daniel Rosenwasser  (3)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)\n\nRC![Ryan Cavanaugh  (2)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nMF![Martin Fischer  (1)](https://gravatar.com/avatar/dc885100e48a5949f1a44bcd6fce398735ff3294f20607ddee8bb45acb29601a?s=32&&d=blank)\n\n19+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"theme-color":"#3178C6","title":"TypeScript: Documentation - Gulp","og:title":"Documentation - Gulp","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","description":"Using TypeScript with Gulp","og:description":"Using TypeScript with Gulp","twitter:site":"typescriptlang","generator":"Gatsby 5.13.5","language":"en","ogTitle":"Documentation - Gulp","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogDescription":"Using TypeScript with Gulp","scrapeId":"ea920adc-46dc-4681-8de2-d76eefde1e8f","sourceURL":"https://www.typescriptlang.org/docs/handbook/gulp.html","url":"https://www.typescriptlang.org/docs/handbook/gulp.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nDOM Manipulation\n================\n\n[](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#dom-manipulation)\nDOM Manipulation\n--------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#an-exploration-into-the-htmlelement-type)\n_An exploration into the `HTMLElement` type_\n\nIn the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.\n\nWebsites are made up of HTML and/or XML documents. These documents are static, they do not change. The _Document Object Model (DOM)_ is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop.\n\nTypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in _lib.dom.d.ts_, one stands out among the rest: `HTMLElement`. This type is the backbone for DOM manipulation with TypeScript.\n\n> You can explore the source code for the [DOM type definitions](https://github.com/microsoft/TypeScript/blob/main/src/lib/dom.generated.d.ts)\n\n[](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#basic-example)\nBasic Example\n--------------------------------------------------------------------------------------------------\n\nGiven a simplified _index.html_ file:\n\nhtml\n\n`   <!DOCTYPE html>  <html lang=\"en\">    <head><title>TypeScript Dom Manipulation</title></head>    <body>      <div id=\"app\"></div>      <!-- Assume index.js is the compiled output of index.ts -->      <script src=\"index.js\"></script>    </body>  </html>   `\n\nLet’s explore a TypeScript script that adds a `<p>Hello, World!</p>` element to the `#app` element.\n\nts\n\n`   // 1. Select the div element using the id property  const app = document.getElementById(\"app\");  // 2. Create a new <p></p> element programmatically  const p = document.createElement(\"p\");  // 3. Add the text content  p.textContent = \"Hello, World!\";  // 4. Append the p element to the div element  app?.appendChild(p);   `\n\nAfter compiling and running the _index.html_ page, the resulting HTML will be:\n\nhtml\n\n`   <div id=\"app\">    <p>Hello, World!</p>  </div>   `\n\n[](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#the-document-interface)\nThe `Document` Interface\n----------------------------------------------------------------------------------------------------------------------\n\nThe first line of the TypeScript code uses a global variable `document`. Inspecting the variable shows it is defined by the `Document` interface from the _lib.dom.d.ts_ file. The code snippet contains calls to two methods, `getElementById` and `createElement`.\n\n### [](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#documentgetelementbyid)\n`Document.getElementById`\n\nThe definition for this method is as follows:\n\nts\n\n`   getElementById(elementId: string): HTMLElement | null;   `\n\nPass it an element id string and it will return either `HTMLElement` or `null`. This method introduces one of the most important types, `HTMLElement`. It serves as the base interface for every other element interface. For example, the `p` variable in the code example is of type `HTMLParagraphElement`. Also, take note that this method can return `null`. This is because the method can’t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new _optional chaining_ operator is used to call `appendChild`.\n\n### [](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#documentcreateelement)\n`Document.createElement`\n\nThe definition for this method is (I have omitted the _deprecated_ definition):\n\nts\n\n`   createElement<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];  createElement(tagName: string, options?: ElementCreationOptions): HTMLElement;   `\n\nThis is an overloaded function definition. The second overload is simplest and works a lot like the `getElementById` method does. Pass it any `string` and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.\n\nFor example `document.createElement('xyz')` returns a `<xyz></xyz>` element, clearly not an element that is specified by the HTML specification.\n\n> For those interested, you can interact with custom tag elements using the `document.getElementsByTagName`\n\nFor the first definition of `createElement`, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: `<K extends keyof HTMLElementTagNameMap>`. This expression defines a generic parameter `K` that is _constrained_ to the keys of the interface `HTMLElementTagNameMap`. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:\n\nts\n\n`   interface HTMLElementTagNameMap {      \"a\": HTMLAnchorElement;      \"abbr\": HTMLElement;      \"address\": HTMLElement;      \"applet\": HTMLAppletElement;      \"area\": HTMLAreaElement;          ...  }   `\n\nSome elements do not exhibit unique properties and so they just return `HTMLElement`, but other types do have unique properties and methods so they return their specific interface (which will extend from or implement `HTMLElement`).\n\nNow, for the remainder of the `createElement` definition: `(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]`. The first argument `tagName` is defined as the generic parameter `K`. The TypeScript interpreter is smart enough to _infer_ the generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to the `tagName` argument will be inferred as `K` and thus can be used throughout the remainder of the definition. This is exactly what happens; the return value `HTMLElementTagNameMap[K]` takes the `tagName` argument and uses it to return the corresponding type. This definition is how the `p` variable from the code snippet gets a type of `HTMLParagraphElement`. And if the code was `document.createElement('a')`, then it would be an element of type `HTMLAnchorElement`.\n\n[](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#the-node-interface)\nThe `Node` interface\n--------------------------------------------------------------------------------------------------------------\n\nThe `document.getElementById` function returns an `HTMLElement`. `HTMLElement` interface extends the `Element` interface which extends the `Node` interface. This prototypal extension allows for all `HTMLElements` to utilize a subset of standard methods. In the code snippet, we use a property defined on the `Node` interface to append the new `p` element to the website.\n\n### [](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#nodeappendchild)\n`Node.appendChild`\n\nThe last line of the code snippet is `app?.appendChild(p)`. The previous, `document.getElementById`, section detailed that the _optional chaining_ operator is used here because `app` can potentially be null at runtime. The `appendChild` method is defined by:\n\nts\n\n`   appendChild<T extends Node>(newChild: T): T;   `\n\nThis method works similarly to the `createElement` method as the generic parameter `T` is inferred from the `newChild` argument. `T` is _constrained_ to another base interface `Node`.\n\n[](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#difference-between-children-and-childnodes)\nDifference between `children` and `childNodes`\n----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPreviously, this document details the `HTMLElement` interface extends from `Element` which extends from `Node`. In the DOM API there is a concept of _children_ elements. For example in the following HTML, the `p` tags are children of the `div` element\n\ntsx\n\n`   <div>    <p>Hello, World</p>    <p>TypeScript!</p>  </div>;  const div = document.getElementsByTagName(\"div\")[0];  div.children;  // HTMLCollection(2) [p, p]  div.childNodes;  // NodeList(2) [p, p]   `\n\nAfter capturing the `div` element, the `children` prop will return an `HTMLCollection` list containing the `HTMLParagraphElements`. The `childNodes` property will return a similar `NodeList` list of nodes. Each `p` tag will still be of type `HTMLParagraphElements`, but the `NodeList` can contain additional _HTML nodes_ that the `HTMLCollection` list cannot.\n\nModify the HTML by removing one of the `p` tags, but keep the text.\n\ntsx\n\n`   <div>    <p>Hello, World</p>    TypeScript!  </div>;  const div = document.getElementsByTagName(\"div\")[0];  div.children;  // HTMLCollection(1) [p]  div.childNodes;  // NodeList(2) [p, text]   `\n\nSee how both lists change. `children` now only contains the `<p>Hello, World</p>` element, and the `childNodes` contains a `text` node rather than two `p` nodes. The `text` part of the `NodeList` is the literal `Node` containing the text `TypeScript!`. The `children` list does not contain this `Node` because it is not considered an `HTMLElement`.\n\n[](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#the-queryselector-and-queryselectorall-methods)\nThe `querySelector` and `querySelectorAll` methods\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBoth of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in _lib.dom.d.ts_ as:\n\nts\n\n`   /**   * Returns the first element that is a descendant of node that matches selectors.   */  querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;  querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;  querySelector<E extends Element = Element>(selectors: string): E | null;  /**   * Returns all element descendants of node that match selectors.   */  querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;  querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;  querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;   `\n\nThe `querySelectorAll` definition is similar to `getElementsByTagName`, except it returns a new type: `NodeListOf`. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing `NodeListOf<E>` with `E[]` would result in a very similar user experience. `NodeListOf` only implements the following properties and methods: `length`, `item(index)`, `forEach((value, key, parent) => void)`, and numeric indexing. Additionally, this method returns a list of _elements_, not _nodes_, which is what `NodeList` was returning from the `.childNodes` method. While this may appear as a discrepancy, take note that interface `Element` extends from `Node`.\n\nTo see these methods in action modify the existing code to:\n\ntsx\n\n`   <ul>    <li>First :)</li>    <li>Second!</li>    <li>Third times a charm.</li>  </ul>;  const first = document.querySelector(\"li\"); // returns the first li element  const all = document.querySelectorAll(\"li\"); // returns the list of all li elements   `\n\n[](https://www.typescriptlang.org/docs/handbook/dom-manipulation.html#interested-in-learning-more)\nInterested in learning more?\n-------------------------------------------------------------------------------------------------------------------------------\n\nThe best part about the _lib.dom.d.ts_ type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the `HTMLElement` interface is documented by this [HTMLElement page](https://developer.mozilla.org/docs/Web/API/HTMLElement)\n on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the [W3C Recommendation for HTMLElement](https://www.w3.org/TR/html52/dom.html#htmlelement)\n.\n\nSources:\n\n*   [ECMA-262 Standard](http://www.ecma-international.org/ecma-262/10.0/index.html)\n    \n*   [Introduction to the DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/tutorials/DOM%20Manipulation.md)\n ❤\n\nContributors to this page:  \n\nEA![Ethan Arrowood  (6)](https://gravatar.com/avatar/403a9bf14e0b6fc02609ad5745ef877b7765e95b45678eaf416719a44c853f63?s=32&&d=blank)\n\nOT![Orta Therox  (5)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nSA![Safei Ashraf  (1)](https://gravatar.com/avatar/2bc6c2fd2222ac10b3c43c79d226d5bbdec299e6846f65d284a8bd0df263f076?s=32&&d=blank)\n\nM![Mateusz  (1)](https://gravatar.com/avatar/a70c4b1c4e91f59b661ed608cbba027b09a169df0c872a99bdc426aace9fd98f?s=32&&d=blank)\n\nIO![Iván Ovejero  (1)](https://gravatar.com/avatar/295845dcef2f47d9aa1059793f23f36ceb739f1772ac1b487f11a1094e733655?s=32&&d=blank)\n\n6+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"Using the DOM with TypeScript","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","twitter:site":"typescriptlang","description":"Using the DOM with TypeScript","og:title":"Documentation - DOM Manipulation","ogTitle":"Documentation - DOM Manipulation","language":"en","generator":"Gatsby 5.13.5","og:description":"Using the DOM with TypeScript","title":"TypeScript: Documentation - DOM Manipulation","scrapeId":"763341ae-e492-47b4-9c77-9f9d66fe096b","sourceURL":"https://www.typescriptlang.org/docs/handbook/dom-manipulation.html","url":"https://www.typescriptlang.org/docs/handbook/dom-manipulation.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModules - ESM/CJS Interoperability\n==================================\n\nIt’s 2015, and you’re writing an ESM-to-CJS transpiler. There’s no specification for how to do this; all you have is a specification of how ES modules are supposed to interact with each other, knowledge of how CommonJS modules interact with each other, and a knack for figuring things out. Consider an exporting ES module:\n\nts\n\n`   export const A = {};  export const B = {};  export default \"Hello, world!\";   `\n\nHow would you turn this into a CommonJS module? Recalling that default exports are just named exports with special syntax, there seems to be only one choice:\n\nts\n\n`   exports.A = {};  exports.B = {};  exports.default = \"Hello, world!\";   `\n\nThis is a nice analog, and it lets you implement a similar on the importing side:\n\nts\n\n`   import hello, { A, B } from \"./module\";  console.log(hello, A, B);  // transpiles to:  const module_1 = require(\"./module\");  console.log(module_1.default, module_1.A, module_1.B);   `\n\nSo far, everything in CJS-world matches up one-to-one with everything in ESM-world. Extending the equivalence above one step further, we can see that we also have:\n\nts\n\n`   import * as mod from \"./module\";  console.log(mod.default, mod.A, mod.B);  // transpiles to:  const mod = require(\"./module\");  console.log(mod.default, mod.A, mod.B);   `\n\nYou might notice that in this scheme, there’s no way to write an ESM export that produces an output where `exports` is assigned a function, class, or primitive:\n\nts\n\n`   // @Filename: exports-function.js  module.exports = function hello() {    console.log(\"Hello, world!\");  };   `\n\nBut existing CommonJS modules frequently take this form. How might an ESM import, processed with our transpiler, access this module? We just established that a namespace import (`import *`) transpiles to a plain `require` call, so we can support an input like:\n\nts\n\n`   import * as hello from \"./exports-function\";  hello();  // transpiles to:  const hello = require(\"./exports-function\");  hello();   `\n\nOur output works at runtime, but we have a compliance problem: according to the JavaScript specification, a namespace import always resolves to a [_Module Namespace Object_](https://tc39.es/ecma262/#sec-module-namespace-objects)\n, that is, an object whose members are the exports of the module. In this case, `require` would return the function `hello`, but `import *` can never return a function. The correspondence we assumed appears invalid.\n\nIt’s worth taking a step back here and clarifying what the _goal_ is. As soon as modules landed in the ES2015 specification, transpilers emerged with support for downleveling ESM to CJS, allowing users to adopt the new syntax long before runtimes implemented support for it. There was even a sense that writing ESM code was a good way to “future-proof” new projects. For this to be true, there needed to be a seamless migration path from executing the transpilers’ CJS output to executing the ESM input natively once runtimes developed support for it. The goal was to find a way to downlevel ESM to CJS that would allow any or all of those transpiled outputs to be replaced by their true ESM inputs in a future runtime, with no observable change in behavior.\n\nBy following the specification, it was easy enough for transpilers to find a set of transformations that made the semantics of their transpiled CommonJS outputs match the specified semantics of their ESM inputs (arrows represent imports):\n\n![A flowchart with two similar flows side-by-side. Left: ESM. Right: ESM transpiled to CJS. In the ESM flow: \"Importing module\" flows to \"Imported module\" through arrow labeled \"specified behavior\". In the ESM transpiled to CJS flow: \"Importing module\" flows to \"Imported module\" through arrow labeled \"designed based on spec\".](https://www.typescriptlang.org/d789cdf9a8f7f88a40e9e703e0698245/esm-cjs-interop.md-1.svg)\n\nHowever, CommonJS modules (written as CommonJS, not as ESM transpiled to CommonJS) were already well-established in the Node.js ecosystem, so it was inevitable that modules written as ESM and transpiled to CJS would start “importing” modules written as CommonJS. The behavior for this interoperability, though, was not specified by ES2015, and didn’t yet exist in any real runtime.\n\n![A flowchart with three areas side-by-side. Left: ESM. Middle: True CJS. Right: ESM transpiled to CJS. Left: ESM \"Importing module\" flows to ESM \"Imported module\" through arrow labeled \"specified behavior,\" and to True CJS \"Imported module\" through dotted arrow labeled \"unspecified behavior.\" Right: ESM transpiled to CJS \"Importing module\" flows to ESM transpiled to CJS \"Imported module\" through arrow labeled \"designed based on spec,\" and to True CJS \"Imported module\" through dotted arrow labeled \"❓🤷‍♂️❓\"](https://www.typescriptlang.org/f935787a9210481bf751b445c081f07b/esm-cjs-interop.md-2.svg)\n\nEven if transpiler authors did nothing, a behavior would emerge from the existing semantics between the `require` calls they emitted in transpiled code and the `exports` defined in existing CJS modules. And to allow users to transition seamlessly from transpiled ESM to true ESM once their runtime supported it, that behavior would have to match the one the runtime chose to implement.\n\nGuessing what interop behavior runtimes would support wasn’t limited to ESM importing “true CJS” modules either. Whether ESM would be able to recognize ESM-transpiled-from-CJS as distinct from CJS, and whether CJS would be able to `require` ES modules, were also unspecified. Even whether ESM imports would use the same module resolution algorithm as CJS `require` calls was unknowable. All these variables would have to be predicted correctly in order to give transpiler users a seamless migration path toward native ESM.\n\n[](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#allowsyntheticdefaultimports-and-esmoduleinterop)\n`allowSyntheticDefaultImports` and `esModuleInterop`\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nLet’s return to our specification compliance problem, where `import *` transpiles to `require`:\n\nts\n\n`   // Invalid according to the spec:  import * as hello from \"./exports-function\";  hello();  // but the transpilation works:  const hello = require(\"./exports-function\");  hello();   `\n\nWhen TypeScript first added support for writing and transpiling ES modules, the compiler addressed this problem by issuing an error on any namespace import of a module whose `exports` was not a namespace-like object:\n\nts\n\n`   import * as hello from \"./exports-function\";  // TS2497              ^^^^^^^^^^^^^^^^^^^^  // External module '\"./exports-function\"' resolves to a non-module entity  // and cannot be imported using this construct.   `\n\nThe only workaround was for users to go back to using the older TypeScript import syntax representing a CommonJS `require`:\n\nts\n\n`   import hello = require(\"./exports-function\");   `\n\nForcing users to revert to non-ESM syntax was essentially an admission that “we don’t know how or if a CJS module like `\"./exports-function\"` will be accessible with ESM imports in the future, but we know it _can’t_ be with `import *`, even though it will work at runtime in the transpilation scheme we’re using.” It doesn’t meet the goal of allowing this file to be migrated to real ESM without changes, but neither does the alternative of allowing the `import *` to link to a function. This is still the behavior in TypeScript today when `allowSyntheticDefaultImports` and `esModuleInterop` are disabled.\n\n> Unfortunately, this is a slight oversimplification—TypeScript didn’t fully avoid the compliance issue with this error, because it allowed namespace imports of functions to work, and retain their call signatures, as long as the function declaration merged with a namespace declaration—even if the namespace was empty. So while a module exporting a bare function was recognized as a “non-module entity”:\n> \n> ts\n> \n> ``   declare function $(selector: string): any;  export = $; // Cannot `import *` this 👍   ``\n> \n> A should-be-meaningless change allowed the invalid import to type check without errors:\n> \n> ts\n> \n> ``   declare namespace $ {}  declare function $(selector: string): any;  export = $; // Allowed to `import *` this and call it 😱   ``\n\nMeanwhile, other transpilers were coming up with a way to solve the same problem. The thought process went something like this:\n\n1.  To import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don’t make sense here.\n2.  Most likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modules _always_ link directly to the whole `exports`, rather than only doing so if the `exports` is a function or primitive.\n3.  So, a default import of a true CJS module should work just like a `require` call. But we’ll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpile `export default \"hello\"` to `exports.default = \"hello\"` and have a default import of _that_ module link to `exports.default`. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).\n4.  When we transpile an ES module to CJS, let’s add a special extra field to the output:\n    \n    ts\n    \n    `   exports.A = {};  exports.B = {};  exports.default = \"Hello, world!\";  // Extra special flag!  exports.__esModule = true;   `\n    \n    that we can check for when we transpile a default import:\n    \n    ts\n    \n    `   // import hello from \"./module\";  const _mod = require(\"./module\");  const hello = _mod.__esModule ? _mod.default : _mod;   `\n    \n\nThe `__esModule` flag first appeared in Traceur, then in Babel, SystemJS, and Webpack shortly after. TypeScript added the `allowSyntheticDefaultImports` in 1.8 to allow the type checker to link default imports directly to the `exports`, rather than the `exports.default`, of any module types that lacked an `export default` declaration. The flag didn’t modify how imports or exports were emitted, but it allowed default imports to reflect how other transpilers would treat them. Namely, it allowed a default import to be used to resolve to “non-module entities,” where `import *` was an error:\n\nts\n\n``   // Error:  import * as hello from \"./exports-function\";  // Old workaround:  import hello = require(\"./exports-function\");  // New way, with `allowSyntheticDefaultImports`:  import hello from \"./exports-function\";   ``\n\nThis was usually enough to let Babel and Webpack users write code that already worked in those systems without TypeScript complaining, but it was only a partial solution, leaving a few issues unsolved:\n\n1.  Babel and others varied their default import behavior on whether an `__esModule` property was found on the target module, but `allowSyntheticDefaultImports` only enabled a _fallback_ behavior when no default export was found in the target module’s types. This created an inconsistency if the target module had an `__esModule` flag but _no_ default export. Transpilers and bundlers would still link a default import of such a module to its `exports.default`, which would be `undefined`, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can’t be linked. But with `allowSyntheticDefaultImports`, TypeScript would think a default import of such an import links to the whole `exports` object, allowing named exports to be accessed as its properties.\n2.  `allowSyntheticDefaultImports` didn’t change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type:\n    \n    ts\n    \n    `   // @Filename: exportEqualsObject.d.ts  declare const obj: object;  export = obj;  // @Filename: main.ts  import objDefault from \"./exportEqualsObject\";  import * as objNamespace from \"./exportEqualsObject\";  // This should be true at runtime, but TypeScript gives an error:  objNamespace.default === objDefault;  //           ^^^^^^^ Property 'default' does not exist on type 'typeof import(\"./exportEqualsObject\")'.   `\n    \n3.  Most importantly, `allowSyntheticDefaultImports` did not change the JavaScript emitted by `tsc`. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting `--module commonjs` with `tsc` and running in Node.js. If they encountered an error with `import *`, it may have appeared as if enabling `allowSyntheticDefaultImports` would fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node.\n\nTypeScript introduced the `esModuleInterop` flag in 2.7, which refined the type checking of imports to address the remaining inconsistencies between TypeScript’s analysis and the interop behavior used in existing transpilers and bundlers, and critically, adopted the same `__esModule`\\-conditional CommonJS emit that transpilers had adopted years before. (Another new emit helper for `import *` ensured the result was always an object, with call signatures stripped, fully resolving the specification compliance issue that the aforementioned “resolves to a non-module entity” error didn’t quite sidestep.) Finally, with the new flag enabled, TypeScript’s type checking, TypeScript’s emit, and the rest of the transpiling and bundling ecosystem were in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps, plausibly adoptable by Node.\n\n[](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#interop-in-nodejs)\nInterop in Node.js\n-----------------------------------------------------------------------------------------------------------------------------\n\nNode.js shipped support for ES modules unflagged in v12. Like the bundlers and transpilers began doing years before, Node.js gave CommonJS modules a “synthetic default export” of their `exports` object, allowing the entire module contents to be accessed with a default import from ESM:\n\nts\n\n`   // @Filename: export.cjs  module.exports = { hello: \"world\" };  // @Filename: import.mjs  import greeting from \"./export.cjs\";  greeting.hello; // \"world\"   `\n\nThat’s one win for seamless migration! Unfortunately, the similarities mostly end there.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#no-__esmodule-detection-the-double-default-problem)\nNo `__esModule` detection (the “double default” problem)\n\nNode.js wasn’t able to respect the `__esModule` marker to vary its default import behavior. So a transpiled module with a “default export” behaves one way when “imported” by another transpiled module, and another way when imported by a true ES module in Node.js:\n\nts\n\n`   // @Filename: node_modules/dependency/index.js  exports.__esModule = true;  exports.default = function doSomething() { /*...*/ }  // @Filename: transpile-vs-run-directly.{js/mjs}  import doSomething from \"dependency\";  // Works after transpilation, but not a function in Node.js ESM:  doSomething();  // Doesn't exist after transpilation, but works in Node.js ESM:  doSomething.default();   `\n\nWhile the transpiled default import only makes the synthetic default export if the target module lacks an `__esModule` flag, Node.js _always_ synthesizes a default export, creating a “double default” on the transpiled module.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#unreliable-named-exports)\nUnreliable named exports\n\nIn addition to making a CommonJS module’s `exports` object available as a default import, Node.js attempts to find properties of `exports` to make available as named imports. This behavior matches bundlers and transpilers when it works; however, Node.js uses [syntactic analysis](https://github.com/nodejs/cjs-module-lexer)\n to synthesize named exports before any code executes, whereas transpiled modules resolve their named imports at runtime. The result is that imports from CJS modules that work in transpiled modules may not work in Node.js:\n\nts\n\n``   // @Filename: named-exports.cjs  exports.hello = \"world\";  exports[\"worl\" + \"d\"] = \"hello\";  // @Filename: transpile-vs-run-directly.{js/mjs}  import { hello, world } from \"./named-exports.cjs\";  // `hello` works, but `world` is missing in Node.js 💥  import mod from \"./named-exports.cjs\";  mod.world;  // Accessing properties from the default always works ✅   ``\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#cannot-require-a-true-es-module-before-nodejs-v22)\nCannot `require` a true ES module before Node.js v22\n\nTrue CommonJS modules can `require` an ESM-transpiled-to-CJS module, since they’re both CommonJS at runtime. But in Node.js versions older than v22.12.0, `require` crashes if it resolves to an ES module. This means published libraries cannot migrate from transpiled modules to true ESM without breaking their CommonJS (true or transpiled) consumers:\n\nts\n\n`   // @Filename: node_modules/dependency/index.js  export function doSomething() { /* ... */ }  // @Filename: dependent.js  import { doSomething } from \"dependency\";  // ✅ Works if dependent and dependency are both transpiled  // ✅ Works if dependent and dependency are both true ESM  // ✅ Works if dependent is true ESM and dependency is transpiled  // 💥 Crashes if dependent is transpiled and dependency is true ESM   `\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#different-module-resolution-algorithms)\nDifferent module resolution algorithms\n\nNode.js introduced a new module resolution algorithm for resolving ESM imports that differed significantly from the long-standing algorithm for resolving `require` calls. While not directly related to interop between CJS and ES modules, this difference was one more reason why a seamless migration from transpiled modules to true ESM might not be possible:\n\nts\n\n`   // @Filename: add.js  export function add(a, b) {    return a + b;  }  // @Filename: math.js  export * from \"./add\";  //            ^^^^^^^  // Works when transpiled to CJS,  // but would have to be \"./add.js\"  // in Node.js ESM.   `\n\n[](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#conclusions)\nConclusions\n----------------------------------------------------------------------------------------------------------------\n\nClearly, a seamless migration from transpiled modules to ESM isn’t possible, at least in Node.js. Where does this leave us?\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#setting-the-right-module-compiler-option-is-critical)\nSetting the right `module` compiler option is critical\n\nSince interoperability rules differ between hosts, TypeScript can’t offer correct checking behavior unless it understands what kind of module is represented by each file it sees, and what set of rules to apply to them. This is the purpose of the `module` compiler option. (In particular, code that is intended to run in Node.js is subject to stricter rules than code that will be processed by a bundler. The compiler’s output is not checked for Node.js compatibility unless `module` is set to `node16`, `node18`, or `nodenext`.)\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#applications-with-commonjs-code-should-always-enable-esmoduleinterop)\nApplications with CommonJS code should always enable `esModuleInterop`\n\nIn a TypeScript _application_ (as opposed to a library that others may consume) where `tsc` is used to emit JavaScript files, whether `esModuleInterop` is enabled doesn’t have major consequences. The way you write imports for certain kinds of modules will change, but TypeScript’s checking and emit are in sync, so error-free code should be safe to run in either mode. The downside of leaving `esModuleInterop` disabled in this case is that it allows you to write JavaScript code with semantics that clearly violate the ECMAScript specification, confusing intuitions about namespace imports and making it harder to migrate to running ES modules in the future.\n\nIn an application that gets processed by a third-party transpiler or bundler, on the other hand, enabling `esModuleInterop` is more important. All major bundlers and transpilers use an `esModuleInterop`\\-like emit strategy, so TypeScript needs to adjust its checking to match. (The compiler always reasons about what will happen in the JavaScript files that `tsc` would emit, so even if another tool is being used in place of `tsc`, emit-affecting compiler options should still be set to match the output of that tool as closely as possible.)\n\n`allowSyntheticDefaultImports` without `esModuleInterop` should be avoided. It changes the compiler’s checking behavior without changing the code emitted by `tsc`, allowing potentially unsafe JavaScript to be emitted. Additionally, the checking changes it introduces are an incomplete version of the ones introduced by `esModuleInterop`. Even if `tsc` isn’t being used for emit, it’s better to enable `esModuleInterop` than `allowSyntheticDefaultImports`.\n\nSome people object to the inclusion of the `__importDefault` and `__importStar` helper functions included in `tsc`’s JavaScript output when `esModuleInterop` is enabled, either because it marginally increases the output size on disk or because the interop algorithm employed by the helpers seems to misrepresent Node.js’s interop behavior by checking for `__esModule`, leading to the hazards discussed earlier. Both of these objections can be addressed, at least partially, without accepting the flawed checking behavior exhibited with `esModuleInterop` disabled. First, the `importHelpers` compiler option can be used to import the helper functions from `tslib` rather than inlining them into each file that needs them. To discuss the second objection, let’s look at a final example:\n\nts\n\n`   // @Filename: node_modules/transpiled-dependency/index.js  exports.__esModule = true;  exports.default = function doSomething() { /* ... */ };  exports.something = \"something\";  // @Filename: node_modules/true-cjs-dependency/index.js  module.exports = function doSomethingElse() { /* ... */ };  // @Filename: src/sayHello.ts  export default function sayHello() { /* ... */ }  export const hello = \"hello\";  // @Filename: src/main.ts  import doSomething from \"transpiled-dependency\";  import doSomethingElse from \"true-cjs-dependency\";  import sayHello from \"./sayHello.js\";   `\n\nAssume we’re compiling `src` to CommonJS for use in Node.js. Without `allowSyntheticDefaultImports` or `esModuleInterop`, the import of `doSomethingElse` from `\"true-cjs-dependency\"` is an error, and the others are not. To fix the error without changing any compiler options, you could change the import to `import doSomethingElse = require(\"true-cjs-dependency\")`. However, depending on how the types for the module (not shown) are written, you may also be able to write and call a namespace import, which would be a language-level specification violation. With `esModuleInterop`, none of the imports shown are errors (and all are callable), but the invalid namespace import would be caught.\n\nWhat would change if we decided to migrate `src` to true ESM in Node.js (say, add `\"type\": \"module\"` to our root package.json)? The first import, `doSomething` from `\"transpiled-dependency\"`, would no longer be callable—it exhibits the “double default” problem, where we’d have to call `doSomething.default()` rather than `doSomething()`. (TypeScript understands and catches this under `--module node16`—`nodenext`.) But notably, the _second_ import of `doSomethingElse`, which needed `esModuleInterop` to work when compiling to CommonJS, works fine in true ESM.\n\nIf there’s something to complain about here, it’s not what `esModuleInterop` does with the second import. The changes it makes, both allowing the default import and preventing callable namespace imports, are exactly in line with Node.js’s real ESM/CJS interop strategy, and made migration to real ESM easier. The problem, if there is one, is that `esModuleInterop` seems to fail at giving us a seamless migration path for the _first_ import. But this problem was not introduced by enabling `esModuleInterop`; the first import was completely unaffected by it. Unfortunately, this problem cannot be solved without breaking the semantic contract between `main.ts` and `sayHello.ts`, because the CommonJS output of `sayHello.ts` looks structurally identical to `transpiled-dependency/index.js`. If `esModuleInterop` changed the way the transpiled import of `doSomething` works to be identical to the way it would work in Node.js ESM, it would change the behavior of the `sayHello` import in the same way, making the input code violate ESM semantics (thus still preventing the `src` directory from being migrated to ESM without changes).\n\nAs we’ve seen, there is no seamless migration path from transpiled modules to true ESM. But `esModuleInterop` is one step in the right direction. For those who still prefer to minimize module syntax transformations and the inclusion of the import helper functions, enabling `verbatimModuleSyntax` is a better choice than disabling `esModuleInterop`. `verbatimModuleSyntax` enforces that the `import mod = require(\"mod\")` and `export = ns` syntax be used in CommonJS-emitting files, avoiding all the kinds of import ambiguity we’ve discussed, at the cost of ease of migration to true ESM.\n\n### [](https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html#library-code-needs-special-considerations)\nLibrary code needs special considerations\n\nLibraries that ship as CommonJS should avoid using default exports, since the way those transpiled exports can be accessed varies between different tools and runtimes, and some of those ways will look confusing to users. A default export, transpiled to CommonJS by `tsc`, is accessible in Node.js as the default property of a default import:\n\njs\n\n`   import pkg from \"pkg\";  pkg.default();   `\n\nin most bundlers or transpiled ESM as the default import itself:\n\njs\n\n`   import pkg from \"pkg\";  pkg();   `\n\nand in vanilla CommonJS as the default property of a `require` call:\n\njs\n\n`   const pkg = require(\"pkg\");  pkg.default();   `\n\nUsers will detect a misconfigured module smell if they have to access the `.default` property of a default import, and if they’re trying to write code that will run both in Node.js and a bundler, they might be stuck. Some third-party TypeScript transpilers expose options that change the way default exports are emitted to mitigate this difference, but they don’t produce their own declaration (`.d.ts`) files, so that creates a mismatch between the runtime behavior and the type checking, further confusing and frustrating users. Instead of using default exports, libraries that need to ship as CommonJS should use `export =` for modules that have a single main export, or named exports for modules that have multiple exports:\n\ndiff\n\n`   - export default function doSomething() { /* ... */ }  + export = function doSomething() { /* ... */ }   `\n\nLibraries (that ship declaration files) should also take extra care to ensure the types they write are error-free under a wide range of compiler options. For example, it’s possible to write one interface that extends another in such a way that it only compiles successfully when `strictNullChecks` is disabled. If a library were to publish types like that, it would force all their users to disable `strictNullChecks` too. `esModuleInterop` can allow type declarations to contain similarly “infectious” default imports:\n\nts\n\n`   // @Filename: /node_modules/dependency/index.d.ts  import express from \"express\";  declare function doSomething(req: express.Request): any;  export = doSomething;   `\n\nSuppose this default import _only_ works with `esModuleInterop` enabled, and causes an error when a user without that option references this file. The user should _probably_ enable `esModuleInterop` anyway, but it’s generally seen as bad form for libraries to make their configurations infectious like this. It would be much better for the library to ship a declaration file like:\n\nts\n\n`   import express = require(\"express\");  // ...   `\n\nExamples like this have led to conventional wisdom that says libraries should _not_ enable `esModuleInterop`. This advice is a reasonable start, but we’ve looked at examples where the type of a namespace import changes, potentially _introducing_ an error, when enabling `esModuleInterop`. So whether libraries compile with or without `esModuleInterop`, they run the risk of writing syntax that makes their choice infectious.\n\nLibrary authors who want to go above and beyond to ensure maximum compatibility would do well to validate their declaration files against a matrix of compiler options. But using `verbatimModuleSyntax` completely sidesteps the issue with `esModuleInterop` by forcing CommonJS-emitting files to use CommonJS-style import and export syntax. Additionally, since `esModuleInterop` only affects CommonJS, as more libraries move to ESM-only publishing over time, the relevance of this issue will decline.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/modules-reference/appendices/ESM-CJS-Interop.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (9)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nXZ![Xavier Zhou  (1)](https://gravatar.com/avatar/48e2ac6a3728c002f2a11a08ca50dd3df9e8153efcd4e85f6a8c224d53b36ff6?s=32&&d=blank)\n\nDR![Diego Rodrigues  (1)](https://gravatar.com/avatar/12c5b3f6897bb3d1a3b6f2dad0a2ba5dae9a0786bd5f28ef849cf0938ff3aa5b?s=32&&d=blank)\n\nK![KnorpelSenf  (1)](https://gravatar.com/avatar/3a6b1cec622f7f3ef1440682f6bd8b8722832d0907161cea1db7f19a8b0b00ee?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"theme-color":"#3178C6","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"A detailed look at interoperability between ES modules and CommonJS modules","og:title":"Documentation - Modules - ESM/CJS Interoperability","og:description":"A detailed look at interoperability between ES modules and CommonJS modules","language":"en","ogDescription":"A detailed look at interoperability between ES modules and CommonJS modules","ogTitle":"Documentation - Modules - ESM/CJS Interoperability","title":"TypeScript: Documentation - Modules - ESM/CJS Interoperability","generator":"Gatsby 5.13.5","twitter:site":"typescriptlang","scrapeId":"acd16c7a-bdff-4f89-b8b3-d8b8ced76479","sourceURL":"https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html","url":"https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nMigrating from JavaScript\n=========================\n\nTypeScript doesn’t exist in a vacuum. It was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today. Converting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging. In this tutorial, we’re going to look at how you might start out. We assume you’ve read enough of the handbook to write new TypeScript code.\n\nIf you’re looking to convert a React project, we recommend looking at the [React Conversion Guide](https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide)\n first.\n\n[](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#setting-up-your-directories)\nSetting up your Directories\n---------------------------------------------------------------------------------------------------------------------------------------\n\nIf you’re writing in plain JavaScript, it’s likely that you’re running your JavaScript directly, where your `.js` files are in a `src`, `lib`, or `dist` directory, and then run as desired.\n\nIf that’s the case, the files that you’ve written are going to be used as inputs to TypeScript, and you’ll run the outputs it produces. During our JS to TS migration, we’ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.\n\nYou might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.\n\nFrom this point on, we’re going to assume that your directory is set up something like this:\n\n`   projectRoot  ├── src  │   ├── file1.js  │   └── file2.js  ├── built  └── tsconfig.json   `\n\nIf you have a `tests` folder outside of your `src` directory, you might have one `tsconfig.json` in `src`, and one in `tests` as well.\n\n[](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#writing-a-configuration-file)\nWriting a Configuration File\n-----------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript uses a file called `tsconfig.json` for managing your project’s options, such as which files you want to include, and what sorts of checking you want to perform. Let’s create a bare-bones one for our project:\n\njson\n\n`   {    \"compilerOptions\": {      \"outDir\": \"./built\",      \"allowJs\": true,      \"target\": \"es5\"    },    \"include\": [\"./src/**/*\"]  }   `\n\nHere we’re specifying a few things to TypeScript:\n\n1.  Read in any files it understands in the `src` directory (with [`include`](https://www.typescriptlang.org/tsconfig#include)\n    ).\n2.  Accept JavaScript files as inputs (with [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)\n    ).\n3.  Emit all of the output files in `built` (with [`outDir`](https://www.typescriptlang.org/tsconfig#outDir)\n    ).\n4.  Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using [`target`](https://www.typescriptlang.org/tsconfig#target)\n    ).\n\nAt this point, if you try running `tsc` at the root of your project, you should see output files in the `built` directory. The layout of files in `built` should look identical to the layout of `src`. You should now have TypeScript working with your project.\n\n[](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#early-benefits)\nEarly Benefits\n-------------------------------------------------------------------------------------------------------------\n\nEven at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like [VS Code](https://code.visualstudio.com/)\n or [Visual Studio](https://visualstudio.com/)\n, you’ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:\n\n*   [`noImplicitReturns`](https://www.typescriptlang.org/tsconfig#noImplicitReturns)\n     which prevents you from forgetting to return at the end of a function.\n*   [`noFallthroughCasesInSwitch`](https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch)\n     which is helpful if you never want to forget a `break` statement between `case`s in a `switch` block.\n\nTypeScript will also warn about unreachable code and labels, which you can disable with [`allowUnreachableCode`](https://www.typescriptlang.org/tsconfig#allowUnreachableCode)\n and [`allowUnusedLabels`](https://www.typescriptlang.org/tsconfig#allowUnusedLabels)\n respectively.\n\n[](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#integrating-with-build-tools)\nIntegrating with Build Tools\n-----------------------------------------------------------------------------------------------------------------------------------------\n\nYou might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we’ll do our best to cover the gist of things.\n\n### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#gulp)\nGulp\n\nIf you’re using Gulp in some fashion, we have a tutorial on [using Gulp](https://www.typescriptlang.org/docs/handbook/gulp.html)\n with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.\n\n### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#webpack)\nWebpack\n\nWebpack integration is pretty simple. You can use `ts-loader`, a TypeScript loader, combined with `source-map-loader` for easier debugging. Simply run\n\nshell\n\n`   npm install ts-loader source-map-loader   `\n\nand merge in options from the following into your `webpack.config.js` file:\n\njs\n\n`   module.exports = {    entry: \"./src/index.ts\",    output: {      filename: \"./dist/bundle.js\",    },    // Enable sourcemaps for debugging webpack's output.    devtool: \"source-map\",    resolve: {      // Add '.ts' and '.tsx' as resolvable extensions.      extensions: [\"\", \".webpack.js\", \".web.js\", \".ts\", \".tsx\", \".js\"],    },    module: {      rules: [        // All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'.        { test: /\\.tsx?$/, loader: \"ts-loader\" },        // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.        { test: /\\.js$/, loader: \"source-map-loader\" },      ],    },    // Other options...  };   `\n\nIt’s important to note that ts-loader will need to run before any other loader that deals with `.js` files.\n\nYou can see an example of using Webpack in our [tutorial on React and Webpack](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#moving-to-typescript-files)\nMoving to TypeScript Files\n-------------------------------------------------------------------------------------------------------------------------------------\n\nAt this point, you’re probably ready to start using TypeScript files. The first step is to rename one of your `.js` files to `.ts`. If your file uses JSX, you’ll need to rename it to `.tsx`.\n\nFinished with that step? Great! You’ve successfully migrated a file from JavaScript to TypeScript!\n\nOf course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run `tsc --pretty`), you might see red squiggles on certain lines. You should think of these the same way you’d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.\n\nIf that sounds too lax for you, you can tighten that behavior up. If, for instance, you _don’t_ want TypeScript to compile to JavaScript in the face of errors, you can use the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)\n option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.\n\nIf you plan on using the stricter settings that are available, it’s best to turn them on now (see [Getting Stricter Checks](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks)\n below). For instance, if you never want TypeScript to silently infer `any` for a type without you explicitly saying so, you can use [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.\n\n### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#weeding-out-errors)\nWeeding out Errors\n\nLike we mentioned, it’s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you’ll have to explain what you’re trying to do a little better to TypeScript.\n\n#### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#importing-from-modules)\nImporting from Modules\n\nYou might start out getting a bunch of errors like `Cannot find name 'require'.`, and `Cannot find name 'define'.`. In these cases, it’s likely that you’re using modules. While you can just convince TypeScript that these exist by writing out\n\nts\n\n`   // For Node/CommonJS  declare function require(path: string): any;   `\n\nor\n\nts\n\n`   // For RequireJS/AMD  declare function define(...args: any[]): any;   `\n\nit’s better to get rid of those calls and use TypeScript syntax for imports.\n\nFirst, you’ll need to enable some module system by setting TypeScript’s [`module`](https://www.typescriptlang.org/tsconfig#module)\n option. Valid options are `commonjs`, `amd`, `system`, and `umd`.\n\nIf you had the following Node/CommonJS code:\n\njs\n\n`   var foo = require(\"foo\");  foo.doStuff();   `\n\nor the following RequireJS/AMD code:\n\njs\n\n`   define([\"foo\"], function (foo) {    foo.doStuff();  });   `\n\nthen you would write the following TypeScript code:\n\nts\n\n`   import foo = require(\"foo\");  foo.doStuff();   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-declaration-files)\nGetting Declaration Files\n\nIf you started converting over to TypeScript imports, you’ll probably run into errors like `Cannot find module 'foo'.`. The issue here is that you likely don’t have _declaration files_ to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like `lodash`, you can just write\n\nshell\n\n`   npm install -S @types/lodash   `\n\nIf you’re using a module option other than `commonjs`, you’ll need to set your [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution)\n option to `node`.\n\nAfter that, you’ll be able to import lodash with no issues, and get accurate completions.\n\n#### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#exporting-from-modules)\nExporting from Modules\n\nTypically, exporting from a module involves adding properties to a value like `exports` or `module.exports`. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:\n\njs\n\n`   module.exports.feedPets = function (pets) {    // ...  };   `\n\nyou could write that out as the following:\n\nts\n\n`   export function feedPets(pets) {    // ...  }   `\n\nSometimes you’ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:\n\njs\n\n`   var express = require(\"express\");  var app = express();   `\n\nYou might have previously written that like so:\n\njs\n\n`   function foo() {    // ...  }  module.exports = foo;   `\n\nIn TypeScript, you can model this with the `export =` construct.\n\nts\n\n`   function foo() {    // ...  }  export = foo;   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#too-manytoo-few-arguments)\nToo many/too few arguments\n\nYou’ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the `arguments` object instead of writing out any parameters:\n\njs\n\n`   function myCoolFunction() {    if (arguments.length == 2 && !Array.isArray(arguments[1])) {      var f = arguments[0];      var arr = arguments[1];      // ...    }    // ...  }  myCoolFunction(    function (x) {      console.log(x);    },    [1, 2, 3, 4]  );  myCoolFunction(    function (x) {      console.log(x);    },    1,    2,    3,    4  );   `\n\nIn this case, we need to use TypeScript to tell any of our callers about the ways `myCoolFunction` can be called using function overloads.\n\nts\n\n`   function myCoolFunction(f: (x: number) => void, nums: number[]): void;  function myCoolFunction(f: (x: number) => void, ...nums: number[]): void;  function myCoolFunction() {    if (arguments.length == 2 && !Array.isArray(arguments[1])) {      var f = arguments[0];      var arr = arguments[1];      // ...    }    // ...  }   `\n\nWe added two overload signatures to `myCoolFunction`. The first checks states that `myCoolFunction` takes a function (which takes a `number`), and then a list of `number`s. The second one says that it will take a function as well, and then uses a rest parameter (`...nums`) to state that any number of arguments after that need to be `number`s.\n\n#### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#sequentially-added-properties)\nSequentially Added Properties\n\nSome people find it more aesthetically pleasing to create an object and add properties immediately after like so:\n\njs\n\n`   var options = {};  options.color = \"red\";  options.volume = 11;   `\n\nTypeScript will say that you can’t assign to `color` and `volume` because it first figured out the type of `options` as `{}` which doesn’t have any properties. If you instead moved the declarations into the object literal themselves, you’d get no errors:\n\nts\n\n`   let options = {    color: \"red\",    volume: 11,  };   `\n\nYou could also define the type of `options` and add a type assertion on the object literal.\n\nts\n\n`   interface Options {    color: string;    volume: number;  }  let options = {} as Options;  options.color = \"red\";  options.volume = 11;   `\n\nAlternatively, you can just say `options` has the type `any` which is the easiest thing to do, but which will benefit you the least.\n\n#### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#any-object-and-)\n`any`, `Object`, and `{}`\n\nYou might be tempted to use `Object` or `{}` to say that a value can have any property on it because `Object` is, for most purposes, the most general type. However **`any` is actually the type you want to use** in those situations, since it’s the most _flexible_ type.\n\nFor instance, if you have something that’s typed as `Object` you won’t be able to call methods like `toLowerCase()` on it. Being more general usually means you can do less with a type, but `any` is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use `any`, you lose out on most of the error checking and editor support that TypeScript gives you.\n\nIf a decision ever comes down to `Object` and `{}`, you should prefer `{}`. While they are mostly the same, technically `{}` is a more general type than `Object` in certain esoteric cases.\n\n### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks)\nGetting Stricter Checks\n\nTypeScript comes with certain checks to give you more safety and analysis of your program. Once you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.\n\n#### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#no-implicit-any)\nNo Implicit `any`\n\nThere are certain cases where TypeScript can’t figure out what certain types should be. To be as lenient as possible, it will decide to use the type `any` in its place. While this is great for migration, using `any` means that you’re not getting any type safety, and you won’t get the same tooling support you’d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n option.\n\n#### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#strict-null--undefined-checks)\nStrict `null` & `undefined` Checks\n\nBy default, TypeScript assumes that `null` and `undefined` are in the domain of every type. That means anything declared with the type `number` could be `null` or `undefined`. Since `null` and `undefined` are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n option to spare you the stress of worrying about these issues.\n\nWhen [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n is enabled, `null` and `undefined` get their own types called `null` and `undefined` respectively. Whenever anything is _possibly_ `null`, you can use a union type with the original type. So for instance, if something could be a `number` or `null`, you’d write the type out as `number | null`.\n\nIf you ever have a value that TypeScript thinks is possibly `null`/`undefined`, but you know better, you can use the postfix `!` operator to tell it otherwise.\n\nts\n\n`   declare var foo: string[] | null;  foo.length; // error - 'foo' is possibly 'null'  foo!.length; // okay - 'foo!' just has type 'string[]'   `\n\nAs a heads up, when using [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n, your dependencies may need to be updated to use [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n as well.\n\n#### [](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#no-implicit-any-for-this)\nNo Implicit `any` for `this`\n\nWhen you use the `this` keyword outside of classes, it has the type `any` by default. For instance, imagine a `Point` class, and imagine a function that we wish to add as a method:\n\nts\n\n`   class Point {    constructor(public x, public y) {}    getDistance(p: Point) {      let dx = p.x - this.x;      let dy = p.y - this.y;      return Math.sqrt(dx ** 2 + dy ** 2);    }  }  // ...  // Reopen the interface.  interface Point {    distanceFromOrigin(): number;  }  Point.prototype.distanceFromOrigin = function () {    return this.getDistance({ x: 0, y: 0 });  };   `\n\nThis has the same problems we mentioned above - we could easily have misspelled `getDistance` and not gotten an error. For this reason, TypeScript has the [`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis)\n option. When that option is set, TypeScript will issue an error when `this` is used without an explicit (or inferred) type. The fix is to use a `this`\\-parameter to give an explicit type in the interface or in the function itself:\n\nts\n\n`   Point.prototype.distanceFromOrigin = function (this: Point) {    return this.getDistance({ x: 0, y: 0 });  };   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/tutorials/Migrating%20from%20JavaScript.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (57)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)\n\nOT![Orta Therox  (14)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nTA![Thomas Ankcorn  (3)](https://gravatar.com/avatar/cfaad6c9f5e219cb7e30901ab4980df675a3df82bdfc42ac23262f0d466f7678?s=32&&d=blank)\n\nMG![Maayan Glikser  (3)](https://gravatar.com/avatar/3a615b34ef2060face8fcd481c6377e1?s=32&&d=blank)\n\nMF![Martin Fischer  (1)](https://gravatar.com/avatar/dc885100e48a5949f1a44bcd6fce398735ff3294f20607ddee8bb45acb29601a?s=32&&d=blank)\n\n19+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","ogDescription":"How to migrate from JavaScript to TypeScript","theme-color":"#3178C6","description":"How to migrate from JavaScript to TypeScript","title":"TypeScript: Documentation - Migrating from JavaScript","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:title":"Documentation - Migrating from JavaScript","og:description":"How to migrate from JavaScript to TypeScript","twitter:site":"typescriptlang","ogTitle":"Documentation - Migrating from JavaScript","scrapeId":"bbea5e32-4c5b-4210-8919-cbcd8bb02a57","sourceURL":"https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html","url":"https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nIntroduction\n============\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)\n to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to [Modules .d.ts](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html)\n.\n\nThe Declaration Files section is broken down into the following sections.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html#declaration-reference)\n[Declaration Reference](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The [Declaration Reference](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)\n section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html#library-structures)\n[Library Structures](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html)\n\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThe [Library Structures](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html)\n guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html#dos-and-donts)\n[Do’s and Don’ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)\n\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nMany common mistakes in declaration files can be easily avoided. The [Do’s and Don’ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)\n section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html#deep-dive)\n[Deep Dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the [Deep Dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)\n section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html#publish-to-npm)\n[Publish to npm](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThe [Publishing](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)\n section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html#find-and-install-declaration-files)\n[Find and Install Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html)\n\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nFor JavaScript library users, the [Consumption](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html)\n section offers a few simple steps to locate and install corresponding declaration files.\n\n[### Declaration Reference\\\n\\\nHow to create a d.ts file for a module](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/Introduction.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (61)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (16)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nJW![Julian Webb  (1)](https://gravatar.com/avatar/c10155d5a128195eac448ba751bbdb957897e69698c49adc0c2c7aad080cc903?s=32&&d=blank)\n\nNR![Nik Rahmel  (1)](https://gravatar.com/avatar/9e6301a8b20ce4d4acadc05dcac31435ed9fac2723b129cf95ffa8266ef717e2?s=32&&d=blank)\n\nDK![Dmitrii Kartashev  (1)](https://gravatar.com/avatar/3cc4e8763d580f9813950ea621af815513bc17fe19f6986deb96885301b2de7f?s=32&&d=blank)\n\n11+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"How to write a high-quality TypeScript Declaration (d.ts) file","language":"en","title":"TypeScript: Documentation - Introduction","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","generator":"Gatsby 5.13.5","ogTitle":"Documentation - Introduction","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","og:title":"Documentation - Introduction","og:description":"How to write a high-quality TypeScript Declaration (d.ts) file","twitter:site":"typescriptlang","description":"How to write a high-quality TypeScript Declaration (d.ts) file","scrapeId":"45c7669f-f98f-4065-a98e-34195eb29485","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModule: Plugin\n==============\n\nFor example, when you want to work with JavaScript code which extends another library.\n\nts\n\n`   import { greeter } from \"super-greeter\";  // Normal Greeter API  greeter(2);  greeter(\"Hello world\");  // Now we extend the object with a new function at runtime  import \"hyper-super-greeter\";  greeter.hyperGreet();   `\n\nThe definition for “super-greeter”:\n\nts\n\n`   /*~ This example shows how to have multiple overloads for your function */  export interface GreeterFunction {    (name: string): void    (time: number): void  }  /*~ This example shows how to export a function specified by an interface */  export const greeter: GreeterFunction;   `\n\nWe can extend the existing module like the following:\n\nts\n\n`   // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]  // Project: [~THE PROJECT NAME~]  // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>  /*~ This is the module plugin template file. You should rename it to index.d.ts   *~ and place it in a folder with the same name as the module.   *~ For example, if you were writing a file for \"super-greeter\", this   *~ file should be 'super-greeter/index.d.ts'   */  /*~ On this line, import the module which this module adds to */  import { greeter } from \"super-greeter\";  /*~ Here, declare the same module as the one you imported above   *~ then we expand the existing declaration of the greeter function   */  export module \"super-greeter\" {    export interface GreeterFunction {      /** Greets even better! */      hyperGreet(): void;    }  }   `\n\nThis uses [declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html#the-impact-of-es6-on-module-plugins)\nThe Impact of ES6 on Module Plugins\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/templates/module-plugin.d.ts.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (14)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nB![B2D1  (1)](https://gravatar.com/avatar/1470171c917b7e9b977c19cd984e9c46c5fa8c49dd84394417b761464b9dc8f2?s=32&&d=blank)\n\n1+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - Module: Plugin","ogTitle":"Documentation - Module: Plugin","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","description":"","twitter:site":"typescriptlang","og:description":"","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","ogDescription":"","og:title":"Documentation - Module: Plugin","scrapeId":"6ed2b6c9-45a3-437c-bd48-305c5cb2dec7","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nDeclaration Reference\n=====================\n\nThe purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.\n\nThese examples are ordered in approximately increasing order of complexity.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#objects-with-properties)\nObjects with Properties\n----------------------------------------------------------------------------------------------------------------------------------\n\n_Documentation_\n\n> The global variable `myLib` has a function `makeGreeting` for creating greetings, and a property `numberOfGreetings` indicating the number of greetings made so far.\n\n_Code_\n\nts\n\n`   let result = myLib.makeGreeting(\"hello, world\");  console.log(\"The computed greeting is:\" + result);  let count = myLib.numberOfGreetings;   `\n\n_Declaration_\n\nUse `declare namespace` to describe types or values accessed by dotted notation.\n\nts\n\n`   declare namespace myLib {    function makeGreeting(s: string): string;    let numberOfGreetings: number;  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#overloaded-functions)\nOverloaded Functions\n----------------------------------------------------------------------------------------------------------------------------\n\n_Documentation_\n\nThe `getWidget` function accepts a number and returns a Widget, or accepts a string and returns a Widget array.\n\n_Code_\n\nts\n\n`   let x: Widget = getWidget(43);  let arr: Widget[] = getWidget(\"all of them\");   `\n\n_Declaration_\n\nts\n\n`   declare function getWidget(n: number): Widget;  declare function getWidget(s: string): Widget[];   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#reusable-types-interfaces)\nReusable Types (Interfaces)\n----------------------------------------------------------------------------------------------------------------------------------------\n\n_Documentation_\n\n> When specifying a greeting, you must pass a `GreetingSettings` object. This object has the following properties:\n> \n> 1 - greeting: Mandatory string\n> \n> 2 - duration: Optional length of time (in milliseconds)\n> \n> 3 - color: Optional string, e.g. ‘#ff00ff’\n\n_Code_\n\nts\n\n`   greet({    greeting: \"hello world\",    duration: 4000  });   `\n\n_Declaration_\n\nUse an `interface` to define a type with properties.\n\nts\n\n`   interface GreetingSettings {    greeting: string;    duration?: number;    color?: string;  }  declare function greet(setting: GreetingSettings): void;   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#reusable-types-type-aliases)\nReusable Types (Type Aliases)\n--------------------------------------------------------------------------------------------------------------------------------------------\n\n_Documentation_\n\n> Anywhere a greeting is expected, you can provide a `string`, a function returning a `string`, or a `Greeter` instance.\n\n_Code_\n\nts\n\n`   function getGreeting() {    return \"howdy\";  }  class MyGreeter extends Greeter {}  greet(\"hello\");  greet(getGreeting);  greet(new MyGreeter());   `\n\n_Declaration_\n\nYou can use a type alias to make a shorthand for a type:\n\nts\n\n`   type GreetingLike = string | (() => string) | MyGreeter;  declare function greet(g: GreetingLike): void;   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#organizing-types)\nOrganizing Types\n--------------------------------------------------------------------------------------------------------------------\n\n_Documentation_\n\n> The `greeter` object can log to a file or display an alert. You can provide LogOptions to `.log(...)` and alert options to `.alert(...)`\n\n_Code_\n\nts\n\n`   const g = new Greeter(\"Hello\");  g.log({ verbose: true });  g.alert({ modal: false, title: \"Current Greeting\" });   `\n\n_Declaration_\n\nUse namespaces to organize types.\n\nts\n\n`   declare namespace GreetingLib {    interface LogOptions {      verbose?: boolean;    }    interface AlertOptions {      modal: boolean;      title?: string;      color?: string;    }  }   `\n\nYou can also create nested namespaces in one declaration:\n\nts\n\n`   declare namespace GreetingLib.Options {    // Refer to via GreetingLib.Options.Log    interface Log {      verbose?: boolean;    }    interface Alert {      modal: boolean;      title?: string;      color?: string;    }  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#classes)\nClasses\n--------------------------------------------------------------------------------------------------\n\n_Documentation_\n\n> You can create a greeter by instantiating the `Greeter` object, or create a customized greeter by extending from it.\n\n_Code_\n\nts\n\n`   const myGreeter = new Greeter(\"hello, world\");  myGreeter.greeting = \"howdy\";  myGreeter.showGreeting();  class SpecialGreeter extends Greeter {    constructor() {      super(\"Very special greetings\");    }  }   `\n\n_Declaration_\n\nUse `declare class` to describe a class or class-like object. Classes can have properties and methods as well as a constructor.\n\nts\n\n`   declare class Greeter {    constructor(greeting: string);    greeting: string;    showGreeting(): void;  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#global-variables)\nGlobal Variables\n--------------------------------------------------------------------------------------------------------------------\n\n_Documentation_\n\n> The global variable `foo` contains the number of widgets present.\n\n_Code_\n\nts\n\n`   console.log(\"Half the number of widgets is \" + foo / 2);   `\n\n_Declaration_\n\nUse `declare var` to declare variables. If the variable is read-only, you can use `declare const`. You can also use `declare let` if the variable is block-scoped.\n\nts\n\n`   /** The number of widgets present */  declare var foo: number;   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html#global-functions)\nGlobal Functions\n--------------------------------------------------------------------------------------------------------------------\n\n_Documentation_\n\n> You can call the function `greet` with a string to show a greeting to the user.\n\n_Code_\n\nts\n\n`   greet(\"hello, world\");   `\n\n_Declaration_\n\nUse `declare function` to declare functions.\n\nts\n\n`   declare function greet(greeting: string): void;   `\n\n[### Introduction\\\n\\\nHow to write a high-quality TypeScript Declaration (d.ts) file](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)\n\n[### Library Structures\\\n\\\nHow to structure your d.ts files](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/By%20Example.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (57)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nY![ydz-one  (1)](https://gravatar.com/avatar/a1cf7e5d7e4c2f73a2789d9d1d3fe001?s=32&&d=blank)\n\nPB![Pylyp Borysov  (1)](https://gravatar.com/avatar/a89473e7a895bc87515a5b3e9fbe207d?s=32&&d=blank)\n\nRK![Rafał Krupiński  (1)](https://gravatar.com/avatar/20c66d3b08e6e3d858973b2a1c66d9a8?s=32&&d=blank)\n\n7+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"How to create a d.ts file for a module","title":"TypeScript: Documentation - Declaration Reference","description":"How to create a d.ts file for a module","theme-color":"#3178C6","ogTitle":"Documentation - Declaration Reference","language":"en","twitter:site":"typescriptlang","generator":"Gatsby 5.13.5","og:title":"Documentation - Declaration Reference","og:description":"How to create a d.ts file for a module","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","scrapeId":"6f0036cb-8836-4236-a072-6f19925ef6cf","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nLibrary Structures\n==================\n\nBroadly speaking, the way you _structure_ your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you’ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.\n\nEach type of major library structuring pattern has a corresponding file in the [Templates](https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html)\n section. You can start with these templates to help you get going faster.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#identifying-kinds-of-libraries)\nIdentifying Kinds of Libraries\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\nFirst, we’ll review the kinds of libraries TypeScript declaration files can represent. We’ll briefly show how each kind of library is _used_, how it is _written_, and list some example libraries from the real world.\n\nIdentifying the structure of a library is the first step in writing its declaration file. We’ll give hints on how to identify structure both based on its _usage_ and its _code_. Depending on the library’s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#what-should-you-look-for)\nWhat should you look for?\n\nQuestion to ask yourself while looking at a library you are trying to type.\n\n1.  How do you obtain the library?\n    \n    For example, can you _only_ get it through npm or only from a CDN?\n    \n2.  How would you import it?\n    \n    Does it add a global object? Does it use `require` or `import`/`export` statements?\n    \n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#smaller-samples-for-different-types-of-libraries)\nSmaller samples for different types of libraries\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#modular-libraries)\nModular Libraries\n\nAlmost every modern Node.js library falls into the module family. These type of libraries only work in a JS environment with a module loader. For example, `express` only works in Node.js and must be loaded using the CommonJS `require` function.\n\nECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of _importing_ a _module_. In JavaScript CommonJS (Node.js), for example, you would write\n\njs\n\n`   var fs = require(\"fs\");   `\n\nIn TypeScript or ES6, the `import` keyword serves the same purpose:\n\nts\n\n`   import * as fs from \"fs\";   `\n\nYou’ll typically see modular libraries include one of these lines in their documentation:\n\njs\n\n`   var someLib = require(\"someLib\");   `\n\nor\n\njs\n\n`   define(..., ['someLib'], function(someLib) {  });   `\n\nAs with global modules, you might see these examples in the documentation of [a UMD](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#umd)\n module, so be sure to check the code or documentation.\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#identifying-a-module-library-from-code)\nIdentifying a Module Library from Code\n\nModular libraries will typically have at least some of the following:\n\n*   Unconditional calls to `require` or `define`\n*   Declarations like `import * as a from 'b';` or `export c;`\n*   Assignments to `exports` or `module.exports`\n\nThey will rarely have:\n\n*   Assignments to properties of `window` or `global`\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#templates-for-modules)\nTemplates For Modules\n\nThere are four templates available for modules, [`module.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html)\n, [`module-class.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html)\n, [`module-function.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html)\n and [`module-plugin.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)\n.\n\nYou should first read [`module.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html)\n for an overview on the way they all work.\n\nThen use the template [`module-function.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html)\n if your module can be _called_ like a function:\n\njs\n\n`   const x = require(\"foo\");  // Note: calling 'x' as a function  const y = x(42);   `\n\nUse the template [`module-class.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html)\n if your module can be _constructed_ using `new`:\n\njs\n\n`   const x = require(\"bar\");  // Note: using 'new' operator on the imported variable  const y = new x(\"hello\");   `\n\nIf you have a module which when imported, makes changes to other modules use template [`module-plugin.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)\n:\n\njs\n\n`   const jest = require(\"jest\");  require(\"jest-matchers-files\");   `\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#global-libraries)\nGlobal Libraries\n\nA _global_ library is one that can be accessed from the global scope (i.e. without using any form of `import`). Many libraries simply expose one or more global variables for use. For example, if you were using [jQuery](https://jquery.com/)\n, the `$` variable can be used by simply referring to it:\n\nts\n\n`   $(() => {    console.log(\"hello!\");  });   `\n\nYou’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:\n\nhtml\n\n`   <script src=\"http://a.great.cdn.for/someLib.js\"></script>   `\n\nToday, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#identifying-a-global-library-from-code)\nIdentifying a Global Library from Code\n\nGlobal library code is usually extremely simple. A global “Hello, world” library might look like this:\n\njs\n\n`   function createGreeting(s) {    return \"Hello, \" + s;  }   `\n\nor like this:\n\njs\n\n`   // Web  window.createGreeting = function (s) {    return \"Hello, \" + s;  };  // Node  global.createGreeting = function (s) {    return \"Hello, \" + s;  };  // Potentially any runtime  globalThis.createGreeting = function (s) {    return \"Hello, \" + s;  };   `\n\nWhen looking at the code of a global library, you’ll usually see:\n\n*   Top-level `var` statements or `function` declarations\n*   One or more assignments to `window.someName`\n*   Assumptions that DOM primitives like `document` or `window` exist\n\nYou _won’t_ see:\n\n*   Checks for, or usage of, module loaders like `require` or `define`\n*   CommonJS/Node.js-style imports of the form `var fs = require(\"fs\");`\n*   Calls to `define(...)`\n*   Documentation describing how to `require` or import the library\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#examples-of-global-libraries)\nExamples of Global Libraries\n\nBecause it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have _no_ dependencies) may still be global.\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#global-library-template)\nGlobal Library Template\n\nThe template file [`global.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html)\n defines an example library `myLib`. Be sure to read the [“Preventing Name Conflicts” footnote](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#preventing-name-conflicts)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#umd)\n_UMD_\n\nA _UMD_ module is one that can _either_ be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as [Moment.js](https://momentjs.com/)\n, are written this way. For example, in Node.js or using RequireJS, you would write:\n\nts\n\n`   import moment = require(\"moment\");  console.log(moment.format());   `\n\nwhereas in a vanilla browser environment you would write:\n\njs\n\n`   console.log(moment.format());   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#identifying-a-umd-library)\nIdentifying a UMD library\n\n[UMD modules](https://github.com/umdjs/umd)\n check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:\n\njs\n\n`   (function (root, factory) {      if (typeof define === \"function\" && define.amd) {          define([\"libName\"], factory);      } else if (typeof module === \"object\" && module.exports) {          module.exports = factory(require(\"libName\"));      } else {          root.returnExports = factory(root.libName);      }  }(this, function (b) {   `\n\nIf you see tests for `typeof define`, `typeof window`, or `typeof module` in the code of a library, especially at the top of the file, it’s almost always a UMD library.\n\nDocumentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing `require`, and a “Using in the browser” example showing using a `<script>` tag to load the script.\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#examples-of-umd-libraries)\nExamples of UMD libraries\n\nMost popular libraries are now available as UMD packages. Examples include [jQuery](https://jquery.com/)\n, [Moment.js](https://momentjs.com/)\n, [lodash](https://lodash.com/)\n, and many more.\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#template)\nTemplate\n\nUse the [`module-plugin.d.ts`](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)\n template.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#consuming-dependencies)\nConsuming Dependencies\n----------------------------------------------------------------------------------------------------------------------------------------\n\nThere are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#dependencies-on-global-libraries)\nDependencies on Global Libraries\n\nIf your library depends on a global library, use a `/// <reference types=\"...\" />` directive:\n\nts\n\n`   /// <reference types=\"someLib\" />  function getThing(): someLib.thing;   `\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#dependencies-on-modules)\nDependencies on Modules\n\nIf your library depends on a module, use an `import` statement:\n\nts\n\n`   import * as moment from \"moment\";  function getThing(): moment;   `\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#dependencies-on-umd-libraries)\nDependencies on UMD libraries\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#from-a-global-library)\nFrom a Global Library\n\nIf your global library depends on a UMD module, use a `/// <reference types` directive:\n\nts\n\n`   /// <reference types=\"moment\" />  function getThing(): moment;   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#from-a-module-or-umd-library)\nFrom a Module or UMD Library\n\nIf your module or UMD library depends on a UMD library, use an `import` statement:\n\nts\n\n`   import * as someLib from \"someLib\";   `\n\nDo _not_ use a `/// <reference` directive to declare a dependency to a UMD library!\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#footnotes)\nFootnotes\n--------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#preventing-name-conflicts)\nPreventing Name Conflicts\n\nNote that it’s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to only declare types _namespaced_ by whatever global variable the library defines. For example, if the library defines the global value ‘cats’, you should write\n\nts\n\n`   declare namespace cats {    interface KittySettings {}  }   `\n\nBut _not_\n\nts\n\n`   // at top-level  interface CatsKittySettings {}   `\n\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#the-impact-of-es6-on-module-call-signatures)\nThe Impact of ES6 on Module Call Signatures\n\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\nts\n\n`   import exp = require(\"express\");  var app = exp();   `\n\nIn ES6-compliant module loaders, the top-level object (here imported as `exp`) can only have properties; the top-level module object can _never_ be callable.\n\nThe most common solution here is to define a `default` export for a callable/constructable object; module loaders commonly detect this situation automatically and replace the top-level object with the `default` export. TypeScript can handle this for you, if you have [`\"esModuleInterop\": true`](https://www.typescriptlang.org/tsconfig/#esModuleInterop)\n in your tsconfig.json.\n\n[### Declaration Reference\\\n\\\nHow to create a d.ts file for a module](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)\n\n[### Modules .d.ts](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/Library%20Structures.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (57)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (17)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nDR![Daniel Rose  (3)](https://gravatar.com/avatar/a818e7f65a790fe4ba3da95110749a30?s=32&&d=blank)\n\nL![lilichao  (1)](https://gravatar.com/avatar/9ec5806b890ecce5cbaa233b6fe1c74b59567687eed7b398bc90c348d73b82f4?s=32&&d=blank)\n\nMF![Martin Fischer  (1)](https://gravatar.com/avatar/dc885100e48a5949f1a44bcd6fce398735ff3294f20607ddee8bb45acb29601a?s=32&&d=blank)\n\n12+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - Library Structures","og:description":"How to structure your d.ts files","language":"en","twitter:site":"typescriptlang","ogTitle":"Documentation - Library Structures","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","ogDescription":"How to structure your d.ts files","description":"How to structure your d.ts files","og:title":"Documentation - Library Structures","scrapeId":"fb02fd49-e403-4e35-b5e9-35f1d99c145d","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModules .d.ts\n=============\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#comparing-javascript-to-an-example-dts)\nComparing JavaScript to an example DTS\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#common-commonjs-patterns)\nCommon CommonJS Patterns\n-----------------------------------------------------------------------------------------------------------------------------------------------\n\nA module using CommonJS patterns uses `module.exports` to describe the exported values. For example, here is a module which exports a function and a numerical constant:\n\njs\n\n`   const maxInterval = 12;  function getArrayLength(arr) {    return arr.length;  }  module.exports = {    getArrayLength,    maxInterval,  };   `\n\nThis can be described by the following `.d.ts`:\n\nts\n\n`   export function getArrayLength(arr: any[]): number;  export const maxInterval: 12;   `\n\nThe TypeScript playground can show you the `.d.ts` equivalent for JavaScript code. You can [try it yourself here](https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA)\n.\n\nThe `.d.ts` syntax intentionally looks like [ES Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)\n syntax. ES Modules was ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:\n\njs\n\n`   export function getArrayLength(arr) {    return arr.length;  }   `\n\nThis would have the following `.d.ts` equivalent:\n\nts\n\n`   export function getArrayLength(arr: any[]): number;   `\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#default-exports)\nDefault Exports\n\nIn CommonJS you can export any value as the default export, for example here is a regular expression module:\n\njs\n\n`   module.exports = /hello( world)?/;   `\n\nWhich can be described by the following .d.ts:\n\nts\n\n`   declare const helloWorld: RegExp;  export = helloWorld;   `\n\nOr a number:\n\njs\n\n`   module.exports = 3.142;   `\n\nts\n\n`   declare const pi: number;  export = pi;   `\n\nOne style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added and are included in the export.\n\njs\n\n`   function getArrayLength(arr) {    return arr.length;  }  getArrayLength.maxInterval = 12;  module.exports = getArrayLength;   `\n\nWhich can be described with:\n\nts\n\n`   declare function getArrayLength(arr: any[]): number;  declare namespace getArrayLength {    declare const maxInterval: 12;  }  export = getArrayLength;   `\n\nSee [Module: Functions](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html)\n for details of how that works, and the [Modules reference](https://www.typescriptlang.org/docs/handbook/modules.html)\n page.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#handling-many-consuming-import)\nHandling Many Consuming Import\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThere are many ways to import a module in modern consuming code:\n\nts\n\n`   const fastify = require(\"fastify\");  const { fastify } = require(\"fastify\");  import fastify = require(\"fastify\");  import * as Fastify from \"fastify\";  import { fastify, FastifyInstance } from \"fastify\";  import fastify from \"fastify\";  import fastify, { FastifyInstance } from \"fastify\";   `\n\nCovering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:\n\njs\n\n`   class FastifyInstance {}  function fastify() {    return new FastifyInstance();  }  fastify.FastifyInstance = FastifyInstance;  // Allows for { fastify }  fastify.fastify = fastify;  // Allows for strict ES Module support  fastify.default = fastify;  // Sets the default export  module.exports = fastify;   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#types-in-modules)\nTypes in Modules\n-------------------------------------------------------------------------------------------------------------------------------\n\nYou may want to provide a type for JavaScript code which does not exist\n\njs\n\n`   function getArrayMetadata(arr) {    return {      length: getArrayLength(arr),      firstObject: arr[0],    };  }  module.exports = {    getArrayMetadata,  };   `\n\nThis can be described with:\n\nts\n\n`   export type ArrayMetadata = {    length: number;    firstObject: any | undefined;  };  export function getArrayMetadata(arr: any[]): ArrayMetadata;   `\n\nThis example is a good case for [using generics](https://www.typescriptlang.org/docs/handbook/generics.html#generic-types)\n to provide richer type information:\n\nts\n\n`   export type ArrayMetadata<ArrType> = {    length: number;    firstObject: ArrType | undefined;  };  export function getArrayMetadata<ArrType>(    arr: ArrType[]  ): ArrayMetadata<ArrType>;   `\n\nNow the type of the array propagates into the `ArrayMetadata` type.\n\nThe types which are exported can then be re-used by consumers of the modules using either `import` or `import type` in TypeScript code or [JSDoc imports](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#namespaces-in-module-code)\nNamespaces in Module Code\n\nTrying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn’t provide enough tools to describe the exports then you can use `namespaces`.\n\nFor example, you may have complex enough types to describe that you choose to namespace them inside your `.d.ts`:\n\nts\n\n`   // This represents the JavaScript class which would be available at runtime  export class API {    constructor(baseURL: string);    getInfo(opts: API.InfoRequest): API.InfoResponse;  }  // This namespace is merged with the API class and allows for consumers, and this file  // to have types which are nested away in their own sections.  declare namespace API {    export interface InfoRequest {      id: string;    }    export interface InfoResponse {      width: number;      height: number;    }  }   `\n\nTo understand how namespaces work in `.d.ts` files read the [`.d.ts` deep dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#optional-global-usage)\nOptional Global Usage\n\nYou can use `export as namespace` to declare that your module will be available in the global scope in UMD contexts:\n\nts\n\n`   export as namespace moduleName;   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#reference-example)\nReference Example\n---------------------------------------------------------------------------------------------------------------------------------\n\nTo give you an idea of how all these pieces can come together, here is a reference `.d.ts` to start with when making a new module\n\nts\n\n`   // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]  // Project: [~THE PROJECT NAME~]  // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>  /*~ This is the module template file. You should rename it to index.d.ts   *~ and place it in a folder with the same name as the module.   *~ For example, if you were writing a file for \"super-greeter\", this   *~ file should be 'super-greeter/index.d.ts'   */  /*~ If this module is a UMD module that exposes a global variable 'myLib' when   *~ loaded outside a module loader environment, declare that global here.   *~ Otherwise, delete this declaration.   */  export as namespace myLib;  /*~ If this module exports functions, declare them like so.   */  export function myFunction(a: string): string;  export function myOtherFunction(a: number): number;  /*~ You can declare types that are available via importing the module */  export interface SomeType {    name: string;    length: number;    extras?: string[];  }  /*~ You can declare properties of the module using const, let, or var */  export const myField: number;   `\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#library-file-layout)\nLibrary file layout\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\n`   myLib    +---- index.js    +---- foo.js    +---- bar           +---- index.js           +---- baz.js   `\n\nThese could be imported as\n\njs\n\n`   var a = require(\"myLib\");  var b = require(\"myLib/foo\");  var c = require(\"myLib/bar\");  var d = require(\"myLib/bar/baz\");   `\n\nYour declaration files should thus be\n\n`   @types/myLib    +---- index.d.ts    +---- foo.d.ts    +---- bar           +---- index.d.ts           +---- baz.d.ts   `\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html#testing-your-types)\nTesting your types\n\nIf you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:\n\n> 1.  Create a new folder in `node_modules/@types/[libname]`\n> 2.  Create an `index.d.ts` in that folder, and copy the example in\n> 3.  See where your usage of the module breaks, and start to fill out the index.d.ts\n> 4.  When you’re happy, clone [DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped)\n>      and follow the instructions in the README.\n\nOtherwise\n\n> 1.  Create a new file in the root of your source tree: `[libname].d.ts`\n> 2.  Add `declare module \"[libname]\" { }`\n> 3.  Add the template inside the braces of the declare module, and see where your usage breaks\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/templates/module.d.ts.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nDS![David Sherret  (1)](https://gravatar.com/avatar/4fb9dbb35453509bfa126e2de592496ffc877368a87dc36a53fc3293770668ec?s=32&&d=blank)\n\nMF![Mike Frysinger  (1)](https://gravatar.com/avatar/8f30bd18f67e98bcba7de1d4148282ae26d4bb8779507d5b2e5760ff49eccf30?s=32&&d=blank)\n\nH![hzrong  (1)](https://gravatar.com/avatar/511f7a8cbf37b9ebc628183ece418568306d7fd2c21676763a79733667fbd156?s=32&&d=blank)\n\n5+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","theme-color":"#3178C6","og:description":"","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","title":"TypeScript: Documentation - Modules .d.ts","ogTitle":"Documentation - Modules .d.ts","ogDescription":"","og:title":"Documentation - Modules .d.ts","description":"","twitter:site":"typescriptlang","scrapeId":"248600d8-8069-4ee1-b502-ef3d82a988e5","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nGlobal .d.ts\n============\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html#global-libraries)\nGlobal Libraries\n-------------------------------------------------------------------------------------------------------------------------------\n\nA _global_ library is one that can be accessed from the global scope (i.e. without using any form of `import`). Many libraries simply expose one or more global variables for use. For example, if you were using [jQuery](https://jquery.com/)\n, the `$` variable can be used by simply referring to it:\n\nts\n\n`   $(() => {    console.log(\"hello!\");  });   `\n\nYou’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:\n\nhtml\n\n`   <script src=\"http://a.great.cdn.for/someLib.js\"></script>   `\n\nToday, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html#identifying-a-global-library-from-code)\nIdentifying a Global Library from Code\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nGlobal library code is usually extremely simple. A global “Hello, world” library might look like this:\n\njs\n\n`   function createGreeting(s) {    return \"Hello, \" + s;  }   `\n\nor like this:\n\njs\n\n`   window.createGreeting = function (s) {    return \"Hello, \" + s;  };   `\n\nWhen looking at the code of a global library, you’ll usually see:\n\n*   Top-level `var` statements or `function` declarations\n*   One or more assignments to `window.someName`\n*   Assumptions that DOM primitives like `document` or `window` exist\n\nYou _won’t_ see:\n\n*   Checks for, or usage of, module loaders like `require` or `define`\n*   CommonJS/Node.js-style imports of the form `var fs = require(\"fs\");`\n*   Calls to `define(...)`\n*   Documentation describing how to `require` or import the library\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html#examples-of-global-libraries)\nExamples of Global Libraries\n-------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBecause it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have _no_ dependencies) may still be global.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html#global-library-template)\nGlobal Library Template\n---------------------------------------------------------------------------------------------------------------------------------------------\n\nYou can see an example DTS below:\n\nts\n\n`   // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]  // Project: [~THE PROJECT NAME~]  // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>  /*~ If this library is callable (e.g. can be invoked as myLib(3)),   *~ include those call signatures here.   *~ Otherwise, delete this section.   */  declare function myLib(a: string): string;  declare function myLib(a: number): number;  /*~ If you want the name of this library to be a valid type name,   *~ you can do so here.   *~   *~ For example, this allows us to write 'var x: myLib';   *~ Be sure this actually makes sense! If it doesn't, just   *~ delete this declaration and add types inside the namespace below.   */  interface myLib {    name: string;    length: number;    extras?: string[];  }  /*~ If your library has properties exposed on a global variable,   *~ place them here.   *~ You should also place types (interfaces and type alias) here.   */  declare namespace myLib {    //~ We can write 'myLib.timeout = 50;'    let timeout: number;    //~ We can access 'myLib.version', but not change it    const version: string;    //~ There's some class we can create via 'let c = new myLib.Cat(42)'    //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }    class Cat {      constructor(n: number);      //~ We can read 'c.age' from a 'Cat' instance      readonly age: number;      //~ We can invoke 'c.purr()' from a 'Cat' instance      purr(): void;    }    //~ We can declare a variable as    //~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'    interface CatSettings {      weight: number;      name: string;      tailLength?: number;    }    //~ We can write 'const v: myLib.VetID = 42;'    //~  or 'const v: myLib.VetID = \"bob\";'    type VetID = string | number;    //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'    function checkCat(c: Cat, s?: VetID);  }   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/templates/global.d.ts.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\n1+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - Global .d.ts","language":"en","generator":"Gatsby 5.13.5","theme-color":"#3178C6","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","description":"","og:title":"Documentation - Global .d.ts","og:description":"","ogDescription":"","ogTitle":"Documentation - Global .d.ts","twitter:site":"typescriptlang","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","scrapeId":"1f3b575c-60a4-4fb5-b5c0-8a4287d20cb1","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModule: Function\n================\n\nFor example, when you want to work with JavaScript code which looks like:\n\nts\n\n`   import greeter from \"super-greeter\";  greeter(2);  greeter(\"Hello world\");   `\n\nTo handle both importing via UMD and modules:\n\nts\n\n`   // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]  // Project: [~THE PROJECT NAME~]  // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>  /*~ This is the module template file for function modules.   *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.   *~ For example, if you were writing a file for \"super-greeter\", this   *~ file should be 'super-greeter/index.d.ts'   */  // Note that ES6 modules cannot directly export class objects.  // This file should be imported using the CommonJS-style:  //   import x = require('[~THE MODULE~]');  //  // Alternatively, if --allowSyntheticDefaultImports or  // --esModuleInterop is turned on, this file can also be  // imported as a default import:  //   import x from '[~THE MODULE~]';  //  // Refer to the TypeScript documentation at  // https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require  // to understand common workarounds for this limitation of ES6 modules.  /*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when   *~ loaded outside a module loader environment, declare that global here.   *~ Otherwise, delete this declaration.   */  export as namespace myFuncLib;  /*~ This declaration specifies that the function   *~ is the exported object from the file   */  export = Greeter;  /*~ This example shows how to have multiple overloads for your function */  declare function Greeter(name: string): Greeter.NamedReturnType;  declare function Greeter(length: number): Greeter.LengthReturnType;  /*~ If you want to expose types from your module as well, you can   *~ place them in this block. Often you will want to describe the   *~ shape of the return type of the function; that type should   *~ be declared in here, as this example shows.   *~   *~ Note that if you decide to include this namespace, the module can be   *~ incorrectly imported as a namespace object, unless   *~ --esModuleInterop is turned on:   *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!   */  declare namespace Greeter {    export interface LengthReturnType {      width: number;      height: number;    }    export interface NamedReturnType {      firstName: string;      lastName: string;    }    /*~ If the module also has properties, declare them here. For example,     *~ this declaration says that this code is legal:     *~   import f = require('super-greeter');     *~   console.log(f.defaultName);     */    export const defaultName: string;    export let defaultLength: number;  }   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/templates/module-function.d.ts.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nDR![Daniel Rose  (1)](https://gravatar.com/avatar/a818e7f65a790fe4ba3da95110749a30?s=32&&d=blank)\n\n2+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - Module: Function","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","og:title":"Documentation - Module: Function","og:description":"","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","generator":"Gatsby 5.13.5","ogTitle":"Documentation - Module: Function","ogDescription":"","description":"","theme-color":"#3178C6","scrapeId":"f1680391-e677-4c7f-9e57-da053a4c51ca","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nGlobal: Modifying Module\n========================\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html#global-modifying-modules)\n_Global-modifying Modules_\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nA _global-modifying module_ alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to `String.prototype` when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html#identifying-global-modifying-modules)\nIdentifying global-modifying modules\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nGlobal-modifying modules are generally easy to identify from their documentation. In general, they’re similar to global plugins, but need a `require` call to activate their effects.\n\nYou might see documentation like this:\n\njs\n\n`   // 'require' call that doesn't use its return value  var unused = require(\"magic-string-time\");  /* or */  require(\"magic-string-time\");  var x = \"hello, world\";  // Creates new methods on built-in types  console.log(x.startsWithHello());  var y = [1, 2, 3];  // Creates new methods on built-in types  console.log(y.reverseAndSort());   `\n\nHere is an example\n\nts\n\n`   // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]  // Project: [~THE PROJECT NAME~]  // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>  /*~ This is the global-modifying module template file. You should rename it to index.d.ts   *~ and place it in a folder with the same name as the module.   *~ For example, if you were writing a file for \"super-greeter\", this   *~ file should be 'super-greeter/index.d.ts'   */  /*~ Note: If your global-modifying module is callable or constructable, you'll   *~ need to combine the patterns here with those in the module-class or module-function   *~ template files   */  declare global {    /*~ Here, declare things that go in the global namespace, or augment     *~ existing declarations in the global namespace     */    interface String {      fancyFormat(opts: StringFormatOptions): string;    }  }  /*~ If your module exports types or values, write them as usual */  export interface StringFormatOptions {    fancinessLevel: number;  }  /*~ For example, declaring a method on the module (in addition to its global side effects) */  export function doSomething(): void;  /*~ If your module exports nothing, you'll need this line. Otherwise, delete it */  export {};   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/templates/global-modifying-module.d.ts.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\n1+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogTitle":"Documentation - Global: Modifying Module","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","title":"TypeScript: Documentation - Global: Modifying Module","generator":"Gatsby 5.13.5","theme-color":"#3178C6","description":"","og:description":"","twitter:site":"typescriptlang","og:title":"Documentation - Global: Modifying Module","ogDescription":"","scrapeId":"7bc4bd44-6d09-4fe7-9837-d8ec0db90d84","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nModule: Class\n=============\n\nFor example, when you want to work with JavaScript code which looks like:\n\nts\n\n`   const Greeter = require(\"super-greeter\");  const greeter = new Greeter();  greeter.greet();   `\n\nTo handle both importing via UMD and modules:\n\nts\n\n`   // Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]  // Project: [~THE PROJECT NAME~]  // Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>  /*~ This is the module template file for class modules.   *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.   *~ For example, if you were writing a file for \"super-greeter\", this   *~ file should be 'super-greeter/index.d.ts'   */  // Note that ES6 modules cannot directly export class objects.  // This file should be imported using the CommonJS-style:  //   import x = require('[~THE MODULE~]');  //  // Alternatively, if --allowSyntheticDefaultImports or  // --esModuleInterop is turned on, this file can also be  // imported as a default import:  //   import x from '[~THE MODULE~]';  //  // Refer to the TypeScript documentation at  // https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require  // to understand common workarounds for this limitation of ES6 modules.  /*~ If this module is a UMD module that exposes a global variable 'myClassLib' when   *~ loaded outside a module loader environment, declare that global here.   *~ Otherwise, delete this declaration.   */  export as namespace myClassLib;  /*~ This declaration specifies that the class constructor function   *~ is the exported object from the file   */  export = Greeter;  /*~ Write your module's methods and properties in this class */  declare class Greeter {    constructor(customGreeting?: string);    greet: void;    myMethod(opts: MyClass.MyClassMethodOptions): number;  }  /*~ If you want to expose types from your module as well, you can   *~ place them in this block.   *~   *~ Note that if you decide to include this namespace, the module can be   *~ incorrectly imported as a namespace object, unless   *~ --esModuleInterop is turned on:   *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!   */  declare namespace MyClass {    export interface MyClassMethodOptions {      width?: number;      height?: number;    }  }   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/templates/module-class.d.ts.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (16)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nW![Waua  (1)](https://gravatar.com/avatar/4f0071ce89cd4cc768dfdd555c9d45c6afcb5dae1002b18073cc021e1ad78ec4?s=32&&d=blank)\n\nAC![Alper Cugun  (1)](https://gravatar.com/avatar/8b2cb77caf52e16805b5c06be7415835cfd7bba5c68fa6ab2ace789345f0ba3e?s=32&&d=blank)\n\nDR![Daniel Rose  (1)](https://gravatar.com/avatar/a818e7f65a790fe4ba3da95110749a30?s=32&&d=blank)\n\n2+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:description":"","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","twitter:site":"typescriptlang","ogTitle":"Documentation - Module: Class","ogDescription":"","title":"TypeScript: Documentation - Module: Class","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","generator":"Gatsby 5.13.5","description":"","og:title":"Documentation - Module: Class","language":"en","scrapeId":"6464a73c-bf71-4287-bc3b-df27a04cd4e7","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nDeep Dive\n=========\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#declaration-file-theory-a-deep-dive)\nDeclaration File Theory: A Deep Dive\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nStructuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without `new` to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.\n\nBy reading this guide, you’ll have the tools to write complex declaration files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#key-concepts)\nKey Concepts\n-----------------------------------------------------------------------------------------------------------\n\nYou can fully understand how to make any shape of declaration by understanding some key concepts of how TypeScript works.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#types)\nTypes\n\nIf you’re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a _type_ is introduced with:\n\n*   A type alias declaration (`type sn = number | string;`)\n*   An interface declaration (`interface I { x: number[]; }`)\n*   A class declaration (`class C { }`)\n*   An enum declaration (`enum E { A, B, C }`)\n*   An `import` declaration which refers to a type\n\nEach of these declaration forms creates a new type name.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#values)\nValues\n\nAs with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example `let x = 5;` creates a value called `x`.\n\nAgain, being explicit, the following things create values:\n\n*   `let`, `const`, and `var` declarations\n*   A `namespace` or `module` declaration which contains a value\n*   An `enum` declaration\n*   A `class` declaration\n*   An `import` declaration which refers to a value\n*   A `function` declaration\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#namespaces)\nNamespaces\n\nTypes can exist in _namespaces_. For example, if we have the declaration `let x: A.B.C`, we say that the type `C` comes from the `A.B` namespace.\n\nThis distinction is subtle and important — here, `A.B` is not necessarily a type or a value.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#simple-combinations-one-name-multiple-meanings)\nSimple Combinations: One name, multiple meanings\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nGiven a name `A`, we might find up to three different meanings for `A`: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration `let m: A.A = A;`, `A` is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!\n\nThis may seem confusing, but it’s actually very convenient as long as we don’t excessively overload things. Let’s look at some useful aspects of this combining behavior.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#built-in-combinations)\nBuilt-in Combinations\n\nAstute readers will notice that, for example, `class` appeared in both the _type_ and _value_ lists. The declaration `class C { }` creates two things: a _type_ `C` which refers to the instance shape of the class, and a _value_ `C` which refers to the constructor function of the class. Enum declarations behave similarly.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#user-combinations)\nUser Combinations\n\nLet’s say we wrote a module file `foo.d.ts`:\n\nts\n\n`   export var SomeVar: { a: SomeType };  export interface SomeType {    count: number;  }   `\n\nThen consumed it:\n\nts\n\n`   import * as foo from \"./foo\";  let x: foo.SomeType = foo.SomeVar.a;  console.log(x.count);   `\n\nThis works well enough, but we might imagine that `SomeType` and `SomeVar` were very closely related such that you’d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name `Bar`:\n\nts\n\n`   export var Bar: { a: Bar };  export interface Bar {    count: number;  }   `\n\nThis presents a very good opportunity for destructuring in the consuming code:\n\nts\n\n`   import { Bar } from \"./foo\";  let x: Bar = Bar.a;  console.log(x.count);   `\n\nAgain, we’ve used `Bar` as both a type and a value here. Note that we didn’t have to declare the `Bar` value as being of the `Bar` type — they’re independent.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#advanced-combinations)\nAdvanced Combinations\n-----------------------------------------------------------------------------------------------------------------------------\n\nSome kinds of declarations can be combined across multiple declarations. For example, `class C { }` and `interface C { }` can co-exist and both contribute properties to the `C` types.\n\nThis is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as `namespace`s, types will conflict if they are declared with a type alias declaration (`type s = string`), and namespaces never conflict.\n\nLet’s see how this can be used.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#adding-using-an-interface)\nAdding using an `interface`\n\nWe can add additional members to an `interface` with another `interface` declaration:\n\nts\n\n`   interface Foo {    x: number;  }  // ... elsewhere ...  interface Foo {    y: number;  }  let a: Foo = ...;  console.log(a.x + a.y); // OK   `\n\nThis also works with classes:\n\nts\n\n`   class Foo {    x: number;  }  // ... elsewhere ...  interface Foo {    y: number;  }  let a: Foo = ...;  console.log(a.x + a.y); // OK   `\n\nNote that we cannot add to type aliases (`type s = string;`) using an interface.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html#adding-using-a-namespace)\nAdding using a `namespace`\n\nA `namespace` declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.\n\nFor example, we can add a static member to a class:\n\nts\n\n`   class C {}  // ... elsewhere ...  namespace C {    export let x: number;  }  let y = C.x; // OK   `\n\nNote that in this example, we added a value to the _static_ side of `C` (its constructor function). This is because we added a _value_, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).\n\nWe could also add a namespaced type to a class:\n\nts\n\n`   class C {}  // ... elsewhere ...  namespace C {    export interface D {}  }  let y: C.D; // OK   `\n\nIn this example, there wasn’t a namespace `C` until we wrote the `namespace` declaration for it. The meaning `C` as a namespace doesn’t conflict with the value or type meanings of `C` created by the class.\n\nFinally, we could perform many different merges using `namespace` declarations. This isn’t a particularly realistic example, but shows all sorts of interesting behavior:\n\nts\n\n`   namespace X {    export interface Y {}    export class Z {}  }  // ... elsewhere ...  namespace X {    export var Y: number;    export namespace Z {      export class C {}    }  }  type X = string;   `\n\nIn this example, the first block creates the following name meanings:\n\n*   A value `X` (because the `namespace` declaration contains a value, `Z`)\n*   A namespace `X` (because the `namespace` declaration contains a type, `Y`)\n*   A type `Y` in the `X` namespace\n*   A type `Z` in the `X` namespace (the instance shape of the class)\n*   A value `Z` that is a property of the `X` value (the constructor function of the class)\n\nThe second block creates the following name meanings:\n\n*   A value `Y` (of type `number`) that is a property of the `X` value\n*   A namespace `Z`\n*   A value `Z` that is a property of the `X` value\n*   A type `C` in the `X.Z` namespace\n*   A value `C` that is a property of the `X.Z` value\n*   A type `X`\n\n[### Do's and Don'ts\\\n\\\nRecommendations for writing d.ts files](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)\n\n[### Publishing\\\n\\\nHow to get your d.ts files to users](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/Deep%20Dive.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (54)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (12)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\n1+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","theme-color":"#3178C6","og:description":"How do d.ts files work, a deep dive","ogDescription":"How do d.ts files work, a deep dive","generator":"Gatsby 5.13.5","title":"TypeScript: Documentation - Deep Dive","og:title":"Documentation - Deep Dive","description":"How do d.ts files work, a deep dive","twitter:site":"typescriptlang","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogTitle":"Documentation - Deep Dive","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","scrapeId":"7f8ec8b1-fc8e-4886-8785-4820c677c08d","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nASP.NET Core\n============\n\n[](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#install-aspnet-core-and-typescript)\nInstall ASP.NET Core and TypeScript\n-----------------------------------------------------------------------------------------------------------------------------------------\n\nFirst, install [ASP.NET Core](https://dotnet.microsoft.com/apps/aspnet)\n if you need it. This quick-start guide requires Visual Studio 2015 or 2017.\n\nNext, if your version of Visual Studio does not already have the latest TypeScript, you can [install it](https://www.typescriptlang.org/index.html#download-links)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#create-a-new-project)\nCreate a new project\n------------------------------------------------------------------------------------------------------------\n\n1.  Choose **File**\n2.  Choose **New Project** (Ctrl + Shift + N)\n3.  Search for **.NET Core** in the project search bar\n4.  Select **ASP.NET Core Web Application** and press the _Next_ button\n\n![Visual Studio Project Window Screenshot](https://www.typescriptlang.org/images/tutorials/aspnet/createwebapp.png)\n\n5.  Name your project and solution. After select the _Create_ button\n\n![Visual Studio New Project Window Screenshot](https://www.typescriptlang.org/images/tutorials/aspnet/namewebapp.png)\n\n6.  In the last window, select the **Empty** template and press the _Create_ button\n\n![Visual Studio Web Application Screenshot](https://www.typescriptlang.org/images/tutorials/aspnet/emptytemplate.png)\n\nRun the application and make sure that it works.\n\n![A screenshot of Edge showing \"Hello World\" as success](https://www.typescriptlang.org/images/tutorials/aspnet/workingsite.png)\n\n### [](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#set-up-the-server)\nSet up the server\n\nOpen **Dependencies > Manage NuGet Packages > Browse.** Search and install `Microsoft.AspNetCore.StaticFiles` and `Microsoft.TypeScript.MSBuild`:\n\n![The Visual Studio search for Nuget](https://www.typescriptlang.org/images/tutorials/aspnet/downloaddependency.png)\n\nOpen up your `Startup.cs` file and edit your `Configure` function to look like this:\n\n`public void Configure(IApplicationBuilder app, IHostEnvironment env) {     if (env.IsDevelopment())     {         app.UseDeveloperExceptionPage();     }      app.UseDefaultFiles();     app.UseStaticFiles(); }`\n\nYou may need to restart VS for the red squiggly lines below `UseDefaultFiles` and `UseStaticFiles` to disappear.\n\n[](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#add-typescript)\nAdd TypeScript\n------------------------------------------------------------------------------------------------\n\nNext we will add a new folder and call it `scripts`.\n\n![The Path of \"Add\" then \"New Folder\" in Visual Studio from a Web Project](https://www.typescriptlang.org/images/tutorials/aspnet/newfolder.png)\n\n![](https://www.typescriptlang.org/images/tutorials/aspnet/scripts.png)\n\n[](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#add-typescript-code)\nAdd TypeScript code\n----------------------------------------------------------------------------------------------------------\n\nRight click on `scripts` and click **New Item**. Then choose **TypeScript File** and name the file `app.ts`\n\n![A highlight of the new folder](https://www.typescriptlang.org/images/tutorials/aspnet/tsfile.png)\n\n### [](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#add-example-code)\nAdd example code\n\nAdd the following code to the `app.ts` file.\n\nts\n\n``   function sayHello() {    const compiler = (document.getElementById(\"compiler\") as HTMLInputElement)      .value;    const framework = (document.getElementById(\"framework\") as HTMLInputElement)      .value;    return `Hello from ${compiler} and ${framework}!`;  }   ``\n\n[](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#set-up-the-build)\nSet up the build\n----------------------------------------------------------------------------------------------------\n\n_Configure the TypeScript compiler_\n\nFirst we need to tell TypeScript how to build. Right click on `scripts` and click **New Item**. Then choose **TypeScript Configuration File** and use the default name of `tsconfig.json`\n\n![A screenshot showing the new file dialogue with TypeScript JSON Config selected](https://www.typescriptlang.org/images/tutorials/aspnet/tsconfig.png)\n\nReplace the contents of the `tsconfig.json` file with:\n\n`   {    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[noEmitOnError](https://www.typescriptlang.org/tsconfig#noEmitOnError) \": true,      \"[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny) \": true,      \"[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap) \": true,      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"es6\"    },    \"[files](https://www.typescriptlang.org/tsconfig#files) \": [\"./app.ts\"],    \"compileOnSave\": true  }   `\n\n*   [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)\n     : Do not emit outputs if any errors were reported.\n*   [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n     : Raise error on expressions and declarations with an implied `any` type.\n*   [`sourceMap`](https://www.typescriptlang.org/tsconfig#sourceMap)\n     : Generates corresponding `.map` file.\n*   [`target`](https://www.typescriptlang.org/tsconfig#target)\n     : Specify ECMAScript target version.\n\nNote: `\"ESNext\"` targets latest supported\n\n[`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n is good idea whenever you’re writing new code — you can make sure that you don’t write any untyped code by mistake. `\"compileOnSave\"` makes it easy to update your code in a running web app.\n\n#### [](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#set-up-npm)\n_Set up NPM_\n\nWe need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select **New Item**. Then choose **NPM Configuration File** and use the default name of `package.json`.\n\n![Screenshot of VS showing new file dialog with 'npm configuration file' selected](https://www.typescriptlang.org/images/tutorials/aspnet/packagejson.png)\n\nInside the `\"devDependencies\"` section of the `package.json` file, add _gulp_ and _del_\n\n`   \"devDependencies\": {      \"gulp\": \"4.0.2\",      \"del\": \"5.1.0\"  }   `\n\nVisual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.\n\nAfter you should see an `npm` folder in your solution explorer\n\n![Screenshot of VS showing npm folder](https://www.typescriptlang.org/images/tutorials/aspnet/npm.png)\n\n#### [](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#set-up-gulp)\n_Set up gulp_\n\nRight click on the project and click **New Item**. Then choose **JavaScript File** and use the name of `gulpfile.js`\n\njs\n\n`   /// <binding AfterBuild='default' Clean='clean' />  /*  This file is the main entry point for defining Gulp tasks and using Gulp plugins.  Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007  */  var gulp = require(\"gulp\");  var del = require(\"del\");  var paths = {    scripts: [\"scripts/**/*.js\", \"scripts/**/*.ts\", \"scripts/**/*.map\"],  };  gulp.task(\"clean\", function () {    return del([\"wwwroot/scripts/**/*\"]);  });  gulp.task(\"default\", function (done) {      gulp.src(paths.scripts).pipe(gulp.dest(\"wwwroot/scripts\"));      done();  });   `\n\nThe first line tells Visual Studio to run the task ‘default’ after the build finishes. It will also run the ‘clean’ task when you ask Visual Studio to clean the build.\n\nNow right-click on `gulpfile.js` and click Task Runner Explorer.\n\n![Screenshot of right clicking on the \"Gulpfile.js\" with 'Task Runner Explorer' selected](https://www.typescriptlang.org/images/tutorials/aspnet/taskrunner.png)\n\nIf ‘default’ and ‘clean’ tasks don’t show up, refresh the explorer:\n\n![Screenshot of task explorer with \"Gulpfile.js\" in it](https://www.typescriptlang.org/images/tutorials/aspnet/taskrunnerrefresh.png)\n\n[](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#write-a-html-page)\nWrite a HTML page\n------------------------------------------------------------------------------------------------------\n\nRight click on the `wwwroot` folder (if you don’t see the folder try building the project) and add a New Item named `index.html` inside. Use the following code for `index.html`\n\n`   <!DOCTYPE html>  <html>  <head>      <meta charset=\"utf-8\" />      <script src=\"scripts/app.js\"></script>      <title></title>  </head>  <body>      <div id=\"message\"></div>      <div>          Compiler: <input id=\"compiler\" value=\"TypeScript\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /><br />          Framework: <input id=\"framework\" value=\"ASP.NET\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" />      </div>  </body>  </html>   `\n\n[](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#test)\nTest\n----------------------------------------------------------------------------\n\n1.  Run the project\n2.  As you type on the boxes you should see the message appear/change!\n\n![A GIF of Edge showing the code you have just wrote](https://media.giphy.com/media/U3mTibRAx34DG3zhAN/giphy.gif)\n\n[](https://www.typescriptlang.org/docs/handbook/asp-net-core.html#debug)\nDebug\n------------------------------------------------------------------------------\n\n1.  In Edge, press F12 and click the Debugger tab.\n2.  Look in the first localhost folder, then scripts/app.ts\n3.  Put a breakpoint on the line with return.\n4.  Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.\n\n![An image showing the debugger running the code you have just wrote](https://www.typescriptlang.org/images/tutorials/aspnet/debugger.png)\n\nCongrats you’ve built your own .NET Core project with a TypeScript frontend.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/tutorials/ASP.NET%20Core.md)\n ❤\n\nContributors to this page:  \n\nBK![Bowden Kelly  (56)](https://gravatar.com/avatar/e87ecf3e2da8b667dd3a8005ac610d4a?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nGC![Gabrielle Crevecoeur  (11)](https://gravatar.com/avatar/1d1c3d0dff776fedc6a4f10cd7824314?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (3)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)\n\nLZ![Limin Zhu  (2)](https://gravatar.com/avatar/6ff09ff871238f23c607356e5eee9dd1?s=32&&d=blank)\n\n14+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"Using TypeScript in ASP.NET Core","generator":"Gatsby 5.13.5","theme-color":"#3178C6","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","title":"TypeScript: Documentation - ASP.NET Core","ogTitle":"Documentation - ASP.NET Core","description":"Using TypeScript in ASP.NET Core","og:description":"Using TypeScript in ASP.NET Core","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","og:title":"Documentation - ASP.NET Core","scrapeId":"0df49667-ab52-404b-afaa-c8e23530068a","sourceURL":"https://www.typescriptlang.org/docs/handbook/asp-net-core.html","url":"https://www.typescriptlang.org/docs/handbook/asp-net-core.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nJS Projects Utilizing TypeScript\n================================\n\nThe type system in TypeScript has different levels of strictness when working with a codebase:\n\n*   A type-system based only on inference with JavaScript code\n*   Incremental typing in JavaScript [via JSDoc](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n    \n*   Using `// @ts-check` in a JavaScript file\n*   TypeScript code\n*   TypeScript with [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n     enabled\n\nEach step represents a move towards a safer type-system, but not every project needs that level of verification.\n\n[](https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html#typescript-with-javascript)\nTypeScript with JavaScript\n--------------------------------------------------------------------------------------------------------------------------\n\nThis is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename. The [homepage](https://www.typescriptlang.org/)\n has a list of editors which have TypeScript plugins.\n\n[](https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html#providing-type-hints-in-js-via-jsdoc)\nProviding Type Hints in JS via JSDoc\n----------------------------------------------------------------------------------------------------------------------------------------------\n\nIn a `.js` file, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax.\n\nJSDoc annotations that come before a declaration will be used to set the type of that declaration. For example:\n\njs\n\n`   /** @type {number} */  var x;  x = 0; // OK  x = false; // OK?!   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeA7ArgWwEaIE4C+4IwAUAG4CG+4AHgNxll3gC84ADA+MMOAHkA0i3bgAZlQA2AZ0Q8+goQH4AhEA)\n\nYou can find the full list of supported JSDoc patterns [in JSDoc Supported Types](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html#ts-check)\n`@ts-check`\n-----------------------------------------------------------------------------------------\n\nThe last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project. To enable errors in your JavaScript files add: `// @ts-check` to the first line in your `.js` files to have TypeScript raise it as an error.\n\njs\n\n`  // @ts-check  /** @type {number} */  var x;  x = 0; // OK  x = false; // Not OK  Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcGcFoGMAWBTeBrAUCCyBOuB7XaALlACYBmc8rAKjokgE8AHZUAbwDsBXAWwBGeAL6g6wDADcAhrlAAPANwYMC0AF5QABiWhsAeQDSazaABmMgDbRke7ADkCkUMaA)\n\nIf you have a lot of JavaScript files you want to add errors to then you can switch to using a [`jsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n. You can skip checking some files by adding a `// @ts-nocheck` comment to files.\n\nTypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding `// @ts-ignore` or `// @ts-expect-error` on the preceding line.\n\njs\n\n`   // @ts-check  /** @type {number} */  var x;  x = 0; // OK  // @ts-expect-error  x = false; // Not OK   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcGcFoGMAWBTeBrAUMAVNikBPAB2VAG8A7AVwFsAjZAJwF9RtgMA3AQ0dAA8A3Bgz9QAXlAAGQaBCgA8gGksYKHGT8S8SLCaMA9o1ETQAM24AbaMlnyAcgciKlQA)\n\nTo learn more about how JavaScript is interpreted by TypeScript read [How TS Type Checks JS](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)\n\n[### Type Checking JavaScript Files\\\n\\\nHow to add type checking to JavaScript files using TypeScript](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/javascript/Intro%20to%20JS%20with%20TS.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (6)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\n6![60x20  (1)](https://gravatar.com/avatar/8284d8550c4ebc384911a9dfca791cecf3eb3ac1ef432ca19d52daa82de6fb34?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - JS Projects Utilizing TypeScript","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogTitle":"Documentation - JS Projects Utilizing TypeScript","language":"en","generator":"Gatsby 5.13.5","theme-color":"#3178C6","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","description":"How to add type checking to JavaScript files using TypeScript","og:title":"Documentation - JS Projects Utilizing TypeScript","og:description":"How to add type checking to JavaScript files using TypeScript","twitter:site":"typescriptlang","ogDescription":"How to add type checking to JavaScript files using TypeScript","scrapeId":"2b042fac-edb2-4171-ba80-9275d9ddac97","sourceURL":"https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html","url":"https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nDo's and Don'ts\n===============\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#general-types)\nGeneral Types\n-------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#number-string-boolean-symbol-and-object)\n`Number`, `String`, `Boolean`, `Symbol` and `Object`\n\n❌ **Don’t** ever use the types `Number`, `String`, `Boolean`, `Symbol`, or `Object` These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.\n\nts\n\n`   /* WRONG */  function reverse(s: String): String;   `\n\n✅ **Do** use the types `number`, `string`, `boolean`, and `symbol`.\n\nts\n\n`   /* OK */  function reverse(s: string): string;   `\n\nInstead of `Object`, use the non-primitive `object` type ([added in TypeScript 2.2](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type)\n).\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#generics)\nGenerics\n\n❌ **Don’t** ever have a generic type which doesn’t use its type parameter. See more details in [TypeScript FAQ page](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#any)\nany\n\n❌ **Don’t** use `any` as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler _effectively_ treats `any` as “please turn off type checking for this thing”. It is similar to putting an `@ts-ignore` comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven’t migrated yet as `any`, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.\n\nIn cases where you don’t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use [`unknown`](https://www.typescriptlang.org/play/#example/unknown-and-never)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#callback-types)\nCallback Types\n---------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#return-types-of-callbacks)\nReturn Types of Callbacks\n\n❌ **Don’t** use the return type `any` for callbacks whose value will be ignored:\n\nts\n\n`   /* WRONG */  function fn(x: () => any) {    x();  }   `\n\n✅ **Do** use the return type `void` for callbacks whose value will be ignored:\n\nts\n\n`   /* OK */  function fn(x: () => void) {    x();  }   `\n\n❔ **Why:** Using `void` is safer because it prevents you from accidentally using the return value of `x` in an unchecked way:\n\nts\n\n`   function fn(x: () => void) {    var k = x(); // oops! meant to do something else    k.doSomething(); // error, but would be OK if the return type had been 'any'  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#optional-parameters-in-callbacks)\nOptional Parameters in Callbacks\n\n❌ **Don’t** use optional parameters in callbacks unless you really mean it:\n\nts\n\n`   /* WRONG */  interface Fetcher {    getObject(done: (data: unknown, elapsedTime?: number) => void): void;  }   `\n\nThis has a very specific meaning: the `done` callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the `elapsedTime` parameter, but there’s no need to make the parameter optional to accomplish this — it’s always legal to provide a callback that accepts fewer arguments.\n\n✅ **Do** write callback parameters as non-optional:\n\nts\n\n`   /* OK */  interface Fetcher {    getObject(done: (data: unknown, elapsedTime: number) => void): void;  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#overloads-and-callbacks)\nOverloads and Callbacks\n\n❌ **Don’t** write separate overloads that differ only on callback arity:\n\nts\n\n`   /* WRONG */  declare function beforeAll(action: () => void, timeout?: number): void;  declare function beforeAll(    action: (done: DoneFn) => void,    timeout?: number  ): void;   `\n\n✅ **Do** write a single overload using the maximum arity:\n\nts\n\n`   /* OK */  declare function beforeAll(    action: (done: DoneFn) => void,    timeout?: number  ): void;   `\n\n❔ **Why:** It’s always legal for a callback to disregard a parameter, so there’s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#function-overloads)\nFunction Overloads\n-----------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#ordering)\nOrdering\n\n❌ **Don’t** put more general overloads before more specific overloads:\n\nts\n\n`   /* WRONG */  declare function fn(x: unknown): unknown;  declare function fn(x: HTMLElement): number;  declare function fn(x: HTMLDivElement): string;  var myElem: HTMLDivElement;  var x = fn(myElem); // x: unknown, wat?   `\n\n✅ **Do** sort overloads by putting the more general signatures after more specific signatures:\n\nts\n\n`   /* OK */  declare function fn(x: HTMLDivElement): string;  declare function fn(x: HTMLElement): number;  declare function fn(x: unknown): unknown;  var myElem: HTMLDivElement;  var x = fn(myElem); // x: string, :)   `\n\n❔ **Why:** TypeScript chooses the _first matching overload_ when resolving function calls. When an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#use-optional-parameters)\nUse Optional Parameters\n\n❌ **Don’t** write several overloads that differ only in trailing parameters:\n\nts\n\n`   /* WRONG */  interface Example {    diff(one: string): number;    diff(one: string, two: string): number;    diff(one: string, two: string, three: boolean): number;  }   `\n\n✅ **Do** use optional parameters whenever possible:\n\nts\n\n`   /* OK */  interface Example {    diff(one: string, two?: string, three?: boolean): number;  }   `\n\nNote that this collapsing should only occur when all overloads have the same return type.\n\n❔ **Why:** This is important for two reasons.\n\nTypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, _and extraneous arguments are allowed_. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:\n\nts\n\n`   function fn(x: (a: string, b: number, c: number) => void) {}  var x: Example;  // When written with overloads, OK -- used first overload  // When written with optionals, correctly an error  fn(x.diff);   `\n\nThe second reason is when a consumer uses the “strict null checking” feature of TypeScript. Because unspecified parameters appear as `undefined` in JavaScript, it’s usually fine to pass an explicit `undefined` to a function with optional arguments. This code, for example, should be OK under strict nulls:\n\nts\n\n`   var x: Example;  // When written with overloads, incorrectly an error because of passing 'undefined' to 'string'  // When written with optionals, correctly OK  x.diff(\"something\", true ? undefined : \"hour\");   `\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#use-union-types)\nUse Union Types\n\n❌ **Don’t** write overloads that differ by type in only one argument position:\n\nts\n\n`   /* WRONG */  interface Moment {    utcOffset(): number;    utcOffset(b: number): Moment;    utcOffset(b: string): Moment;  }   `\n\n✅ **Do** use union types whenever possible:\n\nts\n\n`   /* OK */  interface Moment {    utcOffset(): number;    utcOffset(b: number | string): Moment;  }   `\n\nNote that we didn’t make `b` optional here because the return types of the signatures differ.\n\n❔ **Why:** This is important for people who are “passing through” a value to your function:\n\nts\n\n`   function fn(x: string): Moment;  function fn(x: number): Moment;  function fn(x: number | string) {    // When written with separate overloads, incorrectly an error    // When written with union types, correctly OK    return moment().utcOffset(x);  }   `\n\n[### Deep Dive\\\n\\\nHow do d.ts files work, a deep dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/Do's%20and%20Don'ts.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (55)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nMZ![Micah Zoltu  (3)](https://gravatar.com/avatar/b710592f44be3f43546d5e843d8fbd7122e66102589747658184b7bc398aaea5?s=32&&d=blank)\n\nMF![Martin Fischer  (1)](https://gravatar.com/avatar/dc885100e48a5949f1a44bcd6fce398735ff3294f20607ddee8bb45acb29601a?s=32&&d=blank)\n\nJ![Jongbin  (1)](https://gravatar.com/avatar/c1ef558659f3847439a915dfff757d5fd459bcfae9a04924b09e8af080cbf8d3?s=32&&d=blank)\n\n15+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"description":"Recommendations for writing d.ts files","generator":"Gatsby 5.13.5","og:description":"Recommendations for writing d.ts files","ogTitle":"Documentation - Do's and Don'ts","language":"en","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","title":"TypeScript: Documentation - Do's and Don'ts","og:title":"Documentation - Do's and Don'ts","twitter:site":"typescriptlang","ogDescription":"Recommendations for writing d.ts files","scrapeId":"7781bbcf-75e5-4453-bf0b-0d4d8cd18555","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nPublishing\n==========\n\nNow that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:\n\n1.  bundling with your npm package\n2.  publishing to the [@types organization](https://www.npmjs.com/~types)\n     on npm.\n\nIf your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types via [`declaration`](https://www.typescriptlang.org/tsconfig#declaration)\n.\n\nOtherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the `@types` organization on npm.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#including-declarations-in-your-npm-package)\nIncluding declarations in your npm package\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIf your package has a main `.js` file, you will need to indicate the main declaration file in your `package.json` file as well. Set the `types` property to point to your bundled declaration file. For example:\n\njson\n\n`   {    \"name\": \"awesome\",    \"author\": \"Vandelay Industries\",    \"version\": \"1.0.0\",    \"main\": \"./lib/main.js\",    \"types\": \"./lib/main.d.ts\"  }   `\n\nNote that the `\"typings\"` field is synonymous with `types`, and could be used as well.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#dependencies)\nDependencies\n------------------------------------------------------------------------------------------------------------\n\nAll dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the `\"dependencies\"` section in your `package.json`. For example, imagine we authored a package that used Browserify and TypeScript.\n\njson\n\n`   {    \"name\": \"browserify-typescript-extension\",    \"author\": \"Vandelay Industries\",    \"version\": \"1.0.0\",    \"main\": \"./lib/main.js\",    \"types\": \"./lib/main.d.ts\",    \"dependencies\": {      \"browserify\": \"latest\",      \"@types/browserify\": \"latest\",      \"typescript\": \"next\"    }  }   `\n\nHere, our package depends on the `browserify` and `typescript` packages. `browserify` does not bundle its declaration files with its npm packages, so we needed to depend on `@types/browserify` for its declarations. `typescript`, on the other hand, packages its declaration files, so there was no need for any additional dependencies.\n\nOur package exposes declarations from each of those, so any user of our `browserify-typescript-extension` package needs to have these dependencies as well. For that reason, we used `\"dependencies\"` and not `\"devDependencies\"`, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used `devDependencies`.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#red-flags)\nRed flags\n------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#-reference-path-)\n`/// <reference path=\"...\" />`\n\n_Don’t_ use `/// <reference path=\"...\" />` in your declaration files.\n\nts\n\n`   /// <reference path=\"../typescript/lib/typescriptServices.d.ts\" />  ....   `\n\n_Do_ use `/// <reference types=\"...\" />` instead.\n\nts\n\n`   /// <reference types=\"typescript\" />  ....   `\n\nMake sure to revisit the [Consuming dependencies](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#consuming-dependencies)\n section for more information.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#packaging-dependent-declarations)\nPackaging dependent declarations\n\nIf your type definitions depend on another package:\n\n*   _Don’t_ combine it with yours, keep each in their own file.\n*   _Don’t_ copy the declarations in your package either.\n*   _Do_ depend on the npm type declaration package if it doesn’t package its declaration files.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#version-selection-with-typesversions)\nVersion selection with `typesVersions`\n--------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen TypeScript opens a `package.json` file to figure out which files it needs to read, it first looks at a field called `typesVersions`.\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#folder-redirects-using-)\nFolder redirects (using `*`)\n\nA `package.json` with a `typesVersions` field might look like this:\n\njson\n\n`   {    \"name\": \"package-name\",    \"version\": \"1.0.0\",    \"types\": \"./index.d.ts\",    \"typesVersions\": {      \">=3.1\": { \"*\": [\"ts3.1/*\"] }    }  }   `\n\nThis `package.json` tells TypeScript to first check the current version of TypeScript. If it’s 3.1 or later, TypeScript figures out the path you’ve imported relative to the package, and reads from the package’s `ts3.1` folder.\n\nThat’s what that `{ \"*\": [\"ts3.1/*\"] }` means - if you’re familiar with [path mapping](https://www.typescriptlang.org/tsconfig#paths)\n, it works exactly like that.\n\nIn the above example, if we’re importing from `\"package-name\"`, TypeScript will try to resolve from `[...]/node_modules/package-name/ts3.1/index.d.ts` (and other relevant paths) when running in TypeScript 3.1. If we import from `package-name/foo`, we’ll try to look for `[...]/node_modules/package-name/ts3.1/foo.d.ts` and `[...]/node_modules/package-name/ts3.1/foo/index.d.ts`.\n\nWhat if we’re not running in TypeScript 3.1 in this example? Well, if none of the fields in `typesVersions` get matched, TypeScript falls back to the `types` field, so here TypeScript 3.0 and earlier will be redirected to `[...]/node_modules/package-name/index.d.ts`.\n\n#### [](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#file-redirects)\nFile redirects\n\nWhen you want to only change the resolution for a single file at a time, you can tell TypeScript the file to resolve differently by passing in the exact filenames:\n\njson\n\n`   {    \"name\": \"package-name\",    \"version\": \"1.0.0\",    \"types\": \"./index.d.ts\",    \"typesVersions\": {      \"<4.0\": { \"index.d.ts\": [\"index.v3.d.ts\"] }    }  }   `\n\nOn TypeScript 4.0 and above, an import for `\"package-name\"` would resolve to `./index.d.ts` and for 3.9 and below `\"./index.v3.d.ts`.\n\nNote that redirections only affect the _external_ API of a package; import resolution within a project is not affected by `typesVersions`. For example, a `d.ts` file in the previous example containing `import * as foo from \"./index\"` will still map to `index.d.ts`, not `index.v3.d.ts`, whereas another package importing `import * as foo from \"package-name\"` _will_ get `index.v3.d.ts`.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#matching-behavior)\nMatching behavior\n----------------------------------------------------------------------------------------------------------------------\n\nThe way that TypeScript decides on whether a version of the compiler & language matches is by using Node’s [semver ranges](https://github.com/npm/node-semver#ranges)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#multiple-fields)\nMultiple fields\n------------------------------------------------------------------------------------------------------------------\n\n`typesVersions` can support multiple fields where each field name is specified by the range to match on.\n\n`   {    \"name\": \"package-name\",    \"version\": \"1.0\",    \"[types](https://www.typescriptlang.org/tsconfig#types) \": \"./index.d.ts\",    \"typesVersions\": {      \">=3.2\": { \"*\": [\"ts3.2/*\"] },      \">=3.1\": { \"*\": [\"ts3.1/*\"] }    }  }   `\n\nSince ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the `>=3.2` and the `>=3.1` matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.\n\n`   {    \"name\": \"package-name\",    \"version\": \"1.0\",    \"[types](https://www.typescriptlang.org/tsconfig#types) \": \"./index.d.ts\",    \"typesVersions\": {      // NOTE: this doesn't work!      \">=3.1\": { \"*\": [\"ts3.1/*\"] },      \">=3.2\": { \"*\": [\"ts3.2/*\"] }    }  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#publish-to-types)\nPublish to [@types](https://www.npmjs.com/~types)\n\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPackages under the [@types](https://www.npmjs.com/~types)\n organization are published automatically from [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)\n using the [types-publisher tool](https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher)\n. To get your declarations published as an @types package, please submit a pull request to [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)\n. You can find more details in the [contribution guidelines page](https://definitelytyped.github.io/guides/contributing.html)\n.\n\n[### Deep Dive\\\n\\\nHow do d.ts files work, a deep dive](https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html)\n\n[### Consumption\\\n\\\nHow to download d.ts files for your project](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/Publishing.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (55)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (21)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nMB![Mateusz Burzyński  (2)](https://gravatar.com/avatar/20ed1adc4c9f8665ed276acc30878d51535492623bbc3b441426c81450b14725?s=32&&d=blank)\n\nRV![Rauno Viskus  (2)](https://gravatar.com/avatar/188e3c1cf60722678068e7c7acc1cef5554a1527c470deb063ef3d5f9722e613?s=32&&d=blank)\n\nRC![Ryan Cavanaugh  (2)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\n19+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - Publishing","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","og:title":"Documentation - Publishing","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","ogTitle":"Documentation - Publishing","generator":"Gatsby 5.13.5","ogDescription":"How to get your d.ts files to users","description":"How to get your d.ts files to users","og:description":"How to get your d.ts files to users","scrapeId":"27f975fe-6898-4482-9952-f5809826504c","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nConsumption\n===========\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html#downloading)\nDownloading\n-----------------------------------------------------------------------------------------------------------\n\nGetting type declarations requires no tools apart from npm.\n\nAs an example, getting the declarations for a library like lodash takes nothing more than the following command\n\ncmd\n\n`   npm install --save-dev @types/lodash   `\n\nIt is worth noting that if the npm package already includes its declaration file as described in [Publishing](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)\n, downloading the corresponding `@types` package is not needed.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html#consuming)\nConsuming\n-------------------------------------------------------------------------------------------------------\n\nFrom there you’ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.\n\nFor example, once you’ve `npm install`\\-ed your type declarations, you can use imports and write\n\nts\n\n`   import * as _ from \"lodash\";  _.padStart(\"Hello TypeScript!\", 20, \" \");   `\n\nor if you’re not using modules, you can just use the global variable `_`.\n\nts\n\n`   _.padStart(\"Hello TypeScript!\", 20, \" \");   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html#searching)\nSearching\n-------------------------------------------------------------------------------------------------------\n\nFor the most part, type declaration packages should always have the same name as the package name on `npm`, but prefixed with `@types/`, but if you need, you can use the [Yarn package search](https://yarnpkg.com/)\n to find the package for your favorite library.\n\n> Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped [contribution guidelines page](https://definitelytyped.org/guides/contributing.html)\n>  for details.\n\n[### Publishing\\\n\\\nHow to get your d.ts files to users](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/declaration-files/Consumption.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (52)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (14)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nIO![Iván Ovejero  (1)](https://gravatar.com/avatar/295845dcef2f47d9aa1059793f23f36ceb739f1772ac1b487f11a1094e733655?s=32&&d=blank)\n\nKO![Kristján Oddsson  (1)](https://gravatar.com/avatar/c7938b0536fb43f750fe08c73f804272349f01d9a97a59548c557706ae7cbee4?s=32&&d=blank)\n\nEB![Eli Barzilay  (1)](https://gravatar.com/avatar/7384b5fcebe0e04cdd109255e1189e5135524f0ebc6ff0ff807b0b9d6ebd3976?s=32&&d=blank)\n\n5+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - Consumption","generator":"Gatsby 5.13.5","og:description":"How to download d.ts files for your project","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","language":"en","ogDescription":"How to download d.ts files for your project","description":"How to download d.ts files for your project","twitter:site":"typescriptlang","og:title":"Documentation - Consumption","title":"TypeScript: Documentation - Consumption","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","scrapeId":"7607603f-b3b3-4938-9e65-d20fc0387e9f","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nType Checking JavaScript Files\n==============================\n\nHere are some notable differences on how checking works in `.js` files compared to `.ts` files.\n\n[](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#properties-are-inferred-from-assignments-in-class-bodies)\nProperties are inferred from assignments in class bodies\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.\n\nIn a `.js` file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it’s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.\n\njs\n\n`   class C {    constructor() {      this.constructorOnly = 0;      this.constructorUnknown = undefined;    }    method() {      this.constructorOnly = false;  Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.      this.constructorUnknown = \"plunkbat\"; // ok, constructorUnknown is string | undefined      this.methodOnly = \"ok\"; // ok, but methodOnly could also be undefined    }    method2() {      this.methodOnly = true; // also, ok, methodOnly's type is string | boolean | undefined    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZTS1IAbAQxRVAGFQBvNUUSPAOxQAXbAFdIgggAoAlBy7dQg6AEsUAOl4DhYidgDyfWgE9QAXlAAGANzzuS1Rv5DR4ggFU+CPngDufM6AifAAmsABmynywwTbcAL7yALawSnjBMnIKiirqms46BAbGAWH0tCiwsQr2uU7artgeXr7+5gBEAA60QQgARvSCbVagmHgIADQ8dS66Td5+oKqgzpEA5qAAPoEh4ZHRttkOyanBRSbtY0MjYGOTvSKCoMfQaWdTIrTBoGUoeKC9sG2oQiUWC8gS3GeaVIGU4WRqaihp0M50Uokq12+5Twk1uTxSL2RxgA5MxBEYOoClis+Ostr08HhaLB6P4tkFgXswfE0HEgA)\n\nIf properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don’t even have to give a value if it will be initialized later:\n\njs\n\n`  class C {    constructor() {      /** @type {number | undefined} */      this.prop = undefined;      /** @type {number | undefined} */      this.count;    }  }  let c = new C();  c.prop = 0; // OK  c.count = \"string\";  Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZTS1IAbAQxRVAGFQBvNUUSPAOxQAXbAFdIgggAoAlBy7dQwAFRKIggJ4AHWBz4iAtgCMcoAD6gRfACawAZgEs+sKwF9QS4PO6Do9lADpNfE1QAF4LaztHZwBuL0UVNS0ddj0jE3NLGwcnV3dPBVAfP39eS0E47hc0arRaWEEeMNAnAHdWGTjIQODmgAYYxTAAeQBpGlK8cuaAIiFsRwBzGZigA)\n\n[](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#constructor-functions-are-equivalent-to-classes)\nConstructor functions are equivalent to classes\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBefore ES2015, JavaScript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.\n\njs\n\n`   function C() {    this.constructorOnly = 0;    this.constructorUnknown = undefined;  }  C.prototype.method = function () {    this.constructorOnly = false;  Type 'boolean' is not assignable to type 'number'.2322Type 'boolean' is not assignable to type 'number'.    this.constructorUnknown = \"plunkbat\"; // OK, the type is string | undefined  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgDYAOAZjOtNLQDMBXAO0gBcBLPN0AMIAKAJSgA3mlChO0bigB0kPik7YWXAgHk2AGwCeoALygADAG4pMuYuVtV6zdgCqbBGzwB3fifYATWCZuNlg-SwBfNAEFAAd8TjxOfRjYBQBbWFk8P2NQVg4ePlBRCStZeSUVNQ0E7B0DXKYAQ10UWEtpctsqx1rXdy8fUAAiGN12BAAjJs5h81BMLQBpABprWBlkjflQB2CAc1AAH1B-QODQtHDzIA)\n\n[](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#commonjs-modules-are-supported)\nCommonJS modules are supported\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn a `.js` file, TypeScript understands the CommonJS module format. Assignments to `exports` and `module.exports` are recognized as export declarations. Similarly, `require` function calls are recognized as module imports. For example:\n\njs\n\n``   // same as `import module \"fs\"`  const fs = require(\"fs\");  // same as `export function readFile`  module.exports.readFile = function (f) {    return fs.readFileSync(f);  };   ``\n\nThe module support in JavaScript is much more syntactically forgiving than TypeScript’s module support. Most combinations of assignments and declarations are supported.\n\n[](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#classes-functions-and-object-literals-are-namespaces)\nClasses, functions, and object literals are namespaces\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nClasses are namespaces in `.js` files. This can be used to nest classes, for example:\n\njs\n\n`   class C {}  C.D = class {};   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8C+AoWA6AItAvNUkMyA3EA)\n\nAnd, for pre-ES2015 code, it can be used to simulate static methods:\n\njs\n\n`   function Outer() {    this.y = 2;  }  Outer.Inner = function () {    this.yy = 2;  };  Outer.Inner();   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAeRFApgJwBQEpEDeAUIolABYwDOAdAJ6IC8iATANxEC+RRqGmNAJJgwWJolCRYCRHkIkylWnQbN2XDrzRYhIrHjZA)\n\nIt can also be used to create simple namespaces:\n\njs\n\n`   var ns = {};  ns.C = class {};  ns.func = function () {};  ns;   `[Try](https://www.typescriptlang.org/play/#code/G4QwTgBAdgzhC8EDeBfA3AKFgOgMIIgGMAbEGOVTHAMwFcpCC6GAXASwHsoIAKASmToMWGGiA)\n\nOther variants are allowed as well:\n\njs\n\n`   // IIFE  var ns = (function (n) {    return n || {};  })();  ns.CONST = 1;  // defaulting to global  var assign =    assign ||    function () {      // code goes here    };  assign.extra = 1;   `[Try](https://www.typescriptlang.org/play/#code/PTAEElwMQUQKAG4EMBOoB2BnUBeUAKAMwFd0BjAFwEsB7dA9ASlAG85RQUBTC4le+gB9BrAL4BuOKMb5GkrADoAwgHkAcgGUAKrlABGSXBCgAJl0JJiAG2roA5qAo1QdqzQBGSK4lSgkmTCo7ehx2PwCgoUEwknJqOgJmNg4OYzIaMxcaLmwACy5uMIk4f0DghS4ADwoUJF0DIA)\n\n[](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#object-literals-are-open-ended)\nObject literals are open-ended\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn a `.ts` file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a `.js` file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:\n\njs\n\n`   var obj = { a: 1 };  obj.b = 2; // Allowed   `[Try](https://www.typescriptlang.org/play/#code/G4QwTgBA9gRgVhAvBA3hEAuCBGCBfAbgChY4A6GJCAJgIgHp6IBBAG1agHcBTAEyA)\n\nObject literals behave as if they have an index signature `[x:string]: any` that allows them to be treated as open maps instead of closed objects.\n\nLike other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:\n\njs\n\n`  /** @type {{a: number}} */  var obj = { a: 1 };  obj.b = 2;  Property 'b' does not exist on type '{ a: number; }'.2339Property 'b' does not exist on type '{ a: number; }'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGZyBODAKlogBcBPAB1lAG9OBDEgOwCuAWwBGOAL4TQtYGgBuPbKDyiAVqAC8XUH1ABGUBIDcaVWoB0orWWNA)\n\n[](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#null-undefined-and-empty-array-initializers-are-of-type-any-or-any)\nnull, undefined, and empty array initializers are of type any or any\\[\\]\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nAny variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with \\[\\] will have type any\\[\\], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.\n\njs\n\n`   function Foo(i = null) {    if (!i) i = 1;    var j = undefined;    j = 2;    this.l = [];  }  var foo = new Foo();  foo.l.push(foo.i);  foo.l.push(\"end\");   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAMTnAFDRBeRYQA2BAlIgN4BQiiMwi6AhDKVrgIwDcViAbgIYAnRACscicABMApsBhgpErtVG4ATEsRQAFjADOAOgJiA2gF0uAXwoV+Q4GjHyA7ijTpiXe3EP6ADiF0tdC99Zk80H39A9AAiKTAJGI8gA)\n\n[](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#function-parameters-are-optional-by-default)\nFunction parameters are optional by default\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nSince there is no way to specify optionality on parameters in pre-ES2015 JavaScript, all function parameters in `.js` file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.\n\nIt is important to note that it is an error to call a function with too many arguments.\n\nFor instance:\n\njs\n\n`  function bar(a, b) {    console.log(a + \" \" + b);  }  bar(1); // OK, second argument considered optional  bar(1, 2);  bar(1, 2, 3); // Error, too many arguments  Expected 0-2 arguments, but got 3.2554Expected 0-2 arguments, but got 3.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEEUBcBOBLSbALlADMBDAGxVgzHFl1wHtcVSB2ABm4DZQPfqABMAVjEAWNGQCuAOyL4W80ACMKuABQUANOoCUoAN5pQoSCpQsqsAHRUWAcx2gA1KABEX94YDcaAC+aGga2gCMBn6gmADyANL6tJbyACagmk6yALaw8tgWVvipTLDpLAAO2Mry1KGaWuH6IlH1Ec36AMxRMWAAosxs+tgsLKDZFPIAnhm4Wbn5KEA)\n\nJSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax (`[` `]`) to express optionality. e.g.:\n\njs\n\n`   /**   * @param {string} [somebody] - Somebody's name.   */  function sayHello(somebody) {    if (!somebody) {      somebody = \"John Doe\";    }    console.log(\"Hello \" + somebody);  }  sayHello();   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAHAhgJ0QW0gbwM4BdkCWAdgOYC+kA2tgPZoCmARjQCYCeAupALSQDKdJqzYBybJCLp6AOighg4AGYBXIgGNcBGkUjZEbABL0ANsZoAKWg2bsAlFiiQCiyOYCEVoXYeRfuwTZskAC8kABEAFI0ABY6ACI09GEA3I5kjmratMYyZiTmYUamNOGQANT+1sK2qengeoYmZuY1QA)\n\n[](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#var-args-parameter-declaration-inferred-from-use-of-arguments)\nVar-args parameter declaration inferred from use of `arguments`\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nA function whose body has a reference to the `arguments` reference is implicitly considered to have a var-arg parameter (i.e. `(...arg: any[]) => any`). Use JSDoc var-arg syntax to specify the type of the arguments.\n\njs\n\n`   /** @param {...number} args */  function sum(/* numbers */) {    var total = 0;    for (var i = 0; i < arguments.length; i++) {      total += arguments[i];    }    return total;  }   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEAcEMCdYFtwG8B0mB2BXJAjAU3gF9wEBzAZ3BGACgAzHLAYwBcBLAey3CrwAKUOFwFiNOgEo09cOABuCcO27tYAG3ABecAAYA3HPCNu8cIKXnOO-QfA2APOXgU8hLOyroNHiuwALe04AahCZVGN5VXUtEN1Kd08qAG1OAF0jeRJjeEJ2HHg+GM0jEiA)\n\n[](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#unspecified-type-parameters-default-to-any)\nUnspecified type parameters default to `any`\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nSince there is no natural syntax for specifying generic type parameters in JavaScript, an unspecified type parameter defaults to `any`.\n\n### [](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#in-extends-clause)\nIn extends clause\n\nFor instance, `React.Component` is defined to have two type parameters, `Props` and `State`. In a `.js` file, there is no legal way to specify these in the extends clause. By default the type arguments will be `any`:\n\njs\n\n`   import { Component } from \"react\";  class MyComponent extends Component {    render() {      this.props.b; // Allowed, since this.props is of type any    }  }   `\n\nUse JSDoc `@augments` to specify the types explicitly. for instance:\n\njs\n\n`   import { Component } from \"react\";  /**   * @augments {Component<{a: number}, State>}   */  class MyComponent extends Component {    render() {      this.props.b; // Error: b does not exist on {a:number}    }  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#in-jsdoc-references)\nIn JSDoc references\n\nAn unspecified type argument in JSDoc defaults to any:\n\njs\n\n`   /** @type{Array} */  var x = [];  x.push(1); // OK  x.push(\"string\"); // OK, x is of type Array<any>  /** @type{Array.<number>} */  var y = [];  y.push(1); // OK  y.push(\"string\"); // Error, string is not assignable to number   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCmBvAggJ3QQ1gX3CMAFABuW64AHuALzgDaAugNxFGUB08ArgM4AWACgCMASmbhgwcAHkA0uy58hAIl7R0ASwB2AcxXjJ0+QBoq4Tb3AB7AGbg4ScBmywAPFm2wAfG1AQYBBQXHA43bW4AWwAjRHRvfEJScnBYWgYWNlglARFDKVkFbJ5ctQ0dfXzpAFFMa3QzdS09Cytta2hwLF5eTV1tLGiAG0QHa3AImLigA)\n\n### [](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#in-function-calls)\nIn function calls\n\nA call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to `any`. For example:\n\njs\n\n`   var p = new Promise((resolve, reject) => {    reject();  });  p; // Promise<any>;   `\n\nTo learn all of the features available in JSDoc, see [the reference](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n.\n\n[### JS Projects Utilizing TypeScript\\\n\\\nHow to add type checking to JavaScript files using TypeScript](https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html)\n\n[### JSDoc Reference\\\n\\\nWhat JSDoc does TypeScript-powered JavaScript support?](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/javascript/Type%20Checking%20JavaScript%20Files.md)\n ❤\n\nContributors to this page:  \n\nHN![Harry Nguyen  (51)](https://gravatar.com/avatar/386e27141a29f5c1076619afc140ffb4?s=32&&d=blank)\n\nOT![Orta Therox  (17)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nRC![Ryan Cavanaugh  (3)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nNS![Nathan Shively-Sanders  (2)](https://gravatar.com/avatar/8c5596e6ef2b41132cee585c9b146116?s=32&&d=blank)\n\nMH![Mohamed Hegazy  (2)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\n15+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","generator":"Gatsby 5.13.5","theme-color":"#3178C6","title":"TypeScript: Documentation - Type Checking JavaScript Files","description":"How to add type checking to JavaScript files using TypeScript","ogTitle":"Documentation - Type Checking JavaScript Files","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"How to add type checking to JavaScript files using TypeScript","og:title":"Documentation - Type Checking JavaScript Files","og:description":"How to add type checking to JavaScript files using TypeScript","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","twitter:site":"typescriptlang","scrapeId":"1a7a1f42-d1e4-4d79-9d92-d911ba6c0988","sourceURL":"https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html","url":"https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nWhat is a tsconfig.json\n=======================\n\n[](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#overview)\nOverview\n-------------------------------------------------------------------------------------\n\nThe presence of a `tsconfig.json` file in a directory indicates that the directory is the root of a TypeScript project. The `tsconfig.json` file specifies the root files and the compiler options required to compile the project.\n\nJavaScript projects can use a `jsconfig.json` file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.\n\nA project is compiled in one of the following ways:\n\n[](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#using-tsconfigjson-or-jsconfigjson)\nUsing `tsconfig.json` or `jsconfig.json`\n-----------------------------------------------------------------------------------------------------------------------------------------------\n\n*   By invoking tsc with no input files, in which case the compiler searches for the `tsconfig.json` file starting in the current directory and continuing up the parent directory chain.\n*   By invoking tsc with no input files and a `--project` (or just `-p`) command line option that specifies the path of a directory containing a `tsconfig.json` file, or a path to a valid `.json` file containing the configurations.\n\nWhen input files are specified on the command line, `tsconfig.json` files are ignored.\n\n[](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#examples)\nExamples\n-------------------------------------------------------------------------------------\n\nExample `tsconfig.json` files:\n\n*   Using the [`files`](https://www.typescriptlang.org/tsconfig#files)\n     property\n    \n    `   {    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[module](https://www.typescriptlang.org/tsconfig#module) \": \"commonjs\",      \"[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny) \": true,      \"[removeComments](https://www.typescriptlang.org/tsconfig#removeComments) \": true,      \"[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums) \": true,      \"[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap) \": true    },    \"[files](https://www.typescriptlang.org/tsconfig#files) \": [      \"core.ts\",      \"sys.ts\",      \"types.ts\",      \"scanner.ts\",      \"parser.ts\",      \"utilities.ts\",      \"binder.ts\",      \"checker.ts\",      \"emitter.ts\",      \"program.ts\",      \"commandLineParser.ts\",      \"tsc.ts\",      \"diagnosticInformationMap.generated.ts\"    ]  }   `\n    \n*   Using the [`include`](https://www.typescriptlang.org/tsconfig#include)\n     and [`exclude`](https://www.typescriptlang.org/tsconfig#exclude)\n     properties\n    \n    `   {    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[module](https://www.typescriptlang.org/tsconfig#module) \": \"system\",      \"[noImplicitAny](https://www.typescriptlang.org/tsconfig#noImplicitAny) \": true,      \"[removeComments](https://www.typescriptlang.org/tsconfig#removeComments) \": true,      \"[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums) \": true,      \"[outFile](https://www.typescriptlang.org/tsconfig#outFile) \": \"../../built/local/tsc.js\",      \"[sourceMap](https://www.typescriptlang.org/tsconfig#sourceMap) \": true    },    \"[include](https://www.typescriptlang.org/tsconfig#include) \": [\"src/**/*\"],    \"[exclude](https://www.typescriptlang.org/tsconfig#exclude) \": [\"**/*.spec.ts\"]  }   `\n    \n\n[](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#tsconfig-bases)\nTSConfig Bases\n-------------------------------------------------------------------------------------------------\n\nDepending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at [github.com/tsconfig/bases](https://github.com/tsconfig/bases/)\n. These are `tsconfig.json` files which your project extends from which simplifies your `tsconfig.json` by handling the runtime support.\n\nFor example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module [`@tsconfig/node12`](https://www.npmjs.com/package/@tsconfig/node12)\n:\n\n`   {    \"[extends](https://www.typescriptlang.org/tsconfig#extends) \": \"@tsconfig/node12/tsconfig.json\",    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[preserveConstEnums](https://www.typescriptlang.org/tsconfig#preserveConstEnums) \": true    },    \"[include](https://www.typescriptlang.org/tsconfig#include) \": [\"src/**/*\"],    \"[exclude](https://www.typescriptlang.org/tsconfig#exclude) \": [\"**/*.spec.ts\"]  }   `\n\nThis lets your `tsconfig.json` focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we’re hoping the community can add more for different environments.\n\n[](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#details)\nDetails\n-----------------------------------------------------------------------------------\n\nThe `\"compilerOptions\"` property can be omitted, in which case the compiler’s defaults are used. See our full list of supported [Compiler Options](https://www.typescriptlang.org/tsconfig)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#tsconfig-reference)\nTSConfig Reference\n---------------------------------------------------------------------------------------------------------\n\nTo learn more about the hundreds of configuration options in the [TSConfig Reference](https://www.typescriptlang.org/tsconfig)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#schema)\nSchema\n---------------------------------------------------------------------------------\n\nThe `tsconfig.json` Schema can be found at [the JSON Schema Store](http://json.schemastore.org/tsconfig)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/project-config/tsconfig.json.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (19)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nJB![Jake Bailey  (1)](https://gravatar.com/avatar/127e9f47eb2768eae31eb5809ae4f1ca44336bc51e45473c68ebb9648608f590?s=32&&d=blank)\n\nL☺![Loren ☺️  (1)](https://gravatar.com/avatar/b8eaa4ee5719bf17b085b89caae0e4c260b44072c703ff9ad6bc37112bb4b4e7?s=32&&d=blank)\n\nAG![Anton Gilgur  (1)](https://gravatar.com/avatar/14cf8bfc7e9486a5c6c0acc08682cfef8de31d40c2634eb4099fe3fc008a3492?s=32&&d=blank)\n\nCB![Christian Bromann  (1)](https://gravatar.com/avatar/d9295eb9a2cb8cffb5004b776749da915659fc68aca26fe272e72214fdd3cb4d?s=32&&d=blank)\n\n3+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogTitle":"Documentation - What is a tsconfig.json","ogDescription":"Learn about how a TSConfig works","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","twitter:site":"typescriptlang","og:description":"Learn about how a TSConfig works","og:title":"Documentation - What is a tsconfig.json","theme-color":"#3178C6","description":"Learn about how a TSConfig works","title":"TypeScript: Documentation - What is a tsconfig.json","scrapeId":"bc13f8e6-c1f0-45b4-951a-223a372e188f","sourceURL":"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html","url":"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nCreating .d.ts Files from .js files\n===================================\n\n[With TypeScript 3.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs)\n, TypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax.\n\nThis set up means you can own the editor experience of TypeScript-powered editors without porting your project to TypeScript, or having to maintain .d.ts files in your codebase. TypeScript supports most JSDoc tags, you can find [the reference here](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#supported-jsdoc)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html#setting-up-your-project-to-emit-dts-files)\nSetting up your Project to emit .d.ts files\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTo add creation of .d.ts files in your project, you will need to do up-to four steps:\n\n*   Add TypeScript to your dev dependencies\n*   Add a `tsconfig.json` to configure TypeScript\n*   Run the TypeScript compiler to generate the corresponding d.ts files for JS files\n*   (optional) Edit your package.json to reference the types\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html#adding-typescript)\nAdding TypeScript\n\nYou can learn how to do this in our [installation page](https://www.typescriptlang.org/download)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html#tsconfig)\nTSConfig\n\nThe TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files. In this case, you will want a file like the following:\n\n`   {    // Change this to match your project    \"[include](https://www.typescriptlang.org/tsconfig#include) \": [\"src/**/*\"],    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      // Tells TypeScript to read JS files, as      // normally they are ignored as source files      \"[allowJs](https://www.typescriptlang.org/tsconfig#allowJs) \": true,      // Generate d.ts files      \"[declaration](https://www.typescriptlang.org/tsconfig#declaration) \": true,      // This compiler run should      // only output d.ts files      \"[emitDeclarationOnly](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly) \": true,      // Types should go into this directory.      // Removing this would place the .d.ts files      // next to the .js files      \"[outDir](https://www.typescriptlang.org/tsconfig#outDir) \": \"dist\",      // go to js file when using IDE functions like      // \"Go to Definition\" in VSCode      \"[declarationMap](https://www.typescriptlang.org/tsconfig#declarationMap) \": true    }  }   `\n\nYou can learn more about the options in the [tsconfig reference](https://www.typescriptlang.org/tsconfig)\n. An alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command.\n\nsh\n\n`   npx -p typescript tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types   `\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html#run-the-compiler)\nRun the compiler\n---------------------------------------------------------------------------------------------------------------------\n\nYou can learn how to do this in our [installation page](https://www.typescriptlang.org/download)\n. You want to make sure these files are included in your package if you have the files in your project’s `.gitignore`.\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html#editing-the-packagejson)\nEditing the package.json\n------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript replicates the node resolution for modules in a `package.json`, with an additional step for finding .d.ts files. Roughly, the resolution will first check the optional `types` field, then the `\"main\"` field, and finally will try `index.d.ts` in the root.\n\n| Package.json | Location of default .d.ts |\n| --- | --- |\n| No “types” field | checks “main”, then index.d.ts |\n| “types”: “main.d.ts” | main.d.ts |\n| “types”: “./dist/main.js” | ./dist/main.d.ts |\n\nIf absent, then “main” is used\n\n| Package.json | Location of default .d.ts |\n| --- | --- |\n| No “main” field | index.d.ts |\n| “main”:“index.js” | index.d.ts |\n| “main”:“./dist/index.js” | ./dist/index.d.ts |\n\n[](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html#tips)\nTips\n---------------------------------------------------------------------------------------------\n\nIf you’d like to write tests for your .d.ts files, try [tsd](https://github.com/SamVerschueren/tsd)\n or [TSTyche](https://github.com/tstyche/tstyche)\n.\n\n[### JSDoc Reference\\\n\\\nWhat JSDoc does TypeScript-powered JavaScript support?](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/javascript/Creating%20DTS%20files%20From%20JS.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (16)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nTM![Tom Mrazauskas  (1)](https://gravatar.com/avatar/e6eaf9e3aa9a4ec5d2f6d2eae9d727b0012154a255795d34bc8d8d1fe7de54c0?s=32&&d=blank)\n\nSG![Song Gao  (1)](https://gravatar.com/avatar/f336bdc459c26ba42afda29b1d9972d36d9e6d935cfd5158380bf48532d9b7e9?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nSW![Stafford Williams  (1)](https://gravatar.com/avatar/57994c02cb1b9863049731082943a720e90aca3074ceca90da463f406d047dfa?s=32&&d=blank)\n\n3+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - Creating .d.ts Files from .js files","description":"How to add d.ts generation to JavaScript projects","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","title":"TypeScript: Documentation - Creating .d.ts Files from .js files","theme-color":"#3178C6","og:title":"Documentation - Creating .d.ts Files from .js files","og:description":"How to add d.ts generation to JavaScript projects","twitter:site":"typescriptlang","ogDescription":"How to add d.ts generation to JavaScript projects","scrapeId":"90a378d2-21b2-41a6-a785-3f7bc354dd1b","sourceURL":"https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html","url":"https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nJSDoc Reference\n===============\n\nThe list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.\n\nNote:\n\n*   Any tags which are not explicitly listed below (such as `@async`) are not yet supported.\n*   Only documentation tags are supported in TypeScript files. The rest of the tags are only supported in JavaScript files.\n\n#### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#types)\nTypes\n\n*   [`@type`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#type)\n    \n*   [`@import`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import)\n    \n*   [`@param`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#param-and-returns)\n     (or [`@arg`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#param-and-returns)\n     or [`@argument`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#param-and-returns)\n    )\n*   [`@returns`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#param-and-returns)\n     (or [`@return`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#param-and-returns)\n    )\n*   [`@typedef`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#typedef-callback-and-param)\n    \n*   [`@callback`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#typedef-callback-and-param)\n    \n*   [`@template`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#template)\n    \n*   [`@satisfies`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#satisfies)\n    \n\n#### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#classes)\nClasses\n\n*   [Property Modifiers](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#property-modifiers)\n     `@public`, `@private`, `@protected`, `@readonly`\n*   [`@override`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#override)\n    \n*   [`@extends`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#extends)\n     (or [`@augments`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#extends)\n    )\n*   [`@implements`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#implements)\n    \n*   [`@class`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#constructor)\n     (or [`@constructor`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#constructor)\n    )\n*   [`@this`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#this)\n    \n\n#### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#documentation)\nDocumentation\n\nDocumentation tags work in both TypeScript and JavaScript.\n\n*   [`@deprecated`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#deprecated)\n    \n*   [`@see`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#see)\n    \n*   [`@link`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#link)\n    \n\n#### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#other)\nOther\n\n*   [`@enum`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#enum)\n    \n*   [`@author`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#author)\n    \n*   [Other supported patterns](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#other-supported-patterns)\n    \n*   [Unsupported patterns](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#unsupported-patterns)\n    \n*   [Unsupported tags](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#unsupported-tags)\n    \n\nThe meaning is usually the same, or a superset, of the meaning of the tag given at [jsdoc.app](https://jsdoc.app/)\n. The code below describes the differences and gives some example usage of each tag.\n\n**Note:** You can use [the playground to explore JSDoc support](https://www.typescriptlang.org/play?useJavaScript=truee=4#example/jsdoc-support)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#types-1)\nTypes\n-----------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#type)\n`@type`\n\nYou can reference types with the “@type” tag. The type can be:\n\n1.  Primitive, like `string` or `number`.\n2.  Declared in a TypeScript declaration, either global or imported.\n3.  Declared in a JSDoc [`@typedef`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#typedef-callback-and-param)\n     tag.\n\nYou can use most JSDoc type syntax and any TypeScript syntax, from [the most basic like `string`](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)\n to [the most advanced, like conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)\n.\n\njs\n\n`   /**   * @type {string}   */  var s;  /** @type {Window} */  var win;  /** @type {PromiseLike<string>} */  var promisedString;  // You can specify an HTML Element with DOM properties  /** @type {HTMLElement} */  var myElement = document.querySelector(selector);  element.dataset.myData = \"\";   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4Gd4CcCWAdgOYC+UIw4AbgIa6RYDc44oMCK6GA6kQCYB7AO6loVOg2FEWbMHCRpMABVyCAtviyoAMvgDWqADw4CJAHxjKNepGRrN2-gGU8RYrODBIATUEBXSABjWkJGNCD8ADNESFDIAAkAFQBZHUgAUQAbVHVUQnhIaXgAC0gAEQB5FLs1NFx4fFQsOQ5FbmS07Nz8+CsJW3VEbryCyABeSCEg-1H4ADoAR39UXERnVByg+EFcAAptLZ3cAEoWTZ6C+f5aeFptBaHy29oJyAAid6YgA)\n\n`@type` can specify a union type — for example, something can be either a string or a boolean.\n\njs\n\n`   /**   * @type {string | boolean}   */  var sb;   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4Gd4CcCWAdgOaQA+kARgPbUA2qAhoQL5QjDgBujukWlANxA)\n\nYou can specify array types using a variety of syntaxes:\n\njs\n\n`   /** @type {number[]} */  var ns;  /** @type {Array.<number>} */  var jsdoc;  /** @type {Array<number>} */  var nas;   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeA7ArgWwEaIE4DaAugL7gjABQAbgIb7hoDOA3FaBDAsigIL58dWADoAPJlwEAfOUq0G4AFbMAJgHsAxu05Q4SVAKGwJ2PPlkVq9RmjpsgA)\n\nYou can also specify object literal types. For example, an object with properties ‘a’ (string) and ‘b’ (number) uses the following syntax:\n\njs\n\n`   /** @type {{ a: string, b: number }} */  var var9;   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeLwEMBc4DO0AnASwDsBzAGnACMcSBXAW2sQPAF93wRgAoANwxtBBAJwBuIA)\n\nYou can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax.\n\njs\n\n``   /**   * A map-like object that maps arbitrary `string` properties to `number`s.   *   * @type {Object.<string, number>}   */  var stringToNumber;  /** @type {Object.<number, object>} */  var arrayLike;   ``[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUhBSC2BDADgWgDYEsDWBTSAewCMArPAYwBdIqALJG5FAZ0iQCdisqPOBPSAAMWvLADsA5kMgoOhFHg5UseNlULDxAVwTElIgHRQI0SAAEq-RZADeAeTKUqhgDyiOEyQBpIOvUoAfAC+JsDgAG6ckB5eACqEAHK6+hwA3ODgoDCW1gQOTtRu-qm+JOTUIdDhURzsHHz8ADK4eGlAA)\n\nThe preceding two types are equivalent to the TypeScript types `{ [x: string]: number }` and `{ [x: number]: any }`. The compiler understands both syntaxes.\n\nYou can specify function types using either TypeScript or Google Closure syntax:\n\njs\n\n`   /** @type {function(string, boolean): number} Closure syntax */  var sbn;  /** @type {(s: string, b: boolean) => number} TypeScript syntax */  var sbn2;   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeAzArgOwMbQJYD2WAFAM7QBO+WA5gDTgBGhhANogIZYCUAXOCwYAtk0SUAvuADCbQmQyVkZWFmicAHuBDAAUADdOlcGSZYA3LtAQYCZCnICK1OoyYCW7Lr3ABeAHyCImKS4AAqdgDKONTw0Caq6lo6BkYmZgBM5kA)\n\nOr you can just use the unspecified `Function` type:\n\njs\n\n`   /** @type {Function} */  var fn7;  /** @type {function} */  var fn6;   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcE8AcCm4DeAxArgOwMbQJYD2WAvuCMAFABuAhgE7gBmWA7ANyWgQwLIpNseIqXJU6jFgDZ2QA)\n\nOther types from Closure also work:\n\njs\n\n`   /**   * @type {*} - can be 'any' type   */  var star;  /**   * @type {?} - unknown type (same as 'any')   */  var question;   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4gL6QLSQDGAhgHaQBG6A5GYtZEmlCMOAG7EBOkAzvNwDc4UBGhwm6DAH5cBAK6kA1qQD2Ad3KTIACl7EAtumK9ItUvQCULNpx4BHean4BLVaUFA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#casts)\nCasts\n\nTypeScript borrows cast syntax from Google Closure. This lets you cast types to other types by adding a `@type` tag before any parenthesized expression.\n\njs\n\n`   /**   * @type {number | string}   */  var numberOrString = Math.random() < 0.5 ? \"hello\" : 100;  var typeAssertedNumber = /** @type {number} */ (numberOrString);   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4DsCuBbAI1QCdIAfSAZ3mIEssBzAXyhGHADcBDU3QkgPLEAyjXoNIAXkgBZLvAAWAOmJcsAEwD2eABQBKSAB5IABiUBWSAH5IAIgWoANo823IALkgBGEyYDcnDyQSGgAgpSUJPCo6gBy+ESk0qAwCCjo2AkkTNDAkDp8iUKidIx6fkA)\n\nYou can even cast to `const` just like TypeScript:\n\njs\n\n`   let one = /** @type {const} */(1);   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBA9gdiEF4IHoBUqIAEwE8AO8A3gMawDOYAvhKsgBQCMAlANxA)\n\n#### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types)\nImport types\n\nYou can import declarations from other files using import types. This syntax is TypeScript-specific and differs from the JSDoc standard:\n\njs\n\n``   // @filename: types.d.ts  export type Pet = {    name: string,  };  // @filename: main.js  /**   * @param {import(\"./types\").Pet} p   */  function walk(p) {    console.log(`Walking ${p.name}...`);  }   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKALgTwA7wDOAdACYnZEBQ8AHvgPYBO2OB8oACvGwLygA3tVCgU6LEWzNoiAOYAaagF8A3NWogIMBOMyhUyWSQBWNYACoLIixHzJmaIdFRNWACgBEJYHkJFPAEoSHmxlUHwbYGpIAFdEAGNsaEZEUAB3ZFgAa3d8QKERUATUokYEElhGOXcAAwB1LOzZOVAAEkF8Ej1lEj7awPVlIA)\n\nimport types can be used to get the type of a value from a module if you don’t know the type, or if it has a large type that is annoying to type:\n\njs\n\n`   /**   * @type {typeof import(\"./accounts\").userAccount}   */  var x = require(\"./accounts\").userAccount;   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcE8AcFMDOAuUA7A9gE3gKBBAGYCWANvGgIYC28qlAxgxgK5qSIB0WnHu8AD1gYATpFDM0icS0TwRAQSat2oALygA3rlDoadUACIAcvsMAaHaEpYsIpCiMK012-cSILV4dMqkAwtgGhl66zGyQItCoIZa6sKSUaPCQMaGgiNDS8NRpcaAA5n6UAtFG6WzEAG7ycnm4AL4A3Phg4CTkVLSo1JTEaJwAVoitoAC0EwwskBNj+ABU8zrzEDAIWmvwGISgxNTCYgAUhpzAjOHsngCUnLLySheQDcvAuFWUIqAC6qD2AI4sYj2Y6nc4qDiGG53RTKCJNIA)\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import)\n`@import`\n\nThe `@import` tag can let us reference exports from other files.\n\njs\n\n`   /**   * @import {Pet} from \"./types\"   */  /**   * @type {Pet}   */  var myPet;  myPet.name;   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKALgTwA7wDOAdACYnZEBQ8AHvgPYBO2OB8oACvGwLygA3tVCgU6LEWzNoiAOYAaagF8A3NRAQYCcZlCpkskgCsamgLSWAxgFdsl8xoBUTkU4jRUTVkJ7ZloJDMjKigAEQkwHiERGFuwNTOrqDu4NGcgn7K8dQAbsjM+rh+6qjFvCS6qkA)\n\nThese tags don’t actually import files at runtime, and the symbols they bring into scope can only be used within JSDoc comments for type-checking.\n\njs\n\n`   // @filename: dog.js  export class Dog {    woof() {      console.log(\"Woof!\");    }  }  // @filename: main.js  /** @import { Dog } from \"./dog.js\" */  const d = new Dog(); // error!   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAJgewOYB0AVgM4BQ8AHgA64BOALqAMazKmmgAiBoA3uVCgA7rlyQAFAEoBQ4a1yJSuBIVgFJAIgDq4yAEIt0gNzyAvuUvkQEGAhTosqZNEQkKwAFReI0VHRMAjx85qCQ9LiooFqEwHhEZFqgXsDk5CxKpMzYoAC8oIjwIiH4MiagtvD0kfQGQA)\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#param-and-returns)\n`@param` and `@returns`\n\n`@param` uses the same type syntax as `@type`, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:\n\njs\n\n`   // Parameters may be declared in a variety of syntactic forms  /**   * @param {string}  p1 - A string param.   * @param {string=} p2 - An optional param (Google Closure syntax)   * @param {string} [p3] - Another optional param (JSDoc syntax).   * @param {string} [p4=\"test\"] - An optional param with a default value   * @returns {string} This is the result   */  function stringsStringStrings(p1, p2, p3, p4) {    // TODO  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAUEMCdIWwKYBcHQM6jpAnqARgqACYIDGANjAkaAJYB2okoAbjLcrgPYBmoa2ekkikktUqB5docNAChgAKkVzQi0AAEADjHigA3miTQGAcwC+oUFoCMoALSgAgv2NnruuADpV67Z4MjE3pTAF5LLQAmB2dGLi0xLnpIcg9YOFAACgBxLi5TckIAYXIuNABXaEIBIUgADwBKX00ddMC3EMsAbS0AZgBdGKd6LiQAC1RQeMTk1Na9TIApAGUAES4JGuFGnzUWgMMOi1AegBZQgCIUIwvBx2GphNoklLS9AHdacaZiBB5IcrkJCsFLlBDNDRVJCVegYQ7BY4AFTGtAwqNA40IVQqQN8wDkPHK9FEz0YQTMaGWRypCLQmVsABprJEmX1WacGgZVKAQKBEQB5Vb8uTmIA)\n\nLikewise, for the return type of a function:\n\njs\n\n`   /**   * @return {PromiseLike<string>}   */  function ps() {}  /**   * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'   */  function ab() {}   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAnApgFwK7wHaQN4AV4D2AtgJYDOiAMiQNaIA8Zy8JGA5gHwC+UIw4AM1QYAxshIEsABzIAKAJQ4e4UBGhwkaTGRzZIAQwBckJi3YAaSACNjGVESuJ4kLl0gBaSAFl9AT0ioFJAA5Ago6BhkwQY6AO6IADYJMSFhWhjBvPxCouKSBlYKSkA)\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#typedef-callback-and-param)\n`@typedef`, `@callback`, and `@param`\n\nYou can define complex types with `@typedef`. Similar syntax works with `@param`.\n\njs\n\n`   /**   * @typedef {Object} SpecialType - creates a new type named 'SpecialType'   * @property {string} prop1 - a string property of SpecialType   * @property {number} prop2 - a number property of SpecialType   * @property {number=} prop3 - an optional number property of SpecialType   * @prop {number} [prop4] - an optional number property of SpecialType   * @prop {number} [prop5=42] - an optional number property of SpecialType with default   */  /** @type {SpecialType} */  var specialTypeObject;  specialTypeObject.prop3;   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKYBNUDNIG8DyARgFaoDG8AvpAMppkCWAhgDYAqKqkAtJGQE6om8VAGdITSADtUAd0hI00pgFsMkAOR1yzdpw1QYsZPwD2afkjyj4-BlIDm1E+YCMPCZBt3HkFxatTHG1GVg40Qzh-VEtEPCkAVxVCGOczZAAmD0lE5Ji-dJjA4PpdcNRI40LY+KSU-gBeNPMAZmypSHN4BlMpVmk6-OiaoNpSsM5K-1q8-moAbX8AFgBdds7kbt7+3PqC8yK40ZCyyego9Jn6hf8AVgaljLXeJg6unr6WAdn9gKOSnQTJSyBjwAAWkEwWCYCRY8EMwHA4FARkUXFwJyBqGoIERADcmPwvOM9GgiKQKABucCiEnlcnkeAAOn8LUpQA)\n\nYou can use either `object` or `Object` on the first line.\n\njs\n\n`   /**   * @typedef {object} SpecialType1 - creates a new type named 'SpecialType1'   * @property {string} prop1 - a string property of SpecialType1   * @property {number} prop2 - a number property of SpecialType1   * @property {number=} prop3 - an optional number property of SpecialType1   */  /** @type {SpecialType1} */  var specialTypeObject1;   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKYBNUDNIG8D2ARgFaoDG8AvpAMppkCWAhgDYAqKqAjJALSRkATqibxUAZ0hNIAO1QB3SEjSymAWwyQA5HXLN2nLlqgxYyQfjSCkecfEEMZAc2rnLPftLsPnkN1Zt8HF1GVg40LhM4f1RrRDwZAFc1QljXC2QAJj4pWWTUwT8M2MDg+n1w7iizYriE-NiAXnTLAGYcphlIS3gGfBlWPJTYossS+KDacrDDE2BwcFBTZVQ8EIrDahB5gDcmQvFpgzQAeRJyeC4AbiA)\n\n`@param` allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:\n\njs\n\n`   /**   * @param {Object} options - The shape is the same as SpecialType above   * @param {string} options.prop1   * @param {number} options.prop2   * @param {number=} options.prop3   * @param {number} [options.prop4]   * @param {number} [options.prop5=42]   */  function special(options) {    return (options.prop4 || 1001) + options.prop5;  }   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAHAhgJ0QW0gbwPICMBWApgMYAuAvpAPbykCWVAdgM6QC0kAKgBaGTPdE8PnVale-dH0SsAysOJ1EAG04BPYZES4qAN0JQYCFOizNSyOowDmlGvSbMAdPGQ0AjIbhJUGTIwBXNFxCZDtaBhYXN3gAJi9jXyxA4NCAXnCHKNcaAGYEn1N-IJCwyABte0jnHPgAFgBdApM-FNLKSojHaJoAVjS62KboYHAAMwDGMkj+BSVlAAoqxwBKLChIZEJSAORGSCWu7Ji6yAAfM8h3AAZr9zWAamojmpjegG5wciA)\n\n`@callback` is similar to `@typedef`, but it specifies a function type instead of an object type:\n\njs\n\n`   /**   * @callback Predicate   * @param {string} data   * @param {number} [index]   * @returns {boolean}   */  /** @type {Predicate} */  const ok = (s) => !(s.length % 2);   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBBjAhgG2QI0fA1pACgJwFMATASyQBdCoZYAHRfRAW0gG8BnC-UgOwHMAvpGKIKiGnAZNWbXgFdmaQvmEBtPsUIAPALqTYRCvPy8O7NAHtLyQol6CawcOFC0KATzqF2BEuTFCYRBneEszCkhLHABeSAAKDgBKSBiAPkgAQkSAOlsBCgALSABSSAAmJIBuIA)\n\nOf course, any of these types can be declared using TypeScript syntax in a single-line `@typedef`:\n\njs\n\n`   /** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */  /** @typedef {(data: string, index?: number) => boolean} Predicate */   `\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#template)\n`@template`\n\nYou can declare type parameters with the `@template` tag. This lets you make functions, classes, or types that are generic:\n\njs\n\n`   /**   * @template T   * @param {T} x - A generic parameter that flows through to the return type   * @returns {T}   */  function id(x) {    return x;  }  const a = id(\"string\");  const b = id(123);  const c = id({});   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIBUoyyqYBOmykA3rgL6QAekAtJAIKQDmiAdoiQJYBjSMTLJESEpHgALbJABm6APYB3AM7SZJZQFcOM6cq2JIJCbpLdpAT1SICcc-EvdN1GgWDgFu7oPh+ZWt+ABMACnoASiooMwsrBgBucE9wQWD1eEhMSABeSDDwgCIsgW4OYqiUjLdsgCN8woiARgAmAGZq9Mzs4QKiyhpqoA)\n\nUse comma or multiple tags to declare multiple type parameters:\n\njs\n\n`   /**   * @template T,U,V   * @template W,X   */   `\n\nYou can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:\n\njs\n\n`   /**   * @template {string} K - K must be a string or string literal   * @template {{ serious(): string }} Seriousalizable - must have a serious method   * @param {K} key   * @param {Seriousalizable} object   */  function seriousalize(key, object) {    // ????  }   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIG8DO8ATgJYB2A5gL6QDSkAtHZMgK6GQBGikmkhpSpAD2RfsXIVI6EkiKZ0UGAhQZsPXLn6JSw9gAoAlAC5xgqVRoBlHST34FJAF6ZO6HkzYcAFpgBuPHz4tvYsiPDewgAmSnComPLIeLQ0ANaIAJ6xsPGJeDa67I4ubog0wpwAVogAxvBKwOAAZqxkdXZk2oUOMk6I+ukZADQiVbXwhnhQkMDAkAD8i-PgVEA)\n\nFinally, you can specify a default for a type parameter:\n\njs\n\n`   /** @template [T=object] */  class Cache {      /** @param {T} initial */      constructor(initial) {      }  }  let c = new Cache()   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEBcFMFsAOAbAhncBtAKgXgPYBGAVrAMbQC64IwAUGWgM5PgDCqZAFrOAN51wQ8KAiREqAE6p4-bAF9wASwB2S6EtTIa9YeDL4VTaJICuFfJIAUq9ZuQBKfoOHy6b5LGj7wucCtgAd3ZOHisHIA)\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#satisfies)\n`@satisfies`\n\n`@satisfies` provides access to the postfix [operator `satisfies`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html)\n in TypeScript. Satisfies is used to declare that a value implements a type but does not affect the type of the value.\n\njs\n\n`   // @ts-check  /**   * @typedef {\"hello world\" | \"Hello, world\"} WelcomeMessage   */  /** @satisfies {WelcomeMessage} */  const message = \"hello world\"            const message: \"hello world\"  /** @satisfies {WelcomeMessage} */  Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.1360Type '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.  const failingMessage = \"Hello world!\"  /** @type {WelcomeMessage} */  const messageUsingType = \"hello world\"                 const messageUsingType: WelcomeMessage   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwGYBsAGAUCBAC6IC0AxgBaTkDWBAVA3qA8QJ4AOkAJpAGagA3gCJqAG3FxQAdwTieI0AB9QIgBKRJcADSz5igL6gA6lvJwAtpACykRIgCGAc0gsGwPIzbgnRAJaI-P72wmbiFtZ2Di6Qxh54FgB2iESg1jGuoAC8ahJS+tAKIgRgoOWgAHoA-F7ATBB+gcGhQuGRtvZOrvGeyamg-I7+4v5JztHdkDlqmtqFCgCEJd4c3GHmVp2Zcax9cClpGVMAqohjzgAqXNO5YloFckWKpRXlNUA)\n\n[](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#classes-1)\nClasses\n---------------------------------------------------------------------------------------------\n\nClasses can be declared as ES6 classes.\n\njs\n\n`   class C {    /**     * @param {number} data     */    constructor(data) {      // property types can be inferred      this.name = \"foo\";      // or set explicitly      /** @type {string | null} */      this.title = null;      // or simply annotated, if they're set elsewhere      /** @type {number} */      this.size;      this.initialize(data); // Should error, initializer expects a string    }    /**     * @param {string} s     */    initialize = function (s) {      this.size = s.length;    };  }  var c = new C(0);  // C should only be called with new, but  // because it is JavaScript, this is allowed and  // considered an 'any'.  var result = C(1);   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8BQ1oHoBUGWo9AAgA5gBOYAtogHYCu5ARgKYkC+0AJmAC5g7QZocwAPZUIXEjWBdhJABSceASkR90aaIRLDCzLgE9oB3TGBgq0JtACWVAGbMSjdmq4ALaxAB0VCo2gAvNAARHbCwsEA3EhqaBqy0BCMXNCMAB6EINbA1lwg+rFYBMb+COIktgDm0AA+0LQgIGwCrh7eXLkg-kENINGx8SSJ1uSZhuZUwjxczgA0NnZGboz6AOROicmpIEkA7stOhXj4JdR0TKz8gqio7p5eENYAXoz9N0v3trnWYFkvCtwwEpIupoABlNzCGggdipEjaEjzL4dX7PZipDKMaQwMCJCRVHAsHCYbA3Y7EMiUMr4qiVNgQPgtVDIn5-brQOw0KjSayiaByCAqZDvO7eR4vQKJLxdWnuaKoFjRIlIABupGgwElVEYuzgcgADMCYnE4IlIdDYaJ8pZ-GZGs5oLtcm56jr5vQaFwkCamGYaEkbClPNAAFJgNVg4AVQhceaimw4xrCXYO8wuE0iMTWdjMVMWVbmNZeVXqpwQaEpIKwOQARmBQA)\n\nThey can also be declared as constructor functions; use [`@constructor`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#constructor)\n along with [`@this`](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#this)\n for this.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#property-modifiers)\nProperty Modifiers\n\n`@public`, `@private`, and `@protected` work exactly like `public`, `private`, and `protected` in TypeScript:\n\njs\n\n`  // @ts-check  class Car {    constructor() {      /** @private */      this.identifier = 100;    }    printIdentifier() {      console.log(this.identifier);    }  }  const c = new Car();  console.log(c.identifier);  Property 'identifier' is private and only accessible within class 'Car'.2341Property 'identifier' is private and only accessible within class 'Car'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAUCBAC6IC0AxgBaTkDWee5ANgIaKKgDCL0oA3nlChycAHaIi0AK7kiCABQBKfoKGhgAKg0QADtACWANxZFIoDcFVCilfYgB0+gCaRRRfQDN9MUAF5QOAAMgQDcqgC+DEJ6+m4Aki5unt7QSipqwmKIcEyQ9kxwAObyNnaOie5eMIphQpGRjFlEwn6gopAA7lw8SmEi4jl5BcXk5a6VKTVAA)\n\n*   `@public` is always implied and can be left off, but means that a property can be reached from anywhere.\n*   `@private` means that a property can only be used within the containing class.\n*   `@protected` means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.\n\n`@public`, `@private`, and `@protected` do not work in constructor functions.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#readonly)\n`@readonly`\n\nThe `@readonly` modifier ensures that a property is only ever written to during initialization.\n\njs\n\n`   // @ts-check  class Car {    constructor() {      /** @readonly */      this.identifier = 100;    }    printIdentifier() {      console.log(this.identifier);    }  }  const c = new Car();  console.log(c.identifier);   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUCBAC6IC0AxgBaTkDWee5ANgIaKKgDCL0oA3nlChycAHaIi0AK7kiCABQBKfoKGhgAKg0RokFgBMxTAJ6gNwVUKKUAlogB0N-ZFFEbAMxsxQAXlABGHBwAblUAXwYhAAdoG1cASWdXDy9oJRU1YTFEOCZIeyY4AHN5aztHJLdPGEVQoQiIxmyiYV9QUUgAdy4eJVCRcVz8wpLyCpcq1NqgA)\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#override)\n`@override`\n\n`@override` works the same way as in TypeScript; use it on methods that override a method from a base class:\n\njs\n\n`   export class C {    m() { }  }  class D extends C {    /** @override */    m() { }  }   `[Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAYwDYEMDOa4GE4G8BQccAtgBQCUecAvvrcupgCJygzAB2AJpjgUQHoAVELgABCADdgUKAEsuwOEIGESFKrWpA)\n\nSet `noImplicitOverride: true` in tsconfig to check overrides.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#extends)\n`@extends`\n\nWhen JavaScript classes extend a generic base class, there is no JavaScript syntax for passing a type argument. The `@extends` tag allows this:\n\njs\n\n`   /**   * @template T   * @extends {Set<T>}   */  class SortableSet extends Set {    // ...  }   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXApgWwA4BsCGTIBUoyyIAeSAdgCYDOkA3gMqLwA8uAfAL4HDgDGWVGvQD2AJ3iYARukSN4kEuWqQ5dKJGDBIAOl3gOQA)\n\nNote that `@extends` only works with classes. Currently, there is no way for a constructor function to extend a class.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#implements)\n`@implements`\n\nIn the same way, there is no JavaScript syntax for implementing a TypeScript interface. The `@implements` tag works just like in TypeScript:\n\njs\n\n`   /** @implements {Print} */  class TextBook {    print() {      // TODO    }  }   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEEsFsAcA2BTWyB2AXAzuA3gAoBO0WAvuCMAFADGiAhtrgCrIAemAQgPY8DW+auHDwSWABQBKISJHBg4FgHkAIsuHgy1MkA)\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#constructor)\n`@constructor`\n\nThe compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a `@constructor` tag:\n\njs\n\n`  /**   * @constructor   * @param {number} data   */  function C(data) {    // property types can be inferred    this.name = \"foo\";    // or set explicitly    /** @type {string | null} */    this.title = null;    // or simply annotated, if they're set elsewhere    /** @type {number} */    this.size;    this.initialize(data);  Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.  }  /**   * @param {string} s   */  C.prototype.initialize = function (s) {    this.size = s.length;  };  var c = new C(0);  c.size;  var result = C(1);  Value of type 'typeof C' is not callable. Did you mean to include 'new'?2348Value of type 'typeof C' is not callable. Did you mean to include 'new'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEGMAsFNINYCkDOAoEFYCdsHtsUAuUAJgGYAWAVjKoA4MAqJtUJiSPAOxQBdsAV0h8CbDuAAOAQ2zSAtqADe3QfIBGOAL6gAJtL7TxwNADNB3EQEseoAMIAKfYYCUytqEyT8knHwCeoAG+KKCQ0tygmqBW3KY42LC6HnzQVigAdNwKsKAAvKAARKZ4eIUA3GgemASgKLB8oLAAHpIANlaQVnxt-tUsEMG5SvzYsQDmoAA+oKptbTpMJqBBaZl83W25BXNtldVgtShW8u2BEdx4hnxJADQxpquw-gDkiXUNTW31AO5wif0JENlKoNNp2MtVukMscAF6wfYrVLQ2LdKzSDrwpwGaQuSpaZisdgQGRyRQjAQTHToCFoOwZbxXK7+XwZVEbDFWeH5UDmSwbWwOFBuJQpNYwrnbOoZLbccapfH7ABusjCPO4sB+9gcAAY8WhIBL4crVYkUII2o0Co4AIx4oA)\n\n> Note: Error messages only show up in JS codebases with [a JSConfig](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n>  and [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs)\n>  enabled.\n\nWith `@constructor`, `this` is checked inside the constructor function `C`, so you will get suggestions for the `initialize` method and an error if you pass it a number. Your editor may also show warnings if you call `C` instead of constructing it.\n\nUnfortunately, this means that constructor functions that are also callable cannot use `@constructor`.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#this)\n`@this`\n\nThe compiler can usually figure out the type of `this` when it has some context to work with. When it doesn’t, you can explicitly specify the type of `this` with `@this`:\n\njs\n\n`   /**   * @this {HTMLElement}   * @param {*} e   */  function callbackForLater(e) {    this.clientHeight = parseInt(e); // should be fine!  }   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAFgSwM6QN4AkAqBZAGQFEAbAUwFsyA7eAXyhlgAcBDAJ1YsxDsjMbBwAMwCu1AMbxkAe2qQJrEiQBGrCQGsAYjPYFW8MuwAUZAJSYokJGgB0EkshrwsZZAHNE8SAF5IbdlQyAElaUzMAbkhgYEhURBlREgATSBUySGFkajIAQnA6IA)\n\n[](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#documentation-1)\nDocumentation\n---------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#deprecated)\n`@deprecated`\n\nWhen a function, method, or property is deprecated you can let users know by marking it with a `/** @deprecated */` JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed in a strike-through style ~like this~.\n\njs\n\n`/** @deprecated */  const apiV1 = {};  const apiV2 = {};  apiV;       *   apiV1 *   apiV2`  [Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFDAFSYgEwKYAO8+AxgIYAu+uomwap0kKlo5hAlgGoCMoAXlABvAL4BuRs1bsu3AEyCREtGg49JIUAD0APqqA)\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#see)\n`@see`\n\n`@see` lets you link to other names in your program:\n\nts\n\n`   type Box<T> = { t: T }  /** @see Box for implementation details */  type Boxify<T> = { [K in keyof T]: Box<T> };   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeVgBcUKUAvgFAD0AVNVAAIDOE08CUAZnAE5QCWAWzAAbCAIgA7YAENgfOBKgATCDL7DGUapXKhIsRHw4hUGbHgDaAaX6KA1hBBwOxALpE2psgG4gA)\n\nSome editors will turn `Box` into a link to make it easy to jump there and back.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#link)\n`@link`\n\n`@link` is like `@see`, except that it can be used inside other tags:\n\nts\n\n`   type Box<T> = { t: T }  /** @returns A {@link Box} containing the parameter. */  function box<U>(u: U): Box<U> {    return { t: u };  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeVgBcUKUAvgFAD0AVNVAAIBOEwArowHYDOUAgrvQA2ASw4BrWIlJQAxnA7AAhqNEBzfAAtoYRY0UBbFhEYA6KNUrkAZqw4zgw+VABGiJAFU0AClZF3ASiJ4ZE9ccigoZjZOXHwiVjIAbnJSIA)\n\nYou can also link a property:\n\nts\n\n`   type Pet = {    name: string    hello: () => string  }  /**   * Note: you should implement the {@link Pet.hello} method of Pet.   */  function hello(p: Pet) {    p.hello()  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChxQLxQN4CgpQHYEMC2EAXFAM7ABOAllgOYZQAWEANswPbEAUAlEgHykK1OgF80aAPQAqKRilQAcm2BEoINgFdSDTcwAmUSnjDMIBLAmBNUAAWbUA1rHgA6JqzYioBK2wNsAM2dgFzkJNACNLABjYEo2LEYWdk4wYjhgXnRMMDdkth40ESA)\n\nOr with an optional name:\n\nts\n\n`   type Pet = {    name: string    hello: () => string  }  /**   * Note: you should implement the {@link Pet.hello | hello} method of Pet.   */  function hello(p: Pet) {    p.hello()  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChxQLxQN4CgpQHYEMC2EAXFAM7ABOAllgOYZQAWEANswPbEAUAlEgHykK1OgF80aAPQAqKRilQAcm2BEoINgFdSDTcwAmUSnjDMIBLAmBNUAAWbUA1rHgA6JqzZQAPoxbsRUARWbAZsAGbOwC5yEmhhGlgAxsCUbFi+HpxgxHDAvOiYYG5+bDxoIkA)\n\n[](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#other-1)\nOther\n-----------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#enum)\n`@enum`\n\nThe `@enum` tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in JavaScript, it does not allow other members. `@enum` is intended for compatibility with Google Closure’s `@enum` tag.\n\njs\n\n`   /** @enum {number} */  const JSDocState = {    BeginningOfLine: 0,    SawAsterisk: 1,    SavingComments: 2,  };  JSDocState.SawAsterisk;   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEFMDsFcC24DeDECNoCcC+4RgAoAYwHtYBnAF3ACkBlAETJIeoENrpwBeVIuHAAhaAHMAlrFhSxAeQBmAGSnQAXOAAMAGkHgGHAO4BBGjgmUA1hoCMuoQYBusgMJlEiONUoaATLtwAbiIiRhY2Tm4AOgMTM2wLS0CgA)\n\nNote that `@enum` is quite different from, and much simpler than, TypeScript’s `enum`. However, unlike TypeScript’s enums, `@enum` can have any type:\n\njs\n\n`   /** @enum {function(number): number} */  const MathFuncs = {    add1: (n) => n + 1,    id: (n) => -n,    sub1: (n) => n - 1,  };  MathFuncs.add1;   `[Try](https://www.typescriptlang.org/play/#code/PQKhAIAEFMDsFcC24DeAzesDGAXAlgPawAUCiARtAE4CUAXOGZVQL7gjABQWRAzjuACyAQxwALAGKYsvcAF5UncOGEATVQEYGpGvIB8jcAGpwGgDRLweVdti65BgLSwLy3vHJbwO-YcemLFgBuTk4RcSlsXgA6NU0goA)\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#author)\n`@author`\n\nYou can specify the author of an item with `@author`:\n\nts\n\n`   /**   * Welcome to awesome.ts   * @author Ian Awesome <i.am.awesome@example.com>   */   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUh1BTANgYwPYFt6QC6sgQwHd4BnDeAOmxKhgAF8BXbAC1QCdIBJfAO0gCCxMpkgAeAJYV86acPJ14ADxkAHRJTToAfLWBA)\n\nRemember to surround the email address with angle brackets. Otherwise, `@example` will be parsed as a new tag.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#other-supported-patterns)\nOther supported patterns\n\njs\n\n`   var someObj = {    /**     * @param {string} param1 - JSDocs on property assignments work     */    x: function (param1) {},  };  /**   * As do jsdocs on variable assignments   * @return {Window}   */  let someFunc = function () {};  /**   * And class methods   * @param {string} greeting The greeting to use   */  Foo.prototype.sayHi = (greeting) => console.log(\"Hi!\");  /**   * And arrow function expressions   * @param {number} x - A multiplier   */  let myArrow = (x) => x * x;  /**   * Which means it works for function components in JSX too   * @param {{a: string, b: number}} props - Some param   */  var fc = (props) => <div>{props.a.charAt(0)}</div>;  /**   * A parameter can be a class constructor, using Google Closure syntax.   *   * @param {{new(...args: any[]): object}} C - The class to register   */  function registerClass(C) {}  /**   * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')   */  function fn10(p1) {}  /**   * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')   */  function fn9(p1) {    return p1.join();  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEBcE8AcFMDOAuUAneBDAxpAUNgDaaKKgBiA9paAN4C+eIoAtG9gK6Rst4BumNKESUAtvADyAIwBWoALx08oUMABUa5SrURYgzKLqJIaAJYA7AOb1QetAYCMrUACkAygBFK2MpXO20SgQ0GFASRFNLc3FzSDIAd0o0AGstUDVgLQAPVAAzDnNcUz9QAAo7RwBKOnoAGjx6AG48Jg1lHQBBMgATGhlEXp9QEoEzTClCeDDSSOj4WMR2iAxIDjR-WgB1C174xnTMychhMXhyAuwFUHzCyGL-UuqGZtbNdNAO827QInDQcUgAAtKN1Fu9wBVDLRjGYrDZLBh4HcrKAACqAqYI+BIiyWUCQGgcRDwdqZKiUAB0sECBJgCApiEw0AAEqYrqUsTirNV5AA+H5+ESTCmESiWUoAIlZAEIJZUXuo3p0vmE0IF4tcLncSvAstSkBFBUsIfooeYOKIpPA0DYss4Ov8OIQ7rBCKZraS8Ed-tAOmrKBrFKUsjz+XadFkFW13ptAaZsID-lhzGRTMdEikyLkkprbvcBaJYH55nFQBZXG4ABr46jGyF0WiYVAw3G1UBSVDmy3W+g2alBMgsUBuU62U2e0bXS5B-uwRCh0AAHm6pj4vNos8QFMwFITgg6kFKAAZKvRF8AV2uo0qPmP7ADrT9MP4rWEfsRSAKUyYOLgkm2iVxUAAHFqEsSZQAAYVFRA1imRBoFiTAsgpdo61NBtzHgeJSgpPDBEsFAwnMaAAG0AF1KlQShZHgXBeyg5x0SmX5PwJdB4EsUxjA9A48BuIoSgwLieLQaDwlKSCnkYV50PvOg8IZExcT7JwhwdAByDBjA01U8VKQR7GgapKFyYRlKsLcyhMLBIHgb4SFADTn2gDTKk9ATtX8XJzAcI9ygcaSWkVOSDAUvCWzhWw1NvLSkEgXSCLKQymRMszIsIilrIwTA7IcshnJItyPK1fMfIATgCp4tBWNZ-FgBwKRkSgLEeZp6CAA)\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#unsupported-patterns)\nUnsupported patterns\n\nPostfix equals on a property type in an object literal type doesn’t specify an optional property:\n\njs\n\n`   /**   * @type {{ a: string, b: number= }}   */  var wrong;  /**   * Use postfix question on the property name instead:   * @type {{ a: string, b?: number }}   */  var right;   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4cgQwFyQDO8ATgJYB2A5gDSQBGBFArgLb2okC8kAvr1BDBwANxwlIAdxIB7agG5woCNEgBVQumQziAMzIAPSAEdmqYmTmQr8ABZbZaEkkgUcrdJWKocAEzyCcEhomNj4RKSUtAwA-ExsHBL8gsJiEuRUtvDyQA)\n\nNullable types only have meaning if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n is on:\n\njs\n\n`   /**   * @type {?number}   * With strictNullChecks: true  -- number | null   * With strictNullChecks: false -- number   */  var nullable;   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4H4B2BXAWwCNUAnAXyhgHUBLeAC0gGd5TaBjeAOTwBs+AYQaoOAa2YAuSGzzpIAWgWR8xMpAA+K-nyqQ6jFm048dw0ROkAzAIZ9m6JdrWkqwcADcbpbQJtE+VABuIA)\n\nThe TypeScript-native syntax is a union type:\n\njs\n\n`   /**   * @type {number | null}   * With strictNullChecks: true  -- number | null   * With strictNullChecks: false -- number   */  var unionNullable;   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4DsCuBbAI1QCdIAfSXAGyoF8oYB1AS3gAtIBneY5gY3gA5HDQDCbVHwDWnAFyQeOdJAC0KyviKkK1Kg0gt2XHvyEiq4yTPkAzAIZVO6NRsIkGwcADc7pHFmYAeyxhGjsCKlQAbiA)\n\nNon-nullable types have no meaning and are treated just as their original type:\n\njs\n\n`   /**   * @type {!number}   * Just has type number   */  var normal;   `[Try](https://www.typescriptlang.org/play/#code/PQKhCgAIUgBAXAngBwKaQN4EIB2BXAWwCNUAnAXyhgCk8BneSACwEM7Ik1J9iyrhwANxaluAe1IEWAGwDcQA)\n\nUnlike JSDoc’s type system, TypeScript only allows you to mark types as containing null or not. There is no explicit non-nullability — if strictNullChecks is on, then `number` is not nullable. If it is off, then `number` is nullable.\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#unsupported-tags)\nUnsupported tags\n\nTypeScript ignores any unsupported JSDoc tags.\n\nThe following tags have open issues to support them:\n\n*   `@memberof` ([issue #7237](https://github.com/Microsoft/TypeScript/issues/7237)\n    )\n*   `@yields` ([issue #23857](https://github.com/Microsoft/TypeScript/issues/23857)\n    )\n*   `@member` ([issue #56674](https://github.com/microsoft/TypeScript/issues/56674)\n    )\n\n### [](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#legacy-type-synonyms)\nLegacy type synonyms\n\nA number of common types are given aliases for compatibility with old JavaScript code. Some of the aliases are the same as existing types, although most of those are rarely used. For example, `String` is treated as an alias for `string`. Even though `String` is a type in TypeScript, old JSDoc often uses it to mean `string`. Besides, in TypeScript, the capitalized versions of primitive types are wrapper types — almost always a mistake to use. So the compiler treats these types as synonyms based on usage in old JSDoc:\n\n*   `String -> string`\n*   `Number -> number`\n*   `Boolean -> boolean`\n*   `Void -> void`\n*   `Undefined -> undefined`\n*   `Null -> null`\n*   `function -> Function`\n*   `array -> Array<any>`\n*   `promise -> Promise<any>`\n*   `Object -> any`\n*   `object -> any`\n\nThe last four aliases are turned off when `noImplicitAny: true`:\n\n*   `object` and `Object` are built-in types, although `Object` is rarely used.\n*   `array` and `promise` are not built-in, but might be declared somewhere in your program.\n\n[### Type Checking JavaScript Files\\\n\\\nHow to add type checking to JavaScript files using TypeScript](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)\n\n[### Creating .d.ts Files from .js files\\\n\\\nHow to add d.ts generation to JavaScript projects](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/javascript/JSDoc%20Reference.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (23)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nNS![Nathan Shively-Sanders  (7)](https://gravatar.com/avatar/e9fe6e0aece8151e38b2061705ff728edabbca6ae9a3e1c463996a8a5810cc73?s=32&&d=blank)\n\nRG![Rohit Gohri  (2)](https://gravatar.com/avatar/5b722ab3660f1678d94ee024088da3e15c8322062836c3fc107c82510096b25e?s=32&&d=blank)\n\nR![reillylm  (1)](https://gravatar.com/avatar/1322845529877ed57eca5ea1e9b02ebf1f0d1af52e058d23fe162ceb454c64c3?s=32&&d=blank)\n\nRH![Remco Haszing  (1)](https://gravatar.com/avatar/9b274b72a63c2236ba08b9928fdefb02c1f99bc528a5043159d628cf3b34c88b?s=32&&d=blank)\n\n11+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"What JSDoc does TypeScript-powered JavaScript support?","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:description":"What JSDoc does TypeScript-powered JavaScript support?","og:title":"Documentation - JSDoc Reference","language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"What JSDoc does TypeScript-powered JavaScript support?","generator":"Gatsby 5.13.5","twitter:site":"typescriptlang","title":"TypeScript: Documentation - JSDoc Reference","ogTitle":"Documentation - JSDoc Reference","theme-color":"#3178C6","scrapeId":"771dffd6-65ba-409c-881c-29206d44b13b","sourceURL":"https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html","url":"https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 5.8\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#granular-checks-for-branches-in-return-expressions)\nGranular Checks for Branches in Return Expressions\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nConsider some code like the following:\n\nts\n\n`   declare const untypedCache: Map<any, any>;  function getUrlObject(urlString: string): URL {      return untypedCache.has(urlString) ?          untypedCache.get(urlString) :          urlString;  }   `\n\nThe intent of this code is to retrieve a URL object from a cache if it exists, or to create a new URL object if it doesn’t. However, there’s a bug: we forgot to actually construct a new URL object with the input. Unfortunately, TypeScript generally didn’t catch this sort of bug.\n\nWhen TypeScript checks conditional expressions like `cond ? trueBranch : falseBranch`, its type is treated as a union of the types of the two branches. In other words, it gets the type of `trueBranch` and `falseBranch`, and combines them into a union type. In this case, the type of `untypedCache.get(urlString)` is `any`, and the type of `urlString` is `string`. This is where things go wrong because `any` is so infectious in how it interacts with other types. The union `any | string` is simplified to `any`, so by the time TypeScript starts checking whether the expression in our `return` statement is compatible with the expected return type of `URL`, the type system has lost any information that would have caught the bug in this code.\n\nIn TypeScript 5.8, the type system special-cases conditional expressions directly inside `return` statements. Each branch of the conditional is checked against the declared return type of the containing functions (if one exists), so the type system can catch the bug in the example above.\n\nts\n\n`   declare const untypedCache: Map<any, any>;  function getUrlObject(urlString: string): URL {      return untypedCache.has(urlString) ?          untypedCache.get(urlString) :          urlString;      //  ~~~~~~~~~      // error! Type 'string' is not assignable to type 'URL'.  }   `\n\nThis change was made [within this pull request](https://github.com/microsoft/TypeScript/pull/56941)\n, as part of a broader set of future improvements for TypeScript.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#support-for-require-of-ecmascript-modules-in---module-nodenext)\nSupport for `require()` of ECMAScript Modules in `--module nodenext`\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nFor years, Node.js supported ECMAScript modules (ESM) alongside CommonJS modules. Unfortunately, the interoperability between the two had some challenges.\n\n*   ESM files could `import` CommonJS files\n*   CommonJS files _**could not**_ `require()` ESM files\n\nIn other words, consuming CommonJS files from ESM files was possible, but not the other way around. This introduced many challenges for library authors who wanted to provide ESM support. These library authors would either have to break compatibility with CommonJS users, “dual-publish” their libraries (providing separate entry-points for ESM and CommonJS), or just stay on CommonJS indefinitely. While dual-publishing might sound like a good middle-ground, it is a complex and error-prone process that also roughly doubles the amount of code within a package.\n\nNode.js 22 relaxes some of these restrictions and permits `require(\"esm\")` calls from CommonJS modules to ECMAScript modules. Node.js still does not permit `require()` on ESM files that contain a top-level `await`, but most other ESM files are now consumable from CommonJS files. This presents a major opportunity for library authors to provide ESM support without having to dual-publish their libraries.\n\nTypeScript 5.8 supports this behavior under the `--module nodenext` flag. When `--module nodenext` is enabled, TypeScript will avoid issuing errors on these `require()` calls to ESM files.\n\nBecause this feature may be back-ported to older versions of Node.js, there is currently no stable `--module nodeXXXX` option that enables this behavior; however, we predict future versions of TypeScript may be able to stabilize the feature under `node20`. In the meantime, we encourage users of Node.js 22 and newer to use `--module nodenext`, while library authors and users of older Node.js versions should remain on `--module node16` (or make the minor update to [`--module node18`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#--module-node18)\n).\n\nFor more information, [see our support for require(“esm”) here](https://github.com/microsoft/TypeScript/pull/60761)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#--module-node18)\n`--module node18`\n--------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.8 introduces a stable `--module node18` flag. For users who are fixed on using Node.js 18, this flag provides a stable point of reference that does not incorporate certain behaviors that are in `--module nodenext`. Specifically:\n\n*   `require()` of ECMAScript modules is disallowed under `node18`, but allowed under `nodenext`\n*   import assertions (deprecated in favor of import attributes) are allowed under `node18`, but are disallowed under `nodenext`\n\nSee more at both [the `--module node18` pull request](https://github.com/microsoft/TypeScript/pull/60722)\n and [changes made to `--module nodenext`](https://github.com/microsoft/TypeScript/pull/60761)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#the---erasablesyntaxonly-option)\nThe `--erasableSyntaxOnly` Option\n----------------------------------------------------------------------------------------------------------------------------------------------------\n\nRecently, Node.js 23.6 unflagged [experimental support for running TypeScript files directly](https://nodejs.org/api/typescript.html#type-stripping)\n; however, only certain constructs are supported under this mode. Node.js has unflagged a mode called `--experimental-strip-types` which requires that any TypeScript-specific syntax cannot have runtime semantics. Phrased differently, it must be possible to easily _erase_ or “strip out” any TypeScript-specific syntax from a file, leaving behind a valid JavaScript file.\n\nThat means constructs like the following are not supported:\n\n*   `enum` declarations\n*   `namespace`s and `module`s with runtime code\n*   parameter properties in classes\n*   Non-ECMAScript `import =` and `export =` assignments\n\nHere are some examples of what does not work:\n\nts\n\n``   // ❌ error: An `import ... = require(...)` alias  import foo = require(\"foo\");  // ❌ error: A namespace with runtime code.  namespace container {  }  // ❌ error: An `import =` alias  import Bar = container.Bar;  class Point {      // ❌ error: Parameter properties      constructor(public x: number, public y: number) { }  }  // ❌ error: An `export =` assignment.  export = Point;  // ❌ error: An enum declaration.  enum Direction {      Up,      Down,      Left,      Right,  }   ``\n\nSimilar tools like [ts-blank-space](https://github.com/bloomberg/ts-blank-space)\n or [Amaro](https://github.com/nodejs/amaro)\n (the underlying library for type-stripping in Node.js) have the same limitations. These tools will provide helpful error messages if they encounter code that doesn’t meet these requirements, but you still won’t find out your code doesn’t work until you actually try to run it.\n\nThat’s why TypeScript 5.8 introduces the `--erasableSyntaxOnly` flag. When this flag is enabled, TypeScript will error on most TypeScript-specific constructs that have runtime behavior.\n\nts\n\n`   class C {      constructor(public x: number) { }      //          ~~~~~~~~~~~~~~~~      // error! This syntax is not allowed when 'erasableSyntaxOnly' is enabled.      }  }   `\n\nTypically, you will want to combine this flag with the `--verbatimModuleSyntax`, which ensures that a module contains the appropriate import syntax, and that import elision does not take place.\n\nFor more information, [see the implementation here](https://github.com/microsoft/TypeScript/pull/61011)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#the---libreplacement-flag)\nThe `--libReplacement` Flag\n----------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 4.5, we introduced the possibility of substituting the default `lib` files with custom ones. This was based on the possibility of resolving a library file from packages named `@typescript/lib-*`. For example, you could lock your `dom` libraries onto a specific version of [the `@types/web` package](https://www.npmjs.com/package/@types/web?activeTab=readme)\n with the following `package.json`:\n\njson\n\n`   {      \"devDependencies\": {         \"@typescript/lib-dom\": \"npm:@types/web@0.0.199\"       }  }   `\n\nWhen installed, a package called `@typescript/lib-dom` should exist, and TypeScript will currently always look it up when `dom` is implied by your settings.\n\nThis is a powerful feature, but it also incurs a bit of extra work. Even if you’re not using this feature, TypeScript always performs this lookup, and has to watch for changes in `node_modules` in case a `lib`\\-replacement package _begins_ to exist.\n\nTypeScript 5.8 introduces the `--libReplacement` flag, which allows you to disable this behavior. If you’re not using `--libReplacement`, you can now disable it with `--libReplacement false`. In the future `--libReplacement false` may become the default, so if you currently rely on the behavior you should consider explicitly enabling it with `--libReplacement true`.\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/issues/61023)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#preserved-computed-property-names-in-declaration-files)\nPreserved Computed Property Names in Declaration Files\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn an effort to make computed properties have more predictable emit in declaration files, TypeScript 5.8 will consistently preserve entity names (`bareVariables` and `dotted.names.that.look.like.this`) in computed property names in classes.\n\nFor example, consider the following code:\n\nts\n\n`   export let propName = \"theAnswer\";  export class MyClass {      [propName] = 42;  //  ~~~~~~~~~~  // error!  // A computed property name in a class property declaration must have a simple literal type or a 'unique symbol' type.  }   `\n\nPrevious versions of TypeScript would issue an error when generating a declaration file for this module, and a best-effort declaration file would generate an index signature.\n\nts\n\n`   export declare let propName: string;  export declare class MyClass {      [x: string]: number;  }   `\n\nIn TypeScript 5.8, the example code is now allowed, and the emitted declaration file will match what you wrote:\n\nts\n\n`   export declare let propName: string;  export declare class MyClass {      [propName]: number;  }   `\n\nNote that this does not create statically-named properties on the class. You’ll still end up with what is effectively an index signature like `[x: string]: number`, so for that use case, you’d need to use `unique symbol`s or literal types.\n\nNote that writing this code was and currently is an error under the `--isolatedDeclarations` flag; but we expect that thanks to this change, computed property names will generally be permitted in declaration emit.\n\nNote that it’s possible (though unlikely) that a file compiled in TypeScript 5.8 may generate a declaration file that is not backward compatible in TypeScript 5.7 or earlier.\n\nFor more information, [see the implementing PR](https://github.com/microsoft/TypeScript/pull/60052)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#optimizations-on-program-loads-and-updates)\nOptimizations on Program Loads and Updates\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.8 introduces a number of optimizations that can both improve the time to build up a program, and also to update a program based on a file change in either `--watch` mode or editor scenarios.\n\nFirst, TypeScript now [avoids array allocations that would be involved while normalizing paths](https://github.com/microsoft/TypeScript/pull/60812)\n. Typically, path normalization would involve segmenting each portion of a path into an array of strings, normalizing the resulting path based on relative segments, and then joining them back together using a canonical separator. For projects with many files, this can be a significant and repetitive amount of work. TypeScript now avoids allocating an array, and operates more directly on indexes of the original path.\n\nAdditionally, when edits are made that don’t change the fundamental structure of a project, [TypeScript now avoids re-validating the options provided to it](https://github.com/microsoft/TypeScript/pull/60754)\n (e.g. the contents of a `tsconfig.json`). This means, for example, that a simple edit might not require checking that the output paths of a project don’t conflict with the input paths. Instead, the results of the last check can be used. This should make edits in large projects feel more responsive.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#notable-behavioral-changes)\nNotable Behavioral Changes\n----------------------------------------------------------------------------------------------------------------------------------------\n\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#libdts)\n`lib.d.ts`\n\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, [see linked issues related to DOM and `lib.d.ts` updates for this version of TypeScript](https://github.com/microsoft/TypeScript/issues/60985)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#restrictions-on-import-assertions-under---module-nodenext)\nRestrictions on Import Assertions Under `--module nodenext`\n\nImport assertions were a proposed addition to ECMAScript to ensure certain properties of an import (e.g. “this module is JSON, and is not intended to be executable JavaScript code”). They were reinvented as a proposal called [import attributes](https://github.com/tc39/proposal-import-attributes)\n. As part of the transition, they swapped from using the `assert` keyword to using the `with` keyword.\n\nts\n\n`   // An import assertion ❌ - not future-compatible with most runtimes.  import data from \"./data.json\" assert { type: \"json\" };  // An import attribute ✅ - the preferred way to import a JSON file.  import data from \"./data.json\" with { type: \"json\" };   `\n\nNode.js 22 no longer accepts import assertions using the `assert` syntax. In turn when `--module nodenext` is enabled in TypeScript 5.8, TypeScript will issue an error if it encounters an import assertion.\n\nts\n\n`   import data from \"./data.json\" assert { type: \"json\" };  //                             ~~~~~~  // error! Import assertions have been replaced by import attributes. Use 'with' instead of 'assert'   `\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/60761)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%205.8.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (6)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:description":"TypeScript 5.8 Release Notes","language":"en","twitter:site":"typescriptlang","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"TypeScript 5.8 Release Notes","theme-color":"#3178C6","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"TypeScript 5.8 Release Notes","title":"TypeScript: Documentation - TypeScript 5.8","ogTitle":"Documentation - TypeScript 5.8","generator":"Gatsby 5.13.5","og:title":"Documentation - TypeScript 5.8","scrapeId":"9f6fab9c-287f-4d76-81fe-12a621f7fe62","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nCompiler Options in MSBuild\n===========================\n\n[](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#overview)\nOverview\n---------------------------------------------------------------------------------------------------\n\nWhen you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways. Either via a `tsconfig.json` or via the project settings.\n\n[](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#using-a-tsconfigjson)\nUsing a `tsconfig.json`\n------------------------------------------------------------------------------------------------------------------------------\n\nWe recommend using a `tsconfig.json` for your project when possible. To add one to an existing project, add a new item to your project which is called a “TypeScript JSON Configuration File” in modern versions of Visual Studio.\n\nThe new `tsconfig.json` will then be used as the source of truth for TypeScript-specific build information like files and configuration. You can learn [about how TSConfigs works here](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n and there is a [comprehensive reference here](https://www.typescriptlang.org/tsconfig)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#using-project-settings)\nUsing Project Settings\n-------------------------------------------------------------------------------------------------------------------------------\n\nYou can also define the configuration for TypeScript inside you project’s settings. This is done by editing the XML in your `.csproj` to define `PropertyGroups` which describe how the build can work:\n\nxml\n\n`   <PropertyGroup>    <TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError>    <TypeScriptNoImplicitReturns>true</TypeScriptNoImplicitReturns>  </PropertyGroup>   `\n\nThere is a series of mappings for common TypeScript settings, these are settings which map directly to [TypeScript cli options](https://www.typescriptlang.org/docs/handbook/compiler-options.html)\n and are used to help you write a more understandable project file. You can use the [TSConfig reference](https://www.typescriptlang.org/tsconfig)\n to get more information on what values and defaults are for each mapping.\n\n### CLI Mappings\n\n| MSBuild Config Name | TSC Flag |\n| --- | --- |\n| `<TypeScriptAllowJS>` | `[--allowJs](https://www.typescriptlang.org/tsconfig/#allowJs) ` |\n| Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. |     |     |\n| `<TypeScriptRemoveComments>` | `[--removeComments](https://www.typescriptlang.org/tsconfig/#removeComments) ` |\n| Disable emitting comments. |     |     |\n| `<TypeScriptNoImplicitAny>` | `[--noImplicitAny](https://www.typescriptlang.org/tsconfig/#noImplicitAny) ` |\n| Enable error reporting for expressions and declarations with an implied `any` type.. |     |     |\n| `<TypeScriptGeneratesDeclarations>` | `[--declaration](https://www.typescriptlang.org/tsconfig/#declaration) ` |\n| Generate .d.ts files from TypeScript and JavaScript files in your project. |     |     |\n| `<TypeScriptModuleKind>` | `[--module](https://www.typescriptlang.org/tsconfig/#module) ` |\n| Specify what module code is generated. |     |     |\n| `<TypeScriptJSXEmit>` | `[--jsx](https://www.typescriptlang.org/tsconfig/#jsx) ` |\n| Specify what JSX code is generated. |     |     |\n| `<TypeScriptOutDir>` | `[--outDir](https://www.typescriptlang.org/tsconfig/#outDir) ` |\n| Specify an output folder for all emitted files. |     |     |\n| `<TypeScriptSourceMap>` | `[--sourcemap](https://www.typescriptlang.org/tsconfig/#sourcemap) ` |\n| Create source map files for emitted JavaScript files. |     |     |\n| `<TypeScriptTarget>` | `[--target](https://www.typescriptlang.org/tsconfig/#target) ` |\n| Set the JavaScript language version for emitted JavaScript and include compatible library declarations. |     |     |\n| `<TypeScriptNoResolve>` | `[--noResolve](https://www.typescriptlang.org/tsconfig/#noResolve) ` |\n| Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project. |     |     |\n| `<TypeScriptMapRoot>` | `[--mapRoot](https://www.typescriptlang.org/tsconfig/#mapRoot) ` |\n| Specify the location where debugger should locate map files instead of generated locations. |     |     |\n| `<TypeScriptSourceRoot>` | `[--sourceRoot](https://www.typescriptlang.org/tsconfig/#sourceRoot) ` |\n| Specify the root path for debuggers to find the reference source code. |     |     |\n| `<TypeScriptCharset>` | `[--charset](https://www.typescriptlang.org/tsconfig/#charset) ` |\n| No longer supported. In early versions, manually set the text encoding for reading files. |     |     |\n| `<TypeScriptEmitBOM>` | `[--emitBOM](https://www.typescriptlang.org/tsconfig/#emitBOM) ` |\n| Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. |     |     |\n| `<TypeScriptNoLib>` | `[--noLib](https://www.typescriptlang.org/tsconfig/#noLib) ` |\n| Disable including any library files, including the default lib.d.ts. |     |     |\n| `<TypeScriptPreserveConstEnums>` | `[--preserveConstEnums](https://www.typescriptlang.org/tsconfig/#preserveConstEnums) ` |\n| Disable erasing `const enum` declarations in generated code. |     |     |\n| `<TypeScriptSuppressImplicitAnyIndexErrors>` | `[--suppressImplicitAnyIndexErrors](https://www.typescriptlang.org/tsconfig/#suppressImplicitAnyIndexErrors) ` |\n| Suppress `noImplicitAny` errors when indexing objects that lack index signatures. |     |     |\n| `<TypeScriptNoEmitHelpers>` | `[--noEmitHelpers](https://www.typescriptlang.org/tsconfig/#noEmitHelpers) ` |\n| Disable generating custom helper functions like `__extends` in compiled output. |     |     |\n| `<TypeScriptInlineSourceMap>` | `[--inlineSourceMap](https://www.typescriptlang.org/tsconfig/#inlineSourceMap) ` |\n| Include sourcemap files inside the emitted JavaScript. |     |     |\n| `<TypeScriptInlineSources>` | `[--inlineSources](https://www.typescriptlang.org/tsconfig/#inlineSources) ` |\n| Include source code in the sourcemaps inside the emitted JavaScript. |     |     |\n| `<TypeScriptNewLine>` | `[--newLine](https://www.typescriptlang.org/tsconfig/#newLine) ` |\n| Set the newline character for emitting files. |     |     |\n| `<TypeScriptIsolatedModules>` | `[--isolatedModules](https://www.typescriptlang.org/tsconfig/#isolatedModules) ` |\n| Ensure that each file can be safely transpiled without relying on other imports. |     |     |\n| `<TypeScriptEmitDecoratorMetadata>` | `[--emitDecoratorMetadata](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata) ` |\n| Emit design-type metadata for decorated declarations in source files. |     |     |\n| `<TypeScriptRootDir>` | `[--rootDir](https://www.typescriptlang.org/tsconfig/#rootDir) ` |\n| Specify the root folder within your source files. |     |     |\n| `<TypeScriptExperimentalDecorators>` | `[--experimentalDecorators](https://www.typescriptlang.org/tsconfig/#experimentalDecorators) ` |\n| Enable experimental support for TC39 stage 2 draft decorators. |     |     |\n| `<TypeScriptModuleResolution>` | `[--moduleResolution](https://www.typescriptlang.org/tsconfig/#moduleResolution) ` |\n| Specify how TypeScript looks up a file from a given module specifier. |     |     |\n| `<TypeScriptSuppressExcessPropertyErrors>` | `[--suppressExcessPropertyErrors](https://www.typescriptlang.org/tsconfig/#suppressExcessPropertyErrors) ` |\n| Disable reporting of excess property errors during the creation of object literals. |     |     |\n| `<TypeScriptReactNamespace>` | `[--reactNamespace](https://www.typescriptlang.org/tsconfig/#reactNamespace) ` |\n| Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. |     |     |\n| `<TypeScriptSkipDefaultLibCheck>` | `[--skipDefaultLibCheck](https://www.typescriptlang.org/tsconfig/#skipDefaultLibCheck) ` |\n| Skip type checking .d.ts files that are included with TypeScript. |     |     |\n| `<TypeScriptAllowUnusedLabels>` | `[--allowUnusedLabels](https://www.typescriptlang.org/tsconfig/#allowUnusedLabels) ` |\n| Disable error reporting for unused labels. |     |     |\n| `<TypeScriptNoImplicitReturns>` | `[--noImplicitReturns](https://www.typescriptlang.org/tsconfig/#noImplicitReturns) ` |\n| Enable error reporting for codepaths that do not explicitly return in a function. |     |     |\n| `<TypeScriptNoFallthroughCasesInSwitch>` | `[--noFallthroughCasesInSwitch](https://www.typescriptlang.org/tsconfig/#noFallthroughCasesInSwitch) ` |\n| Enable error reporting for fallthrough cases in switch statements. |     |     |\n| `<TypeScriptAllowUnreachableCode>` | `[--allowUnreachableCode](https://www.typescriptlang.org/tsconfig/#allowUnreachableCode) ` |\n| Disable error reporting for unreachable code. |     |     |\n| `<TypeScriptForceConsistentCasingInFileNames>` | `[--forceConsistentCasingInFileNames](https://www.typescriptlang.org/tsconfig/#forceConsistentCasingInFileNames) ` |\n| Ensure that casing is correct in imports. |     |     |\n| `<TypeScriptAllowSyntheticDefaultImports>` | `[--allowSyntheticDefaultImports](https://www.typescriptlang.org/tsconfig/#allowSyntheticDefaultImports) ` |\n| Allow 'import x from y' when a module doesn't have a default export. |     |     |\n| `<TypeScriptNoImplicitUseStrict>` | `[--noImplicitUseStrict](https://www.typescriptlang.org/tsconfig/#noImplicitUseStrict) ` |\n| Disable adding 'use strict' directives in emitted JavaScript files. |     |     |\n| `<TypeScriptLib>` | `[--lib](https://www.typescriptlang.org/tsconfig/#lib) ` |\n| Specify a set of bundled library declaration files that describe the target runtime environment. |     |     |\n| `<TypeScriptBaseUrl>` | `[--baseUrl](https://www.typescriptlang.org/tsconfig/#baseUrl) ` |\n| Specify the base directory to resolve bare specifier module names. |     |     |\n| `<TypeScriptDeclarationDir>` | `[--declarationDir](https://www.typescriptlang.org/tsconfig/#declarationDir) ` |\n| Specify the output directory for generated declaration files. |     |     |\n| `<TypeScriptNoImplicitThis>` | `[--noImplicitThis](https://www.typescriptlang.org/tsconfig/#noImplicitThis) ` |\n| Enable error reporting when `this` is given the type `any`. |     |     |\n| `<TypeScriptSkipLibCheck>` | `[--skipLibCheck](https://www.typescriptlang.org/tsconfig/#skipLibCheck) ` |\n| Skip type checking all .d.ts files. |     |     |\n| `<TypeScriptStrictNullChecks>` | `[--strictNullChecks](https://www.typescriptlang.org/tsconfig/#strictNullChecks) ` |\n| When type checking, take into account `null` and `undefined`. |     |     |\n| `<TypeScriptNoUnusedLocals>` | `[--noUnusedLocals](https://www.typescriptlang.org/tsconfig/#noUnusedLocals) ` |\n| Enable error reporting when a local variables aren't read. |     |     |\n| `<TypeScriptNoUnusedParameters>` | `[--noUnusedParameters](https://www.typescriptlang.org/tsconfig/#noUnusedParameters) ` |\n| Raise an error when a function parameter isn't read |     |     |\n| `<TypeScriptAlwaysStrict>` | `[--alwaysStrict](https://www.typescriptlang.org/tsconfig/#alwaysStrict) ` |\n| Ensure 'use strict' is always emitted. |     |     |\n| `<TypeScriptImportHelpers>` | `[--importHelpers](https://www.typescriptlang.org/tsconfig/#importHelpers) ` |\n| Allow importing helper functions from tslib once per project, instead of including them per-file. |     |     |\n| `<TypeScriptJSXFactory>` | `[--jsxFactory](https://www.typescriptlang.org/tsconfig/#jsxFactory) ` |\n| Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h' |     |     |\n| `<TypeScriptStripInternal>` | `[--stripInternal](https://www.typescriptlang.org/tsconfig/#stripInternal) ` |\n| Disable emitting declarations that have `@internal` in their JSDoc comments. |     |     |\n| `<TypeScriptCheckJs>` | `[--checkJs](https://www.typescriptlang.org/tsconfig/#checkJs) ` |\n| Enable error reporting in type-checked JavaScript files. |     |     |\n| `<TypeScriptDownlevelIteration>` | `[--downlevelIteration](https://www.typescriptlang.org/tsconfig/#downlevelIteration) ` |\n| Emit more compliant, but verbose and less performant JavaScript for iteration. |     |     |\n| `<TypeScriptStrict>` | `[--strict](https://www.typescriptlang.org/tsconfig/#strict) ` |\n| Enable all strict type checking options. |     |     |\n| `<TypeScriptNoStrictGenericChecks>` | `[--noStrictGenericChecks](https://www.typescriptlang.org/tsconfig/#noStrictGenericChecks) ` |\n| Disable strict checking of generic signatures in function types. |     |     |\n| `<TypeScriptPreserveSymlinks>` | `[--preserveSymlinks](https://www.typescriptlang.org/tsconfig/#preserveSymlinks) ` |\n| Disable resolving symlinks to their realpath. This correlates to the same flag in node. |     |     |\n| `<TypeScriptStrictFunctionTypes>` | `[--strictFunctionTypes](https://www.typescriptlang.org/tsconfig/#strictFunctionTypes) ` |\n| When assigning functions, check to ensure parameters and the return values are subtype-compatible. |     |     |\n| `<TypeScriptStrictPropertyInitialization>` | `[--strictPropertyInitialization](https://www.typescriptlang.org/tsconfig/#strictPropertyInitialization) ` |\n| Check for class properties that are declared but not set in the constructor. |     |     |\n| `<TypeScriptESModuleInterop>` | `[--esModuleInterop](https://www.typescriptlang.org/tsconfig/#esModuleInterop) ` |\n| Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. |     |     |\n| `<TypeScriptEmitDeclarationOnly>` | `[--emitDeclarationOnly](https://www.typescriptlang.org/tsconfig/#emitDeclarationOnly) ` |\n| Only output d.ts files and not JavaScript files. |     |     |\n| `<TypeScriptKeyofStringsOnly>` | `[--keyofStringsOnly](https://www.typescriptlang.org/tsconfig/#keyofStringsOnly) ` |\n| Make keyof only return strings instead of string, numbers or symbols. Legacy option. |     |     |\n| `<TypeScriptUseDefineForClassFields>` | `[--useDefineForClassFields](https://www.typescriptlang.org/tsconfig/#useDefineForClassFields) ` |\n| Emit ECMAScript-standard-compliant class fields. |     |     |\n| `<TypeScriptDeclarationMap>` | `[--declarationMap](https://www.typescriptlang.org/tsconfig/#declarationMap) ` |\n| Create sourcemaps for d.ts files. |     |     |\n| `<TypeScriptResolveJsonModule>` | `[--resolveJsonModule](https://www.typescriptlang.org/tsconfig/#resolveJsonModule) ` |\n| Enable importing .json files |     |     |\n| `<TypeScriptStrictBindCallApply>` | `[--strictBindCallApply](https://www.typescriptlang.org/tsconfig/#strictBindCallApply) ` |\n| Check that the arguments for `bind`, `call`, and `apply` methods match the original function. |     |     |\n| `<TypeScriptNoEmitOnError>` | `[--noEmitOnError](https://www.typescriptlang.org/tsconfig/#noEmitOnError) ` |\n| Disable emitting files if any type checking errors are reported. |     |     |\n\n### [](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#additional-flags)\nAdditional Flags\n\nBecause the MSBuild system passes arguments directly to the TypeScript CLI, you can use the option `TypeScriptAdditionalFlags` to provide specific flags which don’t have a mapping above.\n\nFor example, this would turn on [`noPropertyAccessFromIndexSignature`](https://www.typescriptlang.org/tsconfig#noPropertyAccessFromIndexSignature)\n:\n\nxml\n\n`   <TypeScriptAdditionalFlags> $(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature</TypeScriptAdditionalFlags>   `\n\n### [](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#debug-and-release-builds)\nDebug and Release Builds\n\nYou can use PropertyGroup conditions to define different sets of configurations. For example, a common task is stripping comments and sourcemaps in production. In this example, we define a debug and release property group which have different TypeScript configurations:\n\nxml\n\n`   <PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">    <TypeScriptRemoveComments>false</TypeScriptRemoveComments>    <TypeScriptSourceMap>true</TypeScriptSourceMap>  </PropertyGroup>  <PropertyGroup Condition=\"'$(Configuration)' == 'Release'\">    <TypeScriptRemoveComments>true</TypeScriptRemoveComments>    <TypeScriptSourceMap>false</TypeScriptSourceMap>  </PropertyGroup>  <Import      Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"      Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />   `\n\n### [](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#toolsversion)\nToolsVersion\n\nThe value of `<TypeScriptToolsVersion>1.7</TypeScriptToolsVersion>` property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.\n\nIf `TypeScriptToolsVersion` is not specified, the latest compiler version installed on the machine will be used to build.\n\nUsers using newer versions of TS, will see a prompt to upgrade their project on first load.\n\n### [](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#typescriptcompileblocked)\nTypeScriptCompileBlocked\n\nIf you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set `<TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>` in your project. This should give you all the editing support, but not the build when you hit F5.\n\n### [](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#typescriptenableincrementalmsbuild-typescript-42-beta-and-later)\nTypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)\n\nBy default, MSBuild will attempt to only run the TypeScript compiler when the project’s source files have been updated since the last compilation. However, if this behavior is causing issues, such as when TypeScript’s [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n option is enabled, set `<TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild>` to ensure the TypeScript compiler is invoked with every run of MSBuild.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/project-config/Compiler%20Options%20in%20MSBuild.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (62)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (18)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nY![Yui  (4)](https://gravatar.com/avatar/c43ddeea6c2575b4f28e8e8107222501?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (4)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)\n\nBL![Ben Lichtman  (2)](https://gravatar.com/avatar/61a48e609aa3bd0f4c97f5af9c23f31ae5edcde060657523b26703d6e7cbf8be?s=32&&d=blank)\n\n13+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"theme-color":"#3178C6","og:title":"Documentation - Compiler Options in MSBuild","twitter:site":"typescriptlang","og:description":"Which compiler options are available in MSBuild projects.","ogDescription":"Which compiler options are available in MSBuild projects.","generator":"Gatsby 5.13.5","description":"Which compiler options are available in MSBuild projects.","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogTitle":"Documentation - Compiler Options in MSBuild","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","title":"TypeScript: Documentation - Compiler Options in MSBuild","scrapeId":"2185737d-0d52-4213-920f-8c047cb4d1ce","sourceURL":"https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html","url":"https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html","statusCode":200}},{"markdown":"Was this page helpful?\n\ntsc CLI Options\n===============\n\n[](https://www.typescriptlang.org/docs/handbook/compiler-options.html#using-the-cli)\nUsing the CLI\n--------------------------------------------------------------------------------------------------\n\nRunning `tsc` locally will compile the closest project defined by a `tsconfig.json`, or you can compile a set of TypeScript files by passing in a glob of files you want. When input files are specified on the command line, `tsconfig.json` files are ignored.\n\nsh\n\n`   # Run a compile based on a backwards look through the fs for a tsconfig.json  tsc  # Emit JS for just the index.ts with the compiler defaults  tsc index.ts  # Emit JS for any .ts files in the folder src, with the default settings  tsc src/*.ts  # Emit files referenced in with the compiler settings from tsconfig.production.json  tsc --project tsconfig.production.json  # Emit d.ts files for a js file with showing compiler options which are booleans  tsc index.js --declaration --emitDeclarationOnly  # Emit a single .js file from two files via compiler options which take string arguments  tsc app.ts util.ts --target esnext --outfile index.js   `\n\n[](https://www.typescriptlang.org/docs/handbook/compiler-options.html#compiler-options)\nCompiler Options\n--------------------------------------------------------------------------------------------------------\n\n**If you’re looking for more information about the compiler options in a tsconfig, check out the [TSConfig Reference](https://www.typescriptlang.org/tsconfig)\n**\n\n### CLI Commands\n\n| Flag | Type |\n| --- | --- |\n| `--all` | `boolean` |\n| Show all compiler options. |     |     |\n| `--help` | `boolean` |\n| Gives local information for help on the CLI. |     |     |\n| `--init` | `boolean` |\n| Initializes a TypeScript project and creates a tsconfig.json file. |     |     |\n| `--listFilesOnly` | `boolean` |\n| Print names of files that are part of the compilation and then stop processing. |     |     |\n| `--locale` | `string` |\n| Set the language of the messaging from TypeScript. This does not affect emit. |     |     |\n| `--project` | `string` |\n| Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'. |     |     |\n| `--showConfig` | `boolean` |\n| Print the final configuration instead of building. |     |     |\n| `--version` | `boolean` |\n| Print the compiler's version. |     |     |\n\n### Build Options\n\n| Flag | Type |\n| --- | --- |\n| `--build` | `boolean` |\n| Build one or more projects and their dependencies, if out of date |     |     |\n| `--clean` | `boolean` |\n| Delete the outputs of all projects. |     |     |\n| `--dry` | `boolean` |\n| Show what would be built (or deleted, if specified with '--clean') |     |     |\n| `[--force](https://www.typescriptlang.org/tsconfig/#force) ` | `boolean` |\n| Build all projects, including those that appear to be up to date. |     |     |\n| `[--verbose](https://www.typescriptlang.org/tsconfig/#verbose) ` | `boolean` |\n| Enable verbose logging. |     |     |\n\n### Watch Options\n\n| Flag | Type |\n| --- | --- |\n| `[--excludeDirectories](https://www.typescriptlang.org/tsconfig/#excludeDirectories) ` | `list` |\n| Remove a list of directories from the watch process. |     |     |\n| `[--excludeFiles](https://www.typescriptlang.org/tsconfig/#excludeFiles) ` | `list` |\n| Remove a list of files from the watch mode's processing. |     |     |\n| `[--fallbackPolling](https://www.typescriptlang.org/tsconfig/#fallbackPolling) ` | `fixedinterval`, `priorityinterval`, `dynamicpriority`, or `fixedchunksize` |\n| Specify what approach the watcher should use if the system runs out of native file watchers. |     |     |\n| `[--synchronousWatchDirectory](https://www.typescriptlang.org/tsconfig/#synchronousWatchDirectory) ` | `boolean` |\n| Synchronously call callbacks and update the state of directory watchers on platforms that don\\`t support recursive watching natively. |     |     |\n| `--watch` | `boolean` |\n| Watch input files. |     |     |\n| `[--watchDirectory](https://www.typescriptlang.org/tsconfig/#watchDirectory) ` | `usefsevents`, `fixedpollinginterval`, `dynamicprioritypolling`, or `fixedchunksizepolling` |\n| Specify how directories are watched on systems that lack recursive file-watching functionality. |     |     |\n| `[--watchFile](https://www.typescriptlang.org/tsconfig/#watchFile) ` | `fixedpollinginterval`, `prioritypollinginterval`, `dynamicprioritypolling`, `fixedchunksizepolling`, `usefsevents`, or `usefseventsonparentdirectory` |\n| Specify how the TypeScript watch mode works. |     |     |\n\n### Compiler Flags\n\n| Flag | Type | Default |\n| --- | --- | --- |\n| `[--allowArbitraryExtensions](https://www.typescriptlang.org/tsconfig/#allowArbitraryExtensions) ` | `boolean` | `false` |\n| Enable importing files with any extension, provided a declaration file is present. |     |     |\n| `[--allowImportingTsExtensions](https://www.typescriptlang.org/tsconfig/#allowImportingTsExtensions) ` | `boolean` | `true` if [`rewriteRelativeImportExtensions`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#rewriteRelativeImportExtensions)<br>; `false` otherwise. |\n| Allow imports to include TypeScript file extensions. |     |     |\n| `[--allowJs](https://www.typescriptlang.org/tsconfig/#allowJs) ` | `boolean` | `false` |\n| Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. |     |     |\n| `[--allowSyntheticDefaultImports](https://www.typescriptlang.org/tsconfig/#allowSyntheticDefaultImports) ` | `boolean` | `true` if [`esModuleInterop`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#esModuleInterop)<br> is enabled, [`module`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#module)<br> is `system`, or [`moduleResolution`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#module-resolution)<br> is `bundler`; `false` otherwise. |\n| Allow 'import x from y' when a module doesn't have a default export. |     |     |\n| `[--allowUmdGlobalAccess](https://www.typescriptlang.org/tsconfig/#allowUmdGlobalAccess) ` | `boolean` | `false` |\n| Allow accessing UMD globals from modules. |     |     |\n| `[--allowUnreachableCode](https://www.typescriptlang.org/tsconfig/#allowUnreachableCode) ` | `boolean` |     |\n| Disable error reporting for unreachable code. |     |     |\n| `[--allowUnusedLabels](https://www.typescriptlang.org/tsconfig/#allowUnusedLabels) ` | `boolean` |     |\n| Disable error reporting for unused labels. |     |     |\n| `[--alwaysStrict](https://www.typescriptlang.org/tsconfig/#alwaysStrict) ` | `boolean` | `true` if [`strict`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#strict)<br>; `false` otherwise. |\n| Ensure 'use strict' is always emitted. |     |     |\n| `[--assumeChangesOnlyAffectDirectDependencies](https://www.typescriptlang.org/tsconfig/#assumeChangesOnlyAffectDirectDependencies) ` | `boolean` | `false` |\n| Have recompiles in projects that use [`incremental`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#incremental)<br> and `watch` mode assume that changes within a file will only affect files directly depending on it. |     |     |\n| `[--baseUrl](https://www.typescriptlang.org/tsconfig/#baseUrl) ` | `string` |     |\n| Specify the base directory to resolve bare specifier module names. |     |     |\n| `[--charset](https://www.typescriptlang.org/tsconfig/#charset) ` | `string` | `utf8` |\n| No longer supported. In early versions, manually set the text encoding for reading files. |     |     |\n| `[--checkJs](https://www.typescriptlang.org/tsconfig/#checkJs) ` | `boolean` | `false` |\n| Enable error reporting in type-checked JavaScript files. |     |     |\n| `[--composite](https://www.typescriptlang.org/tsconfig/#composite) ` | `boolean` | `false` |\n| Enable constraints that allow a TypeScript project to be used with project references. |     |     |\n| `[--customConditions](https://www.typescriptlang.org/tsconfig/#customConditions) ` | `list` |     |\n| Conditions to set in addition to the resolver-specific defaults when resolving imports. |     |     |\n| `[--declaration](https://www.typescriptlang.org/tsconfig/#declaration) ` | `boolean` | `true` if [`composite`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#composite)<br>; `false` otherwise. |\n| Generate .d.ts files from TypeScript and JavaScript files in your project. |     |     |\n| `[--declarationDir](https://www.typescriptlang.org/tsconfig/#declarationDir) ` | `string` |     |\n| Specify the output directory for generated declaration files. |     |     |\n| `[--declarationMap](https://www.typescriptlang.org/tsconfig/#declarationMap) ` | `boolean` | `false` |\n| Create sourcemaps for d.ts files. |     |     |\n| `[--diagnostics](https://www.typescriptlang.org/tsconfig/#diagnostics) ` | `boolean` | `false` |\n| Output compiler performance information after building. |     |     |\n| `[--disableReferencedProjectLoad](https://www.typescriptlang.org/tsconfig/#disableReferencedProjectLoad) ` | `boolean` | `false` |\n| Reduce the number of projects loaded automatically by TypeScript. |     |     |\n| `[--disableSizeLimit](https://www.typescriptlang.org/tsconfig/#disableSizeLimit) ` | `boolean` | `false` |\n| Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server. |     |     |\n| `[--disableSolutionSearching](https://www.typescriptlang.org/tsconfig/#disableSolutionSearching) ` | `boolean` | `false` |\n| Opt a project out of multi-project reference checking when editing. |     |     |\n| `[--disableSourceOfProjectReferenceRedirect](https://www.typescriptlang.org/tsconfig/#disableSourceOfProjectReferenceRedirect) ` | `boolean` | `false` |\n| Disable preferring source files instead of declaration files when referencing composite projects. |     |     |\n| `[--downlevelIteration](https://www.typescriptlang.org/tsconfig/#downlevelIteration) ` | `boolean` | `false` |\n| Emit more compliant, but verbose and less performant JavaScript for iteration. |     |     |\n| `[--emitBOM](https://www.typescriptlang.org/tsconfig/#emitBOM) ` | `boolean` | `false` |\n| Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. |     |     |\n| `[--emitDeclarationOnly](https://www.typescriptlang.org/tsconfig/#emitDeclarationOnly) ` | `boolean` | `false` |\n| Only output d.ts files and not JavaScript files. |     |     |\n| `[--emitDecoratorMetadata](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata) ` | `boolean` | `false` |\n| Emit design-type metadata for decorated declarations in source files. |     |     |\n| `[--erasableSyntaxOnly](https://www.typescriptlang.org/tsconfig/#erasableSyntaxOnly) ` | `boolean` | `false` |\n| Do not allow runtime constructs that are not part of ECMAScript. |     |     |\n| `[--esModuleInterop](https://www.typescriptlang.org/tsconfig/#esModuleInterop) ` | `boolean` | `true` if [`module`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#module)<br> is `node16`, `nodenext`, or `preserve`; `false` otherwise. |\n| Emit additional JavaScript to ease support for importing CommonJS modules. This enables [`allowSyntheticDefaultImports`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#allowSyntheticDefaultImports)<br> for type compatibility. |     |     |\n| `[--exactOptionalPropertyTypes](https://www.typescriptlang.org/tsconfig/#exactOptionalPropertyTypes) ` | `boolean` | `false` |\n| Interpret optional property types as written, rather than adding `undefined`. |     |     |\n| `[--experimentalDecorators](https://www.typescriptlang.org/tsconfig/#experimentalDecorators) ` | `boolean` | `false` |\n| Enable experimental support for TC39 stage 2 draft decorators. |     |     |\n| `[--explainFiles](https://www.typescriptlang.org/tsconfig/#explainFiles) ` | `boolean` | `false` |\n| Print files read during the compilation including why it was included. |     |     |\n| `[--extendedDiagnostics](https://www.typescriptlang.org/tsconfig/#extendedDiagnostics) ` | `boolean` | `false` |\n| Output more detailed compiler performance information after building. |     |     |\n| `[--forceConsistentCasingInFileNames](https://www.typescriptlang.org/tsconfig/#forceConsistentCasingInFileNames) ` | `boolean` | `true` |\n| Ensure that casing is correct in imports. |     |     |\n| `[--generateCpuProfile](https://www.typescriptlang.org/tsconfig/#generateCpuProfile) ` | `string` | `profile.cpuprofile` |\n| Emit a v8 CPU profile of the compiler run for debugging. |     |     |\n| `[--generateTrace](https://www.typescriptlang.org/tsconfig/#generateTrace) ` | `string` |     |\n| Generates an event trace and a list of types. |     |     |\n| `[--importHelpers](https://www.typescriptlang.org/tsconfig/#importHelpers) ` | `boolean` | `false` |\n| Allow importing helper functions from tslib once per project, instead of including them per-file. |     |     |\n| `[--importsNotUsedAsValues](https://www.typescriptlang.org/tsconfig/#importsNotUsedAsValues) ` | `remove`, `preserve`, or `error` | `remove` |\n| Specify emit/checking behavior for imports that are only used for types. |     |     |\n| `[--incremental](https://www.typescriptlang.org/tsconfig/#incremental) ` | `boolean` | `true` if [`composite`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#composite)<br>; `false` otherwise. |\n| Save .tsbuildinfo files to allow for incremental compilation of projects. |     |     |\n| `[--inlineSourceMap](https://www.typescriptlang.org/tsconfig/#inlineSourceMap) ` | `boolean` | `false` |\n| Include sourcemap files inside the emitted JavaScript. |     |     |\n| `[--inlineSources](https://www.typescriptlang.org/tsconfig/#inlineSources) ` | `boolean` | `false` |\n| Include source code in the sourcemaps inside the emitted JavaScript. |     |     |\n| `[--isolatedDeclarations](https://www.typescriptlang.org/tsconfig/#isolatedDeclarations) ` | `boolean` | `false` |\n| Require sufficient annotation on exports so other tools can trivially generate declaration files. |     |     |\n| `[--isolatedModules](https://www.typescriptlang.org/tsconfig/#isolatedModules) ` | `boolean` | `true` if [`verbatimModuleSyntax`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#verbatimModuleSyntax)<br>; `false` otherwise. |\n| Ensure that each file can be safely transpiled without relying on other imports. |     |     |\n| `[--jsx](https://www.typescriptlang.org/tsconfig/#jsx) ` | `preserve`, `react`, `react-native`, `react-jsx`, or `react-jsxdev` |     |\n| Specify what JSX code is generated. |     |     |\n| `[--jsxFactory](https://www.typescriptlang.org/tsconfig/#jsxFactory) ` | `string` | `React.createElement` |\n| Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. |     |     |\n| `[--jsxFragmentFactory](https://www.typescriptlang.org/tsconfig/#jsxFragmentFactory) ` | `string` | `React.Fragment` |\n| Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. |     |     |\n| `[--jsxImportSource](https://www.typescriptlang.org/tsconfig/#jsxImportSource) ` | `string` | `react` |\n| Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`. |     |     |\n| `[--keyofStringsOnly](https://www.typescriptlang.org/tsconfig/#keyofStringsOnly) ` | `boolean` | `false` |\n| Make keyof only return strings instead of string, numbers or symbols. Legacy option. |     |     |\n| `[--lib](https://www.typescriptlang.org/tsconfig/#lib) ` | `list` |     |\n| Specify a set of bundled library declaration files that describe the target runtime environment. |     |     |\n| `[--libReplacement](https://www.typescriptlang.org/tsconfig/#libReplacement) ` | `boolean` | `true` |\n| Enable substitution of default `lib` files with custom ones. |     |     |\n| `[--listEmittedFiles](https://www.typescriptlang.org/tsconfig/#listEmittedFiles) ` | `boolean` | `false` |\n| Print the names of emitted files after a compilation. |     |     |\n| `[--listFiles](https://www.typescriptlang.org/tsconfig/#listFiles) ` | `boolean` | `false` |\n| Print all of the files read during the compilation. |     |     |\n| `[--mapRoot](https://www.typescriptlang.org/tsconfig/#mapRoot) ` | `string` |     |\n| Specify the location where debugger should locate map files instead of generated locations. |     |     |\n| `[--maxNodeModuleJsDepth](https://www.typescriptlang.org/tsconfig/#maxNodeModuleJsDepth) ` | `number` | `0` |\n| Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with [`allowJs`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#allowJs)<br>. |     |     |\n| `[--module](https://www.typescriptlang.org/tsconfig/#module) ` | `none`, `commonjs`, `amd`, `umd`, `system`, `es6`/`es2015`, `es2020`, `es2022`, `esnext`, `node16`, `node18`, `nodenext`, or `preserve` | `CommonJS` if [`target`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#target)<br> is `ES5`; `ES6`/`ES2015` otherwise. |\n| Specify what module code is generated. |     |     |\n| `[--moduleDetection](https://www.typescriptlang.org/tsconfig/#moduleDetection) ` | `legacy`, `auto`, or `force` | \"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules. |\n| Specify what method is used to detect whether a file is a script or a module. |     |     |\n| `[--moduleResolution](https://www.typescriptlang.org/tsconfig/#moduleResolution) ` | `classic`, `node10`/`node`, `node16`, `nodenext`, or `bundler` | `Classic` if [`module`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#module)<br> is `AMD`, `UMD`, `System`, or `ES6`/`ES2015`; Matches if [`module`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#module)<br> is `node16` or `nodenext`; `Node` otherwise. |\n| Specify how TypeScript looks up a file from a given module specifier. |     |     |\n| `[--moduleSuffixes](https://www.typescriptlang.org/tsconfig/#moduleSuffixes) ` | `list` |     |\n| List of file name suffixes to search when resolving a module. |     |     |\n| `[--newLine](https://www.typescriptlang.org/tsconfig/#newLine) ` | `crlf` or `lf` | `lf` |\n| Set the newline character for emitting files. |     |     |\n| `[--noCheck](https://www.typescriptlang.org/tsconfig/#noCheck) ` | `boolean` | `false` |\n| Disable full type checking (only critical parse and emit errors will be reported). |     |     |\n| `[--noEmit](https://www.typescriptlang.org/tsconfig/#noEmit) ` | `boolean` | `false` |\n| Disable emitting files from a compilation. |     |     |\n| `[--noEmitHelpers](https://www.typescriptlang.org/tsconfig/#noEmitHelpers) ` | `boolean` | `false` |\n| Disable generating custom helper functions like `__extends` in compiled output. |     |     |\n| `[--noEmitOnError](https://www.typescriptlang.org/tsconfig/#noEmitOnError) ` | `boolean` | `false` |\n| Disable emitting files if any type checking errors are reported. |     |     |\n| `[--noErrorTruncation](https://www.typescriptlang.org/tsconfig/#noErrorTruncation) ` | `boolean` | `false` |\n| Disable truncating types in error messages. |     |     |\n| `[--noFallthroughCasesInSwitch](https://www.typescriptlang.org/tsconfig/#noFallthroughCasesInSwitch) ` | `boolean` | `false` |\n| Enable error reporting for fallthrough cases in switch statements. |     |     |\n| `[--noImplicitAny](https://www.typescriptlang.org/tsconfig/#noImplicitAny) ` | `boolean` | `true` if [`strict`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#strict)<br>; `false` otherwise. |\n| Enable error reporting for expressions and declarations with an implied `any` type. |     |     |\n| `[--noImplicitOverride](https://www.typescriptlang.org/tsconfig/#noImplicitOverride) ` | `boolean` | `false` |\n| Ensure overriding members in derived classes are marked with an override modifier. |     |     |\n| `[--noImplicitReturns](https://www.typescriptlang.org/tsconfig/#noImplicitReturns) ` | `boolean` | `false` |\n| Enable error reporting for codepaths that do not explicitly return in a function. |     |     |\n| `[--noImplicitThis](https://www.typescriptlang.org/tsconfig/#noImplicitThis) ` | `boolean` | `true` if [`strict`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#strict)<br>; `false` otherwise. |\n| Enable error reporting when `this` is given the type `any`. |     |     |\n| `[--noImplicitUseStrict](https://www.typescriptlang.org/tsconfig/#noImplicitUseStrict) ` | `boolean` | `false` |\n| Disable adding 'use strict' directives in emitted JavaScript files. |     |     |\n| `[--noLib](https://www.typescriptlang.org/tsconfig/#noLib) ` | `boolean` | `false` |\n| Disable including any library files, including the default lib.d.ts. |     |     |\n| `[--noPropertyAccessFromIndexSignature](https://www.typescriptlang.org/tsconfig/#noPropertyAccessFromIndexSignature) ` | `boolean` | `false` |\n| Enforces using indexed accessors for keys declared using an indexed type. |     |     |\n| `[--noResolve](https://www.typescriptlang.org/tsconfig/#noResolve) ` | `boolean` | `false` |\n| Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project. |     |     |\n| `[--noStrictGenericChecks](https://www.typescriptlang.org/tsconfig/#noStrictGenericChecks) ` | `boolean` | `false` |\n| Disable strict checking of generic signatures in function types. |     |     |\n| `[--noUncheckedIndexedAccess](https://www.typescriptlang.org/tsconfig/#noUncheckedIndexedAccess) ` | `boolean` | `false` |\n| Add `undefined` to a type when accessed using an index. |     |     |\n| `[--noUncheckedSideEffectImports](https://www.typescriptlang.org/tsconfig/#noUncheckedSideEffectImports) ` | `boolean` | `false` |\n| Check side effect imports. |     |     |\n| `[--noUnusedLocals](https://www.typescriptlang.org/tsconfig/#noUnusedLocals) ` | `boolean` | `false` |\n| Enable error reporting when local variables aren't read. |     |     |\n| `[--noUnusedParameters](https://www.typescriptlang.org/tsconfig/#noUnusedParameters) ` | `boolean` | `false` |\n| Raise an error when a function parameter isn't read. |     |     |\n| `[--out](https://www.typescriptlang.org/tsconfig/#out) ` | `string` |     |\n| Deprecated setting. Use [`outFile`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#outFile)<br> instead. |     |     |\n| `[--outDir](https://www.typescriptlang.org/tsconfig/#outDir) ` | `string` |     |\n| Specify an output folder for all emitted files. |     |     |\n| `[--outFile](https://www.typescriptlang.org/tsconfig/#outFile) ` | `string` |     |\n| Specify a file that bundles all outputs into one JavaScript file. If [`declaration`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#declaration)<br> is true, also designates a file that bundles all .d.ts output. |     |     |\n| `[--paths](https://www.typescriptlang.org/tsconfig/#paths) ` | `object` |     |\n| Specify a set of entries that re-map imports to additional lookup locations. |     |     |\n| `[--plugins](https://www.typescriptlang.org/tsconfig/#plugins) ` | `list` |     |\n| Specify a list of language service plugins to include. |     |     |\n| `[--preserveConstEnums](https://www.typescriptlang.org/tsconfig/#preserveConstEnums) ` | `boolean` | `true` if [`isolatedModules`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#isolatedModules)<br>; `false` otherwise. |\n| Disable erasing `const enum` declarations in generated code. |     |     |\n| `[--preserveSymlinks](https://www.typescriptlang.org/tsconfig/#preserveSymlinks) ` | `boolean` | `false` |\n| Disable resolving symlinks to their realpath. This correlates to the same flag in node. |     |     |\n| `[--preserveValueImports](https://www.typescriptlang.org/tsconfig/#preserveValueImports) ` | `boolean` | `false` |\n| Preserve unused imported values in the JavaScript output that would otherwise be removed. |     |     |\n| `[--preserveWatchOutput](https://www.typescriptlang.org/tsconfig/#preserveWatchOutput) ` | `boolean` | `false` |\n| Disable wiping the console in watch mode. |     |     |\n| `[--pretty](https://www.typescriptlang.org/tsconfig/#pretty) ` | `boolean` | `true` |\n| Enable color and formatting in TypeScript's output to make compiler errors easier to read. |     |     |\n| `[--reactNamespace](https://www.typescriptlang.org/tsconfig/#reactNamespace) ` | `string` | `React` |\n| Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. |     |     |\n| `[--removeComments](https://www.typescriptlang.org/tsconfig/#removeComments) ` | `boolean` | `false` |\n| Disable emitting comments. |     |     |\n| `[--resolveJsonModule](https://www.typescriptlang.org/tsconfig/#resolveJsonModule) ` | `boolean` | `false` |\n| Enable importing .json files. |     |     |\n| `[--resolvePackageJsonExports](https://www.typescriptlang.org/tsconfig/#resolvePackageJsonExports) ` | `boolean` | `true` when [`moduleResolution`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#moduleResolution)<br> is `node16`, `nodenext`, or `bundler`; otherwise `false` |\n| Use the package.json 'exports' field when resolving package imports. |     |     |\n| `[--resolvePackageJsonImports](https://www.typescriptlang.org/tsconfig/#resolvePackageJsonImports) ` | `boolean` | `true` when [`moduleResolution`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#moduleResolution)<br> is `node16`, `nodenext`, or `bundler`; otherwise `false` |\n| Use the package.json 'imports' field when resolving imports. |     |     |\n| `[--rewriteRelativeImportExtensions](https://www.typescriptlang.org/tsconfig/#rewriteRelativeImportExtensions) ` | `boolean` | `false` |\n| Does something |     |     |\n| `[--rootDir](https://www.typescriptlang.org/tsconfig/#rootDir) ` | `string` | Computed from the list of input files. |\n| Specify the root folder within your source files. |     |     |\n| `[--rootDirs](https://www.typescriptlang.org/tsconfig/#rootDirs) ` | `list` | Computed from the list of input files. |\n| Allow multiple folders to be treated as one when resolving modules. |     |     |\n| `[--skipDefaultLibCheck](https://www.typescriptlang.org/tsconfig/#skipDefaultLibCheck) ` | `boolean` | `false` |\n| Skip type checking .d.ts files that are included with TypeScript. |     |     |\n| `[--skipLibCheck](https://www.typescriptlang.org/tsconfig/#skipLibCheck) ` | `boolean` | `false` |\n| Skip type checking all .d.ts files. |     |     |\n| `[--sourceMap](https://www.typescriptlang.org/tsconfig/#sourceMap) ` | `boolean` | `false` |\n| Create source map files for emitted JavaScript files. |     |     |\n| `[--sourceRoot](https://www.typescriptlang.org/tsconfig/#sourceRoot) ` | `string` |     |\n| Specify the root path for debuggers to find the reference source code. |     |     |\n| `[--stopBuildOnErrors](https://www.typescriptlang.org/tsconfig/#stopBuildOnErrors) ` | `boolean` |     |\n| Skip building downstream projects on error in upstream project. |     |     |\n| `[--strict](https://www.typescriptlang.org/tsconfig/#strict) ` | `boolean` | `false` |\n| Enable all strict type-checking options. |     |     |\n| `[--strictBindCallApply](https://www.typescriptlang.org/tsconfig/#strictBindCallApply) ` | `boolean` | `true` if [`strict`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#strict)<br>; `false` otherwise. |\n| Check that the arguments for `bind`, `call`, and `apply` methods match the original function. |     |     |\n| `[--strictBuiltinIteratorReturn](https://www.typescriptlang.org/tsconfig/#strictBuiltinIteratorReturn) ` | `boolean` | `true` if [`strict`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#strict)<br>; `false` otherwise. |\n| Built-in iterators are instantiated with a TReturn type of undefined instead of any. |     |     |\n| `[--strictFunctionTypes](https://www.typescriptlang.org/tsconfig/#strictFunctionTypes) ` | `boolean` | `true` if [`strict`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#strict)<br>; `false` otherwise. |\n| When assigning functions, check to ensure parameters and the return values are subtype-compatible. |     |     |\n| `[--strictNullChecks](https://www.typescriptlang.org/tsconfig/#strictNullChecks) ` | `boolean` | `true` if [`strict`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#strict)<br>; `false` otherwise. |\n| When type checking, take into account `null` and `undefined`. |     |     |\n| `[--strictPropertyInitialization](https://www.typescriptlang.org/tsconfig/#strictPropertyInitialization) ` | `boolean` | `true` if [`strict`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#strict)<br>; `false` otherwise. |\n| Check for class properties that are declared but not set in the constructor. |     |     |\n| `[--stripInternal](https://www.typescriptlang.org/tsconfig/#stripInternal) ` | `boolean` | `false` |\n| Disable emitting declarations that have `@internal` in their JSDoc comments. |     |     |\n| `[--suppressExcessPropertyErrors](https://www.typescriptlang.org/tsconfig/#suppressExcessPropertyErrors) ` | `boolean` | `false` |\n| Disable reporting of excess property errors during the creation of object literals. |     |     |\n| `[--suppressImplicitAnyIndexErrors](https://www.typescriptlang.org/tsconfig/#suppressImplicitAnyIndexErrors) ` | `boolean` | `false` |\n| Suppress [`noImplicitAny`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#noImplicitAny)<br> errors when indexing objects that lack index signatures. |     |     |\n| `[--target](https://www.typescriptlang.org/tsconfig/#target) ` | `es3`, `es5`, `es6`/`es2015`, `es2016`, `es2017`, `es2018`, `es2019`, `es2020`, `es2021`, `es2022`, `es2023`, `es2024`, or `esnext` | `ES5` |\n| Set the JavaScript language version for emitted JavaScript and include compatible library declarations. |     |     |\n| `[--traceResolution](https://www.typescriptlang.org/tsconfig/#traceResolution) ` | `boolean` | `false` |\n| Log paths used during the [`moduleResolution`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#moduleResolution)<br> process. |     |     |\n| `[--tsBuildInfoFile](https://www.typescriptlang.org/tsconfig/#tsBuildInfoFile) ` | `string` | `.tsbuildinfo` |\n| The file to store `.tsbuildinfo` incremental build information in. |     |     |\n| `[--typeRoots](https://www.typescriptlang.org/tsconfig/#typeRoots) ` | `list` |     |\n| Specify multiple folders that act like `./node_modules/@types`. |     |     |\n| `[--types](https://www.typescriptlang.org/tsconfig/#types) ` | `list` |     |\n| Specify type package names to be included without being referenced in a source file. |     |     |\n| `[--useDefineForClassFields](https://www.typescriptlang.org/tsconfig/#useDefineForClassFields) ` | `boolean` | `true` if [`target`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#target)<br> is `ES2022` or higher, including `ESNext`; `false` otherwise. |\n| Emit ECMAScript-standard-compliant class fields. |     |     |\n| `[--useUnknownInCatchVariables](https://www.typescriptlang.org/tsconfig/#useUnknownInCatchVariables) ` | `boolean` | `true` if [`strict`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#strict)<br>; `false` otherwise. |\n| Default catch clause variables as `unknown` instead of `any`. |     |     |\n| `[--verbatimModuleSyntax](https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax) ` | `boolean` | `false` |\n| Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. |     |     |\n\n[](https://www.typescriptlang.org/docs/handbook/compiler-options.html#related)\nRelated\n--------------------------------------------------------------------------------------\n\n*   Every option is fully explained in the [TSConfig Reference](https://www.typescriptlang.org/tsconfig)\n    .\n*   Learn how to use a [`tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n     file.\n*   Learn how to work in an [MSBuild project](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html)\n    .\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/project-config/Compiler%20Options.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (96)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (54)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nDR![Daniel Rosenwasser  (19)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)\n\nAD![Axel D  (14)](https://gravatar.com/avatar/bdf735cd1dd693d2608a997927cb7e7d?s=32&&d=blank)\n\nJB![Jake Bailey  (7)](https://gravatar.com/avatar/127e9f47eb2768eae31eb5809ae4f1ca44336bc51e45473c68ebb9648608f590?s=32&&d=blank)\n\n63+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"A very high-level overview of the CLI compiler options for tsc","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","og:title":"Documentation - tsc CLI Options","og:description":"A very high-level overview of the CLI compiler options for tsc","title":"TypeScript: Documentation - tsc CLI Options","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","description":"A very high-level overview of the CLI compiler options for tsc","twitter:site":"typescriptlang","ogTitle":"Documentation - tsc CLI Options","generator":"Gatsby 5.13.5","theme-color":"#3178C6","scrapeId":"ab362020-689e-485e-9621-946d60bdbeb0","sourceURL":"https://www.typescriptlang.org/docs/handbook/compiler-options.html","url":"https://www.typescriptlang.org/docs/handbook/compiler-options.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nProject References\n==================\n\nProject references allows you to structure your TypeScript programs into smaller pieces, available in TypeScript 3.0 and newer.\n\nBy doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.\n\nWe’re also introducing a new mode for `tsc`, the `--build` flag, that works hand in hand with project references to enable faster TypeScript builds.\n\n[](https://www.typescriptlang.org/docs/handbook/project-references.html#an-example-project)\nAn Example Project\n--------------------------------------------------------------------------------------------------------------\n\nLet’s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, `converter` and `units`, and a corresponding test file for each:\n\n`   /  ├── src/  │   ├── converter.ts  │   └── units.ts  ├── test/  │   ├── converter-tests.ts  │   └── units-tests.ts  └── tsconfig.json   `\n\nThe test files import the implementation files and do some testing:\n\nts\n\n`   // converter-tests.ts  import * as converter from \"../src/converter\";  assert.areEqual(converter.celsiusToFahrenheit(0), 32);   `\n\nPreviously, this structure was rather awkward to work with if you used a single tsconfig file:\n\n*   It was possible for the implementation files to import the test files\n*   It wasn’t possible to build `test` and `src` at the same time without having `src` appear in the output folder name, which you probably don’t want\n*   Changing just the _internals_ in the implementation files required _typechecking_ the tests again, even though this wouldn’t ever cause new errors\n*   Changing just the tests required typechecking the implementation again, even if nothing changed\n\nYou could use multiple tsconfig files to solve _some_ of those problems, but new ones would appear:\n\n*   There’s no built-in up-to-date checking, so you end up always running `tsc` twice\n*   Invoking `tsc` twice incurs more startup time overhead\n*   `tsc -w` can’t run on multiple config files at once\n\nProject references can solve all of these problems and more.\n\n[](https://www.typescriptlang.org/docs/handbook/project-references.html#what-is-a-project-reference)\nWhat is a Project Reference?\n---------------------------------------------------------------------------------------------------------------------------------\n\n`tsconfig.json` files have a new top-level property, [`references`](https://www.typescriptlang.org/tsconfig#references)\n. It’s an array of objects that specifies projects to reference:\n\njs\n\n`   {      \"compilerOptions\": {          // The usual      },      \"references\": [          { \"path\": \"../src\" }      ]  }   `\n\nThe `path` property of each reference can point to a directory containing a `tsconfig.json` file, or to the config file itself (which may have any name).\n\nWhen you reference a project, new things happen:\n\n*   Importing modules from a referenced project will instead load its _output_ declaration file (`.d.ts`)\n*   If the referenced project produces an [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)\n    , the output file `.d.ts` file’s declarations will be visible in this project\n*   Build mode (see below) will automatically build the referenced project if needed\n\nBy separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.\n\n[](https://www.typescriptlang.org/docs/handbook/project-references.html#composite)\n`composite`\n----------------------------------------------------------------------------------------------\n\nReferenced projects must have the new [`composite`](https://www.typescriptlang.org/tsconfig#composite)\n setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the [`composite`](https://www.typescriptlang.org/tsconfig#composite)\n flag changes a few things:\n\n*   The [`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir)\n     setting, if not explicitly set, defaults to the directory containing the `tsconfig` file\n*   All implementation files must be matched by an [`include`](https://www.typescriptlang.org/tsconfig#include)\n     pattern or listed in the [`files`](https://www.typescriptlang.org/tsconfig#files)\n     array. If this constraint is violated, `tsc` will inform you which files weren’t specified\n*   [`declaration`](https://www.typescriptlang.org/tsconfig#declaration)\n     must be turned on\n\n[](https://www.typescriptlang.org/docs/handbook/project-references.html#declarationmap)\n`declarationMap`\n--------------------------------------------------------------------------------------------------------\n\nWe’ve also added support for [declaration source maps](https://github.com/Microsoft/TypeScript/issues/14479)\n. If you enable [`declarationMap`](https://www.typescriptlang.org/tsconfig#declarationMap)\n, you’ll be able to use editor features like “Go to Definition” and Rename to transparently navigate and edit code across project boundaries in supported editors.\n\n[](https://www.typescriptlang.org/docs/handbook/project-references.html#caveats-for-project-references)\nCaveats for Project References\n--------------------------------------------------------------------------------------------------------------------------------------\n\nProject references have a few trade-offs you should be aware of.\n\nBecause dependent projects make use of `.d.ts` files that are built from their dependencies, you’ll either have to check in certain build outputs _or_ build a project after cloning it before you can navigate the project in an editor without seeing spurious errors.\n\nWhen using VS Code (since TS 3.7) we have a behind-the-scenes in-memory `.d.ts` generation process that should be able to mitigate this, but it has some perf implications. For very large composite projects you might want to disable this using [disableSourceOfProjectReferenceRedirect option](https://www.typescriptlang.org/tsconfig#disableSourceOfProjectReferenceRedirect)\n.\n\nAdditionally, to preserve compatibility with existing build workflows, `tsc` will _not_ automatically build dependencies unless invoked with the `--build` switch. Let’s learn more about `--build`.\n\n[](https://www.typescriptlang.org/docs/handbook/project-references.html#build-mode-for-typescript)\nBuild Mode for TypeScript\n----------------------------------------------------------------------------------------------------------------------------\n\nA long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the `--build` flag with `tsc`. This is effectively a new entry point for `tsc` that behaves more like a build orchestrator than a simple compiler.\n\nRunning `tsc --build` (`tsc -b` for short) will do the following:\n\n*   Find all referenced projects\n*   Detect if they are up-to-date\n*   Build out-of-date projects in the correct order\n\nYou can provide `tsc -b` with multiple config file paths (e.g. `tsc -b src test`). Just like `tsc -p`, specifying the config file name itself is unnecessary if it’s named `tsconfig.json`.\n\n### [](https://www.typescriptlang.org/docs/handbook/project-references.html#tsc--b-commandline)\n`tsc -b` Commandline\n\nYou can specify any number of config files:\n\nshell\n\n `> tsc -b                            # Use the tsconfig.json in the current directory   > tsc -b src                        # Use src/tsconfig.json   > tsc -b foo/prd.tsconfig.json bar  # Use foo/prd.tsconfig.json and bar/tsconfig.json`\n\nDon’t worry about ordering the files you pass on the commandline - `tsc` will re-order them if needed so that dependencies are always built first.\n\nThere are also some flags specific to `tsc -b`:\n\n*   [`--verbose`](https://www.typescriptlang.org/tsconfig#verbose)\n    : Prints out verbose logging to explain what’s going on (may be combined with any other flag)\n*   `--dry`: Shows what would be done but doesn’t actually build anything\n*   `--clean`: Deletes the outputs of the specified projects (may be combined with `--dry`)\n*   [`--force`](https://www.typescriptlang.org/tsconfig#force)\n    : Act as if all projects are out of date\n*   `--watch`: Watch mode (may not be combined with any flag except [`--verbose`](https://www.typescriptlang.org/tsconfig#verbose)\n    )\n\n[](https://www.typescriptlang.org/docs/handbook/project-references.html#caveats)\nCaveats\n----------------------------------------------------------------------------------------\n\nNormally, `tsc` will produce outputs (`.js` and `.d.ts`) in the presence of syntax or type errors, unless [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)\n is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you’d only see it _once_ because a subsequent build would skip building the now up-to-date project. For this reason, `tsc -b` effectively acts as if [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)\n is enabled for all projects.\n\nIf you check in any build outputs (`.js`, `.d.ts`, `.d.ts.map`, etc.), you may need to run a [`--force`](https://www.typescriptlang.org/tsconfig#force)\n build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.\n\n[](https://www.typescriptlang.org/docs/handbook/project-references.html#msbuild)\nMSBuild\n----------------------------------------------------------------------------------------\n\nIf you have an msbuild project, you can enable build mode by adding\n\nxml\n\n    `<TypeScriptBuildMode>true</TypeScriptBuildMode>`\n\nto your proj file. This will enable automatic incremental build as well as cleaning.\n\nNote that as with `tsconfig.json` / `-p`, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.\n\nSome teams have set up msbuild-based workflows wherein tsconfig files have the same _implicit_ graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use `msbuild` with `tsc -p` along with project references; these are fully interoperable.\n\n[](https://www.typescriptlang.org/docs/handbook/project-references.html#guidance)\nGuidance\n------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/project-references.html#overall-structure)\nOverall Structure\n\nWith more `tsconfig.json` files, you’ll usually want to use [Configuration file inheritance](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.\n\nAnother good practice is to have a “solution” `tsconfig.json` file that simply has [`references`](https://www.typescriptlang.org/tsconfig#references)\n to all of your leaf-node projects and sets [`files`](https://www.typescriptlang.org/tsconfig#files)\n to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty [`files`](https://www.typescriptlang.org/tsconfig#files)\n array if you have at least one `reference` in a `tsconfig.json` file.\n\nThis presents a simple entry point; e.g. in the TypeScript repo we simply run `tsc -b src` to build all endpoints because we list all the subprojects in `src/tsconfig.json`\n\nYou can see these patterns in the TypeScript repo - see `src/tsconfig_base.json`, `src/tsconfig.json`, and `src/tsc/tsconfig.json` as key examples.\n\n### [](https://www.typescriptlang.org/docs/handbook/project-references.html#structuring-for-relative-modules)\nStructuring for relative modules\n\nIn general, not much is needed to transition a repo using relative modules. Simply place a `tsconfig.json` file in each subdirectory of a given parent folder, and add `reference`s to these config files to match the intended layering of the program. You will need to either set the [`outDir`](https://www.typescriptlang.org/tsconfig#outDir)\n to an explicit subfolder of the output folder, or set the [`rootDir`](https://www.typescriptlang.org/tsconfig#rootDir)\n to the common root of all project folders.\n\n### [](https://www.typescriptlang.org/docs/handbook/project-references.html#structuring-for-outfiles)\nStructuring for outFiles\n\nLayout for compilations using [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)\n is more flexible because relative paths don’t matter as much. The TypeScript repo itself is a good reference here - we have some “library” projects and some “endpoint” projects; “endpoint” projects are kept as small as possible and pull in only the libraries they need.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/project-config/Project%20References.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (18)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nRC![Ryan Cavanaugh  (3)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nMK![Matt Kantor  (1)](https://gravatar.com/avatar/cd99d5732d2c37b59e6e5d4d57f9a4628fb4d36da885219f2173f18ec697c446?s=32&&d=blank)\n\nS![Steven  (1)](https://gravatar.com/avatar/185c12fcb1e761caf7e17efa6a021b1ce971d95524e01da92e252ba3fdf3c7f6?s=32&&d=blank)\n\n22+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:title":"Documentation - Project References","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","ogDescription":"How to split up a large TypeScript project","theme-color":"#3178C6","og:description":"How to split up a large TypeScript project","twitter:site":"typescriptlang","description":"How to split up a large TypeScript project","title":"TypeScript: Documentation - Project References","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogTitle":"Documentation - Project References","generator":"Gatsby 5.13.5","scrapeId":"88882922-0c83-4c4e-b0db-cb112ae416d9","sourceURL":"https://www.typescriptlang.org/docs/handbook/project-references.html","url":"https://www.typescriptlang.org/docs/handbook/project-references.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nIntegrating with Build Tools\n============================\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#babel)\nBabel\n----------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#install)\nInstall\n\nsh\n\n`   npm install @babel/cli @babel/core @babel/preset-typescript --save-dev   `\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#babelrc)\n.babelrc\n\njs\n\n`   {    \"presets\": [\"@babel/preset-typescript\"]  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#using-command-line-interface)\nUsing Command Line Interface\n\nsh\n\n`   ./node_modules/.bin/babel --out-file bundle.js src/index.ts   `\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#packagejson)\npackage.json\n\njs\n\n`   {    \"scripts\": {      \"build\": \"babel --out-file bundle.js main.ts\"    },  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#execute-babel-from-the-command-line)\nExecute Babel from the command line\n\nsh\n\n`   npm run build   `\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#browserify)\nBrowserify\n--------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#install-1)\nInstall\n\nsh\n\n`   npm install tsify   `\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#using-command-line-interface-1)\nUsing Command Line Interface\n\nsh\n\n`   browserify main.ts -p [ tsify --noImplicitAny ] > bundle.js   `\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#using-api)\nUsing API\n\njs\n\n`   var browserify = require(\"browserify\");  var tsify = require(\"tsify\");  browserify()    .add(\"main.ts\")    .plugin(\"tsify\", { noImplicitAny: true })    .bundle()    .pipe(process.stdout);   `\n\nMore details: [smrq/tsify](https://github.com/smrq/tsify)\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#grunt)\nGrunt\n----------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#using-grunt-ts-no-longer-maintained)\nUsing `grunt-ts` (no longer maintained)\n\n#### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#install-2)\nInstall\n\nsh\n\n`   npm install grunt-ts --save-dev   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#basic-gruntfilejs)\nBasic Gruntfile.js\n\njs\n\n`   module.exports = function (grunt) {    grunt.initConfig({      ts: {        default: {          src: [\"**/*.ts\", \"!node_modules/**/*.ts\"],        },      },    });    grunt.loadNpmTasks(\"grunt-ts\");    grunt.registerTask(\"default\", [\"ts\"]);  };   `\n\nMore details: [TypeStrong/grunt-ts](https://github.com/TypeStrong/grunt-ts)\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#using-grunt-browserify-combined-with-tsify)\nUsing `grunt-browserify` combined with `tsify`\n\n#### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#install-3)\nInstall\n\nsh\n\n`   npm install grunt-browserify tsify --save-dev   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#basic-gruntfilejs-1)\nBasic Gruntfile.js\n\njs\n\n`   module.exports = function (grunt) {    grunt.initConfig({      browserify: {        all: {          src: \"src/main.ts\",          dest: \"dist/main.js\",          options: {            plugin: [\"tsify\"],          },        },      },    });    grunt.loadNpmTasks(\"grunt-browserify\");    grunt.registerTask(\"default\", [\"browserify\"]);  };   `\n\nMore details: [jmreidy/grunt-browserify](https://github.com/jmreidy/grunt-browserify)\n, [TypeStrong/tsify](https://github.com/TypeStrong/tsify)\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#gulp)\nGulp\n--------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#install-4)\nInstall\n\nsh\n\n`   npm install gulp-typescript   `\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#basic-gulpfilejs)\nBasic gulpfile.js\n\njs\n\n`   var gulp = require(\"gulp\");  var ts = require(\"gulp-typescript\");  gulp.task(\"default\", function () {    var tsResult = gulp.src(\"src/*.ts\").pipe(      ts({        noImplicitAny: true,        out: \"output.js\",      })    );    return tsResult.js.pipe(gulp.dest(\"built/local\"));  });   `\n\nMore details: [ivogabe/gulp-typescript](https://github.com/ivogabe/gulp-typescript)\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#jspm)\nJspm\n--------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#install-5)\nInstall\n\nsh\n\n`   npm install -g jspm@beta   `\n\n_Note: Currently TypeScript support in jspm is in 0.16beta_\n\nMore details: [TypeScriptSamples/jspm](https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm)\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#msbuild)\nMSBuild\n--------------------------------------------------------------------------------------------------\n\nUpdate project file to include locally installed `Microsoft.TypeScript.Default.props` (at the top) and `Microsoft.TypeScript.targets` (at the bottom) files:\n\nxml\n\n`   <?xml version=\"1.0\" encoding=\"utf-8\"?>  <Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">    <!-- Include default props at the top -->    <Import        Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\"        Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\" />    <!-- TypeScript configurations go here -->    <PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">      <TypeScriptRemoveComments>false</TypeScriptRemoveComments>      <TypeScriptSourceMap>true</TypeScriptSourceMap>    </PropertyGroup>    <PropertyGroup Condition=\"'$(Configuration)' == 'Release'\">      <TypeScriptRemoveComments>true</TypeScriptRemoveComments>      <TypeScriptSourceMap>false</TypeScriptSourceMap>    </PropertyGroup>    <!-- Include default targets at the bottom -->    <Import        Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"        Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />  </Project>   `\n\nMore details about defining MSBuild compiler options: [Setting Compiler Options in MSBuild projects](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html)\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#nuget)\nNuGet\n----------------------------------------------------------------------------------------------\n\n*   Right-Click -> Manage NuGet Packages\n*   Search for `Microsoft.TypeScript.MSBuild`\n*   Hit `Install`\n*   When install is complete, rebuild!\n\nMore details can be found at [Package Manager Dialog](http://docs.nuget.org/Consume/Package-Manager-Dialog)\n and [using nightly builds with NuGet](https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild)\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#rollup)\nRollup\n------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#install-6)\nInstall\n\n`   npm install @rollup/plugin-typescript --save-dev   `\n\nNote that both `typescript` and `tslib` are peer dependencies of this plugin that need to be installed separately.\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#usage)\nUsage\n\nCreate a `rollup.config.js` [configuration file](https://www.rollupjs.org/guide/en/#configuration-files)\n and import the plugin:\n\njs\n\n`   // rollup.config.js  import typescript from '@rollup/plugin-typescript';  export default {    input: 'src/index.ts',    output: {      dir: 'output',      format: 'cjs'    },    plugins: [typescript()]  };   `\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#svelte-compiler)\nSvelte Compiler\n------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#install-7)\nInstall\n\n`   npm install --save-dev svelte-preprocess   `\n\nNote that `typescript` is an optional peer dependencies of this plugin and needs to be installed separately. `tslib` is not provided either.\n\nYou may also consider [`svelte-check`](https://www.npmjs.com/package/svelte-check)\n for CLI type checking.\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#usage-1)\nUsage\n\nCreate a `svelte.config.js` configuration file and import the plugin:\n\njs\n\n`   // svelte.config.js  import preprocess from 'svelte-preprocess';  const config = {    // Consult https://github.com/sveltejs/svelte-preprocess    // for more information about preprocessors    preprocess: preprocess()  };  export default config;   `\n\nYou can now specify that script blocks are written in TypeScript:\n\n`   <script lang=\"ts\">   `\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#vite)\nVite\n--------------------------------------------------------------------------------------------\n\nVite supports importing `.ts` files out-of-the-box. It only performs transpilation and not type checking. It also requires that some `compilerOptions` have certain values. See the [Vite docs](https://vitejs.dev/guide/features.html#typescript)\n for more details.\n\n[](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#webpack)\nWebpack\n--------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#install-8)\nInstall\n\nsh\n\n`   npm install ts-loader --save-dev   `\n\n### [](https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html#basic-webpackconfigjs-when-using-webpack-5-or-4)\nBasic webpack.config.js when using Webpack 5 or 4\n\njs\n\n`   const path = require('path');  module.exports = {    entry: './src/index.ts',    module: {      rules: [        {          test: /\\.tsx?$/,          use: 'ts-loader',          exclude: /node_modules/,        },      ],    },    resolve: {      extensions: ['.tsx', '.ts', '.js'],    },    output: {      filename: 'bundle.js',      path: path.resolve(__dirname, 'dist'),    },  };   `\n\nSee [more details on ts-loader here](https://www.npmjs.com/package/ts-loader)\n.\n\nAlternatives:\n\n*   [awesome-typescript-loader](https://www.npmjs.com/package/awesome-typescript-loader)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/project-config/Integrating%20with%20Build%20Tools.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nMDB![Maurice de Beijer  (6)](https://gravatar.com/avatar/974aa89116fa46b6895f67236546f417?s=32&&d=blank)\n\nRC![Ryan Cavanaugh  (3)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (3)](https://gravatar.com/avatar/8499bf678149d617cc71a23afb377736?s=32&&d=blank)\n\n15+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:description":"How to use TypeScript with other build tools","ogDescription":"How to use TypeScript with other build tools","language":"en","ogTitle":"Documentation - Integrating with Build Tools","title":"TypeScript: Documentation - Integrating with Build Tools","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","generator":"Gatsby 5.13.5","theme-color":"#3178C6","description":"How to use TypeScript with other build tools","og:title":"Documentation - Integrating with Build Tools","scrapeId":"f4574de3-81a6-4bf1-8c07-d8f49071c05b","sourceURL":"https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html","url":"https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nConfiguring Watch\n=================\n\nAs of TypeScript 3.8 and onward, the Typescript compiler exposes configuration which controls how it watches files and directories. Prior to this version, configuration required the use of environment variables which are still available.\n\n[](https://www.typescriptlang.org/docs/handbook/configuring-watch.html#background)\nBackground\n---------------------------------------------------------------------------------------------\n\nThe `--watch` implementation of the compiler relies on Node’s `fs.watch` and `fs.watchFile`. Each of these methods has pros and cons.\n\n`fs.watch` relies on file system events to broadcast changes in the watched files and directories. The implementation of this command is OS dependent and unreliable - on many operating systems, it does not work as expected. Additionally, some operating systems limit the number of watches which can exist simultaneously (e.g. some flavors of [Linux](https://man7.org/linux/man-pages/man7/inotify.7.html)\n). Heavy use of `fs.watch` in large codebases has the potential to exceed these limits and result in undesirable behavior. However, because this implementation relies on an events-based model, CPU use is comparatively light. The compiler typically uses `fs.watch` to watch directories (e.g. source directories included by compiler configuration files and directories in which module resolution failed, among others). TypeScript uses these to augment potential failures in individual file watchers. However, there is a key limitation of this strategy: recursive watching of directories is supported on Windows and macOS, but not on Linux. This suggested a need for additional strategies for file and directory watching.\n\n`fs.watchFile` uses polling and thus costs CPU cycles. However, `fs.watchFile` is by far the most reliable mechanism available to subscribe to the events from files and directories of interest. Under this strategy, the TypeScript compiler typically uses `fs.watchFile` to watch source files, config files, and files which appear missing based on reference statements. This means that the degree to which CPU usage will be higher when using `fs.watchFile` depends directly on number of files watched in the codebase.\n\n[](https://www.typescriptlang.org/docs/handbook/configuring-watch.html#configuring-file-watching-using-a-tsconfigjson)\nConfiguring file watching using a `tsconfig.json`\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThe suggested method of configuring watch behavior is through the new `watchOptions` section of `tsconfig.json`. We provide an example configuration below. See the following section for detailed descriptions of the settings available.\n\n`   {    // Some typical compiler options    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"es2020\",      \"[moduleResolution](https://www.typescriptlang.org/tsconfig#moduleResolution) \": \"node\"      // ...    },    // NEW: Options for file/directory watching    \"watchOptions\": {      // Use native file system events for files and directories      \"[watchFile](https://www.typescriptlang.org/tsconfig#watchFile) \": \"useFsEvents\",      \"[watchDirectory](https://www.typescriptlang.org/tsconfig#watchDirectory) \": \"useFsEvents\",      // Poll files for updates more frequently      // when they're updated a lot.      \"[fallbackPolling](https://www.typescriptlang.org/tsconfig#fallbackPolling) \": \"dynamicPriority\",      // Don't coalesce watch notification      \"[synchronousWatchDirectory](https://www.typescriptlang.org/tsconfig#synchronousWatchDirectory) \": true,      // Finally, two additional settings for reducing the amount of possible      // files to track  work from these directories      \"[excludeDirectories](https://www.typescriptlang.org/tsconfig#excludeDirectories) \": [\"**/node_modules\", \"_build\"],      \"[excludeFiles](https://www.typescriptlang.org/tsconfig#excludeFiles) \": [\"build/fileWhichChangesOften.ts\"]    }  }   `\n\nFor further details, see [the release notes for Typescript 3.8](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/configuring-watch.html#configuring-file-watching-using-environment-variable-tsc_watchfile)\nConfiguring file watching using environment variable `TSC_WATCHFILE`\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n| Option | Description |\n| --- | --- |\n| `PriorityPollingInterval` | Use `fs.watchFile`, but use different polling intervals for source files, config files and missing files |\n| `DynamicPriorityPolling` | Use a dynamic queue where frequently modified files are polled at shorter intervals, and unchanged files are polled less frequently |\n| `UseFsEvents` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to `fs.watchFile` when a watcher fails to be created. |\n| `UseFsEventsWithFallbackDynamicPolling` | Use `fs.watch`. On operating systems that limit the number of active watches, fall back to dynamic polling queues (as explained in `DynamicPriorityPolling`) |\n| `UseFsEventsOnParentDirectory` | Use `fs.watch` on the _parent_ directories of included files (yielding a compromise that results in lower CPU usage than pure `fs.watchFile` but potentially lower accuracy). |\n| default (no value specified) | If environment variable `TSC_NONPOLLING_WATCHER` is set to true, use `UseFsEventsOnParentDirectory`. Otherwise, watch files using `fs.watchFile` with `250ms` as the timeout for any file. |\n\n[](https://www.typescriptlang.org/docs/handbook/configuring-watch.html#configuring-directory-watching-using-environment-variable-tsc_watchdirectory)\nConfiguring directory watching using environment variable `TSC_WATCHDIRECTORY`\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nFor directory watches on platforms which don’t natively allow recursive directory watching (i.e. non macOS and Windows operating systems) is supported through recursively creating directory watchers for each child directory using different options selected by `TSC_WATCHDIRECTORY`.\n\n**NOTE:** On platforms which support native recursive directory watching, the value of `TSC_WATCHDIRECTORY` is ignored.\n\n| Option | Description |\n| --- | --- |\n| `RecursiveDirectoryUsingFsWatchFile` | Use `fs.watchFile` to watch included directories and child directories. |\n| `RecursiveDirectoryUsingDynamicPriorityPolling` | Use a dynamic polling queue to poll changes to included directories and child directories. |\n| default (no value specified) | Use `fs.watch` to watch included directories and child directories. |\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/project-config/Configuring%20Watch.md)\n ❤\n\nContributors to this page:  \n\nSN![Sheetal Nandi  (52)](https://gravatar.com/avatar/eaddbe18695ecd437e1fb16b9eca1922?s=32&&d=blank)\n\nOT![Orta Therox  (16)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nBS![Ben Stein  (1)](https://gravatar.com/avatar/64a9f64575ade37d5e3b4a1b9af36d6b568cd55f6b88f462116ed59c14c97876?s=32&&d=blank)\n\nJM![Josh Malkinson  (1)](https://gravatar.com/avatar/d104c43f583a510b9514336d0443f9f519d813ee8dacf0a2c2161761b958d1c7?s=32&&d=blank)\n\nIO![Iván Ovejero  (1)](https://gravatar.com/avatar/295845dcef2f47d9aa1059793f23f36ceb739f1772ac1b487f11a1094e733655?s=32&&d=blank)\n\n8+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:title":"Documentation - Configuring Watch","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"How to configure the watch mode of TypeScript","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","generator":"Gatsby 5.13.5","theme-color":"#3178C6","og:description":"How to configure the watch mode of TypeScript","title":"TypeScript: Documentation - Configuring Watch","description":"How to configure the watch mode of TypeScript","twitter:site":"typescriptlang","ogTitle":"Documentation - Configuring Watch","scrapeId":"08fd2959-6eb3-4cdd-8f8b-20794d819b54","sourceURL":"https://www.typescriptlang.org/docs/handbook/configuring-watch.html","url":"https://www.typescriptlang.org/docs/handbook/configuring-watch.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 5.7\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#checks-for-never-initialized-variables)\nChecks for Never-Initialized Variables\n----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nFor a long time, TypeScript has been able to catch issues when a variable has not yet been initialized in all prior branches.\n\nts\n\n`   let result: number  if (someCondition()) {      result = doSomeWork();  }  else {      let temporaryWork = doSomeWork();      temporaryWork *= 2;      // forgot to assign to 'result'  }  console.log(result); // error: Variable 'result' is used before being assigned.   `\n\nUnfortunately, there are some places where this analysis doesn’t work. For example, if the variable is accessed in a separate function, the type system doesn’t know when the function will be called, and instead takes an “optimistic” view that the variable will be initialized.\n\nts\n\n`   function foo() {      let result: number      if (someCondition()) {          result = doSomeWork();      }      else {          let temporaryWork = doSomeWork();          temporaryWork *= 2;          // forgot to assign to 'result'      }      printResult();      function printResult() {          console.log(result); // no error here.      }  }   `\n\nWhile TypeScript 5.7 is still lenient on variables that have _possibly_ been initialized, the type system is able to report errors when variables have _never_ been initialized at all.\n\nts\n\n`   function foo() {      let result: number      // do work, but forget to assign to 'result'      function printResult() {          console.log(result); // error: Variable 'result' is used before being assigned.      }  }   `\n\n[This change](https://github.com/microsoft/TypeScript/pull/55887)\n was contributed thanks to the work of GitHub user [Zzzen](https://github.com/Zzzen)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#path-rewriting-for-relative-paths)\nPath Rewriting for Relative Paths\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThere are several tools and runtimes that allow you to run TypeScript code “in-place”, meaning they do not require a build step which generates output JavaScript files. For example, ts-node, tsx, Deno, and Bun all support running `.ts` files directly. More recently, Node.js has been investigating such support with `--experimental-strip-types` (soon to be unflagged!) and `--experimental-transform-types`. This is extremely convenient because it allows us to iterate faster without worrying about re-running a build task.\n\nThere is some complexity to be aware of when using these modes though. To be maximally compatible with all these tools, a TypeScript file that’s imported “in-place” **must** be imported with the appropriate TypeScript extension at runtime. For example, to import a file called `foo.ts`, we have to write the following in Node’s new experimental support:\n\nts\n\n`   // main.ts  import * as foo from \"./foo.ts\"; // <- we need foo.ts here, not foo.js   `\n\nTypically, TypeScript would issue an error if we did this, because it expects us to import _the output file_. Because some tools do allow `.ts` imports, TypeScript has supported this import style with an option called `--allowImportingTsExtensions` for a while now. This works fine, but what happens if we need to actually generate `.js` files out of these `.ts` files? This is a requirement for library authors who will need to be able to distribute just `.js` files, but up until now TypeScript has avoided rewriting any paths.\n\nTo support this scenario, we’ve added a new compiler option called `--rewriteRelativeImportExtensions`. When an import path is _relative_ (starts with `./` or `../`), ends in a TypeScript extension (`.ts`, `.tsx`, `.mts`, `.cts`), and is a non-declaration file, the compiler will rewrite the path to the corresponding JavaScript extension (`.js`, `.jsx`, `.mjs`, `.cjs`).\n\nts\n\n`   // Under --rewriteRelativeImportExtensions...  // these will be rewritten.  import * as foo from \"./foo.ts\";  import * as bar from \"../someFolder/bar.mts\";  // these will NOT be rewritten in any way.  import * as a from \"./foo\";  import * as b from \"some-package/file.ts\";  import * as c from \"@some-scope/some-package/file.ts\";  import * as d from \"#/file.ts\";  import * as e from \"./file.js\";   `\n\nThis allows us to write TypeScript code that can be run in-place and then compiled into JavaScript when we’re ready.\n\nNow, we noted that TypeScript generally avoided rewriting paths. There are several reasons for this, but the most obvious one is dynamic imports. If a developer writes the following, it’s not trivial to handle the path that `import` receives. In fact, it’s impossible to override the behavior of `import` within any dependencies.\n\nts\n\n`   function getPath() {      if (Math.random() < 0.5) {          return \"./foo.ts\";      }      else {          return \"./foo.js\";      }  }  let myImport = await import(getPath());   `\n\nAnother issue is that (as we saw above) only _relative_ paths are rewritten, and they are written “naively”. This means that any path that relies on TypeScript’s `baseUrl` and `paths` will not get rewritten:\n\njson\n\n`   // tsconfig.json  {      \"compilerOptions\": {          \"module\": \"nodenext\",          // ...          \"paths\": {              \"@/*\": [\"./src/*\"]          }      }  }   `\n\nts\n\n`   // Won't be transformed, won't work.  import * as utilities from \"@/utilities.ts\";   `\n\nNor will any path that might resolve through the [`exports`](https://nodejs.org/api/packages.html#exports)\n and [`imports`](https://nodejs.org/api/packages.html#imports)\n fields of a `package.json`.\n\njson\n\n`   // package.json  {      \"name\": \"my-package\",      \"imports\": {          \"#root/*\": \"./dist/*\"      }  }   `\n\nts\n\n`   // Won't be transformed, won't work.  import * as utilities from \"#root/utilities.ts\";   `\n\nAs a result, if you’ve been using a workspace-style layout with multiple packages referencing each other, you might need to use [conditional exports](https://nodejs.org/api/packages.html#conditional-exports)\n with [scoped custom conditions](https://nodejs.org/api/packages.html#resolving-user-conditions)\n to make this work:\n\njson\n\n`   // my-package/package.json  {      \"name\": \"my-package\",      \"exports\": {          \".\": {              \"@my-package/development\": \"./src/index.ts\",              \"import\": \"./lib/index.js\"          },          \"./*\": {              \"@my-package/development\": \"./src/*.ts\",              \"import\": \"./lib/*.js\"          }      }  }   `\n\nAny time you want to import the `.ts` files, you can run it with `node --conditions=@my-package/development`.\n\nNote the “namespace” or “scope” we used for the condition `@my-package/development`. This is a bit of a makeshift solution to avoid conflicts from dependencies that might also use the `development` condition. If everyone ships a `development` in their package, then resolution may try to resolve to a `.ts` file which will not necessarily work. This idea is similar to what’s described in Colin McDonnell’s essay _[Live types in a TypeScript monorepo](https://colinhacks.com/essays/live-types-typescript-monorepo#:~:text=custom%20conditions)\n_, along with [tshy’s guidance for loading from source](https://github.com/isaacs/tshy#loading-from-source)\n.\n\nFor more specifics on how this feature works, [read up on the change here](https://github.com/microsoft/TypeScript/pull/59767)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#support-for---target-es2024-and---lib-es2024)\nSupport for `--target es2024` and `--lib es2024`\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.7 now supports `--target es2024`, which allows users to target ECMAScript 2024 runtimes. This target primarily enables specifying the new `--lib es2024` which contains many features for `SharedArrayBuffer` and `ArrayBuffer`, `Object.groupBy`, `Map.groupBy`, `Promise.withResolvers`, and more. It also moves `Atomics.waitAsync` from `--lib es2022` to `--lib es2024`.\n\nNote that as part of the changes to `SharedArrayBuffer` and `ArrayBuffer`, the two now diverge a bit. To bridge the gap and preserve the underlying buffer type, all `TypedArrays` (like `Uint8Array` and others) [are now also generic](https://github.com/microsoft/TypeScript/pull/59417)\n.\n\nts\n\n`   interface Uint8Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> {      // ...  }   `\n\nEach `TypedArray` now contains a type parameter named `TArrayBuffer`, though that type parameter has a default type argument so that we can continue to refer to `Int32Array` without explicitly writing out `Int32Array<ArrayBufferLike>`.\n\nIf you encounter any issues as part of this update, you may need to update `@types/node`.\n\n[This work](https://github.com/microsoft/TypeScript/pull/58573)\n was primarily provided thanks to [Kenta Moriuchi](https://github.com/petamoriken)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#searching-ancestor-configuration-files-for-project-ownership)\nSearching Ancestor Configuration Files for Project Ownership\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen a TypeScript file is loaded in an editor using TSServer (like Visual Studio or VS Code), the editor will try to find the relevant `tsconfig.json` file that “owns” the file. To do this, it walks up the directory tree from the file being edited, looking for any file named `tsconfig.json`.\n\nPreviously, this search would stop at the first `tsconfig.json` file found; however, imagine a project structure like the following:\n\n`   project/  ├── src/  │   ├── foo.ts  │   ├── foo-test.ts  │   ├── tsconfig.json  │   └── tsconfig.test.json  └── tsconfig.json   `\n\nHere, the idea is that `src/tsconfig.json` is the “main” configuration file for the project, and `src/tsconfig.test.json` is a configuration file for running tests.\n\njson\n\n`   // src/tsconfig.json  {      \"compilerOptions\": {          \"outDir\": \"../dist\"      },      \"exclude\": [\"**/*.test.ts\"]  }   `\n\njson\n\n`   // src/tsconfig.test.json  {      \"compilerOptions\": {          \"outDir\": \"../dist/test\"      },      \"include\": [\"**/*.test.ts\"],      \"references\": [          { \"path\": \"./tsconfig.json\" }      ]  }   `\n\njson\n\n`   // tsconfig.json  {      // This is a \"workspace-style\" or \"solution-style\" tsconfig.      // Instead of specifying any files, it just references all the actual projects.      \"files\": [],      \"references\": [          { \"path\": \"./src/tsconfig.json\" },          { \"path\": \"./src/tsconfig.test.json\" },      ]  }   `\n\nThe problem here is that when editing `foo-test.ts`, the editor would find `project/src/tsconfig.json` as the “owning” configuration file - but that’s not the one we want! If the walk stops at this point, that might not be desirable. The only way to avoid this previously was to rename `src/tsconfig.json` to something like `src/tsconfig.src.json`, and then all files would hit the top-level `tsconfig.json` which references every possible project.\n\n`   project/  ├── src/  │   ├── foo.ts  │   ├── foo-test.ts  │   ├── tsconfig.src.json  │   └── tsconfig.test.json  └── tsconfig.json   `\n\nInstead of forcing developers to do this, TypeScript 5.7 now continues walking up the directory tree to find other appropriate `tsconfig.json` files for editor scenarios. This can provide more flexibility in how projects are organized and how configuration files are structured.\n\nYou can get more specifics on the implementation on GitHub [here](https://github.com/microsoft/TypeScript/pull/57196)\n and [here](https://github.com/microsoft/TypeScript/pull/59688)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#faster-project-ownership-checks-in-editors-for-composite-projects)\nFaster Project Ownership Checks in Editors for Composite Projects\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nImagine a large codebase with the following structure:\n\n`   packages  ├── graphics/  │   ├── tsconfig.json  │   └── src/  │       └── ...  ├── sound/  │   ├── tsconfig.json  │   └── src/  │       └── ...  ├── networking/  │   ├── tsconfig.json  │   └── src/  │       └── ...  ├── input/  │   ├── tsconfig.json  │   └── src/  │       └── ...  └── app/      ├── tsconfig.json      ├── some-script.js      └── src/          └── ...   `\n\nEach directory in `packages` is a separate TypeScript project, and the `app` directory is the main project that depends on all the other projects.\n\njson\n\n`   // app/tsconfig.json  {      \"compilerOptions\": {          // ...      },      \"include\": [\"src\"],      \"references\": [          { \"path\": \"../graphics/tsconfig.json\" },          { \"path\": \"../sound/tsconfig.json\" },          { \"path\": \"../networking/tsconfig.json\" },          { \"path\": \"../input/tsconfig.json\" }      ]  }   `\n\nNow notice we have the file `some-script.js` in the `app` directory. When we open `some-script.js` in the editor, the TypeScript language service (which also handles the editor experience for JavaScript files!) has to figure out which project the file belongs to so it can apply the right settings.\n\nIn this case, the nearest `tsconfig.json` does _not_ include `some-script.js`, but TypeScript will proceed to ask “could one of the projects _referenced_ by `app/tsconfig.json` include `some-script.js`?“. To do so, TypeScript would previously load up each project, one-by-one, and stop as soon as it found a project which contained `some-script.js`. Even if `some-script.js` isn’t included in the root set of files, TypeScript would still parse all the files within a project because some of the root set of files can still _transitively_ reference `some-script.js`.\n\nWhat we found over time was that this behavior caused extreme and unpredictable behavior in larger codebases. Developers would open up stray script files and find themselves waiting for their entire codebase to be opened up.\n\nThankfully, every project that can be referenced by another (non-workspace) project must enable a flag called `composite`, which enforces a rule that all input source files must be known up-front. So when probing a `composite` project, TypeScript 5.7 will only check if a file belongs to the _root set of files_ of that project. This should avoid this common worst-case behavior.\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/59688)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#validated-json-imports-in---module-nodenext)\nValidated JSON Imports in `--module nodenext`\n\nWhen importing from a `.json` file under `--module nodenext`, TypeScript will now enforce certain rules to prevent runtime errors.\n\nFor one, an import attribute containing `type: \"json\"` needs to be present for any JSON file import.\n\nts\n\n``   import myConfig from \"./myConfig.json\";  //                   ~~~~~~~~~~~~~~~~~  // ❌ error: Importing a JSON file into an ECMAScript module requires a 'type: \"json\"' import attribute when 'module' is set to 'NodeNext'.  import myConfig from \"./myConfig.json\" with { type: \"json\" };  //                                          ^^^^^^^^^^^^^^^^  // ✅ This is fine because we provided `type: \"json\"`   ``\n\nOn top of this validation, TypeScript will not generate “named” exports, and the contents of a JSON import will only be accessible via a default.\n\nts\n\n`   // ✅ This is okay:  import myConfigA from \"./myConfig.json\" with { type: \"json\" };  let version = myConfigA.version;  ///////////  import * as myConfigB from \"./myConfig.json\" with { type: \"json\" };  // ❌ This is not:  let version = myConfig.version;  // ✅ This is okay:  let version = myConfig.default.version;   `\n\n[See here](https://github.com/microsoft/TypeScript/pull/60019)\n for more information on this change.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#support-for-v8-compile-caching-in-nodejs)\nSupport for V8 Compile Caching in Node.js\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nNode.js 22 supports [a new API called `module.enableCompileCache()`](https://github.com/nodejs/node/pull/54501)\n. This API allows the runtime to reuse some of the parsing and compilation work done after the first run of a tool.\n\nTypeScript 5.7 now leverages the API so that it can start doing useful work sooner. In some of our own testing, we’ve witnessed about a 2.5x speed-up in running `tsc --version`.\n\n`   Benchmark 1: node ./built/local/_tsc.js --version (*without* caching)    Time (mean ± σ):     122.2 ms ±   1.5 ms    [User: 101.7 ms, System: 13.0 ms]    Range (min … max):   119.3 ms … 132.3 ms    200 runs  Benchmark 2: node ./built/local/tsc.js --version  (*with* caching)    Time (mean ± σ):      48.4 ms ±   1.0 ms    [User: 34.0 ms, System: 11.1 ms]    Range (min … max):    45.7 ms …  52.8 ms    200 runs  Summary    node ./built/local/tsc.js --version ran      2.52 ± 0.06 times faster than node ./built/local/_tsc.js --version   `\n\nFor more information, [see the pull request here](https://github.com/microsoft/TypeScript/pull/59720)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#notable-behavioral-changes)\nNotable Behavioral Changes\n----------------------------------------------------------------------------------------------------------------------------------------\n\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#libdts)\n`lib.d.ts`\n\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, [see linked issues related to DOM and `lib.d.ts` updates for this version of TypeScript](https://github.com/microsoft/TypeScript/pull/60061)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#typedarrays-are-now-generic-over-arraybufferlike)\n`TypedArray`s Are Now Generic Over `ArrayBufferLike`\n\nIn ECMAScript 2024, `SharedArrayBuffer` and `ArrayBuffer` have types that slightly diverge. To bridge the gap and preserve the underlying buffer type, all `TypedArrays` (like `Uint8Array` and others) [are now also generic](https://github.com/microsoft/TypeScript/pull/59417)\n.\n\nts\n\n`   interface Uint8Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> {      // ...  }   `\n\nEach `TypedArray` now contains a type parameter named `TArrayBuffer`, though that type parameter has a default type argument so that users can continue to refer to `Int32Array` without explicitly writing out `Int32Array<ArrayBufferLike>`.\n\nIf you encounter any issues as part of this update, such as\n\n`   error TS2322: Type 'Buffer' is not assignable to type 'Uint8Array<ArrayBufferLike>'.  error TS2345: Argument of type 'Buffer' is not assignable to parameter of type 'Uint8Array<ArrayBufferLike>'.  error TS2345: Argument of type 'ArrayBufferLike' is not assignable to parameter of type 'ArrayBuffer'.  error TS2345: Argument of type 'Buffer' is not assignable to parameter of type 'string | ArrayBufferView | Stream | Iterable<string | ArrayBufferView> | AsyncIterable<string | ArrayBufferView>'.   `\n\nthen you may need to update `@types/node`.\n\nYou can read the [specifics about this change on GitHub](https://github.com/microsoft/TypeScript/pull/59417)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#creating-index-signatures-from-non-literal-method-names-in-classes)\nCreating Index Signatures from Non-Literal Method Names in Classes\n\nTypeScript now has a more consistent behavior for methods in classes when they are declared with non-literal computed property names. For example, in the following:\n\nts\n\n`   declare const symbolMethodName: symbol;  export class A {      [symbolMethodName]() { return 1 };  }   `\n\nPreviously TypeScript just viewed the class in a way like the following:\n\nts\n\n`   export class A {  }   `\n\nIn other words, from the type system’s perspective, `[symbolMethodName]` contributed nothing to the type of `A`\n\nTypeScript 5.7 now views the method `[symbolMethodName]() {}` more meaningfully, and generates an index signature. As a result, the code above is interpreted as something like the following code:\n\nts\n\n`   export class A {      [x: symbol]: () => number;  }   `\n\nThis provides behavior that is consistent with properties and methods in object literals.\n\n[Read up more on this change here](https://github.com/microsoft/TypeScript/pull/59860)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html#more-implicit-any-errors-on-functions-returning-null-and-undefined)\nMore Implicit `any` Errors on Functions Returning `null` and `undefined`\n\nWhen a function expression is contextually typed by a signature returning a generic type, TypeScript now appropriately provides an implicit `any` error under `noImplicitAny`, but outside of `strictNullChecks`.\n\nts\n\n`   declare var p: Promise<number>;  const p2 = p.catch(() => null);  //                 ~~~~~~~~~~  // error TS7011: Function expression, which lacks return-type annotation, implicitly has an 'any' return type.   `\n\n[See this change for more details](https://github.com/microsoft/TypeScript/pull/59661)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%205.7.md)\n ❤\n\nContributors to this page:  \n\nN![navya9singh  (6)](https://gravatar.com/avatar/e896fd3c90d7bd8d3c276d3ea2dd552ae62d81d4a497cdd589f551c5eb5ccb93?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - TypeScript 5.7","language":"en","ogDescription":"TypeScript 5.7 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"TypeScript 5.7 Release Notes","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","og:title":"Documentation - TypeScript 5.7","og:description":"TypeScript 5.7 Release Notes","title":"TypeScript: Documentation - TypeScript 5.7","twitter:site":"typescriptlang","generator":"Gatsby 5.13.5","scrapeId":"020ff349-f848-4d74-a499-cfcfa57707e9","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-7.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 5.6\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#disallowed-nullish-and-truthy-checks)\nDisallowed Nullish and Truthy Checks\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nMaybe you’ve written a regex and forgotten to call `.test(...)` on it:\n\nts\n\n`   if (/0x[0-9a-f]/) {      // Oops! This block always runs.      // ...  }   `\n\nor maybe you’ve accidentally written `=>` (which creates an arrow function) instead of `>=` (the greater-than-or-equal-to operator):\n\nts\n\n`   if (x => 0) {      // Oops! This block always runs.      // ...  }   `\n\nor maybe you’ve tried to use a default value with `??`, but mixed up the precedence of `??` and a comparison operator like `<`:\n\nts\n\n`   function isValid(value: string | number, options: any, strictness: \"strict\" | \"loose\") {      if (strictness === \"loose\") {          value = +value      }      return value < options.max ?? 100;      // Oops! This is parsed as (value < options.max) ?? 100  }   `\n\nor maybe you’ve misplaced a parenthesis in a complex expression:\n\nts\n\n`   if (      isValid(primaryValue, \"strict\") || isValid(secondaryValue, \"strict\") ||      isValid(primaryValue, \"loose\" || isValid(secondaryValue, \"loose\"))  ) {      //                           ^^^^ 👀 Did we forget a closing ')'?  }   `\n\nNone of these examples do what the author intended, but they’re all valid JavaScript code. Previously TypeScript also quietly accepted these examples.\n\nBut with a little bit of experimentation, we found that many _many_ bugs could be caught from flagging down suspicious examples like above. In TypeScript 5.6, the compiler now errors when it can syntactically determine a truthy or nullish check will always evaluate in a specific way. So in the above examples, you’ll start to see errors:\n\nts\n\n`   if (/0x[0-9a-f]/) {  //  ~~~~~~~~~~~~  // error: This kind of expression is always truthy.  }  if (x => 0) {  //  ~~~~~~  // error: This kind of expression is always truthy.  }  function isValid(value: string | number, options: any, strictness: \"strict\" | \"loose\") {      if (strictness === \"loose\") {          value = +value      }      return value < options.max ?? 100;      //     ~~~~~~~~~~~~~~~~~~~      // error: Right operand of ?? is unreachable because the left operand is never nullish.  }  if (      isValid(primaryValue, \"strict\") || isValid(secondaryValue, \"strict\") ||      isValid(primaryValue, \"loose\" || isValid(secondaryValue, \"loose\"))  ) {      //                    ~~~~~~~      // error: This kind of expression is always truthy.  }   `\n\nSimilar results can be achieved by enabling the ESLint `no-constant-binary-expression` rule, and you can [see some of the results they achieved in their blog post](https://eslint.org/blog/2022/07/interesting-bugs-caught-by-no-constant-binary-expression/)\n; but the new checks TypeScript performs does not have perfect overlap with the ESLint rule, and we also believe there is a lot of value in having these checks built into TypeScript itself.\n\nNote that certain expressions are still allowed, even if they are always truthy or nullish. Specifically, `true`, `false`, `0`, and `1` are all still allowed despite always being truthy or falsy, since code like the following:\n\nts\n\n`   while (true) {      doStuff();      if (something()) {          break;      }      doOtherStuff();  }   `\n\nis still idiomatic and useful, and code like the following:\n\nts\n\n`   if (true || inDebuggingOrDevelopmentEnvironment()) {      // ...  }   `\n\nis useful while iterating/debugging code.\n\nIf you’re curious about the implementation or the sorts of bugs it catches, take a look at [the pull request that implemented this feature](https://github.com/microsoft/TypeScript/pull/59217)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods)\nIterator Helper Methods\n----------------------------------------------------------------------------------------------------------------------------------\n\nJavaScript has a notion of _iterables_ (things which we can iterate over by calling a `[Symbol.iterator]()` and getting an iterator) and _iterators_ (things which have a `next()` method which we can call to try to get the next value as we iterate). By and large, you don’t typically have to think about these things when you toss them into a `for`/`of` loop, or `[...spread]` them into a new array. But TypeScript does model these with the types `Iterable` and `Iterator` (and even `IterableIterator` which acts as both!), and these types describe the minimal set of members you need for constructs like `for`/`of` to work on them.\n\n`Iterable`s (and `IterableIterator`s) are nice because they can be used in all sorts of places in JavaScript - but a lot of people found themselves missing methods on `Array`s like `map`, `filter`, and for some reason `reduce`. That’s why [a recent proposal was brought forward in ECMAScript](https://github.com/tc39/proposal-iterator-helpers)\n to add many methods (and more) from `Array` onto most of the `IterableIterator`s that are produced in JavaScript.\n\nFor example, every generator now produces an object that also has a `map` method and a `take` method.\n\nts\n\n`   function* positiveIntegers() {      let i = 1;      while (true) {          yield i;          i++;      }  }  const evenNumbers = positiveIntegers().map(x => x * 2);  // Output:  //    2  //    4  //    6  //    8  //   10  for (const value of evenNumbers.take(5)) {      console.log(value);  }   `\n\nThe same is true for methods like `keys()`, `values()`, and `entries()` on `Map`s and `Set`s.\n\nts\n\n`   function invertKeysAndValues<K, V>(map: Map<K, V>): Map<V, K> {      return new Map(          map.entries().map(([k, v]) => [v, k])      );  }   `\n\nYou can also extend the new `Iterator` object:\n\nts\n\n``   /**   * Provides an endless stream of `0`s.   */  class Zeroes extends Iterator<number> {      next() {          return { value: 0, done: false } as const;      }  }  const zeroes = new Zeroes();  // Transform into an endless stream of `1`s.  const ones = zeroes.map(x => x + 1);   ``\n\nAnd you can adapt any existing `Iterable`s or `Iterator`s into this new type with `Iterator.from`:\n\nts\n\n`   Iterator.from(...).filter(someFunction);   `\n\nNow, we have to talk about naming.\n\nEarlier we mentioned that TypeScript has types for `Iterable` and `Iterator`; however, like we mentioned, these act sort of like “protocols” to ensure certain operations work. _That means that not every value that is declared `Iterable` or `Iterator` in TypeScript will have those methods we mentioned above._\n\nBut there is still a new **runtime value** called `Iterator`. You can reference `Iterator`, as well as `Iterator.prototype`, as actual values in JavaScript. This is a bit awkward since TypeScript already defines its own thing called `Iterator` purely for type-checking. So due to this unfortunate name clash, TypeScript needs to introduce a separate type to describe these native/built-in iterable iterators.\n\nTypeScript 5.6 introduces a new type called `IteratorObject`. It is defined as follows:\n\nts\n\n`   interface IteratorObject<T, TReturn = unknown, TNext = unknown> extends Iterator<T, TReturn, TNext> {      [Symbol.iterator](): IteratorObject<T, TReturn, TNext>;  }   `\n\nLots of built-in collections and methods produce subtypes of `IteratorObject`s (like `ArrayIterator`, `SetIterator`, `MapIterator`, and more), and both the core JavaScript and DOM types in `lib.d.ts`, along with `@types/node`, have been updated to use this new type.\n\nSimilarly, there is a `AsyncIteratorObject` type for parity. `AsyncIterator` does not yet exist as a runtime value in JavaScript that brings the same methods for `AsyncIterable`s, [but it is an active proposal](https://github.com/tc39/proposal-async-iterator-helpers)\n and this new type prepares for it.\n\nWe’d like to thank [Kevin Gibbons](https://github.com/bakkot)\n who contributed [the changes for these types](https://github.com/microsoft/TypeScript/pull/58222)\n, and who is one of the co-authors of [the proposal](https://github.com/tc39/proposal-iterator-helpers)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#strict-builtin-iterator-checks-and---strictbuiltiniteratorreturn)\nStrict Builtin Iterator Checks (and `--strictBuiltinIteratorReturn`)\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen you call the `next()` method on an `Iterator<T, TReturn>`, it returns an object with a `value` and a `done` property. This is modeled with the type `IteratorResult`.\n\nts\n\n`   type IteratorResult<T, TReturn = any> = IteratorYieldResult<T> | IteratorReturnResult<TReturn>;  interface IteratorYieldResult<TYield> {      done?: false;      value: TYield;  }  interface IteratorReturnResult<TReturn> {      done: true;      value: TReturn;  }   `\n\nThe naming here is inspired by the way a generator function works. Generator functions can `yield` values, and then `return` a final value - but the types between the two can be unrelated.\n\nts\n\n`   function abc123() {      yield \"a\";      yield \"b\";      yield \"c\";      return 123;  }  const iter = abc123();  iter.next(); // { value: \"a\", done: false }  iter.next(); // { value: \"b\", done: false }  iter.next(); // { value: \"c\", done: false }  iter.next(); // { value: 123, done: true }   `\n\nWith the new `IteratorObject` type, we discovered some difficulties in allowing safe implementations of `IteratorObject`s. At the same time, there’s been a long standing unsafety with `IteratorResult` in cases where `TReturn` was `any` (the default!). For example, let’s say we have an `IteratorResult<string, any>`. If we end up reaching for the `value` of this type, we’ll end up with `string | any`, which is just `any`.\n\nts\n\n``   function* uppercase(iter: Iterator<string, any>) {      while (true) {          const { value, done } = iter.next();          yield value.toUppercase(); // oops! forgot to check for `done` first and misspelled `toUpperCase`          if (done) {              return;          }      }  }   ``\n\nIt would be hard to fix this on every `Iterator` today without introducing a lot of breaks, but we can at least fix it with most `IteratorObject`s that get created.\n\nTypeScript 5.6 introduces a new intrinsic type called `BuiltinIteratorReturn` and a new `--strict`\\-mode flag called `--strictBuiltinIteratorReturn`. Whenever `IteratorObject`s are used in places like `lib.d.ts`, they are always written with `BuiltinIteratorReturn` type for `TReturn` (though you’ll see the more-specific `MapIterator`, `ArrayIterator`, `SetIterator` more often).\n\nts\n\n`   interface MapIterator<T> extends IteratorObject<T, BuiltinIteratorReturn, unknown> {      [Symbol.iterator](): MapIterator<T>;  }  // ...  interface Map<K, V> {      // ...      /**       * Returns an iterable of key, value pairs for every entry in the map.       */      entries(): MapIterator<[K, V]>;      /**       * Returns an iterable of keys in the map       */      keys(): MapIterator<K>;      /**       * Returns an iterable of values in the map       */      values(): MapIterator<V>;  }   `\n\nBy default, `BuiltinIteratorReturn` is `any`, but when `--strictBuiltinIteratorReturn` is enabled (possibly via `--strict`), it is `undefined`. Under this new mode, if we use `BuiltinIteratorReturn`, our earlier example now correctly errors:\n\nts\n\n`   function* uppercase(iter: Iterator<string, BuiltinIteratorReturn>) {      while (true) {          const { value, done } = iter.next();          yield value.toUppercase();          //    ~~~~~ ~~~~~~~~~~~          // error! ┃      ┃          //        ┃      ┗━ Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?          //        ┃          //        ┗━ 'value' is possibly 'undefined'.          if (done) {              return;          }      }  }   `\n\nYou’ll typically see `BuiltinIteratorReturn` paired up with `IteratorObject` throughout `lib.d.ts`. In general, we recommend being more explicit around the `TReturn` in your own code when possible.\n\nFor more information, you can [read up on the feature here](https://github.com/microsoft/TypeScript/pull/58243)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#support-for-arbitrary-module-identifiers)\nSupport for Arbitrary Module Identifiers\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nJavaScript allows modules to export bindings with invalid identifier names as string literals:\n\nts\n\n`   const banana = \"🍌\";  export { banana as \"🍌\" };   `\n\nLikewise, it allows modules to grab imports with these arbitrary names and bind them to valid identifiers:\n\nts\n\n`   import { \"🍌\" as banana } from \"./foo\"  /**   * om nom nom   */  function eat(food: string) {      console.log(\"Eating\", food);  };  eat(banana);   `\n\nThis seems like a cute party trick (if you’re as fun as we are at parties), but it has its uses for interoperability with other languages (typically via JavaScript/WebAssembly boundaries), since other languages may have different rules for what constitutes a valid identifier. It can also be useful for tools that generate code, like esbuild [with its `inject` feature](https://esbuild.github.io/api/#inject)\n.\n\nTypeScript 5.6 now allows you to use these arbitrary module identifiers in your code! We’d like to thank [Evan Wallace](https://github.com/evanw)\n who [contributed this change to TypeScript](https://github.com/microsoft/TypeScript/pull/58640)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#the---nouncheckedsideeffectimports-option)\nThe `--noUncheckedSideEffectImports` Option\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript it’s possible to `import` a module without actually importing any values from it.\n\nts\n\n`   import \"some-module\";   `\n\nThese imports are often called _side effect imports_ because the only useful behavior they can provide is by executing some side effect (like registering a global variable, or adding a polyfill to a prototype).\n\nIn TypeScript, this syntax has had a pretty strange quirk: if the `import` could be resolved to a valid source file, then TypeScript would load and check the file. On the other hand, if no source file could be found, TypeScript would silently ignore the `import`!\n\nThis is surprising behavior, but it partially stems from modeling patterns in the JavaScript ecosystem. For example, this syntax has also been used with special loaders in bundlers to load CSS or other assets. Your bundler might be configured in such a way where you can include specific `.css` files by writing something like the following:\n\ntsx\n\n`   import \"./button-component.css\";  export function Button() {      // ...  }   `\n\nStill, this masks potential typos on side effect imports. That’s why TypeScript 5.6 introduces a new compiler option called `--noUncheckedSideEffectImports`, to catch these cases. When `--noUncheckedSideEffectImports` is enabled, TypeScript will now error if it can’t find a source file for a side effect import.\n\nts\n\n`   import \"oops-this-module-does-not-exist\";  //     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  // error: Cannot find module 'oops-this-module-does-not-exist' or its corresponding type declarations.   `\n\nWhen enabling this option, some working code may now receive an error, like in the CSS example above. To work around this, users who want to just write side effect `import`s for assets might be better served by writing what’s called an _ambient module declaration_ with a wildcard specifier. It would go in a global file and look something like the following:\n\nts\n\n`   // ./src/globals.d.ts  // Recognize all CSS files as module imports.  declare module \"*.css\" {}   `\n\nIn fact, you might already have a file like this in your project! For example, running something like `vite init` might create a similar `vite-env.d.ts`.\n\nWhile this option is currently off by default, we encourage users to give it a try!\n\nFor more information, [check out the implementation here](https://github.com/microsoft/TypeScript/pull/58941)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#the---nocheck-option)\nThe `--noCheck` Option\n------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.6 introduces a new compiler option, `--noCheck`, which allows you to skip type checking for all input files. This avoids unnecessary type-checking when performing any semantic analysis necessary for emitting output files.\n\nOne scenario for this is to separate JavaScript file generation from type-checking so that the two can be run as separate phases. For example, you could run `tsc --noCheck` while iterating, and then `tsc --noEmit` for a thorough type check. You could also run the two tasks in parallel, even in `--watch` mode, though note you’d probably want to specify a separate `--tsBuildInfoFile` path if you’re truly running them at the same time.\n\n`--noCheck` is also useful for emitting declaration files in a similar fashion. In a project where `--noCheck` is specified on a project that conforms to `--isolatedDeclarations`, TypeScript can quickly generate declaration files without a type-checking pass. The generated declaration files will rely purely on quick syntactic transformations.\n\nNote that in cases where `--noCheck` is specified, but a project does _not_ use `--isolatedDeclarations`, TypeScript may still perform as much type-checking as necessary to generate `.d.ts` files. In this sense, `--noCheck` is a bit of a misnomer; however, the process will be lazier than a full type-check, only calculating the types of unannotated declarations. This should be much faster than a full type-check.\n\n`noCheck` is also available via the TypeScript API as a standard option. Internally, `transpileModule` and `transpileDeclaration` already used `noCheck` to speed things up (at least as of TypeScript 5.5). Now any build tool should be able to leverage the flag, taking a variety of custom strategies to coordinate and speed up builds.\n\nFor more information, see [the work done in TypeScript 5.5 to power up `noCheck` internally](https://github.com/microsoft/TypeScript/pull/58364)\n, along with the relevant work to make it publicly available [on the command line](https://github.com/microsoft/TypeScript/pull/58839)\n and\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#allow---build-with-intermediate-errors)\nAllow `--build` with Intermediate Errors\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s concept of _project references_ allows you to organize your codebase into multiple projects and create dependencies between them. Running the TypeScript compiler in `--build` mode (or `tsc -b` for short) is the built-in way of actually conducting that build across projects and figuring out which projects and files need to be compiled.\n\nPreviously, using `--build` mode would assume `--noEmitOnError` and immediately stop the build if any errors were encountered. This meant that “downstream” projects could never be checked and built if any of their “upstream” dependencies had build errors. In theory, this is a very cromulent approach - if a project has errors, it is not necessarily in a coherent state for its dependencies.\n\nIn reality, this sort of rigidity made things like upgrades a pain. For example, if `projectB` depends on `projectA`, then people more familiar with `projectB` can’t proactively upgrade their code until their dependencies are upgraded. They are blocked by work on upgrading `projectA` first.\n\nAs of TypeScript 5.6, `--build` mode will continue to build projects even if there are intermediate errors in dependencies. In the face of intermediate errors, they will be reported consistently and output files will be generated on a best-effort basis; however, the build will continue to completion on the specified project.\n\nIf you want to stop the build on the first project with errors, you can use a new flag called `--stopOnBuildErrors`. This can be useful when running in a CI environment, or when iterating on a project that’s heavily depended upon by other projects.\n\nNote that to accomplish this, TypeScript now always emits a `.tsbuildinfo` file for any project in a `--build` invocation (even if `--incremental`/`--composite` is not specified). This is to keep track of the state of how `--build` was invoked and what work needs to be performed in the future.\n\nYou can [read more about this change here on the implementation](https://github.com/microsoft/TypeScript/pull/58838)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#region-prioritized-diagnostics-in-editors)\nRegion-Prioritized Diagnostics in Editors\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen TypeScript’s language service is asked for the _diagnostics_ for a file (things like errors, suggestions, and deprecations), it would typically require checking the _entire file_. Most of the time this is fine, but in extremely large files it can incur a delay. That can be frustrating because fixing a typo should feel like a quick operation, but can take _seconds_ in a big-enough file.\n\nTo address this, TypeScript 5.6 introduces a new feature called _region-prioritized diagnostics_ or _region-prioritized checking_. Instead of just requesting diagnostics for a set of files, editors can now also provide a relevant region of a given file - and the intent is that this will typically be the region of the file that is currently visible to a user. The TypeScript language server can then choose to provide two sets of diagnostics: one for the region, and one for the file in its entirety. This allows editing to feel _way_ more responsive in large files so you’re not waiting as long for thoes red squiggles to disappear.\n\nFor some specific numbers, in our testing [on TypeScript’s own `checker.ts`](https://github.com/microsoft/TypeScript/blob/7319968e90600102892a79142fb804bcbe384160/src/compiler/checker.ts)\n, a full semantic diagnostics response took 3330ms. In contrast, the response for the first region-based diagnostics response took 143ms! While the remaining whole-file response took about 3200ms, this can make a huge difference for quick edits.\n\nThis feature also includes quite a bit of work to also make diagnostics report more consistently throughout your experience. Due the way our type-checker leverages caching to avoid work, subsequent checks between the same types could often have a different (typically shorter) error message. Technically, lazy out-of-order checking could cause diagnostics to report differently between two locations in an editor - even before this feature - but we didn’t want to exacerbate the issue. With recent work, we’ve ironed out many of these error inconsistencies.\n\nCurrently, this functionality is available in Visual Studio Code for TypeScript 5.6 and later.\n\nFor more detailed information, [take a look at the implementation and write-up here](https://github.com/microsoft/TypeScript/pull/57842)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#granular-commit-characters)\nGranular Commit Characters\n----------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s language service now provides its own _commit characters_ for each completion item. Commit characters are specific characters that, when typed, will automatically commit the currently-suggested completion item.\n\nWhat this means is that over time your editor will now more frequently commit to the currently-suggested completion item when you type certain characters. For example, take the following code:\n\nts\n\n`   declare let food: {      eat(): any;  }  let f = (foo/**/   `\n\nIf our cursor is at `/**/`, it’s unclear if the code we’re writing is going to be something like `let f = (food.eat())` or `let f = (foo, bar) => foo + bar`. You could imagine that the editor might be able to auto-complete differently depending on which character we type out next. For instance, if we type in the period/dot character (`.`), we probably want the editor to complete with the variable `food`; but if we type the comma character (`,`), we might be writing out a parameter in an arrow function.\n\nUnfortunately, previously TypeScript just signaled to editors that the current text might define a new parameter name so that _no_ commit characters were safe. So hitting a `.` wouldn’t do anything even if it was “obvious” that the editor should auto-complete with the word `food`.\n\nTypeScript now explicitly lists which characters are safe to commit for each completion item. While this won’t _immediately_ change your day-to-day experience, editors that support these commit characters should see behavioral improvements over time. To see those improvements right now, you can now [use the TypeScript nightly extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next)\n with [Visual Studio Code Insiders](https://code.visualstudio.com/insiders/)\n. Hitting `.` in the code above correctly auto-completes with `food`.\n\nFor more information, see [the pull request that added commit characters](https://github.com/microsoft/TypeScript/pull/59339)\n along with our [adjustments to commit characters depending on context](https://github.com/microsoft/TypeScript/pull/59523)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#exclude-patterns-for-auto-imports)\nExclude Patterns for Auto-Imports\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s language service now allows you to specify a list of regular expression patterns which will filter away auto-import suggestions from certain specifiers. For example, if you want to exclude all “deep” imports from a package like `lodash`, you could configure the following preference in Visual Studio Code:\n\njson\n\n`   {      \"typescript.preferences.autoImportSpecifierExcludeRegexes\": [          \"^lodash/.*$\"      ]  }   `\n\nOr going the other way, you might want to disallow importing from the entry-point of a package:\n\njson\n\n`   {      \"typescript.preferences.autoImportSpecifierExcludeRegexes\": [          \"^lodash$\"      ]  }   `\n\nOne could even avoid `node:` imports by using the following setting:\n\njson\n\n`   {      \"typescript.preferences.autoImportSpecifierExcludeRegexes\": [          \"^node:\"      ]  }   `\n\nNote that if you want to specify certain flags like `i` or `u`, you will need to surround your regular expression with slashes. When providing surrounding slashes, you’ll need to escape other inner slashes.\n\njson\n\n`   {      \"typescript.preferences.autoImportSpecifierExcludeRegexes\": [          \"^./lib/internal\",        // no escaping needed          \"/^.\\\\/lib\\\\/internal/\",  // escaping needed - note the leading and trailing slashes          \"/^.\\\\/lib\\\\/internal/i\"  // escaping needed - we needed slashes to provide the 'i' regex flag      ]  }   `\n\nIn Visual Studio Code, the same settings can be applied for JavaScript through `javascript.preferences.autoImportSpecifierExcludeRegexes`.\n\nFor more information, [see the implementation here](https://github.com/microsoft/TypeScript/pull/59543)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#notable-behavioral-changes)\nNotable Behavioral Changes\n----------------------------------------------------------------------------------------------------------------------------------------\n\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#libdts)\n`lib.d.ts`\n\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, [see linked issues related to DOM and `lib.d.ts` updates for this version of TypeScript](https://github.com/microsoft/TypeScript/issues/58764)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#tsbuildinfo-is-always-written)\n`.tsbuildinfo` is Always Written\n\nTo enable `--build` to continue building projects even if there are intermediate errors in dependencies, and to support `--noCheck` on the command line, TypeScript now always emits a `.tsbuildinfo` file for any project in a `--build` invocation. This happens regardless of whether `--incremental` is actually on. [See more information here](https://github.com/microsoft/TypeScript/pull/58626)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#respecting-file-extensions-and-packagejson-from-within-node_modules)\nRespecting File Extensions and `package.json` from within `node_modules`\n\nBefore Node.js implemented support for ECMAScript modules in v12, there was never a good way for TypeScript to know whether `.d.ts` files it found in `node_modules` represented JavaScript files authored as CommonJS or ECMAScript modules. When the vast majority of npm was CommonJS-only, this didn’t cause many problems - if in doubt, TypeScript could just assume that everything behaved like CommonJS. Unfortunately, if that assumption was wrong it could allow unsafe imports:\n\nts\n\n`   // node_modules/dep/index.d.ts  export declare function doSomething(): void;  // index.ts  // Okay if \"dep\" is a CommonJS module, but fails if  // it's an ECMAScript module - even in bundlers!  import dep from \"dep\";  dep.doSomething();   `\n\nIn practice, this didn’t come up very often. But in the years since Node.js started supporting ECMAScript modules, the share of ESM on npm has grown. Fortunately, Node.js also introduced a mechanism that can help TypeScript determine if a file is an ECMAScript module or a CommonJS module: the `.mjs` and `.cjs` file extensions and the `package.json` `\"type\"` field. TypeScript 4.7 added support for understanding these indicators, as well as authoring `.mts` and `.cts` files; however, TypeScript would _only_ read those indicators under `--module node16` and `--module nodenext`, so the unsafe import above was still a problem for anyone using `--module esnext` and `--moduleResolution bundler`, for example.\n\nTo solve this, TypeScript 5.6 collects module format information and uses it to resolve ambiguities like the one in the example above in _all_ `module` modes (except `amd`, `umd`, and `system`). Format-specific file extensions (`.mts` and `.cts`) are respected anywhere they’re found, and the `package.json` `\"type\"` field is consulted inside `node_modules` dependencies, regardless of the `module` setting. Previously, it was technically possible to produce CommonJS output into a `.mjs` file or vice versa:\n\nts\n\n`   // main.mts  export default \"oops\";  // $ tsc --module commonjs main.mts  // main.mjs  Object.defineProperty(exports, \"__esModule\", { value: true });  exports.default = \"oops\";   `\n\nNow, `.mts` files never emit CommonJS output, and `.cts` files never emit ESM output.\n\nNote that much of this behavior was provided in pre-release versions of TypeScript 5.5 ([implementation details here](https://github.com/microsoft/TypeScript/pull/57896)\n), but in 5.6 this behavior is only extended to files within `node_modules`.\n\nMore details are available [on the change here](https://github.com/microsoft/TypeScript/pull/58825)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#correct-override-checks-on-computed-properties)\nCorrect `override` Checks on Computed Properties\n\nPreviously, computed properties marked with `override` did not correctly check for the existence of a base class member. Similarly, if you used `noImplicitOverride`, you would not get an error if you _forgot_ to add an `override` modifier to a computed property.\n\nTypeScript 5.6 now correctly checks computed properties in both cases.\n\nts\n\n`   const foo = Symbol(\"foo\");  const bar = Symbol(\"bar\");  class Base {      [bar]() {}  }  class Derived extends Base {      override [foo]() {}  //           ~~~~~  // error: This member cannot have an 'override' modifier because it is not declared in the base class 'Base'.      [bar]() {}  //  ~~~~~  // error under noImplicitOverride: This member must have an 'override' modifier because it overrides a member in the base class 'Base'.  }   `\n\nThis fix was contributed thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n in [this pull request](https://github.com/microsoft/TypeScript/pull/57146)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%205.6.md)\n ❤\n\nContributors to this page:  \n\nN![navya9singh  (6)](https://gravatar.com/avatar/e896fd3c90d7bd8d3c276d3ea2dd552ae62d81d4a497cdd589f551c5eb5ccb93?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","generator":"Gatsby 5.13.5","ogTitle":"Documentation - TypeScript 5.6","ogDescription":"TypeScript 5.6 Release Notes","title":"TypeScript: Documentation - TypeScript 5.6","theme-color":"#3178C6","og:description":"TypeScript 5.6 Release Notes","language":"en","twitter:site":"typescriptlang","description":"TypeScript 5.6 Release Notes","og:title":"Documentation - TypeScript 5.6","scrapeId":"b0e48760-b665-4445-ae58-7decaa93d6e8","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 5.5\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#inferred-type-predicates)\nInferred Type Predicates\n------------------------------------------------------------------------------------------------------------------------------------\n\n_This section was written by [Dan Vanderkam](https://github.com/danvk)\n, who [implemented this feature in TypeScript 5.5](https://github.com/microsoft/TypeScript/pull/57465)\n. Thanks Dan!_\n\nTypeScript’s control flow analysis does a great job of tracking how the type of a variable changes as it moves through your code:\n\ntsx\n\n`   interface Bird {      commonName: string;      scientificName: string;      sing(): void;  }  // Maps country names -> national bird.  // Not all nations have official birds (looking at you, Canada!)  declare const nationalBirds: Map<string, Bird>;  function makeNationalBirdCall(country: string) {    const bird = nationalBirds.get(country);  // bird has a declared type of Bird | undefined    if (bird) {      bird.sing();  // bird has type Bird inside the if statement    } else {      // bird has type undefined here.    }  }   `\n\nBy making you handle the `undefined` case, TypeScript pushes you to write more robust code.\n\nIn the past, this sort of type refinement was more difficult to apply to arrays. This would have been an error in all previous versions of TypeScript:\n\ntsx\n\n`   function makeBirdCalls(countries: string[]) {    // birds: (Bird | undefined)[]    const birds = countries      .map(country => nationalBirds.get(country))      .filter(bird => bird !== undefined);    for (const bird of birds) {      bird.sing();  // error: 'bird' is possibly 'undefined'.    }  }   `\n\nThis code is perfectly fine: we’ve filtered all the `undefined` values out of the list. But TypeScript hasn’t been able to follow along.\n\nWith TypeScript 5.5, the type checker is fine with this code:\n\ntsx\n\n`   function makeBirdCalls(countries: string[]) {    // birds: Bird[]    const birds = countries      .map(country => nationalBirds.get(country))      .filter(bird => bird !== undefined);    for (const bird of birds) {      bird.sing();  // ok!    }  }   `\n\nNote the more precise type for `birds`.\n\nThis works because TypeScript now infers a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)\n for the `filter` function. You can see what’s going on more clearly by pulling it out into a standalone function:\n\ntsx\n\n`   // function isBirdReal(bird: Bird | undefined): bird is Bird  function isBirdReal(bird: Bird | undefined) {    return bird !== undefined;  }   `\n\n`bird is Bird` is the type predicate. It means that, if the function returns `true`, then it’s a `Bird` (if the function returns `false` then it’s `undefined`). The type declarations for `Array.prototype.filter` know about type predicates, so the net result is that you get a more precise type and the code passes the type checker.\n\nTypeScript will infer that a function returns a type predicate if these conditions hold:\n\n1.  The function does not have an explicit return type or type predicate annotation.\n2.  The function has a single `return` statement and no implicit returns.\n3.  The function does not mutate its parameter.\n4.  The function returns a `boolean` expression that’s tied to a refinement on the parameter.\n\nGenerally this works how you’d expect. Here’s a few more examples of inferred type predicates:\n\ntsx\n\n`   // const isNumber: (x: unknown) => x is number  const isNumber = (x: unknown) => typeof x === 'number';  // const isNonNullish: <T>(x: T) => x is NonNullable<T>  const isNonNullish = <T,>(x: T) => x != null;   `\n\nPreviously, TypeScript would have just inferred that these functions return `boolean`. It now infers signatures with type predicates like `x is number` or `x is NonNullable<T>`.\n\nType predicates have “if and only if” semantics. If a function returns `x is T`, then it means that:\n\n1.  If the function returns `true` then `x` has the type `T`.\n2.  If the function returns `false` then `x` does _not_ have type `T`.\n\nIf you’re expecting a type predicate to be inferred but it’s not, then you may be running afoul of the second rule. This often comes up with “truthiness” checks:\n\ntsx\n\n`   function getClassroomAverage(students: string[], allScores: Map<string, number>) {    const studentScores = students      .map(student => allScores.get(student))      .filter(score => !!score);    return studentScores.reduce((a, b) => a + b) / studentScores.length;    //     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    // error: Object is possibly 'undefined'.  }   `\n\nTypeScript did not infer a type predicate for `score => !!score`, and rightly so: if this returns `true` then `score` is a `number`. But if it returns `false`, then `score` could be either `undefined` or a `number` (specifically, `0`). This is a real bug: if any student got a zero on the test, then filtering out their score will skew the average upwards. Fewer will be above average and more will be sad!\n\nAs with the first example, it’s better to explicitly filter out `undefined` values:\n\ntsx\n\n`   function getClassroomAverage(students: string[], allScores: Map<string, number>) {    const studentScores = students      .map(student => allScores.get(student))      .filter(score => score !== undefined);    return studentScores.reduce((a, b) => a + b) / studentScores.length;  // ok!  }   `\n\nA truthiness check _will_ infer a type predicate for object types, where there’s no ambiguity. Remember that functions must return a `boolean` to be a candidate for an inferred type predicate: `x => !!x` might infer a type predicate, but `x => x` definitely won’t.\n\nExplicit type predicates continue to work exactly as before. TypeScript will not check whether it would infer the same type predicate. Explicit type predicates (“is”) are no safer than a type assertion (“as”).\n\nIt’s possible that this feature will break existing code if TypeScript now infers a more precise type than you want. For example:\n\ntsx\n\n`   // Previously, nums: (number | null)[]  // Now, nums: number[]  const nums = [1, 2, 3, null, 5].filter(x => x !== null);  nums.push(null);  // ok in TS 5.4, error in TS 5.5   `\n\nThe fix is to tell TypeScript the type that you want using an explicit type annotation:\n\ntsx\n\n`   const nums: (number | null)[] = [1, 2, 3, null, 5].filter(x => x !== null);  nums.push(null);  // ok in all versions   `\n\nFor more information, check out the [implementing pull request](https://github.com/microsoft/TypeScript/pull/57465)\n and [Dan’s blog post about implementing this feature](https://effectivetypescript.com/2024/04/16/inferring-a-type-predicate/)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#control-flow-narrowing-for-constant-indexed-accesses)\nControl Flow Narrowing for Constant Indexed Accesses\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript is now able to narrow expressions of the form `obj[key]` when both `obj` and `key` are effectively constant.\n\nts\n\n`   function f1(obj: Record<string, unknown>, key: string) {      if (typeof obj[key] === \"string\") {          // Now okay, previously was error          obj[key].toUpperCase();      }  }   `\n\nIn the above, neither `obj` nor `key` are ever mutated, so TypeScript can narrow the type of `obj[key]` to `string` after the `typeof` check. For more information, [see the implementing pull request here](https://github.com/microsoft/TypeScript/pull/57847)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#the-jsdoc-import-tag)\nThe JSDoc `@import` Tag\n-------------------------------------------------------------------------------------------------------------------------------\n\nToday, if you want to import something only for type-checking in a JavaScript file, it is cumbersome. JavaScript developers can’t simply import a type named `SomeType` if it’s not there at runtime.\n\njs\n\n`   // ./some-module.d.ts  export interface SomeType {      // ...  }  // ./index.js  import { SomeType } from \"./some-module\"; // ❌ runtime error!  /**   * @param {SomeType} myValue   */  function doSomething(myValue) {      // ...  }   `\n\n`SomeType` won’t exist at runtime, so the import will fail. Developers can instead use a namespace import instead.\n\njs\n\n`   import * as someModule from \"./some-module\";  /**   * @param {someModule.SomeType} myValue   */  function doSomething(myValue) {      // ...  }   `\n\nBut `./some-module` is still imported at runtime - which might also not be desirable.\n\nTo avoid this, developers typically had to use `import(...)` types in JSDoc comments.\n\njs\n\n`   /**   * @param {import(\"./some-module\").SomeType} myValue   */  function doSomething(myValue) {      // ...  }   `\n\nIf you wanted to reuse the same type in multiple places, you could use a `typedef` to avoid repeating the import.\n\njs\n\n`   /**   * @typedef {import(\"./some-module\").SomeType} SomeType   */  /**   * @param {SomeType} myValue   */  function doSomething(myValue) {      // ...  }   `\n\nThis helps with local uses of `SomeType`, but it gets repetitive for many imports and can be a bit verbose.\n\nThat’s why TypeScript now supports a new `@import` comment tag that has the same syntax as ECMAScript imports.\n\njs\n\n`   /** @import { SomeType } from \"some-module\" */  /**   * @param {SomeType} myValue   */  function doSomething(myValue) {      // ...  }   `\n\nHere, we used named imports. We could also have written our import as a namespace import.\n\njs\n\n`   /** @import * as someModule from \"some-module\" */  /**   * @param {someModule.SomeType} myValue   */  function doSomething(myValue) {      // ...  }   `\n\nBecause these are just JSDoc comments, they don’t affect runtime behavior at all.\n\nWe would like to extend a big thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n who contributed [this change](https://github.com/microsoft/TypeScript/pull/57207)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#regular-expression-syntax-checking)\nRegular Expression Syntax Checking\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\nUntil now, TypeScript has typically skipped over most regular expressions in code. This is because regular expressions technically have an extensible grammar and TypeScript never made any effort to compile regular expressions to earlier versions of JavaScript. Still, this meant that lots of common problems would go undiscovered in regular expressions, and they would either turn into errors at runtime, or silently fail.\n\nBut TypeScript now does basic syntax checking on regular expressions!\n\nts\n\n`   let myRegex = /@robot(\\s+(please|immediately)))? do some task/;  //                                            ~  // error!  // Unexpected ')'. Did you mean to escape it with backslash?   `\n\nThis is a simple example, but this checking can catch a lot of common mistakes. In fact, TypeScript’s checking goes slightly beyond syntactic checks. For instance, TypeScript can now catch issues around backreferences that don’t exist.\n\nts\n\n`   let myRegex = /@typedef \\{import\\((.+)\\)\\.([a-zA-Z_]+)\\} \\3/u;  //                                                        ~  // error!  // This backreference refers to a group that does not exist.  // There are only 2 capturing groups in this regular expression.   `\n\nThe same applies to named capturing groups.\n\nts\n\n`   let myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<namedImport>/;  //                                                                                        ~~~~~~~~~~~  // error!  // There is no capturing group named 'namedImport' in this regular expression.   `\n\nTypeScript’s checking is now also aware of when certain RegExp features are used when newer than your target version of ECMAScript. For example, if we use named capturing groups like the above in an ES5 target, we’ll get an error.\n\nts\n\n`   let myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<importedEntity>/;  //                                  ~~~~~~~~~~~~         ~~~~~~~~~~~~~~~~  // error!  // Named capturing groups are only available when targeting 'ES2018' or later.   `\n\nThe same is true for certain regular expression flags as well.\n\nNote that TypeScript’s regular expression support is limited to regular expression _literals_. If you try calling `new RegExp` with a string literal, TypeScript will not check the provided string.\n\nWe would like to thank [GitHub user graphemecluster](https://github.com/graphemecluster/)\n who iterated a ton with us [to get this feature into TypeScript](https://github.com/microsoft/TypeScript/pull/55600)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#support-for-new-ecmascript-set-methods)\nSupport for New ECMAScript `Set` Methods\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.5 declares [new proposed methods for the ECMAScript `Set` type](https://github.com/tc39/proposal-set-methods)\n.\n\nSome of these methods, like `union`, `intersection`, `difference`, and `symmetricDifference`, take another `Set` and return a new `Set` as the result. The other methods, `isSubsetOf`, `isSupersetOf`, and `isDisjointFrom`, take another `Set` and return a `boolean`. None of these methods mutate the original `Set`s.\n\nHere’s a quick example of how you might use these methods and how they behave:\n\nts\n\n`   let fruits = new Set([\"apples\", \"bananas\", \"pears\", \"oranges\"]);  let applesAndBananas = new Set([\"apples\", \"bananas\"]);  let applesAndOranges = new Set([\"apples\", \"oranges\"]);  let oranges = new Set([\"oranges\"]);  let emptySet = new Set();  ////  // union  ////  // Set(4) {'apples', 'bananas', 'pears', 'oranges'}  console.log(fruits.union(oranges));  // Set(3) {'apples', 'bananas', 'oranges'}  console.log(applesAndBananas.union(oranges));  ////  // intersection  ////  // Set(2) {'apples', 'bananas'}  console.log(fruits.intersection(applesAndBananas));  // Set(0) {}  console.log(applesAndBananas.intersection(oranges));  // Set(1) {'apples'}  console.log(applesAndBananas.intersection(applesAndOranges));  ////  // difference  ////  // Set(3) {'apples', 'bananas', 'pears'}  console.log(fruits.difference(oranges));  // Set(2) {'pears', 'oranges'}  console.log(fruits.difference(applesAndBananas));  // Set(1) {'bananas'}  console.log(applesAndBananas.difference(applesAndOranges));  ////  // symmetricDifference  ////  // Set(2) {'bananas', 'oranges'}  console.log(applesAndBananas.symmetricDifference(applesAndOranges)); // no apples  ////  // isDisjointFrom  ////  // true  console.log(applesAndBananas.isDisjointFrom(oranges));  // false  console.log(applesAndBananas.isDisjointFrom(applesAndOranges));  // true  console.log(fruits.isDisjointFrom(emptySet));  // true  console.log(emptySet.isDisjointFrom(emptySet));  ////  // isSubsetOf  ////  // true  console.log(applesAndBananas.isSubsetOf(fruits));  // false  console.log(fruits.isSubsetOf(applesAndBananas));  // false  console.log(applesAndBananas.isSubsetOf(oranges));  // true  console.log(fruits.isSubsetOf(fruits));  // true  console.log(emptySet.isSubsetOf(fruits));  ////  // isSupersetOf  ////  // true  console.log(fruits.isSupersetOf(applesAndBananas));  // false  console.log(applesAndBananas.isSupersetOf(fruits));  // false  console.log(applesAndBananas.isSupersetOf(oranges));  // true  console.log(fruits.isSupersetOf(fruits));  // false  console.log(emptySet.isSupersetOf(fruits));   `\n\nWe’d like to thank [Kevin Gibbons](https://github.com/bakkot)\n who not only co-championed the feature in ECMAScript, but [also provided the declarations for `Set`, `ReadonlySet`, and `ReadonlySetLike` in TypeScript](https://github.com/microsoft/TypeScript/pull/57230)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#isolated-declarations)\nIsolated Declarations\n------------------------------------------------------------------------------------------------------------------------------\n\n_This section was co-authored by [Rob Palmer](https://github.com/robpalme)\n who supported the design of isolated declarations._\n\nDeclaration files (a.k.a. `.d.ts` files) describe the shape of existing libraries and modules to TypeScript. This lightweight description includes the library’s type signatures and excludes implementation details such as the function bodies. They are published so that TypeScript can efficiently check your usage of a library without needing to analyse the library itself. Whilst it is possible to handwrite declaration files, if you are authoring typed code, it’s much safer and simpler to let TypeScript generate them automatically from source files using `--declaration`.\n\nThe TypeScript compiler and its APIs have always had the job of generating declaration files; however, there are some use-cases where you might want to use other tools, or where the traditional build process doesn’t scale.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#use-case-faster-declaration-emit-tools)\nUse-case: Faster Declaration Emit Tools\n\nImagine if you wanted to create a faster tool to generate declaration files, perhaps as part of a publishing service or a new bundler. Whilst there is a thriving ecosystem of blazing fast tools that can turn TypeScript into JavaScript, the same is not true for turning TypeScript into declaration files. The reason is that TypeScript’s inference allows us to write code without explicitly declaring types, meaning declaration emit can be complex.\n\nLet’s consider a simple example of a function that adds two imported variables.\n\nts\n\n`   // util.ts  export let one = \"1\";  export let two = \"2\";  // add.ts  import { one, two } from \"./util\";  export function add() { return one + two; }   `\n\nEven if the only thing we want to do is generate `add.d.ts`, TypeScript needs to crawl into another imported file (`util.ts`), infer that the type of `one` and `two` are strings, and then calculate that the `+` operator on two strings will lead to a `string` return type.\n\nts\n\n`   // add.d.ts  export declare function add(): string;   `\n\nWhile this inference is important for the developer experience, it means that tools that want to generate declaration files would need to replicate parts of the type-checker including inference and the ability to resolve module specifiers to follow the imports.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#use-case-parallel-declaration-emit-and-parallel-checking)\nUse-case: Parallel Declaration Emit and Parallel Checking\n\nImagine if you had a monorepo containing many projects and a multi-core CPU that just wished it could help you check your code faster. Wouldn’t it be great if we could check all those projects at the same time by running each project on a different core?\n\nUnfortunately we don’t have the freedom to do all the work in parallel. The reason is that we have to build those projects in dependency order, because each project is checking against the declaration files of their dependencies. So we must build the dependency first to generate the declaration files. TypeScript’s project references feature works the same way, building the set of projects in “topological” dependency order.\n\nAs an example, if we have two projects called `backend` and `frontend`, and they both depend on a project called `core`, TypeScript can’t start type-checking either `frontend` or `backend` until `core` has been built and its declaration files have been generated.\n\n![frontend and backend point to core, other stuff might point to each of those](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2024/04/5-5-beta-isolated-declarations-deps.png)\n\nIn the above graph, you can see that we have a bottleneck. Whilst we can build `frontend` and `backend` in parallel, we need to first wait for `core` to finish building before either can start.\n\nHow could we improve upon this? Well, if a fast tool could generate all those declaration files for `core` _in parallel_, TypeScript then could immediately follow that by type-checking `core`, `frontend`, and `backend` also _in parallel_.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#solution-explicit-types)\nSolution: Explicit Types!\n\nThe common requirement in both use-cases is that we need a cross-file type-checker to generate declaration files. Which is a lot to ask from the tooling community.\n\nAs a more complex example, if we want a declaration file for the following code…\n\nts\n\n`   import { add } from \"./add\";  const x = add();  export function foo() {      return x;  }   `\n\n…we would need to generate a signature for `foo`. Well that requires looking at the implementation of `foo`. `foo` just returns `x`, so getting the type of `x` requires looking at the implementation of `add`. But that might require looking at the implementation of `add`’s dependencies, and so on. What we’re seeing here is that generating declaration files requires a whole lot of logic to figure out the types of different places that might not even be local to the current file.\n\nStill, for developers looking for fast iteration time and fully parallel builds, there is another way of thinking about this problem. A declaration file only requires the types of the public API of a module - in other words, the types of the things that are exported. If, controversially, developers are willing to explicitly write out the types of the things they export, tools could generate declaration files without needing to look at the implementation of the module - and without reimplementing a full type-checker.\n\nThis is where the new `--isolatedDeclarations` option comes in. `--isolatedDeclarations` reports errors when a module can’t be reliably transformed without a type-checker. More plainly, it makes TypeScript report errors if you have a file that isn’t sufficiently annotated on its exports.\n\nThat means in the above example, we would see an error like the following:\n\nts\n\n`   export function foo() {  //              ~~~  // error! Function must have an explicit  // return type annotation with --isolatedDeclarations.      return x;  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#why-are-errors-desirable)\nWhy are errors desirable?\n\nBecause it means that TypeScript can\n\n1.  Tell us up-front whether other tools will have issues with generating declaration files\n2.  Provide a quick fix to help add these missing annotations.\n\nThis mode doesn’t require annotations _everywhere_ though. For locals, these can be ignored, since they don’t affect the public API. For example, the following code would **not** produce an error:\n\nts\n\n`   import { add } from \"./add\";  const x = add(\"1\", \"2\"); // no error on 'x', it's not exported.  export function foo(): string {      return x;  }   `\n\nThere are also certain expressions where the type is “trivial” to calculate.\n\nts\n\n`   // No error on 'x'.  // It's trivial to calculate the type is 'number'  export let x = 10;  // No error on 'y'.  // We can get the type from the return expression.  export function y() {      return 20;  }  // No error on 'z'.  // The type assertion makes it clear what the type is.  export function z() {      return Math.max(x, y()) as number;  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#using-isolateddeclarations)\nUsing `isolatedDeclarations`\n\n`isolatedDeclarations` requires that either the `declaration` or `composite` flags are also set.\n\nNote that `isolatedDeclarations` does not change how TypeScript performs emit - just how it reports errors. Importantly, and similar to `isolatedModules`, enabling the feature in TypeScript won’t immediately bring about the potential benefits discussed here. So please be patient and look forward to future developments in this space. Keeping tool authors in mind, we should also recognize that today, not all of TypeScript’s declaration emit can be easily replicated by other tools wanting to use it as a guide. That’s something we’re actively working on improving.\n\nOn top of this, isolated declarations are still a new feature, and we’re actively working on improving the experience. Some scenarios, like using computed property declarations in classes and object literals, are not _yet_ supported under `isolatedDeclarations`. Keep an eye on this space, and feel free to provide us with feedback.\n\nWe also feel it is worth calling out that `isolatedDeclarations` should be adopted on a case-by-case basis. There are some developer ergonomics that are lost when using `isolatedDeclarations`, and thus it may not be the right choice if your setup is not leveraging the two scenarios mentioned earlier. For others, the work on `isolatedDeclarations` has already uncovered many optimizations and opportunities to unlock different parallel build strategies. In the meantime, if you’re willing to make the trade-offs, we believe `isolatedDeclarations` can be a powerful tool to speed up your build process as external tooling becomes more widely available.\n\nFor more information, read up on the [Isolated Declarations: State of the Feature](https://github.com/microsoft/TypeScript/issues/58944)\n discussion on the TypeScript issue tracker.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#credit)\nCredit\n\nWork on `isolatedDeclarations` has been a long-time collaborative effort between the TypeScript team and the infrastructure and tooling teams within Bloomberg and Google. Individuals like Hana Joo from Google who implemented [the quick fix for isolated declaration errors](https://github.com/microsoft/TypeScript/pull/58260)\n (more on that soon), as well as Ashley Claymore, Jan Kühle, Lisa Velden, Rob Palmer, and Thomas Chetwin have been involved in discussion, specification, and implementation for many months. But we feel it is specifically worth calling out the tremendous amount of work provided by [Titian Cernicova-Dragomir](https://github.com/dragomirtitian)\n from Bloomberg. Titian has been instrumental in driving the implementation of `isolatedDeclarations` and has been a contributor to the TypeScript project for years prior.\n\nWhile the feature involved many changes, you can see [the core work for Isolated Declarations here](https://github.com/microsoft/TypeScript/pull/58201)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#the-configdir-template-variable-for-configuration-files)\nThe `${configDir}` Template Variable for Configuration Files\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIt’s common in many codebases to reuse a shared `tsconfig.json` file that acts as a “base” for other configuration files. This is done by using the `extends` field in a `tsconfig.json` file.\n\njson\n\n`   {      \"extends\": \"../../tsconfig.base.json\",      \"compilerOptions\": {          \"outDir\": \"./dist\"      }  }   `\n\nOne of the issues with this is that all paths in the `tsconfig.json` file are relative to the location of the file itself. This means that if you have a shared `tsconfig.base.json` file that is used by multiple projects, relative paths often won’t be useful in the derived projects. For example, imagine the following `tsconfig.base.json`:\n\njson\n\n`   {      \"compilerOptions\": {          \"typeRoots\": [              \"./node_modules/@types\"              \"./custom-types\"          ],          \"outDir\": \"dist\"      }  }   `\n\nIf author’s intent was that every `tsconfig.json` that extends this file should\n\n1.  output to a `dist` directory relative to the derived `tsconfig.json` , and\n2.  have a `custom-types` directory relative to the derived `tsconfig.json`,\n\nthen this would not work. The `typeRoots` paths would be relative to the location of the shared `tsconfig.base.json` file, not the project that extends it. Each project that extends this shared file would need to declare its own `outDir` and `typeRoots` with identical contents. This could be frustrating and hard to keep in sync between projects, and while the example above is using `typeRoots`, this is a common problem for `paths` and other options.\n\nTo solve this, TypeScript 5.5 introduces a new template variable `${configDir}`. When `${configDir}` is written in certain path fields of a `tsconfig.json` or `jsconfig.json` files, this variable is substituted with the containing directory of the configuration file in a given compilation. This means that the above `tsconfig.base.json` could be rewritten as:\n\njson\n\n`   {      \"compilerOptions\": {          \"typeRoots\": [              \"${configDir}/node_modules/@types\"              \"${configDir}/custom-types\"          ],          \"outDir\": \"${configDir}/dist\"      }  }   `\n\nNow, when a project extends this file, the paths will be relative to the derived `tsconfig.json`, not the shared `tsconfig.base.json` file. This makes it easier to share configuration files across projects and ensures that the configuration files are more portable.\n\nIf you intend to make a `tsconfig.json` file extendable, consider if a `./` should instead be written with `${configDir}`.\n\nFor more information, see [the proposal issue](https://github.com/microsoft/TypeScript/issues/57485)\n and [the implementing pull request](https://github.com/microsoft/TypeScript/pull/58042)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#consulting-packagejson-dependencies-for-declaration-file-generation)\nConsulting `package.json` Dependencies for Declaration File Generation\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPreviously, TypeScript would often issue an error message like\n\n`   The inferred type of \"X\" cannot be named without a reference to \"Y\". This is likely not portable. A type annotation is necessary.   `\n\nThis was often due to TypeScript’s declaration file generation finding itself in the contents of files that were never explicitly imported in a program. Generating an import to such a file could be risky if the path ended up being relative. Still, for codebases with explicit dependencies in the `dependencies` (or `peerDependencies` and `optionalDependencies`) of a `package.json`, generating such an import should be safe under certain resolution modes. So in TypeScript 5.5, we’re more lenient when that’s the case, and many occurrences of this error should disappear.\n\n[See this pull request](https://github.com/microsoft/TypeScript/issues/42873)\n for more details on the change.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#editor-and-watch-mode-reliability-improvements)\nEditor and Watch-Mode Reliability Improvements\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript has either added some new functionality or fixed existing logic that makes `--watch` mode and TypeScript’s editor integration feel more reliable. That should hopefully translate to fewer TSServer/editor restarts.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#correctly-refresh-editor-errors-in-configuration-files)\nCorrectly Refresh Editor Errors in Configuration Files\n\nTypeScript can generate errors for `tsconfig.json` files; however, those errors are actually generated from loading a project, and editors typically don’t directly request those errors for `tsconfig.json` files. While this sounds like a technical detail, it means that when all errors issued in a `tsconfig.json` are fixed, TypeScript doesn’t issue a new fresh empty set of errors, and users are left with stale errors unless they reload their editor.\n\nTypeScript 5.5 now intentionally issues an event to clear these out. [See more here](https://github.com/microsoft/TypeScript/pull/58120)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#better-handling-for-deletes-followed-by-immediate-writes)\nBetter Handling for Deletes Followed by Immediate Writes\n\nInstead of overwriting files, some tools will opt to delete them and then create new files from scratch. This is the case when running `npm ci`, for instance.\n\nWhile this can be efficient for those tools, it can be problematic for TypeScript’s editor scenarios where deleting a watched might dispose of it and all of its transitive dependencies. Deleting and creating a file in quick succession could lead to TypeScript tearing down an entire project and then rebuilding it from scratch.\n\nTypeScript 5.5 now has a more nuanced approach by keeping parts of a deleted project around until it picks up on a new creation event. This should make operations like `npm ci` work a lot better with TypeScript. See [more information on the approach here](https://github.com/microsoft/TypeScript/pull/57492)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#symlinks-are-tracked-in-failed-resolutions)\nSymlinks are Tracked in Failed Resolutions\n\nWhen TypeScript fails to resolve a module, it will still need to watch for any failed lookup paths in case the module is added later. Previously this was not done for symlinked directories, which could cause reliability issues in monorepo-like scenarios when a build occurred in one project but was not witnessed in the other. This should be fixed in TypeScript 5.5, and means you won’t need to restart your editor as often.\n\n[See more information here](https://github.com/microsoft/TypeScript/pull/58139)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#project-references-contribute-to-auto-imports)\nProject References Contribute to Auto-Imports\n\nAuto-imports no longer requires at least one explicit import to dependent projects in a project reference setup. Instead, auto-import completions should just work across anything you’ve listed in the `references` field of your `tsconfig.json`.\n\n[See more on the implementing pull request](https://github.com/microsoft/TypeScript/pull/55955)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#performance-and-size-optimizations)\nPerformance and Size Optimizations\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#monomorphized-objects-in-language-service-and-public-api)\nMonomorphized Objects in Language Service and Public API\n\nIn TypeScript 5.0, we ensured that our [`Node`](https://github.com/microsoft/TypeScript/pull/51682)\n and [`Symbol`](https://github.com/microsoft/TypeScript/pull/51880)\n objects had a consistent set of properties with a consistent initialization order. Doing so helps reduce polymorphism in different operations, which allows runtimes to fetch properties more quickly.\n\nBy making this change, we witnessed impressive speed wins in the compiler; however, most of these changes were performed on internal allocators for our data structures. The language service, along with TypeScript’s public API, uses a different set of allocators for certain objects. This allowed the TypeScript compiler to be a bit leaner, as data used only for the language service would never be used in the compiler.\n\nIn TypeScript 5.5, the same monomorphization work has been done for the language service and public API. What this means is that your editor experience, and any build tools that use the TypeScript API, will get a decent amount faster. In fact, in our benchmarks, we’ve seen a **5-8% speedup in build times** when using the public TypeScript API’s allocators, and **language service operations getting 10-20% faster**. While this does imply an increase in memory, we believe that tradeoff is worth it and hope to find ways to reduce that memory overhead. Things should feel a lot snappier now.\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/58045)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#monomorphized-control-flow-nodes)\nMonomorphized Control Flow Nodes\n\nIn TypeScript 5.5, nodes of the control flow graph have been monomorphized so that they always hold a consistent shape. By doing so, check times will often be reduced by about 1%.\n\n[See this change here](https://github.com/microsoft/TypeScript/pull/57977)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#optimizations-on-our-control-flow-graph)\nOptimizations on our Control Flow Graph\n\nIn many cases, control flow analysis will traverse nodes that don’t provide any new information. We observed that in the absence of any early termination or effects in the antecedents (or “dominators”) of certain nodes meant that those nodes could always be skipped over. As such, TypeScript now constructs its control flow graphs to take advantage of this by linking to an earlier node that _does_ provide interesting information for control flow analysis. This yields a flatter control flow graph, which can be more efficient to traverse. This optimization has yielded modest gains, but with up to 2% reductions in build time on certain codebases.\n\nYou can [read more here](https://github.com/microsoft/TypeScript/pull/58013)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#skipped-checking-in-transpilemodule-and-transpiledeclaration)\nSkipped Checking in `transpileModule` and `transpileDeclaration`\n\nTypeScript’s `transpileModule` API can be used for compiling a single TypeScript file’s contents into JavaScript. Similarly, the `transpileDeclaration` API (see below) can be used to generate a declaration file for a single TypeScript file. One of the issues with these APIs is that TypeScript internally would perform a full type-checking pass over the entire contents of the file before emitting the output. This was necessary to collect certain information which would later be used for the emit phase.\n\nIn TypeScript 5.5, we’ve found a way to avoid performing a full check, only lazily collecting this information as necessary, and `transpileModule` and `transpileDeclaration` both enable this functionality by default. As a result, tools that integrate with these APIs, like [ts-loader](https://www.npmjs.com/package/ts-loader)\n with `transpileOnly` and [ts-jest](https://www.npmjs.com/package/ts-jest)\n, should see a noticeable speedup. In our testing, [we generally witness around a 2x speed-up in build time using `transpileModule`](https://github.com/microsoft/TypeScript/pull/58364#issuecomment-2138580690)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#typescript-package-size-reduction)\nTypeScript Package Size Reduction\n\nFurther leveraging [our transition to modules in 5.0](https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/)\n, we’ve significantly reduced TypeScript’s overall package size [by making `tsserver.js` and `typingsInstaller.js` import from a common API library instead of having each of them produce standalone bundles](https://github.com/microsoft/TypeScript/pull/55326)\n.\n\nThis reduces TypeScript’s size on disk from 30.2 MB to 20.4 MB, and reduces its packed size from 5.5 MB to 3.7 MB!\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#node-reuse-in-declaration-emit)\nNode Reuse in Declaration Emit\n\nAs part of the work to enable `isolatedDeclarations`, we’ve substantially improved how often TypeScript can directly copy your input source code when producing declaration files.\n\nFor example, let’s say you wrote\n\nts\n\n`   export const strBool: string | boolean = \"hello\";  export const boolStr: boolean | string = \"world\";   `\n\nNote that the union types are equivalent, but the order of the union is different. When emitting the declaration file, TypeScript has two equivalent output possibilities.\n\nThe first is to use a consistent canonical representation for each type:\n\nts\n\n`   export const strBool: string | boolean;  export const boolStr: string | boolean;   `\n\nThe second is to re-use the type annotations exactly as written:\n\nts\n\n`   export const strBool: string | boolean;  export const boolStr: boolean | string;   `\n\nThe second approach is generally preferable for a few reasons:\n\n*   Many equivalent representations still encode some level of intent that is better to preserve in the declaration file\n*   Producing a fresh representation of a type can be somewhat expensive, so avoiding is better\n*   User-written types are usually shorter than generated type representations\n\nIn 5.5, we’ve greatly improved the number of places where TypeScript can correctly identify places where it’s safe and correct to print back types exactly as they were written in the input file. Many of these cases are invisible performance improvements - TypeScript would generate fresh sets of syntax nodes and serialize them into a string. Instead, TypeScript can now operate over the original syntax nodes directly, which is much cheaper and faster.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#caching-contextual-types-from-discriminated-unions)\nCaching Contextual Types from Discriminated Unions\n\nWhen TypeScript asks for the contextual type of an expression like an object literal, it will often encounter a union type. In those cases, TypeScript tries to filter out members of the union based on known properties with well known values (i.e. discriminant properties). This work can be fairly expensive, especially if you end up with an object consisting of many many properties. In TypeScript 5.5, [much of the computation is cached once so that TypeScript doesn’t need to recompute it for every property in the object literal](https://github.com/microsoft/TypeScript/pull/58372)\n. Performing this optimization shaved 250ms off of compiling the TypeScript compiler itself.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#easier-api-consumption-from-ecmascript-modules)\nEasier API Consumption from ECMAScript Modules\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPreviously, if you were writing an ECMAScript module in Node.js, named imports were not available from the `typescript` package.\n\nts\n\n`   import { createSourceFile } from \"typescript\"; // ❌ error  import * as ts from \"typescript\";  ts.createSourceFile // ❌ undefined???  ts.default.createSourceFile // ✅ works - but ugh!   `\n\nThis is because [cjs-module-lexer](https://github.com/nodejs/cjs-module-lexer)\n did not recognize the pattern of TypeScript’s generated CommonJS code. This has been fixed, and users can now use named imports from the TypeScript npm package with ECMAScript modules in Node.js.\n\nts\n\n`   import { createSourceFile } from \"typescript\"; // ✅ works now!  import * as ts from \"typescript\";  ts.createSourceFile // ✅ works now!   `\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/57133)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#the-transpiledeclaration-api)\nThe `transpileDeclaration` API\n----------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s API exposes a function called `transpileModule`. It’s intended to make it easy to compile a single file of TypeScript code. Because it doesn’t have access to an entire _program_, the caveat is that it may not produce the right output if the code violates any errors under the `isolatedModules` option.\n\nIn TypeScript 5.5, we’ve added a new similar API called `transpileDeclaration`. This API is similar to `transpileModule`, but it’s specifically designed to generate a single _declaration file_ based on some input source text. Just like `transpileModule`, it doesn’t have access to a full program, and a similar caveat applies: it only generates an accurate declaration file if the input code is free of errors under the new `isolatedDeclarations` option.\n\nIf desired, this function can be used to parallelize declaration emit across all files under `isolatedDeclarations` mode.\n\nFor more information, [see the implementation here](https://github.com/microsoft/TypeScript/pull/58261)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#notable-behavioral-changes)\nNotable Behavioral Changes\n----------------------------------------------------------------------------------------------------------------------------------------\n\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#disabling-features-deprecated-in-typescript-50)\nDisabling Features Deprecated in TypeScript 5.0\n\nTypeScript 5.0 deprecated the following options and behaviors:\n\n*   `charset`\n*   `target: ES3`\n*   `importsNotUsedAsValues`\n*   `noImplicitUseStrict`\n*   `noStrictGenericChecks`\n*   `keyofStringsOnly`\n*   `suppressExcessPropertyErrors`\n*   `suppressImplicitAnyIndexErrors`\n*   `out`\n*   `preserveValueImports`\n*   `prepend` in project references\n*   implicitly OS-specific `newLine`\n\nTo continue using the deprecated options above, developers using TypeScript 5.0 and other more recent versions have had to specify a new option called `ignoreDeprecations` with the value `\"5.0\"`.\n\nIn TypeScript 5.5, these options no longer have any effect. To help with a smooth upgrade path, you may still specify them in your tsconfig, but these will be an error to specify in TypeScript 6.0. See also the [Flag Deprecation Plan](https://github.com/microsoft/TypeScript/issues/51000)\n which outlines our deprecation strategy.\n\n[More information around these deprecation plans is available on GitHub](https://github.com/microsoft/TypeScript/issues/51909)\n, which contains suggestions in how to best adapt your codebase.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#libdts-changes)\n`lib.d.ts` Changes\n\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, [see the DOM updates for TypeScript 5.5](https://github.com/microsoft/TypeScript/pull/58211)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#stricter-parsing-for-decorators)\nStricter Parsing for Decorators\n\nSince TypeScript originally introduced support for decorators, the specified grammar for the proposal has been tightened up. TypeScript is now stricter about what forms it allows. While rare, existing decorators may need to be parenthesized to avoid errors.\n\nts\n\n`   class DecoratorProvider {      decorate(...args: any[]) { }  }  class D extends DecoratorProvider {      m() {          class C {              @super.decorate // ❌ error              method1() { }              @(super.decorate) // ✅ okay              method2() { }          }      }  }   `\n\nSee [more information on the change here](https://github.com/microsoft/TypeScript/pull/57749)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#undefined-is-no-longer-a-definable-type-name)\n`undefined` is No Longer a Definable Type Name\n\nTypeScript has always disallowed type alias names that conflict with built-in types:\n\nts\n\n`   // Illegal  type null = any;  // Illegal  type number = any;  // Illegal  type object = any;  // Illegal  type any = any;   `\n\nDue to a bug, this logic didn’t also apply to the built-in type `undefined`. In 5.5, this is now correctly identified as an error:\n\nts\n\n`   // Now also illegal  type undefined = any;   `\n\nBare references to type aliases named `undefined` never actually worked in the first place. You could define them, but you couldn’t use them as an unqualified type name.\n\nts\n\n`   export type undefined = string;  export const m: undefined = \"\";  //           ^  // Errors in 5.4 and earlier - the local definition of 'undefined' was not even consulted.   `\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/57575)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html#simplified-reference-directive-declaration-emit)\nSimplified Reference Directive Declaration Emit\n\nWhen producing a declaration file, TypeScript would synthesize a reference directive when it believed one was required. For example, all Node.js modules are declared ambiently, so cannot be loaded by module resolution alone. A file like:\n\ntsx\n\n`   import path from \"path\";  export const myPath = path.parse(__filename);   `\n\nWould emit a declaration file like:\n\ntsx\n\n`   /// <reference types=\"node\" />  import path from \"path\";  export declare const myPath: path.ParsedPath;   `\n\nEven though the reference directive never appeared in the original source.\n\nSimilarly, TypeScript also _removed_ reference directives that it did not believe needed to be a part of the output. For example, let’s imagine we had a reference directive to `jest`; however, imagine the reference directive isn’t necessary to generate the declaration file. TypeScript would simply drop it. So in the following example:\n\ntsx\n\n`   /// <reference types=\"jest\" />  import path from \"path\";  export const myPath = path.parse(__filename);   `\n\nTypeScript would still emit:\n\ntsx\n\n`   /// <reference types=\"node\" />  import path from \"path\";  export declare const myPath: path.ParsedPath;   `\n\nIn the course of working on `isolatedDeclarations`, we realized that this logic was untenable for anyone attempting to implement a declaration emitter without type checking or using more than a single file’s context. This behavior is also hard to understand from a user’s perspective; whether or not a reference directive appeared in the emitted file seems inconsistent and difficult to predict unless you understand exactly what’s going on during typechecking. To prevent declaration emit from being different when `isolatedDeclarations` was enabled, we knew that our emit needed to change.\n\nThrough [experimentation](https://github.com/microsoft/TypeScript/pull/57569)\n, we found that nearly all cases where TypeScript synthesized reference directives were just to pull in `node` or `react`. These are cases where the expectation is that a downstream user already references those types through tsconfig.json `\"types\"` or library imports, so no longer synthesizing these reference directives would be unlikely to break anyone. It’s worth noting that this is already how it works for `lib.d.ts`; TypeScript doesn’t synthesize a reference to `lib=\"es2015\"` when a module exports a `WeakMap`, instead assuming that a downstream user will have included that as part of their environment.\n\nFor reference directives that had been written by library authors (not synthesized), [further experimentation](https://github.com/microsoft/TypeScript/pull/57656)\n showed that nearly all were removed, never showing up in the output. Most reference directives that were preserved were broken and likely not intended to be preserved.\n\nGiven those results, we decided to greatly simplfy reference directives in declaration emit in TypeScript 5.5. A more consistent strategy will help library authors and consumers have better control of their declaration files.\n\nReference directives are no longer synthesized. User-written reference directives are no longer preserved, unless annotated with a new `preserve=\"true\"` attribute. Concretely, an input file like:\n\ntsx\n\n`   /// <reference types=\"some-lib\" preserve=\"true\" />  /// <reference types=\"jest\" />  import path from \"path\";  export const myPath = path.parse(__filename);   `\n\nwill emit:\n\ntsx\n\n`   /// <reference types=\"some-lib\" preserve=\"true\" />  import path from \"path\";  export declare const myPath: path.ParsedPath;   `\n\nAdding `preserve=\"true\"` is backwards compatible with older versions of TypeScript as unknown attributes are ignored.\n\nThis change also improved performance; in our benchmarks, the emit stage saw a 1-4% improvement in projects with declaration emit enabled.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%205.5.md)\n ❤\n\nContributors to this page:  \n\nN![navya9singh  (6)](https://gravatar.com/avatar/e896fd3c90d7bd8d3c276d3ea2dd552ae62d81d4a497cdd589f551c5eb5ccb93?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (1)](https://gravatar.com/avatar/3cb42391bbae78f84e416c9407fb9ef82c008ab291b8193611b0a77946c499d8?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","ogDescription":"TypeScript 5.5 Release Notes","title":"TypeScript: Documentation - TypeScript 5.5","theme-color":"#3178C6","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"TypeScript 5.5 Release Notes","og:title":"Documentation - TypeScript 5.5","twitter:site":"typescriptlang","og:description":"TypeScript 5.5 Release Notes","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogTitle":"Documentation - TypeScript 5.5","scrapeId":"a8b42b64-42ea-49f4-b004-2ba77f4f74cd","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-5.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 5.4\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#preserved-narrowing-in-closures-following-last-assignments)\nPreserved Narrowing in Closures Following Last Assignments\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript can usually figure out a more specific type for a variable based on checks that you might perform. This process is called narrowing.\n\nts\n\n`   function uppercaseStrings(x: string | number) {      if (typeof x === \"string\") {          // TypeScript knows 'x' is a 'string' here.          return x.toUpperCase();      }  }   `\n\nOne common pain point was that these narrowed types weren’t always preserved within function closures.\n\nts\n\n`   function getUrls(url: string | URL, names: string[]) {      if (typeof url === \"string\") {          url = new URL(url);      }      return names.map(name => {          url.searchParams.set(\"name\", name)          //  ~~~~~~~~~~~~          // error!          // Property 'searchParams' does not exist on type 'string | URL'.          return url.toString();      });  }   `\n\nHere, TypeScript decided that it wasn’t “safe” to assume that `url` was _actually_ a `URL` object in our callback function because it was mutated elsewhere; however, in this instance, that arrow function is _always_ created after that assignment to `url`, and it’s also the _last_ assignment to `url`.\n\nTypeScript 5.4 takes advantage of this to make narrowing a little smarter. When parameters and `let` variables are used in non-[hoisted](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)\n functions, the type-checker will look for a last assignment point. If one is found, TypeScript can safely narrow from outside the containing function. What that means is the above example just works now.\n\nNote that narrowing analysis doesn’t kick in if the variable is assigned anywhere in a nested function. This is because there’s no way to know for sure whether the function will be called later.\n\nts\n\n`   function printValueLater(value: string | undefined) {      if (value === undefined) {          value = \"missing!\";      }      setTimeout(() => {          // Modifying 'value', even in a way that shouldn't affect          // its type, will invalidate type refinements in closures.          value = value;      }, 500);      setTimeout(() => {          console.log(value.toUpperCase());          //          ~~~~~          // error! 'value' is possibly 'undefined'.      }, 1000);  }   `\n\nThis should make lots of typical JavaScript code easier to express. You can [read more about the change on GitHub](https://github.com/microsoft/TypeScript/pull/56908)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#the-noinfer-utility-type)\nThe `NoInfer` Utility Type\n--------------------------------------------------------------------------------------------------------------------------------------\n\nWhen calling generic functions, TypeScript is able to infer type arguments from whatever you pass in.\n\nts\n\n`   function doSomething<T>(arg: T) {      // ...  }  // We can explicitly say that 'T' should be 'string'.  doSomething<string>(\"hello!\");  // We can also just let the type of 'T' get inferred.  doSomething(\"hello!\");   `\n\nOne challenge, however, is that it is not always clear what the “best” type is to infer. This might lead to TypeScript rejecting valid calls, accepting questionable calls, or just reporting worse error messages when it catches a bug.\n\nFor example, let’s imagine a `createStreetLight` function that takes a list of color names, along with an optional default color.\n\nts\n\n`   function createStreetLight<C extends string>(colors: C[], defaultColor?: C) {      // ...  }  createStreetLight([\"red\", \"yellow\", \"green\"], \"red\");   `\n\nWhat happens when we pass in a `defaultColor` that wasn’t in the original `colors` array? In this function, `colors` is supposed to be the “source of truth” and describe what can be passed to `defaultColor`.\n\nts\n\n`   // Oops! This is undesirable, but is allowed!  createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");   `\n\nIn this call, type inference decided that `\"blue\"` was just as valid of a type as `\"red\"` or `\"yellow\"` or `\"green\"`. So instead of rejecting the call, TypeScript infers the type of `C` as `\"red\" | \"yellow\" | \"green\" | \"blue\"`. You might say that inference just blue up in our faces!\n\nOne way people currently deal with this is to add a separate type parameter that’s bounded by the existing type parameter.\n\nts\n\n`   function createStreetLight<C extends string, D extends C>(colors: C[], defaultColor?: D) {  }  createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");  //                                            ~~~~~~  // error!  // Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'.   `\n\nThis works, but is a little bit awkward because `D` probably won’t be used anywhere else in the signature for `createStreetLight`. While not bad _in this case_, using a type parameter only once in a signature is often a code smell.\n\nThat’s why TypeScript 5.4 introduces a new `NoInfer<T>` utility type. Surrounding a type in `NoInfer<...>` gives a signal to TypeScript not to dig in and match against the inner types to find candidates for type inference.\n\nUsing `NoInfer`, we can rewrite `createStreetLight` as something like this:\n\nts\n\n`   function createStreetLight<C extends string>(colors: C[], defaultColor?: NoInfer<C>) {      // ...  }  createStreetLight([\"red\", \"yellow\", \"green\"], \"blue\");  //                                            ~~~~~~  // error!  // Argument of type '\"blue\"' is not assignable to parameter of type '\"red\" | \"yellow\" | \"green\" | undefined'.   `\n\nExcluding the type of `defaultColor` from being explored for inference means that `\"blue\"` never ends up as an inference candidate, and the type-checker can reject it.\n\nYou can see the specific changes in [the implementing pull request](https://github.com/microsoft/TypeScript/pull/56794)\n, along with [the initial implementation](https://github.com/microsoft/TypeScript/pull/52968)\n provided thanks to [Mateusz Burzyński](https://github.com/Andarist)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#objectgroupby-and-mapgroupby)\n`Object.groupBy` and `Map.groupBy`\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.4 adds declarations for JavaScript’s new `Object.groupBy` and `Map.groupBy` static methods.\n\n`Object.groupBy` takes an iterable, and a function that decides which “group” each element should be placed in. The function needs to make a “key” for each distinct group, and `Object.groupBy` uses that key to make an object where every key maps to an array with the original element in it.\n\nSo the following JavaScript:\n\njs\n\n`   const array = [0, 1, 2, 3, 4, 5];  const myObj = Object.groupBy(array, (num, index) => {      return num % 2 === 0 ? \"even\": \"odd\";  });   `\n\nis basically equivalent to writing this:\n\njs\n\n`   const myObj = {      even: [0, 2, 4],      odd: [1, 3, 5],  };   `\n\n`Map.groupBy` is similar, but produces a `Map` instead of a plain object. This might be more desirable if you need the guarantees of `Map`s, you’re dealing with APIs that expect `Map`s, or you need to use any kind of key for grouping - not just keys that can be used as property names in JavaScript.\n\njs\n\n`   const myObj = Map.groupBy(array, (num, index) => {      return num % 2 === 0 ? \"even\" : \"odd\";  });   `\n\nand just as before, you could have created `myObj` in an equivalent way:\n\njs\n\n`   const myObj = new Map();  myObj.set(\"even\", [0, 2, 4]);  myObj.set(\"odd\", [1, 3, 5]);   `\n\nNote that in the above example of `Object.groupBy`, the object produced uses all optional properties.\n\nts\n\n`   interface EvenOdds {      even?: number[];      odd?: number[];  }  const myObj: EvenOdds = Object.groupBy(...);  myObj.even;  //    ~~~~  // Error to access this under 'strictNullChecks'.   `\n\nThis is because there’s no way to guarantee in a general way that _all_ the keys were produced by `groupBy`.\n\nNote also that these methods are only accessible by configuring your `target` to `esnext` or adjusting your `lib` settings. We expect they will eventually be available under a stable `es2024` target.\n\nWe’d like to extend a thanks to [Kevin Gibbons](https://github.com/bakkot)\n for [adding the declarations to these `groupBy` methods](https://github.com/microsoft/TypeScript/pull/56805)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve)\nSupport for `require()` calls in `--moduleResolution bundler` and `--module preserve`\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript has a `moduleResolution` option called `bundler` that is meant to model the way modern bundlers figure out which file an import path refers to. One of the limitations of the option is that it had to be paired with `--module esnext`, making it impossible to use the `import ... = require(...)` syntax.\n\nts\n\n`   // previously errored  import myModule = require(\"module/path\");   `\n\nThat might not seem like a big deal if you’re planning on just writing standard ECMAScript `import`s, but there’s a difference when using a package with [conditional exports](https://nodejs.org/api/packages.html#conditional-exports)\n.\n\nIn TypeScript 5.4, `require()` can now be used when setting the `module` setting to a new option called `preserve`.\n\nBetween `--module preserve` and `--moduleResolution bundler`, the two more accurately model what bundlers and runtimes like Bun will allow, and how they’ll perform module lookups. In fact, when using `--module preserve`, the `bundler` option will be implicitly set for `--moduleResolution` (along with `--esModuleInterop` and `--resolveJsonModule`)\n\njson\n\n`   {      \"compilerOptions\": {          \"module\": \"preserve\",          // ^ also implies:          // \"moduleResolution\": \"bundler\",          // \"esModuleInterop\": true,          // \"resolveJsonModule\": true,          // ...      }  }   `\n\nUnder `--module preserve`, an ECMAScript `import` will always be emitted as-is, and `import ... = require(...)` will be emitted as a `require()` call (though in practice you may not even use TypeScript for emit, since it’s likely you’ll be using a bundler for your code). This holds true regardless of the file extension of the containing file. So the output of this code:\n\nts\n\n`   import * as foo from \"some-package/foo\";  import bar = require(\"some-package/bar\");   `\n\nshould look something like this:\n\njs\n\n`   import * as foo from \"some-package/foo\";  var bar = require(\"some-package/bar\");   `\n\nWhat this also means is that the syntax you choose directs how [conditional exports](https://nodejs.org/api/packages.html#conditional-exports)\n are matched. So in the above example, if the `package.json` of `some-package` looks like this:\n\njson\n\n`   {    \"name\": \"some-package\",    \"version\": \"0.0.1\",    \"exports\": {      \"./foo\": {          \"import\": \"./esm/foo-from-import.mjs\",          \"require\": \"./cjs/foo-from-require.cjs\"      },      \"./bar\": {          \"import\": \"./esm/bar-from-import.mjs\",          \"require\": \"./cjs/bar-from-require.cjs\"      }    }  }   `\n\nTypeScript will resolve these paths to `[...]/some-package/esm/foo-from-import.mjs` and `[...]/some-package/cjs/bar-from-require.cjs`.\n\nFor more information, you can [read up on these new settings here](https://github.com/microsoft/TypeScript/pull/56785)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#checked-import-attributes-and-assertions)\nChecked Import Attributes and Assertions\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nImport attributes and assertions are now checked against the global `ImportAttributes` type. This means that runtimes can now more accurately describe the import attributes\n\nts\n\n`   // In some global file.  interface ImportAttributes {      type: \"json\";  }  // In some other module  import * as ns from \"foo\" with { type: \"not-json\" };  //                                     ~~~~~~~~~~  // error!  //  // Type '{ type: \"not-json\"; }' is not assignable to type 'ImportAttributes'.  //  Types of property 'type' are incompatible.  //    Type '\"not-json\"' is not assignable to type '\"json\"'.   `\n\n[This change](https://github.com/microsoft/TypeScript/pull/56034)\n was provided thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#quick-fix-for-adding-missing-parameters)\nQuick Fix for Adding Missing Parameters\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript now has a quick fix to add a new parameter to functions that are called with too many arguments.\n\n![A quick fix being offered when someFunction calls someHelperFunction with 2 more arguments than are expected.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2024/01/add-missing-params-5-4-beta-before.png)\n\n![The missing arguments have been added to someHelperFunction after the quick fix was applied.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2024/01/add-missing-params-5-4-beta-after.png)\n\nThis can be useful when threading a new argument through several existing functions, which can be cumbersome today.\n\n[This quick fix](https://github.com/microsoft/TypeScript/pull/56411)\n was provided courtsey of [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#upcoming-changes-from-typescript-50-deprecations)\nUpcoming Changes from TypeScript 5.0 Deprecations\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.0 deprecated the following options and behaviors:\n\n*   `charset`\n*   `target: ES3`\n*   `importsNotUsedAsValues`\n*   `noImplicitUseStrict`\n*   `noStrictGenericChecks`\n*   `keyofStringsOnly`\n*   `suppressExcessPropertyErrors`\n*   `suppressImplicitAnyIndexErrors`\n*   `out`\n*   `preserveValueImports`\n*   `prepend` in project references\n*   implicitly OS-specific `newLine`\n\nTo continue using them, developers using TypeScript 5.0 and other more recent versions have had to specify a new option called `ignoreDeprecations` with the value `\"5.0\"`.\n\nHowever, TypScript 5.4 will be the last version in which these will continue to function as normal. By TypeScript 5.5 (likely June 2024), these will become hard errors, and code using them will need to be migrated away.\n\nFor more information, you can [read up on this plan on GitHub](https://github.com/microsoft/TypeScript/issues/51909)\n, which contains suggestions in how to best adapt your codebase.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#notable-behavioral-changes)\nNotable Behavioral Changes\n----------------------------------------------------------------------------------------------------------------------------------------\n\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#libdts-changes)\n`lib.d.ts` Changes\n\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, [see the DOM updates for TypeScript 5.4](https://github.com/microsoft/TypeScript/pull/57027)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#more-accurate-conditional-type-constraints)\nMore Accurate Conditional Type Constraints\n\nThe following code no longer allows the second variable declaration in the function `foo`.\n\nts\n\n`   type IsArray<T> = T extends any[] ? true : false;  function foo<U extends object>(x: IsArray<U>) {      let first: true = x;    // Error      let second: false = x;  // Error, but previously wasn't  }   `\n\nPreviously, when TypeScript checked the initializer for `second`, it needed to determine whether `IsArray<U>` was assignable to the unit type `false`. While `IsArray<U>` isn’t compatible any obvious way, TypeScript looks at the _constraint_ of that type as well. In a conditional type like `T extends Foo ? TrueBranch : FalseBranch`, where `T` is generic, the type system would look at the constraint of `T`, substitute it in for `T` itself, and decide on either the true or false branch.\n\nBut this behavior was inaccurate because it was overly eager. Even if the constraint of `T` isn’t assignable to `Foo`, that doesn’t mean that it won’t be instantiated with something that is. And so the more correct behavior is to produce a union type for the constraint of the conditional type in cases where it can’t be proven that `T` _never_ or _always_ extends `Foo.`\n\nTypeScript 5.4 adopts this more accurate behavior. What this means in practice is that you may begin to find that some conditional type instances are no longer compatible with their branches.\n\n[You can read about the specific changes here](https://github.com/microsoft/TypeScript/pull/56004)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#more-aggressive-reduction-of-intersections-between-type-variables-and-primitive-types)\nMore Aggressive Reduction of Intersections Between Type Variables and Primitive Types\n\nTypeScript now reduces intersections with type variables and primitives more aggressively, depending on how the type variable’s constraint overlaps with those primitives.\n\nts\n\n`   declare function intersect<T, U>(x: T, y: U): T & U;  function foo<T extends \"abc\" | \"def\">(x: T, str: string, num: number) {      // Was 'T & string', now is just 'T'      let a = intersect(x, str);      // Was 'T & number', now is just 'never'      let b = intersect(x, num)      // Was '(T & \"abc\") | (T & \"def\")', now is just 'T'      let c = Math.random() < 0.5 ?          intersect(x, \"abc\") :          intersect(x, \"def\");  }   `\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/56515)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#improved-checking-against-template-strings-with-interpolations)\nImproved Checking Against Template Strings with Interpolations\n\nTypeScript now more accurately checks whether or not strings are assignable to the placeholder slots of a template string type.\n\nts\n\n``   function a<T extends {id: string}>() {      let x: `-${keyof T & string}`;      // Used to error, now doesn't.      x = \"-id\";  }   ``\n\nThis behavior is more desirable, but may cause breaks in code using constructs like conditional types, where these rule changes are easy to witness.\n\n[See this change](https://github.com/microsoft/TypeScript/pull/56598)\n for more details.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#errors-when-type-only-imports-conflict-with-local-values)\nErrors When Type-Only Imports Conflict with Local Values\n\nPreviously, TypeScript would permit the following code under `isolatedModules` if the import to `Something` only referred to a type.\n\nts\n\n`   import { Something } from \"./some/path\";  let Something = 123;   `\n\nHowever, it’s not safe for single-file compilers to assume whether it’s “safe” to drop the `import`, even if the code is guaranteed to fail at runtime. In TypeScript 5.4, this code will trigger an error like the following:\n\n`   Import 'Something' conflicts with local value, so must be declared with a type-only import when 'isolatedModules' is enabled.   `\n\nThe fix should be to either make a local rename, or, as the error states, add the `type` modifier to the import:\n\nts\n\n`   import type { Something } from \"./some/path\";  // or  import { type Something } from \"./some/path\";   `\n\n[See more information on the change itself](https://github.com/microsoft/TypeScript/pull/56354)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#new-enum-assignability-restrictions)\nNew Enum Assignability Restrictions\n\nWhen two enums have the same declared names and enum member names, they were previously always considered compatible; however, when the values were known, TypeScript would silently allow them to have differing values.\n\nTypeScript 5.4 tightens this restriction by requiring the values to be identical when they are known.\n\nts\n\n`   namespace First {      export enum SomeEnum {          A = 0,          B = 1,      }  }  namespace Second {      export enum SomeEnum {          A = 0,          B = 2,      }  }  function foo(x: First.SomeEnum, y: Second.SomeEnum) {      // Both used to be compatible - no longer the case,      // TypeScript errors with something like:      //      //  Each declaration of 'SomeEnum.B' differs in its value, where '1' was expected but '2' was given.      x = y;      y = x;  }   `\n\nAdditionally, there are new restrictions for when one of the enum members does not have a statically known value. In these cases, the other enum must at least be implicitly numeric (e.g. it has no statically resolved initializer), or it is explicitly numeric (meaning TypeScript could resolve the value to something numeric). Practically speaking, what this means is that string enum members are only ever compatible with other string enums of the same value.\n\nts\n\n`   namespace First {      export declare enum SomeEnum {          A,          B,      }  }  namespace Second {      export declare enum SomeEnum {          A,          B = \"some known string\",      }  }  function foo(x: First.SomeEnum, y: Second.SomeEnum) {      // Both used to be compatible - no longer the case,      // TypeScript errors with something like:      //      //  One value of 'SomeEnum.B' is the string '\"some known string\"', and the other is assumed to be an unknown numeric value.      x = y;      y = x;  }   `\n\nFor more information, [see the pull request that introduced this change](https://github.com/microsoft/TypeScript/pull/55924)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#name-restrictions-on-enum-members)\nName Restrictions on Enum Members\n\nTypeScript no longer allows enum members to use the names `Infinity`, `-Infinity`, or `NaN`.\n\nts\n\n`   // Errors on all of these:  //  //  An enum member cannot have a numeric name.  enum E {      Infinity = 0,      \"-Infinity\" = 1,      NaN = 2,  }   `\n\n[See more details here](https://github.com/microsoft/TypeScript/pull/56161)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#better-mapped-type-preservation-over-tuples-with-any-rest-elements)\nBetter Mapped Type Preservation Over Tuples with `any` Rest Elements\n\nPreviously, applying a mapped type with `any` into a tuple would create an `any` element type. This is undesirable and is now fixed.\n\nts\n\n`   Promise.all([\"\", ...([] as any)])      .then((result) => {          const head = result[0];       // 5.3: any, 5.4: string          const tail = result.slice(1); // 5.3 any, 5.4: any[]      });   `\n\nFor more information, see [the fix](https://github.com/microsoft/TypeScript/pull/57031)\n along with [the follow-on discussion around behavioral changes](https://github.com/microsoft/TypeScript/issues/57389)\n and [further tweaks](https://github.com/microsoft/TypeScript/issues/57389)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#emit-changes)\nEmit Changes\n\nWhile not a breaking change per se, developers may have implicitly taken dependencies on TypeScript’s JavaScript or declaration emit outputs. The following are notable changes.\n\n*   [Preserve type parameter names more often when shadowed](https://github.com/microsoft/TypeScript/pull/55820)\n    \n*   [Move complex parameter lists of async function into downlevel generator body](https://github.com/microsoft/TypeScript/pull/56296)\n    \n*   [Do not remove binding alias in function declarations](https://github.com/microsoft/TypeScript/pull/57020)\n    \n*   [ImportAttributes should go through the same emit phases when in an ImportTypeNode](https://github.com/microsoft/TypeScript/pull/56395)\n    \n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%205.4.md)\n ❤\n\nContributors to this page:  \n\nN![navya9singh  (6)](https://gravatar.com/avatar/e896fd3c90d7bd8d3c276d3ea2dd552ae62d81d4a497cdd589f551c5eb5ccb93?s=32&&d=blank)\n\nI![IC-EnzoD-FRA  (1)](https://gravatar.com/avatar/a86c74b5166ec42050a2c2227b2b84cac659f19d96d9515d2cc8ac58fc3a118c?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - TypeScript 5.4","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogTitle":"Documentation - TypeScript 5.4","og:description":"TypeScript 5.4 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","generator":"Gatsby 5.13.5","twitter:site":"typescriptlang","og:title":"Documentation - TypeScript 5.4","ogDescription":"TypeScript 5.4 Release Notes","description":"TypeScript 5.4 Release Notes","theme-color":"#3178C6","scrapeId":"08233cb2-b798-4830-b2f8-3b48a17690c7","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html","statusCode":200}},{"markdown":"[![ag grid](https://www.typescriptlang.org/ag-grid-logo.6a68915181a34a15.png)](https://www.ag-grid.com/?utm_source=webpack&utm_medium=banner&utm_campaign=sponsorship)\n\n[![ag charts](https://www.typescriptlang.org/ag-charts-logo.f1735fb8902861d2.png)](https://charts.ag-grid.com/?utm_source=webpack&utm_medium=banner&utm_campaign=sponsorship)\n\n[Datagrid and Charting for Enterprise Applications\\\n\\\n![webpack](https://www.typescriptlang.org/icon-square-small.9e8aff7a67a5dd20.svg)\\\n\\\nProud to partner with webpack](https://www.ag-grid.com/?utm_source=webpack&utm_medium=banner&utm_campaign=sponsorship)\n\nTypeScript\n==========\n\n[TypeScript](https://www.typescriptlang.org/)\n is a typed superset of JavaScript that compiles to plain JavaScript. In this guide we will learn how to integrate TypeScript with webpack.\n\nBasic Setup[](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html#basic-setup)\n\n---------------------------------------------------------------------------------------------\n\nFirst install the TypeScript compiler and loader by running:\n\n    npm install --save-dev typescript ts-loader\n\nNow we'll modify the directory structure & the configuration files:\n\n**project**\n\n      webpack-demo\n      |- package.json\n      |- package-lock.json\n    + |- tsconfig.json\n      |- webpack.config.js\n      |- /dist\n        |- bundle.js\n        |- index.html\n      |- /src\n        |- index.js\n    +   |- index.ts\n      |- /node_modules\n\n**tsconfig.json**\n\nLet's set up a configuration to support JSX and compile TypeScript down to ES5...\n\n    {\n      \"compilerOptions\": {\n        \"outDir\": \"./dist/\",\n        \"noImplicitAny\": true,\n        \"module\": \"es6\",\n        \"target\": \"es5\",\n        \"jsx\": \"react\",\n        \"allowJs\": true,\n        \"moduleResolution\": \"node\"\n      }\n    }\n\nSee [TypeScript's documentation](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)\n to learn more about `tsconfig.json` configuration options.\n\nTo learn more about webpack configuration, see the [configuration concepts](https://www.typescriptlang.org/concepts/configuration/)\n.\n\nNow let's configure webpack to handle TypeScript:\n\n**webpack.config.js**\n\n    const path = require('path');\n    \n    module.exports = {\n      entry: './src/index.ts',\n      module: {\n        rules: [\\\n          {\\\n            test: /\\.tsx?$/,\\\n            use: 'ts-loader',\\\n            exclude: /node_modules/,\\\n          },\\\n        ],\n      },\n      resolve: {\n        extensions: ['.tsx', '.ts', '.js'],\n      },\n      output: {\n        filename: 'bundle.js',\n        path: path.resolve(__dirname, 'dist'),\n      },\n    };\n\nThis will direct webpack to _enter_ through `./index.ts`, _load_ all `.ts` and `.tsx` files through the `ts-loader`, and _output_ a `bundle.js` file in our current directory.\n\nNow lets change the import of `lodash` in our `./index.ts` due to the fact that there is no default export present in `lodash` definitions.\n\n**./index.ts**\n\n    - import _ from 'lodash';\n    + import * as _ from 'lodash';\n    \n      function component() {\n        const element = document.createElement('div');\n    \n        element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n    \n        return element;\n      }\n    \n      document.body.appendChild(component());\n\nWays to Use TypeScript in `webpack.config.ts`[](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html#ways-to-use-typescript-in-webpackconfigts)\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThere are 5 ways to use TypeScript in `webpack.config.ts`:\n\n1.  **Using webpack with TypeScript config:**\n    \n        webpack -c ./webpack.config.ts\n    \n    (Not all things are supported due to limitations of `rechoir` and `interpret`.)\n    \n2.  **Using custom `--import` for Node.js:**\n    \n        NODE_OPTIONS='--import tsx'  webpack --disable-interpret -c ./webpack.config.ts\n    \n3.  **Using built-in TypeScript module for Node.js v22.7.0 ≥ YOUR NODE.JS VERSION < v23.6.0:**\n    \n        NODE_OPTIONS='--experimental-strip-types' webpack --disable-interpret -c ./webpack.config.ts\n    \n4.  **Using built-in TypeScript module for Node.js ≥ v22.6.0:**\n    \n        webpack --disable-interpret -c ./webpack.config.ts\n    \n5.  **Using a tsx for Node.js ≥ v22.6.0:**\n    \n        NODE_OPTIONS='--no-experimental-strip-types --import tsx' webpack --disable-interpret -c ./webpack.config.ts\n    \n\nLoader[](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html#loader)\n\n-----------------------------------------------------------------------------------\n\n[`ts-loader`](https://github.com/TypeStrong/ts-loader)\n\nWe use `ts-loader` in this guide as it makes enabling additional webpack features, such as importing other web assets, a bit easier.\n\nNote that if you're already using [`babel-loader`](https://github.com/babel/babel-loader)\n to transpile your code, you can use [`@babel/preset-typescript`](https://babeljs.io/docs/en/babel-preset-typescript)\n and let Babel handle both your JavaScript and TypeScript files instead of using an additional loader. Keep in mind that, contrary to `ts-loader`, the underlying [`@babel/plugin-transform-typescript`](https://babeljs.io/docs/en/babel-plugin-transform-typescript)\n plugin does not perform any type checking.\n\nSource Maps[](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html#source-maps)\n\n---------------------------------------------------------------------------------------------\n\nTo learn more about source maps, see the [development guide](https://www.typescriptlang.org/guides/development)\n.\n\nTo enable source maps, we must configure TypeScript to output inline source maps to our compiled JavaScript files. The following line must be added to our TypeScript configuration:\n\n**tsconfig.json**\n\n      {\n        \"compilerOptions\": {\n          \"outDir\": \"./dist/\",\n    +     \"sourceMap\": true,\n          \"noImplicitAny\": true,\n          \"module\": \"commonjs\",\n          \"target\": \"es5\",\n          \"jsx\": \"react\",\n          \"allowJs\": true,\n          \"moduleResolution\": \"node\",\n        }\n      }\n\nNow we need to tell webpack to extract these source maps and include in our final bundle:\n\n**webpack.config.js**\n\n      const path = require('path');\n    \n      module.exports = {\n        entry: './src/index.ts',\n    +   devtool: 'inline-source-map',\n        module: {\n          rules: [\\\n            {\\\n              test: /\\.tsx?$/,\\\n              use: 'ts-loader',\\\n              exclude: /node_modules/,\\\n            },\\\n          ],\n        },\n        resolve: {\n          extensions: [ '.tsx', '.ts', '.js' ],\n        },\n        output: {\n          filename: 'bundle.js',\n          path: path.resolve(__dirname, 'dist'),\n        },\n      };\n\nSee the [devtool documentation](https://www.typescriptlang.org/configuration/devtool/)\n for more information.\n\nClient types[](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html#client-types)\n\n-----------------------------------------------------------------------------------------------\n\nIt's possible to use webpack specific features in your TypeScript code, such as [`import.meta.webpack`](https://www.typescriptlang.org/api/module-variables/#importmetawebpack)\n. And webpack provides types for them as well, add a TypeScript [`reference`](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-types-)\n directive to declare it:\n\n    /// <reference types=\"webpack/module\" />\n    console.log(import.meta.webpack); // without reference declared above, TypeScript will throw an error\n\nUsing Third Party Libraries[](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html#using-third-party-libraries)\n\n-----------------------------------------------------------------------------------------------------------------------------\n\nWhen installing third party libraries from npm, it is important to remember to install the typing definition for that library.\n\nFor example, if we want to install lodash we can run the following command to get the typings for it:\n\n    npm install --save-dev @types/lodash\n\nIf the npm package already includes its declaration typings in the package bundle, downloading the corresponding `@types` package is not needed. For more information see the [TypeScript changelog blog](https://github.blog/changelog/2020-12-16-npm-displays-packages-with-bundled-typescript-declarations/)\n.\n\nImporting Other Assets[](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html#importing-other-assets)\n\n-------------------------------------------------------------------------------------------------------------------\n\nTo use non-code assets with TypeScript, we need to defer the type for these imports. This requires a `custom.d.ts` file which signifies custom definitions for TypeScript in our project. Let's set up a declaration for `.svg` files:\n\n**custom.d.ts**\n\n    declare module '*.svg' {\n      const content: any;\n      export default content;\n    }\n\nHere we declare a new module for SVGs by specifying any import that ends in `.svg` and defining the module's `content` as `any`. We could be more explicit about it being a url by defining the type as string. The same concept applies to other assets including CSS, SCSS, JSON and more.\n\nBuild Performance[](https://www.typescriptlang.org/docs/handbook/react-&-webpack.html#build-performance)\n\n---------------------------------------------------------------------------------------------------------\n\nSee the [Build Performance](https://www.typescriptlang.org/guides/build-performance/)\n guide on build tooling.\n\n[Edit this page](https://github.com/webpack/webpack.js.org/edit/main/src/content/guides/typescript.mdx)\n·Print this page\n\n« Previous\n\n[Shimming](https://www.typescriptlang.org/guides/shimming/)\n\nNext »\n\n[Web Workers](https://www.typescriptlang.org/guides/web-workers/)\n\n7 Contributors\n--------------\n\n[![morsdyce](https://www.typescriptlang.org/icon-square-small-slack.1c7f4f7a52c41f94.png \"morsdyce\")](https://github.com/morsdyce)\n[![kkamali](https://www.typescriptlang.org/icon-square-small-slack.1c7f4f7a52c41f94.png \"kkamali\")](https://github.com/kkamali)\n[![mtrivera](https://www.typescriptlang.org/icon-square-small-slack.1c7f4f7a52c41f94.png \"mtrivera\")](https://github.com/mtrivera)\n[![byzyk](https://www.typescriptlang.org/icon-square-small-slack.1c7f4f7a52c41f94.png \"byzyk\")](https://github.com/byzyk)\n[![EugeneHlushko](https://www.typescriptlang.org/icon-square-small-slack.1c7f4f7a52c41f94.png \"EugeneHlushko\")](https://github.com/EugeneHlushko)\n[![chenxsan](https://www.typescriptlang.org/icon-square-small-slack.1c7f4f7a52c41f94.png \"chenxsan\")](https://github.com/chenxsan)\n[![snitin315](https://www.typescriptlang.org/icon-square-small-slack.1c7f4f7a52c41f94.png \"snitin315\")](https://github.com/snitin315)\n\nYou are reading the documentation for webpack 5, the latest release. Read the [webpack 4 documentation here](https://v4.webpack.js.org/)\n. See the [migration guide](https://www.typescriptlang.org/migrate/5)\n for upgrading to webpack 5.","metadata":{"og:title":"TypeScript | webpack","apple-mobile-web-app-status-bar-style":"black","msapplication-TileColor":"#465e69","apple-mobile-web-app-title":"webpack","ogSiteName":"webpack","ogTitle":"TypeScript | webpack","theme-color":"#2B3A42","mobile-web-app-capable":"yes","msapplication-TileImage":"/icon_150x150.png","language":"en","title":"TypeScript | webpack","ogDescription":"webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging just about any resource or asset.","og:site_name":"webpack","og:image":"https://webpack.js.org/icon-pwa-512x512.934507c816afbcdb.png","twitter:card":"summary","twitter:site":"@webpack","og:type":"website","description":["webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging just about any resource or asset.","webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging just about any resource or asset."],"twitter:creator":"@webpack","ogImage":"https://webpack.js.org/icon-pwa-512x512.934507c816afbcdb.png","favicon":"https://www.typescriptlang.org/favicon.a3dd58d3142f7566.ico","viewport":"width=device-width, initial-scale=1","twitter:domain":"https://webpack.js.org/","apple-mobile-web-app-capable":"yes","scrapeId":"34f8cf5e-d04b-4504-95bd-c81bf4c75caa","sourceURL":"https://www.typescriptlang.org/docs/handbook/react-&-webpack.html","url":"https://www.typescriptlang.org/docs/handbook/react-&-webpack.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nNightly Builds\n==============\n\nA nightly build from the [TypeScript’s `main`](https://github.com/Microsoft/TypeScript/tree/main)\n branch is published by midnight PST to npm. Here is how you can get it and use it with your tools.\n\n[](https://www.typescriptlang.org/docs/handbook/nightly-builds.html#using-npm)\nUsing npm\n----------------------------------------------------------------------------------------\n\nshell\n\n`   npm install -D typescript@next   `\n\n[](https://www.typescriptlang.org/docs/handbook/nightly-builds.html#updating-your-ide-to-use-the-nightly-builds)\nUpdating your IDE to use the nightly builds\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nYou can also update your editor/IDE to use the nightly drop. You will typically need to install the package through npm. The rest of this section mostly assumes `typescript@next` is already installed.\n\n### [](https://www.typescriptlang.org/docs/handbook/nightly-builds.html#visual-studio-code)\nVisual Studio Code\n\nThe VS Code website [has documentation on selecting a workspace version of TypeScript](https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions)\n. After installing a nightly version of TypeScript in your workspace, you can follow directions there, or simply update your workspace settings in the JSON view. A direct way to do this is to open or create your workspace’s `.vscode/settings.json` and add the following property:\n\njson\n\n`   \"typescript.tsdk\": \"<path to your folder>/node_modules/typescript/lib\"   `\n\nAlternatively, if you simply want to run the nightly editing experience for JavaScript and TypeScript in Visual Studio Code without changing your workspace version, you can run the [JavaScript and TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName%253Dms-vscode.vscode-typescript-next)\n\n### [](https://www.typescriptlang.org/docs/handbook/nightly-builds.html#sublime-text)\nSublime Text\n\nUpdate the `Settings - User` file with the following:\n\njson\n\n`   \"typescript_tsdk\": \"<path to your folder>/node_modules/typescript/lib\"   `\n\nMore information is available at the [TypeScript Plugin for Sublime Text installation documentation](https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/nightly-builds.html#visual-studio-2013-and-2015)\nVisual Studio 2013 and 2015\n\n> Note: Most changes do not require you to install a new version of the VS TypeScript plugin.\n\nThe nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.\n\n1.  Download the [VSDevMode.ps1](https://github.com/Microsoft/TypeScript/blob/main/scripts/VSDevMode.ps1)\n     script.\n    \n    > Also see our wiki page on [using a custom language service file](https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file)\n    > .\n    \n2.  From a PowerShell command window, run:\n    \n\nFor VS 2015:\n\n`VSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib`\n\nFor VS 2013:\n\n`VSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib`\n\n### [](https://www.typescriptlang.org/docs/handbook/nightly-builds.html#intellij-idea-mac)\nIntelliJ IDEA (Mac)\n\nGo to `Preferences` > `Languages & Frameworks` > `TypeScript`:\n\n> TypeScript Version: If you installed with npm: `/usr/local/lib/node_modules/typescript/lib`\n\n### [](https://www.typescriptlang.org/docs/handbook/nightly-builds.html#intellij-idea-windows)\nIntelliJ IDEA (Windows)\n\nGo to `File` > `Settings` > `Languages & Frameworks` > `TypeScript`:\n\n> TypeScript Version: If you installed with npm: `C:\\Users\\USERNAME\\AppData\\Roaming\\npm\\node_modules\\typescript\\lib`\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/Nightly%20Builds.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (52)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nS![StefanRein  (2)](https://gravatar.com/avatar/078daaad2c37d829a53e4db1827c0961?s=32&&d=blank)\n\nDR![Daniel Rosenwasser  (1)](https://gravatar.com/avatar/3cb42391bbae78f84e416c9407fb9ef82c008ab291b8193611b0a77946c499d8?s=32&&d=blank)\n\nNS![Nihaal Sangha  (1)](https://gravatar.com/avatar/6f0e1006521ebd927661b94fed3058d9133446051988f6f6ef5f2abe7ad7be01?s=32&&d=blank)\n\n4+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"How to use a nightly build of TypeScript","og:title":"Documentation - Nightly Builds","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","twitter:site":"typescriptlang","ogTitle":"Documentation - Nightly Builds","title":"TypeScript: Documentation - Nightly Builds","language":"en","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","description":"How to use a nightly build of TypeScript","og:description":"How to use a nightly build of TypeScript","scrapeId":"a47de078-03eb-4899-86ec-17ca8f032c56","sourceURL":"https://www.typescriptlang.org/docs/handbook/nightly-builds.html","url":"https://www.typescriptlang.org/docs/handbook/nightly-builds.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.8\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#improved-intersection-reduction-union-compatibility-and-narrowing)\nImproved Intersection Reduction, Union Compatibility, and Narrowing\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.8 brings a series of correctness and consistency improvements under `--strictNullChecks`. These changes affect how intersection and union types work, and are leveraged in how TypeScript narrows types.\n\nFor example, `unknown` is close in spirit to the union type `{} | null | undefined` because it accepts `null`, `undefined`, and any other type. TypeScript now recognizes this, and allows assignments from `unknown` to `{} | null | undefined`.\n\nts\n\n`   function f(x: unknown, y: {} | null | undefined) {      x = y; // always worked      y = x; // used to error, now works  }   `\n\nAnother change is that `{}` intersected with any other object type simplifies right down to that object type. That meant that we were able to rewrite `NonNullable` to just use an intersection with `{}`, because `{} & null` and `{} & undefined` just get tossed away.\n\ndiff\n\n`   - type NonNullable<T> = T extends null | undefined ? never : T;  + type NonNullable<T> = T & {};   `\n\nThis is an improvement because intersection types like this can be reduced and assigned to, while conditional types currently cannot. So `NonNullable<NonNullable<T>>` now simplifies at least to `NonNullable<T>`, whereas it didn’t before.\n\nts\n\n`   function foo<T>(x: NonNullable<T>, y: NonNullable<NonNullable<T>>) {      x = y; // always worked      y = x; // used to error, now works  }   `\n\nThese changes also allowed us to bring in sensible improvements in control flow analysis and type narrowing. For example, `unknown` is now narrowed just like `{} | null | undefined` in truthy branches.\n\nts\n\n`   function narrowUnknownishUnion(x: {} | null | undefined) {      if (x) {          x;  // {}      }      else {          x;  // {} | null | undefined      }  }  function narrowUnknown(x: unknown) {      if (x) {          x;  // used to be 'unknown', now '{}'      }      else {          x;  // unknown      }  }   `\n\nGeneric values also get narrowed similarly. When checking that a value isn’t `null` or `undefined`, TypeScript now just intersects it with `{}` - which again, is the same as saying it’s `NonNullable`. Putting many of the changes here together, we can now define the following function without any type assertions.\n\nts\n\n`   function throwIfNullable<T>(value: T): NonNullable<T> {      if (value === undefined || value === null) {          throw Error(\"Nullable value!\");      }      // Used to fail because 'T' was not assignable to 'NonNullable<T>'.      // Now narrows to 'T & {}' and succeeds because that's just 'NonNullable<T>'.      return value;  }   `\n\n`value` now gets narrowed to `T & {}`, and is now identical with `NonNullable<T>` - so the body of the function just works with no TypeScript-specific syntax.\n\nOn their own, these changes may appear small - but they represent fixes for many many paper cuts that have been reported over several years.\n\nFor more specifics on these improvements, you can [read more here](https://github.com/microsoft/TypeScript/pull/49119)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#improved-inference-for-infer-types-in-template-string-types)\nImproved Inference for `infer` Types in Template String Types\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript recently introduced a way to add `extends` constraints to `infer` type variables in conditional types.\n\nts\n\n`   // Grabs the first element of a tuple if it's assignable to 'number',  // and returns 'never' if it can't find one.  type TryGetNumberIfFirst<T> =      T extends [infer U extends number, ...unknown[]] ? U : never;   `\n\nIf these `infer` types appear in a template string type and are constrained to a primitive type, TypeScript will now try to parse out a literal type.\n\nts\n\n``   // SomeNum used to be 'number'; now it's '100'.  type SomeNum = \"100\" extends `${infer U extends number}` ? U : never;  // SomeBigInt used to be 'bigint'; now it's '100n'.  type SomeBigInt = \"100\" extends `${infer U extends bigint}` ? U : never;  // SomeBool used to be 'boolean'; now it's 'true'.  type SomeBool = \"true\" extends `${infer U extends boolean}` ? U : never;   ``\n\nThis can now better convey what a library will do at runtime, and give more precise types.\n\nOne note on this is that when TypeScript parses these literal types out it will greedily try to parse out as much of what looks like of the appropriate primitive type; however it then checks to see if the print-back of that primitive matches up with the string contents. In other words, TypeScript checks whether the going from the string, to the primitive, and back matches. If it doesn’t see that the string can be “round-tripped”, then it will fall back to the base primitive type.\n\nts\n\n``// JustNumber is `number` here because TypeScript parses out `\"1.0\"`, but `String(Number(\"1.0\"))` is `\"1\"` and doesn't match.  type JustNumber = \"1.0\" extends `${infer T extends number}` ? T : never;`` \n\nYou can [see more about this feature here](https://github.com/microsoft/TypeScript/pull/48094)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#--build---watch-and---incremental-performance-improvements)\n`--build`, `--watch`, and `--incremental` Performance Improvements\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.8 introduces several optimizations that should speed up scenarios around `--watch` and `--incremental`, along with project references builds using `--build`. For example, TypeScript is now able to avoid spending time updating timestamps during no-op changes in `--watch` mode, which makes rebuilds faster and avoids messing with other build tools that might be watching for TypeScript’s output. Many other optimizations where we’re able to reuse information across `--build`, `--watch`, and `--incremental` have been introduced as well.\n\nHow big are these improvements? Well, on a fairly large internal codebase, we’ve seen time reductions on the order of 10%-25% on many simple common operations, with around 40% time reductions in no-change scenarios. We’ve seen similar results on the TypeScript codebase as well.\n\nYou can see [the changes, along with the performance results on GitHub](https://github.com/microsoft/TypeScript/pull/48784)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#errors-when-comparing-object-and-array-literals)\nErrors When Comparing Object and Array Literals\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn many languages, operators like `==` perform what’s called “value” equality on objects. For example, in Python it’s valid to check whether a list is empty by checking whether a value is equal to the empty list using `==`.\n\npy\n\n`   if people_at_home == []:      print(\"here's where I lie, broken inside. </3\")      adopt_animals()   `\n\nThis is not the case in JavaScript, where `==` and `===` between objects (and therefore, arrays) check whether both references point to the same value. We believe that similar code in JavaScript is at best an early foot-gun for JavaScript developers, and at worst a bug in production code. That’s why TypeScript now disallows code like the following.\n\nts\n\n`   if (peopleAtHome === []) {  //  ~~~~~~~~~~~~~~~~~~~  // This condition will always return 'false' since JavaScript compares objects by reference, not value.      console.log(\"here's where I lie, broken inside. </3\")      adoptAnimals();  }   `\n\nWe’d like to extend our gratitude to [Jack Works](https://github.com/Jack-Works)\n who contributed this check. You can [view the changes involved here](https://github.com/microsoft/TypeScript/pull/45978)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#improved-inference-from-binding-patterns)\nImproved Inference from Binding Patterns\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn some cases, TypeScript will pick up a type from a binding pattern to make better inferences.\n\nts\n\n`   declare function chooseRandomly<T>(x: T, y: T): T;  let [a, b, c] = chooseRandomly([42, true, \"hi!\"], [0, false, \"bye!\"]);  //   ^  ^  ^  //   |  |  |  //   |  |  string  //   |  |  //   |  boolean  //   |  //   number   `\n\nWhen `chooseRandomly` needs to figure out a type for `T`, it will primarily look at `[42, true, \"hi!\"]` and `[0, false, \"bye!\"]`; but TypeScript needs to figure out whether those two types should be `Array<number | boolean | string>` or the tuple type `[number, boolean, string]`. To do that, it will look for existing candidates as a hint to see whether there are any tuple types. When TypeScript sees the binding pattern `[a, b, c]`, it creates the type `[any, any, any]`, and that type gets picked up as a low-priority candidate for `T` which also gets used as a hint for the types of `[42, true, \"hi!\"]` and `[0, false, \"bye!\"]`.\n\nYou can see how this was good for `chooseRandomly`, but it fell short in other cases. For example, take the following code\n\nts\n\n`   declare function f<T>(x?: T): T;  let [x, y, z] = f();   `\n\nThe binding pattern `[x, y, z]` hinted that `f` should produce an `[any, any, any]` tuple; but `f` really shouldn’t change its type argument based on a binding pattern. It can’t suddenly conjure up a new array-like value based on what it’s being assigned to, so the binding pattern type has way too much influence on the produced type. On top of that, because the binding pattern type is full of `any`s, we’re left with `x`, `y`, and `z` being typed as `any`.\n\nIn TypeScript 4.8, these binding patterns are never used as candidates for type arguments. Instead, they’re just consulted in case a parameter needs a more specific type like in our `chooseRandomly` example. If you need to revert to the old behavior, you can always provide explicit type arguments.\n\nYou can [look at the change on GitHub](https://github.com/microsoft/TypeScript/pull/49086)\n if you’re curious to learn more.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#file-watching-fixes-especially-across-git-checkouts)\nFile-Watching Fixes (Especially Across `git checkout`s)\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWe’ve had a long-standing bug where TypeScript has a very hard time with certain file changes in `--watch` mode and editor scenarios. Sometimes the symptoms are stale or inaccurate errors that might show up that require restarting `tsc` or VS Code. Frequently these occur on Unix systems, and you might have seen these after saving a file with vim or swapping branches in git.\n\nThis was caused by assumptions of how Node.js handles rename events across file systems. File systems used by Linux and macOS utilize [inodes](https://en.wikipedia.org/wiki/Inode)\n, and [Node.js will attach file watchers to inodes rather than file paths](https://nodejs.org/api/fs.html#inodes)\n. So when Node.js returns [a watcher object](https://nodejs.org/api/fs.html#class-fsfswatcher)\n, it might be watching a path or an inode depending on the platform and file system.\n\nTo be a bit more efficient, TypeScript tries to reuse the same watcher objects if it detects a path still exists on disk. This is where things went wrong, because even if a file still exists at that path, a distinct file might have been created, and that file will have a different inode. So TypeScript would end up reusing the watcher object instead of installing a new watcher at the original location, and watch for changes at what might be a totally irrelevant file. So TypeScript 4.8 now handles these cases on inode systems and properly installs a new watcher and fixes this.\n\nWe’d like to extend our thanks to [Marc Celani](https://github.com/MarcCelani-at)\n and his team at Airtable who invested lots of time in investigating the issues they were experiencing and pointing out the root cause. You can view [the specific fixes around file-watching here](https://github.com/microsoft/TypeScript/pull/48997)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#find-all-references-performance-improvements)\nFind-All-References Performance Improvements\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen running find-all-references in your editor, TypeScript is now able to act a little smarter as it aggregates references. This reduced the amount of time TypeScript took to search a widely-used identifier in its own codebase by about 20%.\n\n[You can read up more on the improvement here](https://github.com/microsoft/TypeScript/pull/49581)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#exclude-specific-files-from-auto-imports)\nExclude Specific Files from Auto-Imports\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.8 introduces an editor preference for excluding files from auto-imports. In Visual Studio Code, file names or globs can be added under “Auto Import File Exclude Patterns” in the Settings UI, or in a `.vscode/settings.json` file:\n\njsonc\n\n``   {      // Note that `javascript.preferences.autoImportFileExcludePatterns` can be specified for JavaScript too.      \"typescript.preferences.autoImportFileExcludePatterns\": [        \"**/node_modules/@types/node\"      ]  }   ``\n\nThis can be useful in cases where you can’t avoid having certain modules or libraries in your compilation but you rarely want to import from them. These modules might have lots of exports that can pollute the auto-imports list and make it harder to navigate, and this option can help in those situations.\n\nYou can [see more specifics about the implementation here](https://github.com/microsoft/TypeScript/pull/49578)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#correctness-fixes-and-breaking-changes)\nCorrectness Fixes and Breaking Changes\n----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nDue to the nature of type system changes, there are very few changes that can be made that don’t affect _some_ code; however, there are a few changes that are more likely to require adapting existing code.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#libdts-updates)\n`lib.d.ts` Updates\n\nWhile TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don’t expect major breaks as a result of DOM and `lib.d.ts` updates, but one notable change is that the `cause` property on `Error`s now has the type `unknown` instead of `Error`.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#unconstrained-generics-no-longer-assignable-to-)\nUnconstrained Generics No Longer Assignable to `{}`\n\nIn TypeScript 4.8, for projects with `strictNullChecks` enabled, TypeScript will now correctly issue an error when an unconstrained type parameter is used in a position where `null` or `undefined` are not legal values. That will include any type that expects `{}`, `object`, or an object type with all-optional properties.\n\nA simple example can be seen in the following.\n\nts\n\n`   // Accepts any non-null non-undefined value  function bar(value: {}) {    Object.keys(value); // This call throws on null/undefined at runtime.  }  // Unconstrained type parameter T...  function foo<T>(x: T) {      bar(x); // Used to be allowed, now is an error in 4.8.      //  ~      // error: Argument of type 'T' is not assignable to parameter of type '{}'.  }  foo(undefined);   `\n\nAs demonstrated above, code like this has a potential bug - the values `null` and `undefined` can be indirectly passed through these unconstrained type parameters to code that is not supposed to observe those values.\n\nThis behavior will also be visible in type positions. One example would be:\n\nts\n\n`   interface Foo<T> {    x: Bar<T>;  }  interface Bar<T extends {}> { }   `\n\nExisting code that didn’t want to handle `null` and `undefined` can be fixed by propagating the appropriate constraints through.\n\ndiff\n\n`   - function foo<T>(x: T) {  + function foo<T extends {}>(x: T) {   `\n\nAnother work-around would be to check for `null` and `undefined` at runtime.\n\ndiff\n\n  `function foo<T>(x: T) {  +     if (x !== null && x !== undefined) {            bar(x);  +     }    }`\n\nAnd if you know that for some reason, your generic value can’t be `null` or `undefined`, you can just use a non-null assertion.\n\ndiff\n\n  `function foo<T>(x: T) {  -     bar(x);  +     bar(x!);    }`\n\nWhen it comes to types, you’ll often either need to propagate constraints, or intersect your types with `{}`.\n\nFor more information, you can [see the change that introduced this](https://github.com/microsoft/TypeScript/pull/49119)\n along with [the specific discussion issue regarding how unconstrained generics now work](https://github.com/microsoft/TypeScript/issues/49489)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#decorators-are-placed-on-modifiers-on-typescripts-syntax-trees)\nDecorators are placed on `modifiers` on TypeScript’s Syntax Trees\n\nThe current direction of decorators in TC39 means that TypeScript will have to handle a break in terms of placement of decorators. Previously, TypeScript assumed decorators would always be placed prior to all keywords/modifiers. For example\n\nts\n\n`   @decorator  export class Foo {    // ...  }   `\n\nDecorators as currently proposed do not support this syntax. Instead, the `export` keyword must precede the decorator.\n\nts\n\n`   export @decorator class Foo {    // ...  }   `\n\nUnfortunately, TypeScript’s trees are _concrete_ rather than _abstract_, and our architecture expects syntax tree node fields to be entirely ordered before or after each other. To support both legacy decorators and decorators as proposed, TypeScript will have to gracefully parse, and intersperse, modifiers and decorators.\n\nTo do this, it exposes a new type alias called `ModifierLike` which is a `Modifier` or a `Decorator`.\n\nts\n\n`   export type ModifierLike = Modifier | Decorator;   `\n\nDecorators are now placed in the same field as `modifiers` which is now a `NodeArray<ModifierLike>` when set, and the entire field is deprecated.\n\ndiff\n\n``   - readonly modifiers?: NodeArray<Modifier> | undefined;  + /**  +  * @deprecated ...  +  * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.  +  * Use `ts.getModifiers()` to get the modifiers of a `Node`.  +  * ...  +  */  + readonly modifiers?: NodeArray<ModifierLike> | undefined;   ``\n\nAll existing `decorators` properties have been marked as deprecated and will always be `undefined` if read. The type has also been changed to `undefined` so that existing tools know to handle them correctly.\n\ndiff\n\n``   - readonly decorators?: NodeArray<Decorator> | undefined;  + /**  +  * @deprecated ...  +  * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.  +  * Use `ts.getDecorators()` to get the decorators of a `Node`.  +  * ...  +  */  + readonly decorators?: undefined;   ``\n\nTo avoid new deprecation warnings and other issues, TypeScript now exposes four new functions to use in place of the `decorators` and `modifiers` properties. There are individual predicates for testing whether a node has support modifiers and decorators, along with respective accessor functions for grabbing them.\n\nts\n\n`   function canHaveModifiers(node: Node): node is HasModifiers;  function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;  function canHaveDecorators(node: Node): node is HasDecorators;  function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;   `\n\nAs an example of how to access modifiers off of a node, you can write\n\nts\n\n`   const modifiers = canHaveModifiers(myNode) ? getModifiers(myNode) : undefined;   `\n\nWith the note that each call to `getModifiers` and `getDecorators` may allocate a new array.\n\nFor more information, see changes around\n\n*   [the restructuring of our tree nodes](https://github.com/microsoft/TypeScript/pull/49089)\n    \n*   [the deprecations](https://github.com/microsoft/TypeScript/pull/50343)\n    \n*   [exposing the predicate functions](https://github.com/microsoft/TypeScript/pull/50399)\n    \n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#types-cannot-be-importedexported-in-javascript-files)\nTypes Cannot Be Imported/Exported in JavaScript Files\n\nTypeScript previously allowed JavaScript files to import and export entities declared with a type, but no value, in `import` and `export` statements. This behavior was incorrect, because named imports and exports for values that don’t exist will cause a runtime error under ECMAScript modules. When a JavaScript file is type-checked under `--checkJs` or through a `// @ts-check` comment, TypeScript will now issue an error.\n\nts\n\n`   // @ts-check  // Will fail at runtime because 'SomeType' is not a value.  import { someValue, SomeType } from \"some-module\";  /**   * @type {SomeType}   */  export const myValue = someValue;  /**   * @typedef {string | number} MyType   */  // Will fail at runtime because 'MyType' is not a value.  export { MyType as MyExportedType };   `\n\nTo reference a type from another module, you can instead directly qualify the import.\n\ndiff\n\n`   - import { someValue, SomeType } from \"some-module\";  + import { someValue } from \"some-module\";    /**  -  * @type {SomeType}  +  * @type {import(\"some-module\").SomeType}     */    export const myValue = someValue;   `\n\nTo export a type, you can just use a `/** @typedef */` comment in JSDoc. `@typedef` comments already automatically export types from their containing modules.\n\ndiff\n\n  `/**     * @typedef {string | number} MyType     */  + /**  +  * @typedef {MyType} MyExportedType  +  */  - export { MyType as MyExportedType };`\n\nYou can [read more about the change here](https://github.com/microsoft/TypeScript/pull/49580)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#binding-patterns-do-not-directly-contribute-to-inference-candidates)\nBinding Patterns Do Not Directly Contribute to Inference Candidates\n\nAs mentioned above, binding patterns no longer change the type of inference results in function calls. You can [read more about the original change here](https://github.com/microsoft/TypeScript/pull/49086)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html#unused-renames-in-binding-patterns-are-now-errors-in-type-signatures)\nUnused Renames in Binding Patterns are Now Errors in Type Signatures\n\nTypeScript’s type annotation syntax often looks like it can be used when destructuring values. For example, take the following function.\n\nts\n\n`   declare function makePerson({ name: string, age: number }): Person;   `\n\nYou might read this signature and think that `makePerson` obviously takes an object with a `name` property with the type `string` and an `age` property with the type `number`; however, JavaScript’s destructuring syntax is actually taking precedence here. `makePerson` does say that it’s going to take an object with a `name` and an `age` property, but instead of specifying a type for them, it’s just saying that it renames `name` and `age` to `string` and `number` respectively.\n\nIn a pure type construct, writing code like this is useless, and typically a mistake since developers usually assume they’re writing a type annotation.\n\nTypeScript 4.8 makes these an error unless they’re referenced later in the signature. The correct way to write the above signature would be as follows:\n\nts\n\n`   declare function makePerson(options: { name: string, age: number }): Person;  // or  declare function makePerson({ name, age }: { name: string, age: number }): Person;   `\n\nThis change can catch bugs in declarations, and has been helpful for improving existing code. We’d like to extend our thanks to [GitHub user uhyo](https://github.com/uhyo)\n for providing this check. [You can read up on the change here](https://github.com/microsoft/TypeScript/pull/41044)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.8.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (6)](https://gravatar.com/avatar/86ed396e4ffb41b052654b9f8ad4d1caaf732bc42985860b0cac8191a66e33df?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","ogDescription":"TypeScript 4.8 Release Notes","ogTitle":"Documentation - TypeScript 4.8","description":"TypeScript 4.8 Release Notes","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:description":"TypeScript 4.8 Release Notes","og:title":"Documentation - TypeScript 4.8","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","title":"TypeScript: Documentation - TypeScript 4.8","theme-color":"#3178C6","twitter:site":"typescriptlang","scrapeId":"5e03a98a-cfb3-41aa-ad1c-f12e5cb8a49d","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.9\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator)\nThe `satisfies` Operator\n----------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript developers are often faced with a dilemma: we want to ensure that some expression _matches_ some type, but also want to keep the _most specific_ type of that expression for inference purposes.\n\nFor example:\n\nts\n\n`   // Each property can be a string or an RGB tuple.  const palette = {      red: [255, 0, 0],      green: \"#00ff00\",      bleu: [0, 0, 255]  //  ^^^^ sacrebleu - we've made a typo!  };  // We want to be able to use string methods on 'green'...  const greenNormalized = palette.green.toUpperCase();   `\n\nNotice that we’ve written `bleu`, whereas we probably should have written `blue`. We could try to catch that `bleu` typo by using a type annotation on `palette`, but we’d lose the information about each property.\n\nts\n\n`   type Colors = \"red\" | \"green\" | \"blue\";  type RGB = [red: number, green: number, blue: number];  const palette: Record<Colors, string | RGB> = {      red: [255, 0, 0],      green: \"#00ff00\",      bleu: [0, 0, 255]  //  ~~~~ The typo is now correctly detected  };  // But we now have an undesirable error here - 'palette.green' \"could\" be of type RGB and  // property 'toUpperCase' does not exist on type 'string | RGB'.  const greenNormalized = palette.green.toUpperCase();   `\n\nThe new `satisfies` operator lets us validate that the type of an expression matches some type, without changing the resulting type of that expression. As an example, we could use `satisfies` to validate that all the properties of `palette` are compatible with `string | number[]`:\n\nts\n\n`   type Colors = \"red\" | \"green\" | \"blue\";  type RGB = [red: number, green: number, blue: number];  const palette = {      red: [255, 0, 0],      green: \"#00ff00\",      bleu: [0, 0, 255]  //  ~~~~ The typo is now caught!  } satisfies Record<Colors, string | RGB>;  // toUpperCase() method is still accessible!  const greenNormalized = palette.green.toUpperCase();   `\n\n`satisfies` can be used to catch lots of possible errors. For example, we could ensure that an object has _all_ the keys of some type, but no more:\n\nts\n\n`   type Colors = \"red\" | \"green\" | \"blue\";  // Ensure that we have exactly the keys from 'Colors'.  const favoriteColors = {      \"red\": \"yes\",      \"green\": false,      \"blue\": \"kinda\",      \"platypus\": false  //  ~~~~~~~~~~ error - \"platypus\" was never listed in 'Colors'.  } satisfies Record<Colors, unknown>;  // All the information about the 'red', 'green', and 'blue' properties are retained.  const g: boolean = favoriteColors.green;   `\n\nMaybe we don’t care about if the property names match up somehow, but we do care about the types of each property. In that case, we can also ensure that all of an object’s property values conform to some type.\n\nts\n\n`   type RGB = [red: number, green: number, blue: number];  const palette = {      red: [255, 0, 0],      green: \"#00ff00\",      blue: [0, 0]      //    ~~~~~~ error!  } satisfies Record<string, string | RGB>;  // Information about each property is still maintained.  const redComponent = palette.red.at(0);  const greenNormalized = palette.green.toUpperCase();   `\n\nFor more examples, you can see the [issue proposing this](https://github.com/microsoft/TypeScript/issues/47920)\n and [the implementing pull request](https://github.com/microsoft/TypeScript/pull/46827)\n. We’d like to thank [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n who implemented and iterated on this feature with us.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#unlisted-property-narrowing-with-the-in-operator)\nUnlisted Property Narrowing with the `in` Operator\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nAs developers, we often need to deal with values that aren’t fully known at runtime. In fact, we often don’t know if properties exist, whether we’re getting a response from a server or reading a configuration file. JavaScript’s `in` operator can check whether a property exists on an object.\n\nPreviously, TypeScript allowed us to narrow away any types that don’t explicitly list a property.\n\nts\n\n`   interface RGB {      red: number;      green: number;      blue: number;  }  interface HSV {      hue: number;      saturation: number;      value: number;  }  function setColor(color: RGB | HSV) {      if (\"hue\" in color) {          // 'color' now has the type HSV      }      // ...  }   `\n\nHere, the type `RGB` didn’t list the `hue` and got narrowed away, and leaving us with the type `HSV`.\n\nBut what about examples where no type listed a given property? In those cases, the language didn’t help us much. Let’s take the following example in JavaScript:\n\njs\n\n`   function tryGetPackageName(context) {      const packageJSON = context.packageJSON;      // Check to see if we have an object.      if (packageJSON && typeof packageJSON === \"object\") {          // Check to see if it has a string name property.          if (\"name\" in packageJSON && typeof packageJSON.name === \"string\") {              return packageJSON.name;          }      }      return undefined;  }   `\n\nRewriting this to canonical TypeScript would just be a matter of defining and using a type for `context`; however, picking a safe type like `unknown` for the `packageJSON` property would cause issues in older versions of TypeScript.\n\nts\n\n`   interface Context {      packageJSON: unknown;  }  function tryGetPackageName(context: Context) {      const packageJSON = context.packageJSON;      // Check to see if we have an object.      if (packageJSON && typeof packageJSON === \"object\") {          // Check to see if it has a string name property.          if (\"name\" in packageJSON && typeof packageJSON.name === \"string\") {          //                                              ~~~~          // error! Property 'name' does not exist on type 'object.              return packageJSON.name;          //                     ~~~~          // error! Property 'name' does not exist on type 'object.          }      }      return undefined;  }   `\n\nThis is because while the type of `packageJSON` was narrowed from `unknown` to `object`, the `in` operator strictly narrowed to types that actually defined the property being checked. As a result, the type of `packageJSON` remained `object`.\n\nTypeScript 4.9 makes the `in` operator a little bit more powerful when narrowing types that _don’t_ list the property at all. Instead of leaving them as-is, the language will intersect their types with `Record<\"property-key-being-checked\", unknown>`.\n\nSo in our example, `packageJSON` will have its type narrowed from `unknown` to `object` to `object & Record<\"name\", unknown>` That allows us to access `packageJSON.name` directly and narrow that independently.\n\nts\n\n`   interface Context {      packageJSON: unknown;  }  function tryGetPackageName(context: Context): string | undefined {      const packageJSON = context.packageJSON;      // Check to see if we have an object.      if (packageJSON && typeof packageJSON === \"object\") {          // Check to see if it has a string name property.          if (\"name\" in packageJSON && typeof packageJSON.name === \"string\") {              // Just works!              return packageJSON.name;          }      }      return undefined;  }   `\n\nTypeScript 4.9 also tightens up a few checks around how `in` is used, ensuring that the left side is assignable to the type `string | number | symbol`, and the right side is assignable to `object`. This helps check that we’re using valid property keys, and not accidentally checking primitives.\n\nFor more information, [read the implementing pull request](https://github.com/microsoft/TypeScript/pull/50666)\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#auto-accessors-in-classes)\nAuto-Accessors in Classes\n--------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.9 supports an upcoming feature in ECMAScript called auto-accessors. Auto-accessors are declared just like properties on classes, except that they’re declared with the `accessor` keyword.\n\nts\n\n`   class Person {      accessor name: string;      constructor(name: string) {          this.name = name;      }  }   `\n\nUnder the covers, these auto-accessors “de-sugar” to a `get` and `set` accessor with an unreachable private property.\n\nts\n\n`   class Person {      #__name: string;      get name() {          return this.#__name;      }      set name(value: string) {          this.#__name = value;      }      constructor(name: string) {          this.name = name;      }  }   `\n\nYou can [read up more about the auto-accessors pull request on the original PR](https://github.com/microsoft/TypeScript/pull/49705)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#checks-for-equality-on-nan)\nChecks For Equality on `NaN`\n------------------------------------------------------------------------------------------------------------------------------------------\n\nA major gotcha for JavaScript developers is checking against the value `NaN` using the built-in equality operators.\n\nFor some background, `NaN` is a special numeric value that stands for “Not a Number”. Nothing is ever equal to `NaN` - even `NaN`!\n\njs\n\n`   console.log(NaN == 0)  // false  console.log(NaN === 0) // false  console.log(NaN == NaN)  // false  console.log(NaN === NaN) // false   `\n\nBut at least symmetrically _everything_ is always not-equal to `NaN`.\n\njs\n\n`   console.log(NaN != 0)  // true  console.log(NaN !== 0) // true  console.log(NaN != NaN)  // true  console.log(NaN !== NaN) // true   `\n\nThis technically isn’t a JavaScript-specific problem, since any language that contains IEEE-754 floats has the same behavior; but JavaScript’s primary numeric type is a floating point number, and number parsing in JavaScript can often result in `NaN`. In turn, checking against `NaN` ends up being fairly common, and the correct way to do so is to use [`Number.isNaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)\n - _but_ as we mentioned, lots of people accidentally end up checking with `someValue === NaN` instead.\n\nTypeScript now errors on direct comparisons against `NaN`, and will suggest using some variation of `Number.isNaN` instead.\n\nts\n\n`   function validate(someValue: number) {      return someValue !== NaN;      //     ~~~~~~~~~~~~~~~~~      // error: This condition will always return 'true'.      //        Did you mean '!Number.isNaN(someValue)'?  }   `\n\nWe believe that this change should strictly help catch beginner errors, similar to how TypeScript currently issues errors on comparisons against object and array literals.\n\nWe’d like to extend our thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n who [contributed this check](https://github.com/microsoft/TypeScript/pull/50626)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#file-watching-now-uses-file-system-events)\nFile-Watching Now Uses File System Events\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn earlier versions, TypeScript leaned heavily on _polling_ for watching individual files. Using a polling strategy meant checking the state of a file periodically for updates. On Node.js, [`fs.watchFile`](https://nodejs.org/docs/latest-v18.x/api/fs.html#fswatchfilefilename-options-listener)\n is the built-in way to get a polling file-watcher. While polling tends to be more predictable across platforms and file systems, it means that your CPU has to periodically get interrupted and check for updates to the file, even when nothing’s changed. For a few dozen files, this might not be noticeable; but on a bigger project with lots of files - or lots of files in `node_modules` - this can become a resource hog.\n\nGenerally speaking, a better approach is to use file system events. Instead of polling, we can announce that we’re interested in updates of specific files and provide a callback for when those files _actually do_ change. Most modern platforms in use provide facilities and APIs like `CreateIoCompletionPort`, `kqueue`, `epoll`, and `inotify`. Node.js mostly abstracts these away by providing [`fs.watch`](https://nodejs.org/docs/latest-v18.x/api/fs.html#fswatchfilename-options-listener)\n. File system events usually work great, but there are [lots of caveats](https://nodejs.org/docs/latest-v18.x/api/fs.html#caveats)\n to using them, and in turn, to using the `fs.watch` API. A watcher needs to be careful to consider [inode watching](https://nodejs.org/docs/latest-v18.x/api/fs.html#inodes)\n, [unavailability on certain file systems](https://nodejs.org/docs/latest-v18.x/api/fs.html#availability)\n (e.g.networked file systems), whether recursive file watching is available, whether directory renames trigger events, and even file watcher exhaustion! In other words, it’s not quite a free lunch, especially if you’re looking for something cross-platform.\n\nAs a result, our default was to pick the lowest common denominator: polling. Not always, but most of the time.\n\nOver time, we’ve provided the means to [choose other file-watching strategies](https://www.typescriptlang.org/docs/handbook/configuring-watch.html)\n. This allowed us to get feedback and harden our file-watching implementation against most of these platform-specific gotchas. As TypeScript has needed to scale to larger codebases, and has improved in this area, we felt swapping to file system events as the default would be a worthwhile investment.\n\nIn TypeScript 4.9, file watching is powered by file system events by default, only falling back to polling if we fail to set up event-based watchers. For most developers, this should provide a much less resource-intensive experience when running in `--watch` mode, or running with a TypeScript-powered editor like Visual Studio or VS Code.\n\n[The way file-watching works can still be configured](https://www.typescriptlang.org/docs/handbook/configuring-watch.html)\n through environment variables and `watchOptions` - and [some editors like VS Code can support `watchOptions` independently](https://code.visualstudio.com/docs/getstarted/settings#:~:text=typescript%2etsserver%2ewatchOptions)\n. Developers using more exotic set-ups where source code resides on a networked file systems (like NFS and SMB) may need to opt back into the older behavior; though if a server has reasonable processing power, it might just be better to enable SSH and run TypeScript remotely so that it has direct local file access. VS Code has plenty of [remote extensions](https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All%20categories&sortBy=Relevance)\n to make this easier.\n\nYou can [read up more on this change on GitHub](https://github.com/microsoft/TypeScript/pull/50366)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#remove-unused-imports-and-sort-imports-commands-for-editors)\n“Remove Unused Imports” and “Sort Imports” Commands for Editors\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPreviously, TypeScript only supported two editor commands to manage imports. For our examples, take the following code:\n\nts\n\n`   import { Zebra, Moose, HoneyBadger } from \"./zoo\";  import { foo, bar } from \"./helper\";  let x: Moose | HoneyBadger = foo();   `\n\nThe first was called “Organize Imports” which would remove unused imports, and then sort the remaining ones. It would rewrite that file to look like this one:\n\nts\n\n`   import { foo } from \"./helper\";  import { HoneyBadger, Moose } from \"./zoo\";  let x: Moose | HoneyBadger = foo();   `\n\nIn TypeScript 4.3, we introduced a command called “Sort Imports” which would _only_ sort imports in the file, but not remove them - and would rewrite the file like this.\n\nts\n\n`   import { bar, foo } from \"./helper\";  import { HoneyBadger, Moose, Zebra } from \"./zoo\";  let x: Moose | HoneyBadger = foo();   `\n\nThe caveat with “Sort Imports” was that in Visual Studio Code, this feature was only available as an on-save command - not as a manually triggerable command.\n\nTypeScript 4.9 adds the other half, and now provides “Remove Unused Imports”. TypeScript will now remove unused import names and statements, but will otherwise leave the relative ordering alone.\n\nts\n\n`   import { Moose, HoneyBadger } from \"./zoo\";  import { foo } from \"./helper\";  let x: Moose | HoneyBadger = foo();   `\n\nThis feature is available to all editors that wish to use either command; but notably, Visual Studio Code (1.73 and later) will have support built in _and_ will surface these commands via its Command Palette. Users who prefer to use the more granular “Remove Unused Imports” or “Sort Imports” commands should be able to reassign the “Organize Imports” key combination to them if desired.\n\nYou can [view specifics of the feature here](https://github.com/microsoft/TypeScript/pull/50931)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#go-to-definition-on-return-keywords)\nGo-to-Definition on `return` Keywords\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn the editor, when running a go-to-definition on the `return` keyword, TypeScript will now jump you to the top of the corresponding function. This can be helpful to get a quick sense of which function a `return` belongs to.\n\nWe expect TypeScript will expand this functionality to more keywords [such as `await` and `yield`](https://github.com/microsoft/TypeScript/issues/51223)\n or [`switch`, `case`, and `default`](https://github.com/microsoft/TypeScript/issues/51225)\n.\n\n[This feature was implemented](https://github.com/microsoft/TypeScript/pull/51227)\n thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#performance-improvements)\nPerformance Improvements\n------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript has a few small, but notable, performance improvements.\n\nFirst, TypeScript’s `forEachChild` function has been rewritten to use a function table lookup instead of a `switch` statement across all syntax nodes. `forEachChild` is a workhorse for traversing syntax nodes in the compiler, and is used heavily in the binding stage of our compiler, along with parts of the language service. The refactoring of `forEachChild` yielded up to a 20% reduction of time spent in our binding phase and across language service operations.\n\nOnce we discovered this performance win for `forEachChild`, we tried it out on `visitEachChild`, a function we use for transforming nodes in the compiler and language service. The same refactoring yielded up to a 3% reduction in time spent in generating project output.\n\nThe initial exploration in `forEachChild` was [inspired by a blog post](https://artemis.sh/2022/08/07/emulating-calculators-fast-in-js.html)\n by [Artemis Everfree](https://artemis.sh/)\n. While we have some reason to believe the root cause of our speed-up might have more to do with function size/complexity than the issues described in the blog post, we’re grateful that we were able to learn from the experience and try out a relatively quick refactoring that made TypeScript faster.\n\nFinally, the way TypeScript preserves the information about a type in the true branch of a conditional type has been optimized. In a type like\n\nts\n\n`   interface Zoo<T extends Animal> {      // ...  }  type MakeZoo<A> = A extends Animal ? Zoo<A> : never;   `\n\nTypeScript has to “remember” that `A` must also be an `Animal` when checking if `Zoo<A>` is valid. This is basically done by creating a special type that used to hold the intersection of `A` with `Animal`; however, TypeScript previously did this eagerly which isn’t always necessary. Furthermore, some faulty code in our type-checker prevented these special types from being simplified. TypeScript now defers intersecting these types until it’s necessary. For codebases with heavy use of conditional types, you might witness significant speed-ups with TypeScript, but in our performance testing suite, we saw a more modest 3% reduction in type-checking time.\n\nYou can read up more on these optimizations on their respective pull requests:\n\n*   [`forEachChild` as a jump-table](https://github.com/microsoft/TypeScript/pull/50225)\n    \n*   [`visitEachChild` as a jump-table](https://github.com/microsoft/TypeScript/pull/50266)\n    \n*   [Optimize substitition types](https://github.com/microsoft/TypeScript/pull/50397)\n    \n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#correctness-fixes-and-breaking-changes)\nCorrectness Fixes and Breaking Changes\n----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#libdts-updates)\n`lib.d.ts` Updates\n\nWhile TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don’t expect major breaks as a result of DOM and `lib.d.ts` updates, but there may be some small ones.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#better-types-for-promiseresolve)\nBetter Types for `Promise.resolve`\n\n`Promise.resolve` now uses the `Awaited` type to unwrap Promise-like types passed to it. This means that it more often returns the right `Promise` type, but that improved type can break existing code if it was expecting `any` or `unknown` instead of a `Promise`. For more information, [see the original change](https://github.com/microsoft/TypeScript/pull/33074)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#javascript-emit-no-longer-elides-imports)\nJavaScript Emit No Longer Elides Imports\n\nWhen TypeScript first supported type-checking and compilation for JavaScript, it accidentally supported a feature called import elision. In short, if an import is not used as a value, or the compiler can detect that the import doesn’t refer to a value at runtime, the compiler will drop the import during emit.\n\nThis behavior was questionable, especially the detection of whether the import doesn’t refer to a value, since it means that TypeScript has to trust sometimes-inaccurate declaration files. In turn, TypeScript now preserves imports in JavaScript files.\n\njs\n\n`   // Input:  import { someValue, SomeClass } from \"some-module\";  /** @type {SomeClass} */  let val = someValue;  // Previous Output:  import { someValue } from \"some-module\";  /** @type {SomeClass} */  let val = someValue;  // Current Output:  import { someValue, SomeClass } from \"some-module\";  /** @type {SomeClass} */  let val = someValue;   `\n\nMore information is available at [the implementing change](https://github.com/microsoft/TypeScript/pull/50404)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#exports-is-prioritized-over-typesversions)\n`exports` is Prioritized Over `typesVersions`\n\nPreviously, TypeScript incorrectly prioritized the `typesVersions` field over the `exports` field when resolving through a `package.json` under `--moduleResolution node16`. If this change impacts your library, you may need to add `types@` version selectors in your `package.json`’s `exports` field.\n\ndiff\n\n  `{        \"type\": \"module\",        \"main\": \"./dist/main.js\"        \"typesVersions\": {            \"<4.8\": { \".\": [\"4.8-types/main.d.ts\"] },            \"*\": { \".\": [\"modern-types/main.d.ts\"] }        },        \"exports\": {            \".\": {  +             \"types@<4.8\": \"4.8-types/main.d.ts\",  +             \"types\": \"modern-types/main.d.ts\",                \"import\": \"./dist/main.js\"            }        }    }`\n\nFor more information, [see this pull request](https://github.com/microsoft/TypeScript/pull/50890)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#substitute-replaced-with-constraint-on-substitutiontypes)\n`substitute` Replaced With `constraint` on `SubstitutionType`s\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nAs part of an optimization on substitution types, `SubstitutionType` objects no longer contain the `substitute` property representing the effective substitution (usually an intersection of the base type and the implicit constraint) - instead, they just contain the `constraint` property.\n\nFor more details, [read more on the original pull request](https://github.com/microsoft/TypeScript/pull/50397)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.9.md)\n ❤\n\nContributors to this page:  \n\nN![navya9singh  (6)](https://gravatar.com/avatar/e896fd3c90d7bd8d3c276d3ea2dd552ae62d81d4a497cdd589f551c5eb5ccb93?s=32&&d=blank)\n\nB![Brennan  (1)](https://gravatar.com/avatar/8b8d800a527c9b6c78d9ade8d0f357b4a822008356accf3b99a12a5b51d7876a?s=32&&d=blank)\n\nM![Marius  (1)](https://gravatar.com/avatar/dd6a3226bbd78a435ace4193917985c124456a45a463d2831fcaef5f527d7398?s=32&&d=blank)\n\n제![제스  (1)](https://gravatar.com/avatar/32d718fa25a6c599a81f4ba0e3531b8a2641376c419f2a9f4057cb1c515cad25?s=32&&d=blank)\n\nN![N0N1m3  (1)](https://gravatar.com/avatar/516149fa91fcc7875dc912d70242c06daee0600edbea61254e1a04bae7551e6b?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"twitter:site":"typescriptlang","ogTitle":"Documentation - TypeScript 4.9","og:title":"Documentation - TypeScript 4.9","language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","title":"TypeScript: Documentation - TypeScript 4.9","og:description":"TypeScript 4.9 Release Notes","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"TypeScript 4.9 Release Notes","description":"TypeScript 4.9 Release Notes","scrapeId":"9dcab05e-9917-461f-9d38-aaf9c41be99e","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.5\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#speed-improvements)\nSpeed improvements\n------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.5 introduces several optimizations around type-checking and incremental builds.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#type-checking-speed-ups)\nType-checking speed-ups\n\nTypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently. These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#--incremental-improvements)\n`--incremental` improvements\n\nTypeScript 3.5 improves on 3.4’s [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc. In scenarios involving hundreds of projects using TypeScript’s project references in `--build` mode, [we’ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4](https://github.com/Microsoft/TypeScript/pull/31101)\n!\n\nFor more details, you can see the pull requests to\n\n*   [cache module resolution](https://github.com/Microsoft/TypeScript/pull/31100)\n    \n*   [cache settings calculated from `tsconfig.json`](https://github.com/Microsoft/TypeScript/pull/31101)\n    \n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type)\nThe `Omit` helper type\n------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.5 introduces the new `Omit` helper type, which creates a new type with some properties dropped from the original.\n\nts\n\n`   type Person = {    name: string;    age: number;    location: string;  };  type QuantumPerson = Omit<Person, \"location\">;  // equivalent to  type QuantumPerson = {    name: string;    age: number;  };   `\n\nHere we were able to copy over all the properties of `Person` except for `location` using the `Omit` helper.\n\nFor more details, [see the pull request on GitHub to add `Omit`](https://github.com/Microsoft/TypeScript/pull/30552)\n, as well as [the change to use `Omit` for object rest](https://github.com/microsoft/TypeScript/pull/31134)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#improved-excess-property-checks-in-union-types)\nImproved excess property checks in union types\n\nIn TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn’t have been. For instance, TypeScript 3.4 permitted the incorrect `name` property in the object literal even though its types don’t match between `Point` and `Label`.\n\nts\n\n`   type Point = {    x: number;    y: number;  };  type Label = {    name: string;  };  const thing: Point | Label = {    x: 0,    y: 0,    name: true // uh-oh!  };   `\n\nPreviously, a non-discriminated union wouldn’t have _any_ excess property checking done on its members, and as a result, the incorrectly typed `name` property slipped by.\n\nIn TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to _some_ union member and have the appropriate type, meaning that the sample above correctly issues an error.\n\nNote that partial overlap is still permitted as long as the property types are valid.\n\nts\n\n`   const pl: Point | Label = {    x: 0,    y: 0,    name: \"origin\" // okay  };   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the---allowumdglobalaccess-flag)\nThe `--allowUmdGlobalAccess` flag\n----------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 3.5, you can now reference UMD global declarations like\n\n`   export as namespace foo;   `\n\nfrom anywhere - even modules - using the new [`allowUmdGlobalAccess`](https://www.typescriptlang.org/tsconfig#allowUmdGlobalAccess)\n flag.\n\nThis mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.\n\nFor more details, [see the pull request on GitHub](https://github.com/Microsoft/TypeScript/pull/30776/files)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#smarter-union-type-checking)\nSmarter union type checking\n------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 3.4 and prior, the following example would fail:\n\nts\n\n`   type S = { done: boolean; value: number };  type T = { done: false; value: number } | { done: true; value: number };  declare let source: S;  declare let target: T;  target = source;   `\n\nThat’s because `S` isn’t assignable to `{ done: false, value: number }` nor `{ done: true, value: number }`. Why? Because the `done` property in `S` isn’t specific enough - it’s `boolean` whereas each constituent of `T` has a `done` property that’s specifically `true` or `false`. That’s what we meant by each constituent type being checked in isolation: TypeScript doesn’t just union each property together and see if `S` is assignable to that. If it did, some bad code could get through like the following:\n\nts\n\n`   interface Foo {    kind: \"foo\";    value: string;  }  interface Bar {    kind: \"bar\";    value: number;  }  function doSomething(x: Foo | Bar) {    if (x.kind === \"foo\") {      x.value.toLowerCase();    }  }  // uh-oh - luckily TypeScript errors here!  doSomething({    kind: \"foo\",    value: 123  });   `\n\nHowever, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of `S`, you can actually see that it matches the types in `T` exactly.\n\nIn TypeScript 3.5, when assigning to types with discriminant properties like in `T`, the language actually _will_ go further and decompose types like `S` into a union of every possible inhabitant type. In this case, since `boolean` is a union of `true` and `false`, `S` will be viewed as a union of `{ done: false, value: number }` and `{ done: true, value: number }`.\n\nFor more details, you can [see the original pull request on GitHub](https://github.com/microsoft/TypeScript/pull/30779)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#higher-order-type-inference-from-generic-constructors)\nHigher order type inference from generic constructors\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 3.4, we improved inference for when generic functions that return functions like so:\n\nts\n\n`   function compose<T, U, V>(f: (x: T) => U, g: (y: U) => V): (x: T) => V {    return x => g(f(x));  }   `\n\ntook other generic functions as arguments, like so:\n\nts\n\n`   function arrayify<T>(x: T): T[] {    return [x];  }  type Box<U> = { value: U };  function boxify<U>(y: U): Box<U> {    return { value: y };  }  let newFn = compose(arrayify, boxify);   `\n\nInstead of a relatively useless type like `(x: {}) => Box<{}[]>`, which older versions of the language would infer, TypeScript 3.4’s inference allows `newFn` to be generic. Its new type is `<T>(x: T) => Box<T[]>`.\n\nTypeScript 3.5 generalizes this behavior to work on constructor functions as well.\n\nts\n\n`   class Box<T> {    kind: \"box\";    value: T;    constructor(value: T) {      this.value = value;    }  }  class Bag<U> {    kind: \"bag\";    value: U;    constructor(value: U) {      this.value = value;    }  }  function composeCtor<T, U, V>(    F: new (x: T) => U,    G: new (y: U) => V  ): (x: T) => V {    return x => new G(new F(x));  }  let f = composeCtor(Box, Bag); // has type '<T>(x: T) => Bag<Box<T>>'  let a = f(1024); // has type 'Bag<Box<number>>'   `\n\nIn addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.\n\nts\n\n`   type ComponentClass<P> = new (props: P) => Component<P>;  declare class Component<P> {    props: P;    constructor(props: P);  }  declare function myHoc<P>(C: ComponentClass<P>): ComponentClass<P>;  type NestedProps<T> = { foo: number; stuff: T };  declare class GenericComponent<T> extends Component<NestedProps<T>> {}  // type is 'new <T>(props: NestedProps<T>) => Component<NestedProps<T>>'  const GenericComponent2 = myHoc(GenericComponent);   `\n\nTo learn more, [check out the original pull request on GitHub](https://github.com/microsoft/TypeScript/pull/31116)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.5.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (51)](https://gravatar.com/avatar/cd1cc3769958ccc22b86d6a87badfe31?s=32&&d=blank)\n\nOT![Orta Therox  (11)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nEI![Eugene Ilyin  (1)](https://gravatar.com/avatar/a65caef54cbaba95975117e96ca2d411668cedaea6e5bbc59287ed673c84751e?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\n1+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"TypeScript 3.5 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","generator":"Gatsby 5.13.5","language":"en","ogTitle":"Documentation - TypeScript 3.5","description":"TypeScript 3.5 Release Notes","twitter:site":"typescriptlang","og:title":"Documentation - TypeScript 3.5","og:description":"TypeScript 3.5 Release Notes","title":"TypeScript: Documentation - TypeScript 3.5","theme-color":"#3178C6","scrapeId":"f797cce2-5658-4e0b-9603-05d10fbca5d6","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.1\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)\nTemplate Literal Types\n--------------------------------------------------------------------------------------------------------------------------------\n\nString literal types in TypeScript allow us to model functions and APIs that expect a set of specific strings.\n\nts\n\n`  function setVerticalAlignment(location: \"top\" | \"middle\" | \"bottom\") {    // ...  }  setVerticalAlignment(\"middel\");  Argument of type '\"middel\"' is not assignable to parameter of type '\"top\" | \"middle\" | \"bottom\"'.2345Argument of type '\"middel\"' is not assignable to parameter of type '\"top\" | \"middle\" | \"bottom\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaIpBQGozVkCGANgIKdUDmJALaQSFABSc4HarVQAiCnAAO80AB9Q8oVQAmuzpDWb5AIzgUlQ+QEpQAbzyhQIUADoPeAL548DZqxUHDx8giJi4tp6upCctgDcQA)\n\nThis is pretty nice because string literal types can basically spell-check our string values.\n\nWe also like that string literals can be used as property names in mapped types. In this sense, they’re also usable as building blocks:\n\nts\n\n`   type Options = {    [K in \"noImplicitAny\" | \"strictNullChecks\" | \"strictFunctionTypes\"]?: boolean;  };  // same as  //   type Options = {  //       noImplicitAny?: boolean,  //       strictNullChecks?: boolean,  //       strictFunctionTypes?: boolean  //   };   `\n\nBut there’s another place that string literal types could be used as building blocks: building other string literal types.\n\nThat’s why TypeScript 4.1 brings the template literal string type. It has the same syntax as [template literal strings in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)\n, but is used in type positions. When you use it with concrete literal types, it produces a new string literal type by concatenating the contents.\n\nts\n\n``   type World = \"world\";  type Greeting = `hello ${World}`;            type Greeting = \"hello world\"   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6g9gJwDYBMoF4oCIDujVYDcAUMaJFAOIIQTACWAdgOYZQAGAFhEknFABIA3vGQoAvuxIB6aVHkA9APxA)\n\nWhat happens when you have unions in substitution positions? It produces the set of every possible string literal that could be represented by each union member.\n\nts\n\n``   type Color = \"red\" | \"blue\";  type Quantity = \"one\" | \"two\";  type SeussFish = `${Quantity | Color} fish`;  type SeussFish = \"one fish\" | \"two fish\" | \"red fish\" | \"blue fish\"   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gGzgJygXigImRAJpqAHywCMEBXCTAbgChRIoBFcgQwDtgBLUdLOdlSJZgAdzg1a9cNADKEcgGdFAMS6KAFnwAGAEgDeLDt17F4SZAF8oAM3UbtdAPROobgHoB+IA)\n\nThis can be used beyond cute examples in release notes. For example, several libraries for UI components have a way to specify both vertical and horizontal alignment in their APIs, often with both at once using a single string like `\"bottom-right\"`. Between vertically aligning with `\"top\"`, `\"middle\"`, and `\"bottom\"`, and horizontally aligning with `\"left\"`, `\"center\"`, and `\"right\"`, there are 9 possible strings where each of the former strings is connected with each of the latter strings using a dash.\n\nts\n\n``  type VerticalAlignment = \"top\" | \"middle\" | \"bottom\";  type HorizontalAlignment = \"left\" | \"center\" | \"right\";  // Takes  //   | \"top-left\"    | \"top-center\"    | \"top-right\"  //   | \"middle-left\" | \"middle-center\" | \"middle-right\"  //   | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"  declare function setAlignment(value: `${VerticalAlignment}-${HorizontalAlignment}`): void;  setAlignment(\"top-left\");   // works!  setAlignment(\"top-middel\"); // error!  Argument of type '\"top-middel\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.2345Argument of type '\"top-middel\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.  setAlignment(\"top-pot\");    // error! but good doughnuts if you're ever in Seattle  Argument of type '\"top-pot\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.2345Argument of type '\"top-pot\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAGowECWAxgIYA2AgkzQOYB2AtpFwVABeUACICcEqNAAfMTxoATRU0jS5ogEZwCEnqIDchUuQASCGgC84A5m069+gkaNUAzAurF0nML6OhOAAtPIzwQUAAVBgBrSERwsFBZMQkSAFp3T2TkjTT0nwE-HJTxSXTAjhDRRJyNBWVVTMgPfwaVSALfaDalDorgz1rcsW1dOB5m1tKxvS6inpmdOcrqvDxFSDomBmhyNwBXLjpaG1BESAJ7bj4BAAoAN2YDyFQAAwASAG8qaFpGVjsG5OAC+6W+5kC1lsgIctwIILeAEpUA84EowhcrkDHPcyhksqIkQYchEAO4IGKIACEeCx11xBDu+PS7UgTCJJIiMHg0Fp9Jx8OZ+RIOk5JW5sAQ1NAmgOgg4cDgilAijgByqXHliFANDcoCI6oA5HtQJAHjBdVxQABlSAMXSqIA)\n\nWhile there are **lots** of examples of this sort of API in the wild, this is still a bit of a toy example since we could write these out manually. In fact, for 9 strings, this is likely fine; but when you need a ton of strings, you should consider automatically generating them ahead of time to save work on every type-check (or just use `string`, which will be much simpler to comprehend).\n\nSome of the real value comes from dynamically creating new string literals. For example, imagine a `makeWatchedObject` API that takes an object and produces a mostly identical object, but with a new `on` method to detect for changes to the properties.\n\nts\n\n``   let person = makeWatchedObject({    firstName: \"Homer\",    age: 42, // give-or-take    location: \"Springfield\",  });  person.on(\"firstNameChanged\", () => {    console.log(`firstName was changed!`);  });   ``\n\nNotice that `on` listens on the event `\"firstNameChanged\"`, not just `\"firstName\"`. How would we type this?\n\nts\n\n``   type PropEventSource<T> = {      on(eventName: `${string & keyof T}Changed`, callback: () => void): void;  };  /// Create a \"watched object\" with an 'on' method  /// so that you can watch for changes to properties.  declare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;   ``\n\nWith this, we can build something that errors when we give the wrong property!\n\nts\n\n`  // error!  person.on(\"firstName\", () => {});  Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.2345Argument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.  // error!  person.on(\"frstNameChanged\", () => {});  Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.2345Argument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAArwkCiAbpAHYEDKcArtAMaQA8AKgD5QAXlABvPKGmg4jABSQGzAHIBDALaRUAAwAk4xAWgBLRgHNQAMlABrSETgAzUPwC+AYQAWai5AAmOgA0oFxqADbhAEZqXLao8gCUosJ0cCb+iahpGQDceG75-pBc4WrQ5E7sjFwEJnKgGmr2AOpqBFxeAQDyUQBWJQQCgvJw-aj8Wa7WlNT0TKwc3HxC+eGQBKBkSA1iTa3tnT39g-KS0k4mSATqWqgARAAScFrQ90FSoGrm2qBYaCEQKBzCYGABaBBggjNSCfcJwMJ1OQPFgkUwWS6QcL+d4FRL5PBAsHErjsAjEsGEsAweDQACEeG2iDkADo5PJ7pdrrdIO9QEkUhI3Pi8FTQDSEAymaz2ZzuZpIN5fD8cSEBSJhOJhbkgA)\n\nWe can also do something special in template literal types: we can _infer_ from substitution positions. We can make our last example generic to infer from parts of the `eventName` string to figure out the associated property.\n\nts\n\n``   type PropEventSource<T> = {      on<K extends string & keyof T>          (eventName: `${K}Changed`, callback: (newValue: T[K]) => void ): void;  };  declare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;  let person = makeWatchedObject({      firstName: \"Homer\",      age: 42,      location: \"Springfield\",  });  // works! 'newName' is typed as 'string'  person.on(\"firstNameChanged\", newName => {      // 'newName' has the type of 'firstName'      console.log(`new name is ${newName.toUpperCase()}`);  });  // works! 'newAge' is typed as 'number'  person.on(\"ageChanged\", newAge => {      if (newAge < 0) {          console.log(\"warning! negative age\");      }  })   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACoB8UAvFAN4BQUzUCGJA0lBAB7CYATAM5QhwOAEsMAcygAyKAGsIIBADMolJix0AKCOiwA5AIYBbCAC4oAAwAkdDgF8AwgAsTMiAJsAaKIQmADZBAEYmhIrWuhgQAO4AasF4VpoA2hwAugCUNFSoCBICUNnWBUUA3AxOVQwCEIRBJnDQangYhMASbFBmJsoA6ibAhG7eAPKhAFYNwOQUugjT1mSlmvKwiCiGOPhEpJS1QRDAUJBwQj20fYPDoxPTs7qMOmoSF8CmFtYARAASCAscB+vm0zBM0lSABYAEygnRBBCBLpsX7YMCSGRvCBBAQg6rZWoAeiJUDiCDgiiEAEIoAByWJxL4QOlQCQiUCQYomER0sSY6R0hjnS4YAB0bF0PzeH2Z7k8kLx-kZzLy9DBUBJ9JV5hZUA8HLGUE50HU9JlYmZQp0hDYl2OYsR0l0NkZUAwurZIgcOosYuACAAqmBzi4eRBdNknDZCQTiaTyZSadr4gBBSGs9nG8DeKA87V4MyhCBwIUitgSjBSiEQeVeJXutOQtUvFgSDQxJvQEhQAAMuVbOmYtow9ogjoQzp+cWaGCk0lpsWkwwk6DzkJ+sZ0TgJQA)\n\nHere we made `on` into a generic method. When a user calls with the string `\"firstNameChanged'`, TypeScript will try to infer the right type for `K`. To do that, it will match `K` against the content prior to `\"Changed\"` and infer the string `\"firstName\"`. Once TypeScript figures that out, the `on` method can fetch the type of `firstName` on the original object, which is `string` in this case. Similarly, when we call with `\"ageChanged\"`, it finds the type for the property `age` which is `number`).\n\nInference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways. In fact, to help with modifying these string literal types, we’ve added a few new utility type aliases for modifying casing in letters (i.e. converting to lowercase and uppercase characters).\n\nts\n\n``   type EnthusiasticGreeting<T extends string> = `${Uppercase<T>}`  type HELLO = EnthusiasticGreeting<\"hello\">;          type HELLO = \"HELLO\"   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogdsAFgVwM4EsCGrjoMYDiAThBLnAOYA8AKlBAB7ARwAmqUOR6lAfFAF4oAAwAkAbwCqYSETzYItXgF9hAKDWhIUABIwAMvoDyg2AhQZsuQiTI9qAIkQQANi4D2D3gG41Aej8oIIA9AH4gA)\n\nThe new type aliases are `Uppercase`, `Lowercase`, `Capitalize` and `Uncapitalize`. The first two transform every character in a string, and the latter two transform only the first character in a string.\n\nFor more details, [see the original pull request](https://github.com/microsoft/TypeScript/pull/40336)\n and [the in-progress pull request to switch to type alias helpers](https://github.com/microsoft/TypeScript/pull/40580)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types)\nKey Remapping in Mapped Types\n----------------------------------------------------------------------------------------------------------------------------------------------\n\nJust as a refresher, a mapped type can create new object types based on arbitrary keys\n\nts\n\n`   type Options = {    [K in \"noImplicitAny\" | \"strictNullChecks\" | \"strictFunctionTypes\"]?: boolean;  };  // same as  //   type Options = {  //       noImplicitAny?: boolean,  //       strictNullChecks?: boolean,  //       strictFunctionTypes?: boolean  //   };   `\n\nor new object types based on other object types.\n\nts\n\n`   /// 'Partial<T>' is the same as 'T', but with each property marked optional.  type Partial<T> = {    [K in keyof T]?: T[K];  };   `\n\nUntil now, mapped types could only produce new object types with keys that you provided them; however, lots of the time you want to be able to create new keys, or filter out keys, based on the inputs.\n\nThat’s why TypeScript 4.1 allows you to re-map keys in mapped types with a new `as` clause.\n\nts\n\n`   type MappedTypeWithNewKeys<T> = {      [K in keyof T as NewKeyType]: T[K]      //            ^^^^^^^^^^^^^      //            This is the new syntax!  }   `\n\nWith this new `as` clause, you can leverage features like template literal types to easily create property names based off of old ones.\n\nts\n\n``   type Getters<T> = {      [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]  };  interface Person {      name: string;      age: number;      location: string;  }  type LazyPerson = Getters<Person>;             type LazyPerson = {     getName: () => string;     getAge: () => number;     getLocation: () => string; }   ``[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hzAgJwM4B4AqA+KBeKA3gFBSlQDaA0lAJYB2UA1hCAPYBmUGUAhilAAMA5vAAkBAMI8wNYDwA2NAF4Q0KYEnpCoAMiiUsAXwEBdAFxQAFAEo8ODFRNFDAbiJF6iJOx4BjaAAKyCisDMRkUHQ8ALYQFuqadEJuETwiFnQArtEARsgpZPKsvjzANKHxGlpuhu6gkFAAMjxKIEGooXiw8F7o7SF0WG4A9MNkAHoA-EA)\n\nand you can even filter out keys by producing `never`. That means you don’t have to use an extra `Omit` helper type in some cases.\n\nts\n\n`   // Remove the 'kind' property  type RemoveKindField<T> = {      [K in keyof T as Exclude<K, \"kind\">]: T[K]  };  interface Circle {      kind: \"circle\";      radius: number;  }  type KindlessCircle = RemoveKindField<Circle>;               type KindlessCircle = {     radius: number; }   `[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdKgC4AskHIDWBLAdgCYagAOATrCZGcgJ4BQdVEMCkA0vgQGI6QA2BADwAVAHygAvKADe9UAtABtdqHygskWrABmoEaACGAZ1ABRAB4BjfgFcCkIewA0oAES5CbsQF0AXPoqPvQAvgDc9PT4yNQ6hlZIAMI4ZDZIcooaXAFuVilpbhGZZIYEOLbGAXi20ABG1BEhkUxInIT8kMbGyakdUixwiG08fIJCPWliESCKAHoA-EA)\n\nFor more information, take a look at [the original pull request over on GitHub](https://github.com/microsoft/TypeScript/pull/40336)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)\nRecursive Conditional Types\n------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript it’s fairly common to see functions that can flatten and build up container types at arbitrary levels. For example, consider the `.then()` method on instances of `Promise`. `.then(...)` unwraps each promise until it finds a value that’s not “promise-like”, and passes that value to a callback. There’s also a relatively new `flat` method on `Array`s that can take a depth of how deep to flatten.\n\nExpressing this in TypeScript’s type system was, for all practical intents and purposes, not possible. While there were hacks to achieve this, the types ended up looking very unreasonable.\n\nThat’s why TypeScript 4.1 eases some restrictions on conditional types - so that they can model these patterns. In TypeScript 4.1, conditional types can now immediately reference themselves within their branches, making it easier to write recursive type aliases.\n\nFor example, if we wanted to write a type to get the element types of nested arrays, we could write the following `deepFlatten` type.\n\nts\n\n`   type ElementType<T> = T extends ReadonlyArray<infer U> ? ElementType<U> : T;  function deepFlatten<T extends readonly unknown[]>(x: T): ElementType<T>[] {    throw \"not implemented\";  }  // All of these return the type 'number[]':  deepFlatten([1, 2, 3]);  deepFlatten([[1], [2, 3]]);  deepFlatten([[1], [[2]], [[[3]]]]);   `\n\nSimilarly, in TypeScript 4.1 we can write an `Awaited` type to deeply unwrap `Promise`s.\n\nts\n\n``   type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;  /// Like `promise.then(...)`, but more accurate in types.  declare function customThen<T, U>(    p: Promise<T>,    onFulfilled: (value: Awaited<T>) => U  ): Promise<Awaited<U>>;   ``\n\nKeep in mind that while these recursive types are powerful, they should be used responsibly and sparingly.\n\nFirst off, these types can do a lot of work which means that they can increase type-checking time. Trying to model numbers in the Collatz conjecture or Fibonacci sequence might be fun, but don’t ship that in `.d.ts` files on npm.\n\nBut apart from being computationally intensive, these types can hit an internal recursion depth limit on sufficiently-complex inputs. When that recursion limit is hit, that results in a compile-time error. In general, it’s better not to use these types at all than to write something that fails on more realistic examples.\n\nSee more [at the implementation](https://github.com/microsoft/TypeScript/pull/40002)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#checked-indexed-accesses---nouncheckedindexedaccess)\nChecked Indexed Accesses (`--noUncheckedIndexedAccess`)\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript has a feature called _index signatures_. These signatures are a way to signal to the type system that users can access arbitrarily-named properties.\n\nts\n\n`   interface Options {    path: string;    permissions: number;    // Extra properties are caught by this index signature.    [propName: string]: string | number;  }  function checkOptions(opts: Options) {    opts.path; // string    opts.permissions; // number    // These are all allowed too!    // They have the type 'string | number'.    opts.yadda.toString();    opts[\"foo bar baz\"].toString();    opts[Math.random()].toString();  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM7IDeAUMsunGABYBcyeYUoA5gNynnQC2weeO+OiACuXAEbR2HAPTTkAUQAejOOSjZ00LBAJwoKBHGHMqYZGICeyar2SgAJhEX1gzEJWH6AdBwDa6dXQAOTguCDoGJhBmAF0IxhZkAB9kEXFJYgBfYmIYYRAELFxkBCoIBABrDCL8AAoNMDw6aoE8AEoiDga8LwpqVmRZegTorswezSgePlaBobSJKByyIYAVMrwUPS2AGx3kOD3sAHcIe2tsbABCGTl1iCsqOAA3FGo3i01kAHJIxJSFtBvj4yN0vBY4PZ7HAvGBsABlEbMWptdig8a+ABEMEu5j0eIAXpiYrCEUiUWjkN1fABZShULxQOAgezYLgoklwxFRZGorJAA)\n\nIn the above example, `Options` has an index signature that says any accessed property that’s not already listed should have the type `string | number`. This is often convenient for optimistic code that assumes you know what you’re doing, but the truth is that most values in JavaScript do not support every potential property name. Most types will not, for example, have a value for a property key created by `Math.random()` like in the previous example. For many users, this behavior was undesirable, and felt like it wasn’t leveraging the full strict-checking of [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n.\n\nThat’s why TypeScript 4.1 ships with a new flag called [`noUncheckedIndexedAccess`](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess)\n. Under this new mode, every property access (like `foo.bar`) or indexed access (like `foo[\"bar\"]`) is considered potentially undefined. That means that in our last example, `opts.yadda` will have the type `string | number | undefined` as opposed to just `string | number`. If you need to access that property, you’ll either have to check for its existence first or use a non-null assertion operator (the postfix `!` character).\n\nts\n\n`   function checkOptions(opts: Options) {    opts.path; // string    opts.permissions; // number    // These are not allowed with noUncheckedIndexedAccess    opts.yadda.toString();  'opts.yadda' is possibly 'undefined'.18048'opts.yadda' is possibly 'undefined'.    opts[\"foo bar baz\"].toString();  Object is possibly 'undefined'.2532Object is possibly 'undefined'.    opts[Math.random()].toString();  Object is possibly 'undefined'.2532Object is possibly 'undefined'.    // Checking if it's really there first.    if (opts.yadda) {      console.log(opts.yadda.toString());    }    // Basically saying \"trust me I know what I'm doing\"    // with the '!' non-null assertion operator.    opts.yadda!.toString();  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoECAOzgFVqBjAC0kYGtIATASWq8gAPbgEFGjSIkTkAltQAuMAGYBDCaADyAB3ky41RKADe5UKC0r5zVInnQ5AcwDcp8zAC2MqXoOpqAV3cAIxgXVyoAUUE7FXN4LRhdSVAVaEhQRhV-B2Z5UCCAT1ArL1A5AUFQRBkHakt-NIA6VwBtLXiAORV3SBs7RwBdPvtqB1AAH1AA4NDyAF9KMABaFcZ-eRWl8iV-Jl19DNYObX2DAAo4HRRNHR9EAEpjV0v5REaLKydQKlsRh2eru8PF5qvpEF8qNMQtByOEwAAVViIdKpdK0PIqAA2mLgAHduKBcTIrFN6EwjpxePwhKJxJJpGYXm8CiouFwVI15HAAMr9UZne4uRlXFoAIiUcDg+VS0oAXqKBpyeXyHAKhaAmS0ALKWZiNaAqfhwdwCxVc3l-NWwsxUADCFMcZSUZXkAHJDGksZiilYYOklDIkPJmmYZM6LoCWWyVI8TGYzIwwXBMZBGjjVUzGlH2UqLY4BYLXAs4aAAEIqaqZbFFRAqAqO0V2fy2UA9UA8UDsWi4wnMSzt13uUBcOCOUUlokk32gV0AQldpOoSwC2JSUkSPg1CQNXOgIa3ryzrPZs9zKqtcyAA)\n\nOne consequence of using [`noUncheckedIndexedAccess`](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess)\n is that indexing into an array is also more strictly checked, even in a bounds-checked loop.\n\nts\n\n`   function screamLines(strs: string[]) {    // This will have issues    for (let i = 0; i < strs.length; i++) {      console.log(strs[i].toUpperCase());  Object is possibly 'undefined'.2532Object is possibly 'undefined'.    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoECAOzgFVqBjAC0kYGtIATASWq8gAPbgEFGjSIkTkAZgFcmAFwCWcaqESNokAIYBbADLLqkgBSJFSVBejGA5gG0AugEpQAb3KhQVACrNlRFAAd2UAGzDQZh0AN0hQQMQ5SS9QGQRQUzDIRQTQAF5QIgBuPIAeDUtEADps6jtFZlLlAGoWt09vb0Y1RDhs2rg7cyqHZSdqxXoAB2mYAGEdREhTFxdi1IBfck2gA)\n\nIf you don’t need the indexes, you can iterate over individual elements by using a `for`\\-`of` loop or a `forEach` call.\n\nts\n\n`   function screamLines(strs: string[]) {    // This works fine    for (const str of strs) {      console.log(str.toUpperCase());    }    // This works fine    strs.forEach((str) => {      console.log(str.toUpperCase());    });  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIMYAsCmCDWKAmBJSWUAPbAQQQRQGdKAoAMwFdEAXAS2klEoQCcUBDALYAZVpCoAKSsx6UAXFxliA5gG0AugEpQAbxqhQIUABUkrSqADu0Hugt0xKfaDo3QEhB2mKeoaHR9KbT0DA09ISmgAGxQAOijoZSkZWOY4AAd0lB4AYX5KFAlNTQBuZwBfGmcjU3MrGzsXR2dpWVjXHgBRfmQJZJ5tAF4APl1nMK9ouISk1tSMrNz8wuKyg3LSmnKgA)\n\nThis flag can be handy for catching out-of-bounds errors, but it might be noisy for a lot of code, so it is not automatically enabled by the [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n flag; however, if this feature is interesting to you, you should feel free to try it and determine whether it makes sense for your team’s codebase!\n\nYou can learn more [at the implementing pull request](https://github.com/microsoft/TypeScript/pull/39560)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#paths-without-baseurl)\n`paths` without `baseUrl`\n----------------------------------------------------------------------------------------------------------------------------------\n\nUsing path-mapping is fairly common - often it’s to have nicer imports, often it’s to simulate monorepo linking behavior.\n\nUnfortunately, specifying [`paths`](https://www.typescriptlang.org/tsconfig#paths)\n to enable path-mapping required also specifying an option called [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl)\n, which allows bare specifier paths to be reached relative to the [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl)\n too. This also often caused poor paths to be used by auto-imports.\n\nIn TypeScript 4.1, the [`paths`](https://www.typescriptlang.org/tsconfig#paths)\n option can be used without [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl)\n. This helps avoid some of these issues.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#checkjs-implies-allowjs)\n`checkJs` Implies `allowJs`\n--------------------------------------------------------------------------------------------------------------------------------------\n\nPreviously if you were starting a checked JavaScript project, you had to set both [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)\n and [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs)\n. This was a slightly annoying bit of friction in the experience, so [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs)\n now implies [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)\n by default.\n\n[See more details at the pull request](https://github.com/microsoft/TypeScript/pull/40275)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#react-17-jsx-factories)\nReact 17 JSX Factories\n--------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.1 supports React 17’s upcoming `jsx` and `jsxs` factory functions through two new options for the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)\n compiler option:\n\n*   `react-jsx`\n*   `react-jsxdev`\n\nThese options are intended for production and development compiles respectively. Often, the options from one can extend from the other. For example, a `tsconfig.json` for production builds might look like the following:\n\n`   // ./src/tsconfig.json  {    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[module](https://www.typescriptlang.org/tsconfig#module) \": \"esnext\",      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"es2015\",      \"[jsx](https://www.typescriptlang.org/tsconfig#jsx) \": \"react-jsx\",      \"[strict](https://www.typescriptlang.org/tsconfig#strict) \": true    },    \"[include](https://www.typescriptlang.org/tsconfig#include) \": [\"./**/*\"]  }   `\n\nand one for development builds might look like the following:\n\n`   // ./src/tsconfig.dev.json  {    \"[extends](https://www.typescriptlang.org/tsconfig#extends) \": \"./tsconfig.json\",    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[jsx](https://www.typescriptlang.org/tsconfig#jsx) \": \"react-jsxdev\"    }  }   `\n\nFor more information, [check out the corresponding PR](https://github.com/microsoft/TypeScript/pull/39199)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#editor-support-for-the-jsdoc-see-tag)\nEditor Support for the JSDoc `@see` Tag\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThe JSDoc tag `@see` tag now has better support in editors for TypeScript and JavaScript. This allows you to use functionality like go-to-definition in a dotted name following the tag. For example, going to definition on `first` or `C` in the JSDoc comment just works in the following example:\n\nts\n\n`   // @filename: first.ts  export class C {}  // @filename: main.ts  import * as first from \"./first\";  /**   * @see first.C   */  function related() {}   `\n\nThanks to frequent contributor [Wenlu Wang](https://github.com/Kingwl)\n [for implementing this](https://github.com/microsoft/TypeScript/pull/39760)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#libdts-changes)\n`lib.d.ts` Changes\n\n`lib.d.ts` may have a set of changed APIs, potentially in part due to how the DOM types are automatically generated. One specific change is that `Reflect.enumerate` has been removed, as it was removed from ES2016.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#abstract-members-cant-be-marked-async)\n`abstract` Members Can’t Be Marked `async`\n\nMembers marked as `abstract` can no longer be marked as `async`. The fix here is to remove the `async` keyword, since callers are only concerned with the return type.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#anyunknown-are-propagated-in-falsy-positions)\n`any`/`unknown` Are Propagated in Falsy Positions\n\nPreviously, for an expression like `foo && somethingElse`, the type of `foo` was `any` or `unknown`, the type of the whole that expression would be the type of `somethingElse`.\n\nFor example, previously the type for `x` here was `{ someProp: string }`.\n\nts\n\n`   declare let foo: unknown;  declare let somethingElse: { someProp: string };  let x = foo && somethingElse;   `\n\nHowever, in TypeScript 4.1, we are more careful about how we determine this type. Since nothing is known about the type on the left side of the `&&`, we propagate `any` and `unknown` outward instead of the type on the right side.\n\nThe most common pattern we saw of this tended to be when checking compatibility with `boolean`s, especially in predicate functions.\n\nts\n\n`   function isThing(x: any): boolean {    return x && typeof x === \"object\" && x.blah === \"foo\";  }   `\n\nOften the appropriate fix is to switch from `foo && someExpression` to `!!foo && someExpression`.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#resolves-parameters-are-no-longer-optional-in-promises)\n`resolve`’s Parameters Are No Longer Optional in `Promise`s\n\nWhen writing code like the following\n\nts\n\n`   new Promise((resolve) => {    doSomethingAsync(() => {      doSomething();      resolve();    });  });   `\n\nYou may get an error like the following:\n\n  `resolve()    ~~~~~~~~~  error TS2554: Expected 1 arguments, but got 0.    An argument for 'value' was not provided.`\n\nThis is because `resolve` no longer has an optional parameter, so by default, it must now be passed a value. Often this catches legitimate bugs with using `Promise`s. The typical fix is to pass it the correct argument, and sometimes to add an explicit type argument.\n\nts\n\n`   new Promise<number>((resolve) => {    //     ^^^^^^^^    doSomethingAsync((value) => {      doSomething();      resolve(value);      //      ^^^^^    });  });   `\n\nHowever, sometimes `resolve()` really does need to be called without an argument. In these cases, we can give `Promise` an explicit `void` generic type argument (i.e. write it out as `Promise<void>`). This leverages new functionality in TypeScript 4.1 where a potentially-`void` trailing parameter can become optional.\n\nts\n\n`   new Promise<void>((resolve) => {    //     ^^^^^^    doSomethingAsync(() => {      doSomething();      resolve();    });  });   `\n\nTypeScript 4.1 ships with a quick fix to help fix this break.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#conditional-spreads-create-optional-properties)\nConditional Spreads Create Optional Properties\n\nIn JavaScript, object spreads (like `{ ...foo }`) don’t operate over falsy values. So in code like `{ ...foo }`, `foo` will be skipped over if it’s `null` or `undefined`.\n\nMany users take advantage of this to spread properties “conditionally”.\n\nts\n\n`   interface Person {    name: string;    age: number;    location: string;  }  interface Animal {    name: string;    owner: Person;  }  function copyOwner(pet?: Animal) {    return {      ...(pet && pet.owner),      otherStuff: 123,    };  }  // We could also use optional chaining here:  function copyOwner(pet?: Animal) {    return {      ...pet?.owner,      otherStuff: 123,    };  }   `\n\nHere, if `pet` is defined, the properties of `pet.owner` will be spread in - otherwise, no properties will be spread into the returned object.\n\nThe return type of `copyOwner` was previously a union type based on each spread:\n\n`   { x: number } | { x: number, name: string, age: number, location: string }   `\n\nThis modeled exactly how the operation would occur: if `pet` was defined, all the properties from `Person` would be present; otherwise, none of them would be defined on the result. It was an all-or-nothing operation.\n\nHowever, we’ve seen this pattern taken to the extreme, with hundreds of spreads in a single object, each spread potentially adding in hundreds or thousands of properties. It turns out that for various reasons, this ends up being extremely expensive, and usually for not much benefit.\n\nIn TypeScript 4.1, the returned type sometimes uses all-optional properties.\n\n`   {      x: number;      name?: string;      age?: number;      location?: string;  }   `\n\nThis ends up performing better and generally displaying better too.\n\nFor more details, [see the original change](https://github.com/microsoft/TypeScript/pull/40778)\n. While this behavior is not entirely consistent right now, we expect a future release will produce cleaner and more predictable results.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#unmatched-parameters-are-no-longer-related)\nUnmatched parameters are no longer related\n\nTypeScript would previously relate parameters that didn’t correspond to each other by relating them to the type `any`. With [changes in TypeScript 4.1](https://github.com/microsoft/TypeScript/pull/41308)\n, the language now skips this process entirely. This means that some cases of assignability will now fail, but it also means that some cases of overload resolution can fail as well. For example, overload resolution on `util.promisify` in Node.js may select a different overload in TypeScript 4.1, sometimes causing new or different errors downstream.\n\nAs a workaround, you may be best using a type assertion to squelch errors.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.1.md)\n ❤\n\nContributors to this page:  \n\nEI![Eugene Ilyin  (1)](https://gravatar.com/avatar/a65caef54cbaba95975117e96ca2d411668cedaea6e5bbc59287ed673c84751e?s=32&&d=blank)\n\nAB![Andrew Branch  (1)](https://gravatar.com/avatar/86ed396e4ffb41b052654b9f8ad4d1caaf732bc42985860b0cac8191a66e33df?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nH![HumanEquivalentUnit  (1)](https://gravatar.com/avatar/9983b66c13f37c6b49f24701f3cda81ef09b6c09592bd7f8ab4e283e3c602812?s=32&&d=blank)\n\nOT![Orta Therox  (1)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:title":"Documentation - TypeScript 4.1","og:description":"TypeScript 4.1 Release Notes","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","title":"TypeScript: Documentation - TypeScript 4.1","language":"en","ogTitle":"Documentation - TypeScript 4.1","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogDescription":"TypeScript 4.1 Release Notes","description":"TypeScript 4.1 Release Notes","scrapeId":"238a61f3-207e-4640-a1c6-5aa00df32466","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.8\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export)\nType-Only Imports and Export\n--------------------------------------------------------------------------------------------------------------------------------------------\n\nThis feature is something most users may never have to think about; however, if you’ve hit issues under [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules)\n, TypeScript’s `transpileModule` API, or Babel, this feature might be relevant.\n\nTypeScript 3.8 adds a new syntax for type-only imports and exports.\n\nts\n\n`   import type { SomeThing } from \"./some-module.js\";  export type { SomeThing };   `\n\n`import type` only imports declarations to be used for type annotations and declarations. It _always_ gets fully erased, so there’s no remnant of it at runtime. Similarly, `export type` only provides an export that can be used for type contexts, and is also erased from TypeScript’s output.\n\nIt’s important to note that classes have a value at runtime and a type at design-time, and the use is context-sensitive. When using `import type` to import a class, you can’t do things like extend from it.\n\nts\n\n`   import type { Component } from \"react\";  interface ButtonProps {    // ...  }  class Button extends Component<ButtonProps> {    //               ~~~~~~~~~    // error! 'Component' only refers to a type, but is being used as a value here.    // ...  }   `\n\nIf you’ve used Flow before, the syntax is fairly similar. One difference is that we’ve added a few restrictions to avoid code that might appear ambiguous.\n\nts\n\n`   // Is only 'Foo' a type? Or every declaration in the import?  // We just give an error because it's not clear.  import type Foo, { Bar, Baz } from \"some-module\";  //     ~~~~~~~~~~~~~~~~~~~~~~  // error! A type-only import can specify a default import or named bindings, but not both.   `\n\nIn conjunction with `import type`, TypeScript 3.8 also adds a new compiler flag to control what happens with imports that won’t be utilized at runtime: [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)\n. This flag takes 3 different values:\n\n*   `remove`: this is today’s behavior of dropping these imports. It’s going to continue to be the default, and is a non-breaking change.\n*   `preserve`: this _preserves_ all imports whose values are never used. This can cause imports/side-effects to be preserved.\n*   `error`: this preserves all imports (the same as the `preserve` option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.\n\nFor more information about the feature, you can [take a look at the pull request](https://github.com/microsoft/TypeScript/pull/35200)\n, and [relevant changes](https://github.com/microsoft/TypeScript/pull/36092/)\n around broadening where imports from an `import type` declaration can be used.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#ecmascript-private-fields)\nECMAScript Private Fields\n--------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.8 brings support for ECMAScript’s private fields, part of the [stage-3 class fields proposal](https://github.com/tc39/proposal-class-fields/)\n.\n\nts\n\n``   class Person {    #name: string;    constructor(name: string) {      this.#name = name;    }    greet() {      console.log(`Hello, my name is ${this.#name}!`);    }  }  let jeremy = new Person(\"Jeremy Bearimy\");  jeremy.#name;  //     ~~~~~  // Property '#name' is not accessible outside class 'Person'  // because it has a private identifier.   ``\n\nUnlike regular properties (even ones declared with the `private` modifier), private fields have a few rules to keep in mind. Some of them are:\n\n*   Private fields start with a `#` character. Sometimes we call these _private names_.\n*   Every private field name is uniquely scoped to its containing class.\n*   TypeScript accessibility modifiers like `public` or `private` can’t be used on private fields.\n*   Private fields can’t be accessed or even detected outside of the containing class - even by JS users! Sometimes we call this _hard privacy_.\n\nApart from “hard” privacy, another benefit of private fields is that uniqueness we just mentioned. For example, regular property declarations are prone to being overwritten in subclasses.\n\nts\n\n`   class C {    foo = 10;    cHelper() {      return this.foo;    }  }  class D extends C {    foo = 20;    dHelper() {      return this.foo;    }  }  let instance = new D();  // 'this.foo' refers to the same property on each instance.  console.log(instance.cHelper()); // prints '20'  console.log(instance.dHelper()); // prints '20'   `\n\nWith private fields, you’ll never have to worry about this, since each field name is unique to the containing class.\n\nts\n\n`   class C {    #foo = 10;    cHelper() {      return this.#foo;    }  }  class D extends C {    #foo = 20;    dHelper() {      return this.#foo;    }  }  let instance = new D();  // 'this.#foo' refers to a different field within each class.  console.log(instance.cHelper()); // prints '10'  console.log(instance.dHelper()); // prints '20'   `\n\nAnother thing worth noting is that accessing a private field on any other type will result in a `TypeError`!\n\nts\n\n`   class Square {    #sideLength: number;    constructor(sideLength: number) {      this.#sideLength = sideLength;    }    equals(other: any) {      return this.#sideLength === other.#sideLength;    }  }  const a = new Square(100);  const b = { sideLength: 100 };  // Boom!  // TypeError: attempted to get private field on non-instance  // This fails because 'b' is not an instance of 'Square'.  console.log(a.equals(b));   `\n\nFinally, for any plain `.js` file users, private fields _always_ have to be declared before they’re assigned to.\n\njs\n\n`   class C {    // No declaration for '#foo'    // :(    constructor(foo: number) {      // SyntaxError!      // '#foo' needs to be declared before writing to it.      this.#foo = foo;    }  }   `\n\nJavaScript has always allowed users to access undeclared properties, whereas TypeScript has always required declarations for class properties. With private fields, declarations are always needed regardless of whether we’re working in `.js` or `.ts` files.\n\njs\n\n`   class C {    /** @type {number} */    #foo;    constructor(foo: number) {      // This works.      this.#foo = foo;    }  }   `\n\nFor more information about the implementation, you can [check out the original pull request](https://github.com/Microsoft/TypeScript/pull/30829)\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#which-should-i-use)\nWhich should I use?\n\nWe’ve already received many questions on which type of privates you should use as a TypeScript user: most commonly, “should I use the `private` keyword, or ECMAScript’s hash/pound (`#`) private fields?” It depends!\n\nWhen it comes to properties, TypeScript’s `private` modifiers are fully erased - that means that at runtime, it acts entirely like a normal property and there’s no way to tell that it was declared with a `private` modifier. When using the `private` keyword, privacy is only enforced at compile-time/design-time, and for JavaScript consumers it’s entirely intent-based.\n\nts\n\n`   class C {    private foo = 10;  }  // This is an error at compile time,  // but when TypeScript outputs .js files,  // it'll run fine and print '10'.  console.log(new C().foo); // prints '10'  //                  ~~~  // error! Property 'foo' is private and only accessible within class 'C'.  // TypeScript allows this at compile-time  // as a \"work-around\" to avoid the error.  console.log(new C()[\"foo\"]); // prints '10'   `\n\nThe upside is that this sort of “soft privacy” can help your consumers temporarily work around not having access to some API, and also works in any runtime.\n\nOn the other hand, ECMAScript’s `#` privates are completely inaccessible outside of the class.\n\nts\n\n`   class C {    #foo = 10;  }  console.log(new C().#foo); // SyntaxError  //                  ~~~~  // TypeScript reports an error *and*  // this won't work at runtime!  console.log(new C()[\"#foo\"]); // prints undefined  //          ~~~~~~~~~~~~~~~  // TypeScript reports an error under 'noImplicitAny',  // and this prints 'undefined'.   `\n\nThis hard privacy is really useful for strictly ensuring that nobody can take use of any of your internals. If you’re a library author, removing or renaming a private field should never cause a breaking change.\n\nAs we mentioned, another benefit is that subclassing can be easier with ECMAScript’s `#` privates because they _really_ are private. When using ECMAScript `#` private fields, no subclass ever has to worry about collisions in field naming. When it comes to TypeScript’s `private` property declarations, users still have to be careful not to trample over properties declared in superclasses.\n\nOne more thing to think about is where you intend for your code to run. TypeScript currently can’t support this feature unless targeting ECMAScript 2015 (ES6) targets or higher. This is because our downleveled implementation uses `WeakMap`s to enforce privacy, and `WeakMap`s can’t be polyfilled in a way that doesn’t cause memory leaks. In contrast, TypeScript’s `private`\\-declared properties work with all targets - even ECMAScript 3!\n\nA final consideration might be speed: `private` properties are no different from any other property, so accessing them is as fast as any other property access no matter which runtime you target. In contrast, because `#` private fields are downleveled using `WeakMap`s, they may be slower to use. While some runtimes might optimize their actual implementations of `#` private fields, and even have speedy `WeakMap` implementations, that might not be the case in all runtimes.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#export--as-ns-syntax)\n`export * as ns` Syntax\n-------------------------------------------------------------------------------------------------------------------------------\n\nIt’s often common to have a single entry-point that exposes all the members of another module as a single member.\n\nts\n\n`   import * as utilities from \"./utilities.js\";  export { utilities };   `\n\nThis is so common that ECMAScript 2020 recently added a new syntax to support this pattern!\n\nts\n\n`   export * as utilities from \"./utilities.js\";   `\n\nThis is a nice quality-of-life improvement to JavaScript, and TypeScript 3.8 implements this syntax. When your module target is earlier than `es2020`, TypeScript will output something along the lines of the first code snippet.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#top-level-await)\nTop-Level `await`\n--------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.8 provides support for a handy upcoming ECMAScript feature called “top-level `await`“.\n\nJavaScript users often introduce an `async` function in order to use `await`, and then immediately called the function after defining it.\n\njs\n\n`   async function main() {    const response = await fetch(\"...\");    const greeting = await response.text();    console.log(greeting);  }  main().catch((e) => console.error(e));   `\n\nThis is because previously in JavaScript (along with most other languages with a similar feature), `await` was only allowed within the body of an `async` function. However, with top-level `await`, we can use `await` at the top level of a module.\n\nts\n\n`   const response = await fetch(\"...\");  const greeting = await response.text();  console.log(greeting);  // Make sure we're a module  export {};   `\n\nNote there’s a subtlety: top-level `await` only works at the top level of a _module_, and files are only considered modules when TypeScript finds an `import` or an `export`. In some basic cases, you might need to write out `export {}` as some boilerplate to make sure of this.\n\nTop level `await` may not work in all environments where you might expect at this point. Currently, you can only use top level `await` when the [`target`](https://www.typescriptlang.org/tsconfig#target)\n compiler option is `es2017` or above, and `module` is `esnext` or `system`. Support within several environments and bundlers may be limited or may require enabling experimental support.\n\nFor more information on our implementation, you can [check out the original pull request](https://github.com/microsoft/TypeScript/pull/35813)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#es2020-for-target-and-module)\n`es2020` for `target` and `module`\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.8 supports `es2020` as an option for `module` and [`target`](https://www.typescriptlang.org/tsconfig#target)\n. This will preserve newer ECMAScript 2020 features like optional chaining, nullish coalescing, `export * as ns`, and dynamic `import(...)` syntax. It also means `bigint` literals now have a stable [`target`](https://www.typescriptlang.org/tsconfig#target)\n below `esnext`.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#jsdoc-property-modifiers)\nJSDoc Property Modifiers\n------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.8 supports JavaScript files by turning on the [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)\n flag, and also supports _type-checking_ those JavaScript files via the [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs)\n option or by adding a `// @ts-check` comment to the top of your `.js` files.\n\nBecause JavaScript files don’t have dedicated syntax for type-checking, TypeScript leverages JSDoc. TypeScript 3.8 understands a few new JSDoc tags for properties.\n\nFirst are the accessibility modifiers: `@public`, `@private`, and `@protected`. These tags work exactly like `public`, `private`, and `protected` respectively work in TypeScript.\n\njs\n\n`   // @ts-check  class Foo {    constructor() {      /** @private */      this.stuff = 100;    }    printStuff() {      console.log(this.stuff);    }  }  new Foo().stuff;  //        ~~~~~  // error! Property 'stuff' is private and only accessible within class 'Foo'.   `\n\n*   `@public` is always implied and can be left off, but means that a property can be reached from anywhere.\n*   `@private` means that a property can only be used within the containing class.\n*   `@protected` means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.\n\nNext, we’ve also added the `@readonly` modifier to ensure that a property is only ever written to during initialization.\n\njs\n\n`   // @ts-check  class Foo {    constructor() {      /** @readonly */      this.stuff = 100;    }    writeToStuff() {      this.stuff = 200;      //   ~~~~~      // Cannot assign to 'stuff' because it is a read-only property.    }  }  new Foo().stuff++;  //        ~~~~~  // Cannot assign to 'stuff' because it is a read-only property.   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions)\nBetter Directory Watching on Linux and `watchOptions`\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.8 ships a new strategy for watching directories, which is crucial for efficiently picking up changes to `node_modules`.\n\nFor some context, on operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on `node_modules` and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the number of files in `node_modules`, whereas there are way fewer directories to track.\n\nOlder versions of TypeScript would _immediately_ install directory watchers on folders, and at startup that would be fine; however, during an npm install, a lot of activity will take place within `node_modules` and that can overwhelm TypeScript, often slowing editor sessions to a crawl. To prevent this, TypeScript 3.8 waits slightly before installing directory watchers to give these highly volatile directories some time to stabilize.\n\nBecause every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new `watchOptions` field in `tsconfig.json` and `jsconfig.json` which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.\n\n`   {    // Some typical compiler options    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"es2020\",      \"[moduleResolution](https://www.typescriptlang.org/tsconfig#moduleResolution) \": \"node\"      // ...    },    // NEW: Options for file/directory watching    \"watchOptions\": {      // Use native file system events for files and directories      \"[watchFile](https://www.typescriptlang.org/tsconfig#watchFile) \": \"useFsEvents\",      \"[watchDirectory](https://www.typescriptlang.org/tsconfig#watchDirectory) \": \"useFsEvents\",      // Poll files for updates more frequently      // when they're updated a lot.      \"[fallbackPolling](https://www.typescriptlang.org/tsconfig#fallbackPolling) \": \"dynamicPriority\"    }  }   `\n\n`watchOptions` contains 4 new options that can be configured:\n\n*   [`watchFile`](https://www.typescriptlang.org/tsconfig#watchFile)\n    : the strategy for how individual files are watched. This can be set to\n    \n    *   `fixedPollingInterval`: Check every file for changes several times a second at a fixed interval.\n    *   `priorityPollingInterval`: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.\n    *   `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified files will be checked less often.\n    *   `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for file changes.\n    *   `useFsEventsOnParentDirectory`: Attempt to use the operating system/file system’s native events to listen for changes on a file’s containing directories. This can use fewer file watchers, but might be less accurate.\n*   [`watchDirectory`](https://www.typescriptlang.org/tsconfig#watchDirectory)\n    : the strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality. This can be set to:\n    \n    *   `fixedPollingInterval`: Check every directory for changes several times a second at a fixed interval.\n    *   `dynamicPriorityPolling`: Use a dynamic queue where less-frequently modified directories will be checked less often.\n    *   `useFsEvents` (the default): Attempt to use the operating system/file system’s native events for directory changes.\n*   [`fallbackPolling`](https://www.typescriptlang.org/tsconfig#fallbackPolling)\n    : when using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers. This can be set to\n    \n    *   `fixedPollingInterval`: _(See above.)_\n    *   `priorityPollingInterval`: _(See above.)_\n    *   `dynamicPriorityPolling`: _(See above.)_\n    *   `synchronousWatchDirectory`: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in `node_modules` from running `npm install`), but you might want to disable it with this flag for some less-common setups.\n\nFor more information on these changes, [head over to GitHub to see the pull request](https://github.com/microsoft/TypeScript/pull/35615)\n to read more.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#fast-and-loose-incremental-checking)\n“Fast and Loose” Incremental Checking\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.8 introduces a new compiler option called [`assumeChangesOnlyAffectDirectDependencies`](https://www.typescriptlang.org/tsconfig#assumeChangesOnlyAffectDirectDependencies)\n. When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.\n\nFor example, consider a file `fileD.ts` that imports `fileC.ts` that imports `fileB.ts` that imports `fileA.ts` as follows:\n\n`   fileA.ts <- fileB.ts <- fileC.ts <- fileD.ts   `\n\nIn `--watch` mode, a change in `fileA.ts` would typically mean that TypeScript would need to at least re-check `fileB.ts`, `fileC.ts`, and `fileD.ts`. Under [`assumeChangesOnlyAffectDirectDependencies`](https://www.typescriptlang.org/tsconfig#assumeChangesOnlyAffectDirectDependencies)\n, a change in `fileA.ts` means that only `fileA.ts` and `fileB.ts` need to be re-checked.\n\nIn a codebase like Visual Studio Code, this reduced rebuild times for changes in certain files from about 14 seconds to about 1 second. While we don’t necessarily recommend this option for all codebases, you might be interested if you have an extremely large codebase and are willing to defer full project errors until later (e.g. a dedicated build via a `tsconfig.fullbuild.json` or in CI).\n\nFor more details, you can [see the original pull request](https://github.com/microsoft/TypeScript/pull/35711)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.8.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (51)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)\n\nOT![Orta Therox  (15)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nAB![Adam Boyce  (1)](https://gravatar.com/avatar/926030db4940c7c4c24f80503b192014a626355852ca615d455afe731ffb60ac?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nMU![Masato Urai  (1)](https://gravatar.com/avatar/ed67cd61e7c19e1081270e954cbe4249efd9429305d34b6c43061196ee05a6eb?s=32&&d=blank)\n\n2+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:title":"Documentation - TypeScript 3.8","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"TypeScript 3.8 Release Notes","language":"en","generator":"Gatsby 5.13.5","title":"TypeScript: Documentation - TypeScript 3.8","ogTitle":"Documentation - TypeScript 3.8","theme-color":"#3178C6","og:description":"TypeScript 3.8 Release Notes","ogDescription":"TypeScript 3.8 Release Notes","scrapeId":"a23d0ce9-1ab7-4ba8-9e2a-6bffb512685d","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.6\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#allowing-code-in-constructors-before-super)\nAllowing Code in Constructors Before `super()`\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript classes it’s mandatory to call `super()` before referring to `this`. TypeScript enforces this as well, though it was a bit too strict in _how_ it ensured this. In TypeScript, it was previously an error to contain _any_ code at the beginning of a constructor if its containing class had any property initializers.\n\nts\n\n`   class Base {    // ...  }  class Derived extends Base {    someProperty = true;    constructor() {      // error!      // have to call 'super()' first because it needs to initialize 'someProperty'.      doSomeStuff();      super();    }  }   `\n\nThis made it cheap to check that `super()` gets called before `this` is referenced, but it ended up rejecting a lot of valid code. TypeScript 4.6 is now much more lenient in that check and permits other code to run before `super()`., all while still ensuring that `super()` occurs at the top-level before any references to `this`.\n\nWe’d like to extend our thanks to [Joshua Goldberg](https://github.com/JoshuaKGoldberg)\n for [patiently working with us to land this change](https://github.com/microsoft/TypeScript/pull/29374)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#control-flow-analysis-for-destructured-discriminated-unions)\nControl Flow Analysis for Destructured Discriminated Unions\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript is able to narrow types based on what’s called a discriminant property. For example, in the following code snippet, TypeScript is able to narrow the type of `action` based on every time we check against the value of `kind`.\n\nts\n\n``   type Action =    | { kind: \"NumberContents\"; payload: number }    | { kind: \"StringContents\"; payload: string };  function processAction(action: Action) {    if (action.kind === \"NumberContents\") {      // `action.payload` is a number here.      let num = action.payload * 2;      // ...    } else if (action.kind === \"StringContents\") {      // `action.payload` is a string here.      const str = action.payload.trim();      // ...    }  }   ``\n\nThis lets us work with objects that can hold different data, but a common field tells us _which_ data those objects have.\n\nThis is very common in TypeScript; however, depending on your preferences, you might have wanted to destructure `kind` and `payload` in the example above. Perhaps something like the following:\n\nts\n\n`   type Action =    | { kind: \"NumberContents\"; payload: number }    | { kind: \"StringContents\"; payload: string };  function processAction(action: Action) {    const { kind, payload } = action;    if (kind === \"NumberContents\") {      let num = payload * 2;      // ...    } else if (kind === \"StringContents\") {      const str = payload.trim();      // ...    }  }   `\n\nPreviously TypeScript would error on these - once `kind` and `payload` were extracted from the same object into variables, they were considered totally independent.\n\nIn TypeScript 4.6, this just works!\n\nWhen destructuring individual properties into a `const` declaration, or when destructuring a parameter into variables that are never assigned to, TypeScript will check for if the destructured type is a discriminated union. If it is, TypeScript can now narrow the types of variables depending on checks of other variables So in our example, a check on `kind` narrows the type of `payload`.\n\nFor more information, [see the pull request that implemented this analysis](https://github.com/microsoft/TypeScript/pull/46266)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#improved-recursion-depth-checks)\nImproved Recursion Depth Checks\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript has some interesting challenges due to the fact that it’s built on a structural type system that also provides generics.\n\nIn a structural type system, object types are compatible based on the members they have.\n\nts\n\n`   interface Source {    prop: string;  }  interface Target {    prop: number;  }  function check(source: Source, target: Target) {    target = source;    // error!    // Type 'Source' is not assignable to type 'Target'.    //   Types of property 'prop' are incompatible.    //     Type 'string' is not assignable to type 'number'.  }   `\n\nNotice that whether or not `Source` is compatible with `Target` has to do with whether their _properties_ are assignable. In this case, that’s just `prop`.\n\nWhen you introduce generics into this, there are some harder questions to answer. For instance, is a `Source<string>` assignable to a `Target<number>` in the following case?\n\nts\n\n`   interface Source<T> {    prop: Source<Source<T>>;  }  interface Target<T> {    prop: Target<Target<T>>;  }  function check(source: Source<string>, target: Target<number>) {    target = source;  }   `\n\nIn order to answer that, TypeScript needs to check whether the types of `prop` are compatible. That leads to the another question: is a `Source<Source<string>>` assignable to a `Target<Target<number>>`? To answer that, TypeScript checks whether `prop` is compatible for _those_ types, and ends up checking whether `Source<Source<Source<string>>>` is assignable to `Target<Target<Target<number>>>`. Keep going for a bit, and you might notice that the type infinitely expands the more you dig in.\n\nTypeScript has a few heuristics here - if a type _appears_ to be infinitely expanding after encountering a certain depth check, then it considers that the types _could_ be compatible. This is usually enough, but embarrassingly there were some false-negatives that this wouldn’t catch.\n\nts\n\n`   interface Foo<T> {    prop: T;  }  declare let x: Foo<Foo<Foo<Foo<Foo<Foo<string>>>>>>;  declare let y: Foo<Foo<Foo<Foo<Foo<string>>>>>;  x = y;   `\n\nA human reader can see that `x` and `y` should be incompatible in the above example. While the types are deeply nested, that’s just a consequence of how they were declared. The heuristic was meant to capture cases where deeply-nested types were generated through exploring the types, not from when a developer wrote that type out themselves.\n\nTypeScript 4.6 is now able to distinguish these cases, and correctly errors on the last example. Additionally, because the language is no longer concerned with false-positives from explicitly-written types, TypeScript can conclude that a type is infinitely expanding much earlier, and save a bunch of work in checking for type compatibility. As a result, libraries on DefinitelyTyped like `redux-immutable`, `react-lazylog`, and `yup` saw a 50% reduction in check-time.\n\nYou may already have this change because it was cherry-picked into TypeScript 4.5.3, but it is a notable feature of TypeScript 4.6 which you can read up more about [here](https://github.com/microsoft/TypeScript/pull/46599)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#indexed-access-inference-improvements)\nIndexed Access Inference Improvements\n--------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript now can correctly infer to indexed access types which immediately index into a mapped object type.\n\nts\n\n`   interface TypeMap {    number: number;    string: string;    boolean: boolean;  }  type UnionRecord<P extends keyof TypeMap> = {    [K in P]: {      kind: K;      v: TypeMap[K];      f: (p: TypeMap[K]) => void;    };  }[P];  function processRecord<K extends keyof TypeMap>(record: UnionRecord<K>) {    record.f(record.v);  }  // This call used to have issues - now works!  processRecord({    kind: \"string\",    v: \"hello!\",    // 'val' used to implicitly have the type 'string | number | boolean',    // but now is correctly inferred to just 'string'.    f: (val) => {      console.log(val.toUpperCase());    },  });   `\n\nThis pattern was already supported and allowed TypeScript to understand that the call to `record.f(record.v)` is valid, but previously the call to `processRecord` would give poor inference results for `val`\n\nTypeScript 4.6 improves this so that no type assertions are necessary within the call to `processRecord`.\n\nFor more information, you can [read up on the pull request](https://github.com/microsoft/TypeScript/pull/47109)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#control-flow-analysis-for-dependent-parameters)\nControl Flow Analysis for Dependent Parameters\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nA signature can be declared with a rest parameter whose type is a discriminated union of tuples.\n\nts\n\n`   function func(...args: [\"str\", string] | [\"num\", number]) {    // ...  }   `\n\nWhat this says is that the arguments to `func` depends entirely on the first argument. When the first argument is the string `\"str\"`, then its second argument has to be a `string`. When its first argument is the string `\"num\"`, its second argument has to be a `number`.\n\nIn cases where TypeScript infers the type of a function from a signature like this, TypeScript can now narrow parameters that depend on each other.\n\nts\n\n`   type Func = (...args: [\"a\", number] | [\"b\", string]) => void;  const f1: Func = (kind, payload) => {    if (kind === \"a\") {      payload.toFixed(); // 'payload' narrowed to 'number'    }    if (kind === \"b\") {      payload.toUpperCase(); // 'payload' narrowed to 'string'    }  };  f1(\"a\", 42);  f1(\"b\", \"hello\");   `\n\nFor more information, [see the change on GitHub](https://github.com/microsoft/TypeScript/pull/47190)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#--target-es2022)\n`--target es2022`\n--------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s `--target` option now supports `es2022`. This means features like class fields now have a stable output target where they can be preserved. It also means that new built-in functionality like the [`at()` method on `Array`s](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at)\n, [`Object.hasOwn`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn)\n, or [the `cause` option on `new Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error#rethrowing_an_error_with_a_cause)\n can be used either with this new `--target` setting, or with `--lib es2022`.\n\nThis functionality was [implemented](https://github.com/microsoft/TypeScript/pull/46291)\n by [Kagami Sascha Rosylight (saschanaz)](https://github.com/saschanaz)\n over several PRs, and we’re grateful for that contribution!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#removed-unnecessary-arguments-in-react-jsx)\nRemoved Unnecessary Arguments in `react-jsx`\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPreviously, when compiling code like the following in `--jsx react-jsx`\n\ntsx\n\n`   export const el = <div>foo</div>;   `\n\nTypeScript would produce the following JavaScript code:\n\njsx\n\n`   import { jsx as _jsx } from \"react/jsx-runtime\";  export const el = _jsx(\"div\", { children: \"foo\" }, void 0);   `\n\nThat last `void 0` argument is unnecessary in this emit mode, and removing it can improve bundle sizes.\n\ndiff\n\n`   - export const el = _jsx(\"div\", { children: \"foo\" }, void 0);  + export const el = _jsx(\"div\", { children: \"foo\" });   `\n\nThanks to [a pull request](https://github.com/microsoft/TypeScript/pull/47467)\n from [Alexander Tarasyuk](https://github.com/a-tarasyuk)\n, TypeScript 4.6 now drops the `void 0` argument.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#jsdoc-name-suggestions)\nJSDoc Name Suggestions\n--------------------------------------------------------------------------------------------------------------------------------\n\nIn JSDoc, you can document parameters using an `@param` tag.\n\njs\n\n`   /**   * @param x The first operand   * @param y The second operand   */  function add(x, y) {    return x + y;  }   `\n\nBut what happens when these comments fall out of date? What if we rename `x` and `y` to `a` and `b`?\n\njs\n\n`   /**   * @param x {number} The first operand   * @param y {number} The second operand   */  function add(a, b) {    return a + b;  }   `\n\nPreviously TypeScript would only tell you about this when performing type-checking on JavaScript files - when using either the `checkJs` option, or adding a `// @ts-check` comment to the top of your file.\n\nYou can now get similar information for TypeScript files in your editor! TypeScript now provides suggestions for when parameter names don’t match between your function and its JSDoc comment.\n\n![Suggestion diagnostics being shown in the editor for parameter names in JSDoc comments that don't match an actual parameter name.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/02/jsdoc-comment-suggestions-4-6.png)\n\n[This change](https://github.com/microsoft/TypeScript/pull/47257)\n was provided courtesy of [Alexander Tarasyuk](https://github.com/a-tarasyuk)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#more-syntax-and-binding-errors-in-javascript)\nMore Syntax and Binding Errors in JavaScript\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript has expanded its set of syntax and binding errors in JavaScript files. You’ll see these new errors if you open JavaScript files in an editor like Visual Studio or Visual Studio Code, or if you run JavaScript code through the TypeScript compiler - even if you don’t turn on `checkJs` or add a `// @ts-check` comment to the top of your files.\n\nAs one example, if you have two declarations of a `const` in the same scope of a JavaScript file, TypeScript will now issue an error on those declarations.\n\nts\n\n`   const foo = 1234;  //    ~~~  // error: Cannot redeclare block-scoped variable 'foo'.  // ...  const foo = 5678;  //    ~~~  // error: Cannot redeclare block-scoped variable 'foo'.   `\n\nAs another example, TypeScript will let you know if a modifier is being incorrectly used.\n\nts\n\n`   function container() {      export function foo() {  //  ~~~~~~  // error: Modifiers cannot appear here.      }  }   `\n\nThese errors can be disabled by adding a `// @ts-nocheck` at the top of your file, but we’re interested in hearing some early feedback about how it works for your JavaScript workflow. You can easily try it out for Visual Studio Code by installing the [TypeScript and JavaScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next)\n, and read up more on the [first](https://github.com/microsoft/TypeScript/pull/47067)\n and [second](https://github.com/microsoft/TypeScript/pull/47075)\n pull requests.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#typescript-trace-analyzer)\nTypeScript Trace Analyzer\n--------------------------------------------------------------------------------------------------------------------------------------\n\nOccasionally, teams may encounter types that are computationally expensive to create and compare against other types. [TypeScript has a `--generateTrace` flag](https://github.com/microsoft/TypeScript/wiki/Performance#performance-tracing)\n to help identify some of those expensive types, or sometimes help diagnose issues in the TypeScript compiler. While the information generated by `--generateTrace` can be useful (especially with some information added in TypeScript 4.6), it can often be hard to read in existing trace visualizers.\n\nWe recently published a tool called [@typescript/analyze-trace](https://www.npmjs.com/package/@typescript/analyze-trace)\n to get a more digestible view of this information. While we don’t expect everyone to need `analyze-trace`, we think it can come in handy for any team that is running into [build performance issues with TypeScript](https://github.com/microsoft/TypeScript/wiki/Performance)\n.\n\nFor more information, [see the `analyze-trace` tool’s repo](https://github.com/microsoft/typescript-analyze-trace)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#object-rests-drop-unspreadable-members-from-generic-objects)\nObject Rests Drop Unspreadable Members from Generic Objects\n\nObject rest expressions now drop members that appear to be unspreadable on generic objects. In the following example…\n\nts\n\n`   class Thing {    someProperty = 42;    someMethod() {      // ...    }  }  function foo<T extends Thing>(x: T) {    let { someProperty, ...rest } = x;    // Used to work, is now an error!    // Property 'someMethod' does not exist on type 'Omit<T, \"someProperty\" | \"someMethod\">'.    rest.someMethod();  }   `\n\nthe variable `rest` used to have the type `Omit<T, \"someProperty\">` because TypeScript would strictly analyze which other properties were destructured. This doesn’t model how `...rest` would work in a destructuring from a non-generic type because `someMethod` would typically be dropped as well. In TypeScript 4.6, the type of `rest` is `Omit<T, \"someProperty\" | \"someMethod\">`.\n\nThis can also come up in cases when destructuring from `this`. When destructuring `this` using a `...rest` element, unspreadable and non-public members are now dropped, which is consistent with destructuring instances of a class in other places.\n\nts\n\n`   class Thing {    someProperty = 42;    someMethod() {      // ...    }    someOtherMethod() {      let { someProperty, ...rest } = this;      // Used to work, is now an error!      // Property 'someMethod' does not exist on type 'Omit<T, \"someProperty\" | \"someMethod\">'.      rest.someMethod();    }  }   `\n\nFor more details, [see the corresponding change here](https://github.com/microsoft/TypeScript/pull/47078)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html#javascript-files-always-receive-grammar-and-binding-errors)\nJavaScript Files Always Receive Grammar and Binding Errors\n\nPreviously, TypeScript would ignore most grammar errors in JavaScript apart from accidentally using TypeScript syntax in a JavaScript file. TypeScript now shows JavaScript syntax and binding errors in your file, such as using incorrect modifiers, duplicate declarations, and more. These will typically be most apparent in Visual Studio Code or Visual Studio, but can also occur when running JavaScript code through the TypeScript compiler.\n\nYou can explicitly turn these errors off by inserting a `// @ts-nocheck` comment at the top of your file.\n\nFor more information, see the [first](https://github.com/microsoft/TypeScript/pull/47067)\n and [second](https://github.com/microsoft/TypeScript/pull/47075)\n implementing pull requests for these features.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.6.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (6)](https://gravatar.com/avatar/3cb42391bbae78f84e416c9407fb9ef82c008ab291b8193611b0a77946c499d8?s=32&&d=blank)\n\nAB![Andrew Branch  (3)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nDP![Dimitri POSTOLOV  (1)](https://gravatar.com/avatar/9ff3f1184582cb5f3a4890c5a8787dd539b8f3783a40eaaba9301b34be71ee23?s=32&&d=blank)\n\nN![navya9singh  (1)](https://gravatar.com/avatar/e896fd3c90d7bd8d3c276d3ea2dd552ae62d81d4a497cdd589f551c5eb5ccb93?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"description":"TypeScript 4.6 Release Notes","language":"en","ogDescription":"TypeScript 4.6 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","og:description":"TypeScript 4.6 Release Notes","title":"TypeScript: Documentation - TypeScript 4.6","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","generator":"Gatsby 5.13.5","twitter:site":"typescriptlang","ogTitle":"Documentation - TypeScript 4.6","og:title":"Documentation - TypeScript 4.6","scrapeId":"7ccd951f-7374-4156-99ea-9cb4e325f786","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.6\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#stricter-generators)\nStricter Generators\n--------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.6 introduces stricter checking for iterators and generator functions. In earlier versions, users of generators had no way to differentiate whether a value was yielded or returned from a generator.\n\nts\n\n`   function* foo() {    if (Math.random() < 0.5) yield 100;    return \"Finished!\";  }  let iter = foo();  let curr = iter.next();  if (curr.done) {    // TypeScript 3.5 and prior thought this was a 'string | number'.    // It should know it's 'string' since 'done' was 'true'!    curr.value;  }   `\n\nAdditionally, generators just assumed the type of `yield` was always `any`.\n\nts\n\n`   function* bar() {    let x: { hello(): void } = yield;    x.hello();  }  let iter = bar();  iter.next();  iter.next(123); // oops! runtime error!   `\n\nIn TypeScript 3.6, the checker now knows that the correct type for `curr.value` should be `string` in our first example, and will correctly error on our call to `next()` in our last example. This is thanks to some changes in the `Iterator` and `IteratorResult` type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the `Generator` type.\n\nThe `Iterator` type now allows users to specify the yielded type, the returned type, and the type that `next` can accept.\n\nts\n\n`   interface Iterator<T, TReturn = any, TNext = undefined> {    // Takes either 0 or 1 arguments - doesn't accept 'undefined'    next(...args: [] | [TNext]): IteratorResult<T, TReturn>;    return?(value?: TReturn): IteratorResult<T, TReturn>;    throw?(e?: any): IteratorResult<T, TReturn>;  }   `\n\nBuilding on that work, the new `Generator` type is an `Iterator` that always has both the `return` and `throw` methods present, and is also iterable.\n\nts\n\n`   interface Generator<T = unknown, TReturn = any, TNext = unknown>    extends Iterator<T, TReturn, TNext> {    next(...args: [] | [TNext]): IteratorResult<T, TReturn>;    return(value: TReturn): IteratorResult<T, TReturn>;    throw(e: any): IteratorResult<T, TReturn>;    [Symbol.iterator](): Generator<T, TReturn, TNext>;  }   `\n\nTo allow differentiation between returned values and yielded values, TypeScript 3.6 converts the `IteratorResult` type to a discriminated union type:\n\nts\n\n`   type IteratorResult<T, TReturn = any> =    | IteratorYieldResult<T>    | IteratorReturnResult<TReturn>;  interface IteratorYieldResult<TYield> {    done?: false;    value: TYield;  }  interface IteratorReturnResult<TReturn> {    done: true;    value: TReturn;  }   `\n\nIn short, what this means is that you’ll be able to appropriately narrow down values from iterators when dealing with them directly.\n\nTo correctly represent the types that can be passed in to a generator from calls to `next()`, TypeScript 3.6 also infers certain uses of `yield` within the body of a generator function.\n\nts\n\n`   function* foo() {    let x: string = yield;    console.log(x.toUpperCase());  }  let x = foo();  x.next(); // first call to 'next' is always ignored  x.next(42); // error! 'number' is not assignable to 'string'   `\n\nIf you’d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from `yield` expressions using an explicit return type. Below, `next()` can only be called with `boolean`s, and depending on the value of `done`, `value` is either a `string` or a `number`.\n\nts\n\n`   /**   * - yields numbers   * - returns strings   * - can be passed in booleans   */  function* counter(): Generator<number, string, boolean> {    let i = 0;    while (true) {      if (yield i++) {        break;      }    }    return \"done!\";  }  var iter = counter();  var curr = iter.next();  while (!curr.done) {    console.log(curr.value);    curr = iter.next(curr.value === 5);  }  console.log(curr.value.toUpperCase());  // prints:  //  // 0  // 1  // 2  // 3  // 4  // 5  // DONE!   `\n\nFor more details on the change, [see the pull request here](https://github.com/Microsoft/TypeScript/issues/2983)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#more-accurate-array-spread)\nMore Accurate Array Spread\n----------------------------------------------------------------------------------------------------------------------------------------\n\nIn pre-ES2015 targets, the most faithful emit for constructs like `for`/`of` loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration)\n flag. The looser default without [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration)\n works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread\n\nts\n\n`   [...Array(5)];   `\n\ncan be rewritten as the following array literal\n\njs\n\n`   [undefined, undefined, undefined, undefined, undefined];   `\n\nHowever, TypeScript would instead transform the original code into this code:\n\nts\n\n`   Array(5).slice();   `\n\nwhich is slightly different. `Array(5)` produces an array with a length of 5, but with no defined property slots.\n\nTypeScript 3.6 introduces a new `__spreadArrays` helper to accurately model what happens in ECMAScript 2015 in older targets outside of [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration)\n. `__spreadArrays` is also available in [tslib](https://github.com/Microsoft/tslib/)\n.\n\nFor more information, [see the relevant pull request](https://github.com/microsoft/TypeScript/pull/31166)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#improved-ux-around-promises)\nImproved UX Around Promises\n------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.6 introduces some improvements for when `Promise`s are mis-handled.\n\nFor example, it’s often very common to forget to `.then()` or `await` the contents of a `Promise` before passing it to another function. TypeScript’s error messages are now specialized, and inform the user that perhaps they should consider using the `await` keyword.\n\nts\n\n`   interface User {    name: string;    age: number;    location: string;  }  declare function getUserData(): Promise<User>;  declare function displayUser(user: User): void;  async function f() {    displayUser(getUserData());    //              ~~~~~~~~~~~~~    // Argument of type 'Promise<User>' is not assignable to parameter of type 'User'.    //   ...    // Did you forget to use 'await'?  }   `\n\nIt’s also common to try to access a method before `await`\\-ing or `.then()`\\-ing a `Promise`. This is another example, among many others, where we’re able to do better.\n\nts\n\n`   async function getCuteAnimals() {    fetch(\"https://reddit.com/r/aww.json\").json();    //   ~~~~    // Property 'json' does not exist on type 'Promise<Response>'.    //    // Did you forget to use 'await'?  }   `\n\nFor more details, [see the originating issue](https://github.com/microsoft/TypeScript/issues/30646)\n, as well as the pull requests that link back to it.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#better-unicode-support-for-identifiers)\nBetter Unicode Support for Identifiers\n----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.6 contains better support for Unicode characters in identifiers when emitting to ES2015 and later targets.\n\nts\n\n`   const 𝓱𝓮𝓵𝓵𝓸 = \"world\"; // previously disallowed, now allowed in '--target es2015'   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#importmeta-support-in-systemjs)\n`import.meta` Support in SystemJS\n---------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.6 supports transforming `import.meta` to `context.meta` when your `module` target is set to `system`.\n\nts\n\n`   // This module:  console.log(import.meta.url);  // gets turned into the following:  System.register([], function (exports, context) {    return {      setters: [],      execute: function () {        console.log(context.meta.url);      },    };  });   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#get-and-set-accessors-are-allowed-in-ambient-contexts)\n`get` and `set` Accessors Are Allowed in Ambient Contexts\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn previous versions of TypeScript, the language didn’t allow `get` and `set` accessors in ambient contexts (like in `declare`\\-d classes, or in `.d.ts` files in general). The rationale was that accessors weren’t distinct from properties as far as writing and reading to these properties; however, [because ECMAScript’s class fields proposal may have differing behavior from in existing versions of TypeScript](https://github.com/tc39/proposal-class-fields/issues/248)\n, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.\n\nAs a result, users can write getters and setters in ambient contexts in TypeScript 3.6.\n\nts\n\n`   declare class Foo {    // Allowed in 3.6+.    get x(): number;    set x(val: number);  }   `\n\nIn TypeScript 3.7, the compiler itself will take advantage of this feature so that generated `.d.ts` files will also emit `get`/`set` accessors.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#ambient-classes-and-functions-can-merge)\nAmbient Classes and Functions Can Merge\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the `declare` modifier, or in `.d.ts` files) can merge. This means that now you can write the following:\n\nts\n\n`   export declare function Point2D(x: number, y: number): Point2D;  export declare class Point2D {    x: number;    y: number;    constructor(x: number, y: number);  }   `\n\ninstead of needing to use\n\nts\n\n`   export interface Point2D {    x: number;    y: number;  }  export declare var Point2D: {    (x: number, y: number): Point2D;    new (x: number, y: number): Point2D;  };   `\n\nOne advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since `var` declarations can’t merge with `namespace`s).\n\nIn TypeScript 3.7, the compiler will take advantage of this feature so that `.d.ts` files generated from `.js` files can appropriately capture both the callability and constructability of a class-like function.\n\nFor more details, [see the original PR on GitHub](https://github.com/microsoft/TypeScript/pull/32584)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#apis-to-support---build-and---incremental)\nAPIs to Support `--build` and `--incremental`\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.0 introduced support for referencing other projects and building them incrementally using the `--build` flag. Additionally, TypeScript 3.4 introduced the [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n flag for saving information about previous compilations to only rebuild certain files. These flags were incredibly useful for structuring projects more flexibly and speeding builds up. Unfortunately, using these flags didn’t work with 3rd party build tools like Gulp and Webpack. TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.\n\nFor creating [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n builds, users can leverage the `createIncrementalProgram` and `createIncrementalCompilerHost` APIs. Users can also re-hydrate old program instances from `.tsbuildinfo` files generated by this API using the newly exposed `readBuilderProgram` function, which is only meant to be used as for creating new programs (i.e. you can’t modify the returned instance - it’s only meant to be used for the `oldProgram` parameter in other `create*Program` functions).\n\nFor leveraging project references, a new `createSolutionBuilder` function has been exposed, which returns an instance of the new type `SolutionBuilder`.\n\nFor more details on these APIs, you can [see the original pull request](https://github.com/microsoft/TypeScript/pull/31432)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#semicolon-aware-code-edits)\nSemicolon-Aware Code Edits\n----------------------------------------------------------------------------------------------------------------------------------------\n\nEditors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users’ style guidelines, and many users were displeased with the editor inserting semicolons.\n\nTypeScript is now smart enough to detect whether your file uses semicolons when applying these sorts of edits. If your file generally lacks semicolons, TypeScript won’t add one.\n\nFor more details, [see the corresponding pull request](https://github.com/microsoft/TypeScript/pull/31801)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#smarter-auto-import-syntax)\nSmarter Auto-Import Syntax\n----------------------------------------------------------------------------------------------------------------------------------------\n\nJavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and `require` calls.\n\nTypeScript 3.6 is now a bit smarter about looking at your existing imports before deciding on how to auto-import other modules. You can [see more details in the original pull request here](https://github.com/microsoft/TypeScript/pull/32684)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html#new-typescript-playground)\nNew TypeScript Playground\n--------------------------------------------------------------------------------------------------------------------------------------\n\nThe TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of [Artem Tyurin](https://github.com/agentcooper)\n’s [TypeScript playground](https://github.com/agentcooper/typescript-play)\n which community members have been using more and more. We owe Artem a big thanks for helping out here!\n\nThe new playground now supports many new options including:\n\n*   The [`target`](https://www.typescriptlang.org/tsconfig#target)\n     option (allowing users to switch out of `es5` to `es3`, `es2015`, `esnext`, etc.)\n*   All the strictness flags (including just [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n    )\n*   Support for plain JavaScript files (using `allowJS` and optionally [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs)\n    )\n\nThese options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient “oh, don’t forget to turn on the [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n option!“.\n\nIn the near future, we’re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you’ll be able to see the same experience on the playground as you’d get in your personal editor.\n\nAs we improve the playground and the website, [we welcome feedback and pull requests on GitHub](https://github.com/microsoft/TypeScript-Website/)\n!\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.6.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (51)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)\n\nOT![Orta Therox  (12)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nEL![Eliran Levi  (1)](https://gravatar.com/avatar/f00fd5d066bb6174a9369ab456ce99bbc444afa281ff050a70a8a6cb0820894a?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nJRU![John Ralph Umandal  (1)](https://gravatar.com/avatar/5b3624ae65a0c25d6a006151bc968449931d98e6009107d5b33552b971cd2968?s=32&&d=blank)\n\n3+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"twitter:site":"typescriptlang","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogDescription":"TypeScript 3.6 Release Notes","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","title":"TypeScript: Documentation - TypeScript 3.6","ogTitle":"Documentation - TypeScript 3.6","language":"en","theme-color":"#3178C6","description":"TypeScript 3.6 Release Notes","generator":"Gatsby 5.13.5","og:title":"Documentation - TypeScript 3.6","og:description":"TypeScript 3.6 Release Notes","scrapeId":"2296eda8-ed3c-4608-865b-e44380497596","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.4\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag)\nFaster subsequent builds with the `--incremental` flag\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.4 introduces a new flag called [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n which tells TypeScript to save information about the project graph from the last compilation. The next time TypeScript is invoked with [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n, it will use that information to detect the least costly way to type-check and emit changes to your project.\n\n`   // tsconfig.json  {    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[incremental](https://www.typescriptlang.org/tsconfig#incremental) \": true,      \"[outDir](https://www.typescriptlang.org/tsconfig#outDir) \": \"./lib\"    },    \"[include](https://www.typescriptlang.org/tsconfig#include) \": [\"./src\"]  }   `\n\nBy default with these settings, when we run `tsc`, TypeScript will look for a file called `.tsbuildinfo` in the output directory (`./lib`). If `./lib/.tsbuildinfo` doesn’t exist, it’ll be generated. But if it does, `tsc` will try to use that file to incrementally type-check and update our output files.\n\nThese `.tsbuildinfo` files can be safely deleted and don’t have any impact on our code at runtime - they’re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the [`tsBuildInfoFile`](https://www.typescriptlang.org/tsconfig#tsBuildInfoFile)\n option.\n\n`   // front-end.tsconfig.json  {    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[incremental](https://www.typescriptlang.org/tsconfig#incremental) \": true,      \"[tsBuildInfoFile](https://www.typescriptlang.org/tsconfig#tsBuildInfoFile) \": \"./buildcache/front-end\",      \"[outDir](https://www.typescriptlang.org/tsconfig#outDir) \": \"./lib\"    },    \"[include](https://www.typescriptlang.org/tsconfig#include) \": [\"./src\"]  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#composite-projects)\nComposite projects\n\nPart of the intent with composite projects (`tsconfig.json`s with [`composite`](https://www.typescriptlang.org/tsconfig#composite)\n set to `true`) is that references between different projects can be built incrementally. As such, composite projects will **always** produce `.tsbuildinfo` files.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#outfile)\n`outFile`\n\nWhen [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)\n is used, the build information file’s name will be based on the output file’s name. As an example, if our output JavaScript file is `./output/foo.js`, then under the [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n flag, TypeScript will generate the file `./output/foo.tsbuildinfo`. As above, this can be controlled with the [`tsBuildInfoFile`](https://www.typescriptlang.org/tsconfig#tsBuildInfoFile)\n option.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#higher-order-type-inference-from-generic-functions)\nHigher order type inference from generic functions\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences. This means many function composition patterns now work better in 3.4.\n\nTo get more specific, let’s build up some motivation and consider the following `compose` function:\n\nts\n\n`   function compose<A, B, C>(f: (arg: A) => B, g: (arg: B) => C): (arg: A) => C {    return (x) => g(f(x));  }   `\n\n`compose` takes two other functions:\n\n*   `f` which takes some argument (of type `A`) and returns a value of type `B`\n*   `g` which takes an argument of type `B` (the type `f` returned), and returns a value of type `C`\n\n`compose` then returns a function which feeds its argument through `f` and then `g`.\n\nWhen calling this function, TypeScript will try to figure out the types of `A`, `B`, and `C` through a process called _type argument inference_. This inference process usually works pretty well:\n\nts\n\n`   interface Person {    name: string;    age: number;  }  function getDisplayName(p: Person) {    return p.name.toLowerCase();  }  function getLength(s: string) {    return s.length;  }  // has type '(p: Person) => number'  const getDisplayNameLength = compose(getDisplayName, getLength);  // works and returns the type 'number'  getDisplayNameLength({ name: \"Person McPersonface\", age: 42 });   `\n\nThe inference process is fairly straightforward here because `getDisplayName` and `getLength` use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like `compose` didn’t work so well when passed other generic functions.\n\nts\n\n`   interface Box<T> {    value: T;  }  function makeArray<T>(x: T): T[] {    return [x];  }  function makeBox<U>(value: U): Box<U> {    return { value };  }  // has type '(arg: {}) => Box<{}[]>'  const makeBoxedArray = compose(makeArray, makeBox);  makeBoxedArray(\"hello!\").value[0].toUpperCase();  //                                ~~~~~~~~~~~  // error: Property 'toUpperCase' does not exist on type '{}'.   `\n\nIn older versions, TypeScript would infer the empty object type (`{}`) when inferring from other type variables like `T` and `U`.\n\nDuring type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript _will_, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.\n\nIn other words, instead of producing the type\n\nts\n\n`   (arg: {}) => Box<{}[]>   `\n\nTypeScript 3.4 produces the type\n\nts\n\n`   <T>(arg: T) => Box<T[]>   `\n\nNotice that `T` has been propagated from `makeArray` into the resulting type’s type parameter list. This means that genericity from `compose`’s arguments has been preserved and our `makeBoxedArray` sample will just work!\n\nts\n\n`   interface Box<T> {    value: T;  }  function makeArray<T>(x: T): T[] {    return [x];  }  function makeBox<U>(value: U): Box<U> {    return { value };  }  // has type '<T>(arg: T) => Box<T[]>'  const makeBoxedArray = compose(makeArray, makeBox);  // works with no problem!  makeBoxedArray(\"hello!\").value[0].toUpperCase();   `\n\nFor more details, you can [read more at the original change](https://github.com/Microsoft/TypeScript/pull/30215)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#improvements-for-readonlyarray-and-readonly-tuples)\nImprovements for `ReadonlyArray` and `readonly` tuples\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.4 makes it a little bit easier to use read-only array-like types.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#a-new-syntax-for-readonlyarray)\nA new syntax for `ReadonlyArray`\n\nThe `ReadonlyArray` type describes `Array`s that can only be read from. Any variable with a reference to a `ReadonlyArray` can’t add, remove, or replace any elements of the array.\n\nts\n\n`   function foo(arr: ReadonlyArray<string>) {    arr.slice(); // okay    arr.push(\"hello!\"); // error!  }   `\n\nWhile it’s good practice to use `ReadonlyArray` over `Array` when no mutation is intended, it’s often been a pain given that arrays have a nicer syntax. Specifically, `number[]` is a shorthand version of `Array<number>`, just as `Date[]` is a shorthand for `Array<Date>`.\n\nTypeScript 3.4 introduces a new syntax for `ReadonlyArray` using a new `readonly` modifier for array types.\n\nts\n\n`   function foo(arr: readonly string[]) {    arr.slice(); // okay    arr.push(\"hello!\"); // error!  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#readonly-tuples)\n`readonly` tuples\n\nTypeScript 3.4 also introduces new support for `readonly` tuples. We can prefix any tuple type with the `readonly` keyword to make it a `readonly` tuple, much like we now can with array shorthand syntax. As you might expect, unlike ordinary tuples whose slots could be written to, `readonly` tuples only permit reading from those positions.\n\nts\n\n`   function foo(pair: readonly [string, string]) {    console.log(pair[0]); // okay    pair[1] = \"hello!\"; // error  }   `\n\nThe same way that ordinary tuples are types that extend from `Array` - a tuple with elements of type `T1`, `T2`, … `Tn` extends from `Array< T1 | T2 | … Tn >` - `readonly` tuples are types that extend from `ReadonlyArray`. So a `readonly` tuple with elements `T1`, `T2`, … `Tn` extends from `ReadonlyArray< T1 | T2 | … Tn`.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#readonly-mapped-type-modifiers-and-readonly-arrays)\n`readonly` mapped type modifiers and `readonly` arrays\n\nIn earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like `Boxify` could work on arrays and tuples alike.\n\nts\n\n`   interface Box<T> {    value: T;  }  type Boxify<T> = {    [K in keyof T]: Box<T[K]>;  };  // { a: Box<string>, b: Box<number> }  type A = Boxify<{ a: string; b: number }>;  // Array<Box<number>>  type B = Boxify<number[]>;  // [Box<string>, Box<number>]  type C = Boxify<[string, boolean]>;   `\n\nUnfortunately, mapped types like the `Readonly` utility type were effectively no-ops on array and tuple types.\n\nts\n\n`   // lib.d.ts  type Readonly<T> = {    readonly [K in keyof T]: T[K];  };  // How code acted *before* TypeScript 3.4  // { readonly a: string, readonly b: number }  type A = Readonly<{ a: string; b: number }>;  // number[]  type B = Readonly<number[]>;  // [string, boolean]  type C = Readonly<[string, boolean]>;   `\n\nIn TypeScript 3.4, the `readonly` modifier in a mapped type will automatically convert array-like types to their corresponding `readonly` counterparts.\n\nts\n\n`   // How code acts now *with* TypeScript 3.4  // { readonly a: string, readonly b: number }  type A = Readonly<{ a: string; b: number }>;  // readonly number[]  type B = Readonly<number[]>;  // readonly [string, boolean]  type C = Readonly<[string, boolean]>;   `\n\nSimilarly, you could write a utility type like `Writable` mapped type that strips away `readonly`\\-ness, and that would convert `readonly` array containers back to their mutable equivalents.\n\nts\n\n`   type Writable<T> = {    -readonly [K in keyof T]: T[K];  };  // { a: string, b: number }  type A = Writable<{    readonly a: string;    readonly b: number;  }>;  // number[]  type B = Writable<readonly number[]>;  // [string, boolean]  type C = Writable<readonly [string, boolean]>;   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#caveats)\nCaveats\n\nDespite its appearance, the `readonly` type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.\n\nts\n\n`   let err1: readonly Set<number>; // error!  let err2: readonly Array<boolean>; // error!  let okay: readonly boolean[]; // works fine   `\n\nYou can [see more details in the pull request](https://github.com/Microsoft/TypeScript/pull/29435)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)\n`const` assertions\n----------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.4 introduces a new construct for literal values called _`const`_ assertions. Its syntax is a type assertion with `const` in place of the type name (e.g. `123 as const`). When we construct new literal expressions with `const` assertions, we can signal to the language that\n\n*   no literal types in that expression should be widened (e.g. no going from `\"hello\"` to `string`)\n*   object literals get `readonly` properties\n*   array literals become `readonly` tuples\n\nts\n\n`   // Type '\"hello\"'  let x = \"hello\" as const;  // Type 'readonly [10, 20]'  let y = [10, 20] as const;  // Type '{ readonly text: \"hello\" }'  let z = { text: \"hello\" } as const;   `\n\nOutside of `.tsx` files, the angle bracket assertion syntax can also be used.\n\nts\n\n`   // Type '\"hello\"'  let x = <const>\"hello\";  // Type 'readonly [10, 20]'  let y = <const>[10, 20];  // Type '{ readonly text: \"hello\" }'  let z = <const>{ text: \"hello\" };   `\n\nThis feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.\n\nts\n\n`   // Works with no types referenced or declared.  // We only needed a single const assertion.  function getShapes() {    let result = [      { kind: \"circle\", radius: 100 },      { kind: \"square\", sideLength: 50 },    ] as const;    return result;  }  for (const shape of getShapes()) {    // Narrows perfectly!    if (shape.kind === \"circle\") {      console.log(\"Circle radius\", shape.radius);    } else {      console.log(\"Square side length\", shape.sideLength);    }  }   `\n\nNotice the above needed no type annotations. The `const` assertion allowed TypeScript to take the most specific type of the expression.\n\nThis can even be used to enable `enum`\\-like patterns in plain JavaScript code if you choose not to use TypeScript’s `enum` construct.\n\nts\n\n`   export const Colors = {    red: \"RED\",    blue: \"BLUE\",    green: \"GREEN\",  } as const;  // or use an 'export default'  export default {    red: \"RED\",    blue: \"BLUE\",    green: \"GREEN\",  } as const;   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#caveats-1)\nCaveats\n\nOne thing to note is that `const` assertions can only be applied immediately on simple literal expressions.\n\nts\n\n`   // Error! A 'const' assertion can only be applied to a  // to a string, number, boolean, array, or object literal.  let a = (Math.random() < 0.5 ? 0 : 1) as const;  let b = (60 * 60 * 1000) as const;  // Works!  let c = Math.random() < 0.5 ? (0 as const) : (1 as const);  let d = 3_600_000 as const;   `\n\nAnother thing to keep in mind is that `const` contexts don’t immediately convert an expression to be fully immutable.\n\nts\n\n`   let arr = [1, 2, 3, 4];  let foo = {    name: \"foo\",    contents: arr,  } as const;  foo.name = \"bar\"; // error!  foo.contents = []; // error!  foo.contents.push(5); // ...works!   `\n\nFor more details, you can [check out the respective pull request](https://github.com/Microsoft/TypeScript/pull/29510)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#type-checking-for-globalthis)\nType-checking for `globalThis`\n----------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.4 introduces support for type-checking ECMAScript’s new `globalThis` - a global variable that, well, refers to the global scope. Unlike the above solutions, `globalThis` provides a standard way for accessing the global scope which can be used across different environments.\n\nts\n\n`   // in a global file:  var abc = 100;  // Refers to 'abc' from above.  globalThis.abc = 200;   `\n\nNote that global variables declared with `let` and `const` don’t show up on `globalThis`.\n\nts\n\n`   let answer = 42;  // error! Property 'answer' does not exist on 'typeof globalThis'.  globalThis.answer = 333333;   `\n\nIt’s also important to note that TypeScript doesn’t transform references to `globalThis` when compiling to older versions of ECMAScript. As such, unless you’re targeting evergreen browsers (which already support `globalThis`), you may want to [use an appropriate polyfill](https://github.com/ljharb/globalThis)\n instead.\n\nFor more details on the implementation, see [the feature’s pull request](https://github.com/Microsoft/TypeScript/pull/29332)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.4.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (51)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)\n\nOT![Orta Therox  (14)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nMU![Masato Urai  (1)](https://gravatar.com/avatar/ed67cd61e7c19e1081270e954cbe4249efd9429305d34b6c43061196ee05a6eb?s=32&&d=blank)\n\nMC![Max Coplan  (1)](https://gravatar.com/avatar/1dfb515c7b19e61f20f82434b22f300150b95e456f8442a8f868c3dff10bdd29?s=32&&d=blank)\n\n3+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - TypeScript 3.4","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","ogTitle":"Documentation - TypeScript 3.4","description":"TypeScript 3.4 Release Notes","ogDescription":"TypeScript 3.4 Release Notes","language":"en","theme-color":"#3178C6","og:description":"TypeScript 3.4 Release Notes","twitter:site":"typescriptlang","generator":"Gatsby 5.13.5","og:title":"Documentation - TypeScript 3.4","scrapeId":"07e7b607-504c-443a-a937-444b6e8d8670","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.1\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#mapped-types-on-tuples-and-arrays)\nMapped types on tuples and arrays\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 3.1, mapped object types[\\[1\\]](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#ts-3-1-only-homomorphic)\n over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like `push()`, `pop()`, and `length` are converted. For example:\n\nts\n\n`   type MapToPromise<T> = { [K in keyof T]: Promise<T[K]> };  type Coordinate = [number, number];  type PromiseCoordinate = MapToPromise<Coordinate>; // [Promise<number>, Promise<number>]   `\n\n`MapToPromise` takes a type `T`, and when that type is a tuple like `Coordinate`, only the numeric properties are converted. In `[number, number]`, there are two numerically named properties: `0` and `1`. When given a tuple like that, `MapToPromise` will create a new tuple where the `0` and `1` properties are `Promise`s of the original type. So the resulting type `PromiseCoordinate` ends up with the type `[Promise<number>, Promise<number>]`.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#properties-declarations-on-functions)\nProperties declarations on functions\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.1 brings the ability to define properties on function declarations and `const`\\-declared functions, simply by assigning to properties on these functions in the same scope. This allows us to write canonical JavaScript code without resorting to `namespace` hacks. For example:\n\nts\n\n`   function readImage(path: string, callback: (err: any, image: Image) => void) {    // ...  }  readImage.sync = (path: string) => {    const contents = fs.readFileSync(path);    return decodeImageSync(contents);  };   `\n\nHere, we have a function `readImage` which reads an image in a non-blocking asynchronous way. In addition to `readImage`, we’ve provided a convenience function on `readImage` itself called `readImage.sync`.\n\nWhile ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to “just work” in TypeScript. Additionally, this approach for property declarations allows us to express common patterns like `defaultProps` and `propTypes` on React function components (formerly known as SFCs).\n\nts\n\n`   export const FooComponent = ({ name }) => <div>Hello! I am {name}</div>;  FooComponent.defaultProps = {    name: \"(anonymous)\",  };   `\n\n* * *\n\n\\[1\\] More specifically, homomorphic mapped types like in the above form.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#version-selection-with-typesversions)\nVersion selection with `typesVersions`\n--------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nFeedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called `typesVersions` to help accommodate these scenarios.\n\nYou can read [about it in the Publishing section of the declaration files section](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#version-selection-with-typesversions)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.1.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (51)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)\n\nOT![Orta Therox  (18)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nCF![Cory Forsyth  (1)](https://gravatar.com/avatar/eaf35fd3c3ff412f3d279155b1e8462ebb92ade6ae8b9cb46eb9c7b42431d039?s=32&&d=blank)\n\nMU![Masato Urai  (1)](https://gravatar.com/avatar/ed67cd61e7c19e1081270e954cbe4249efd9429305d34b6c43061196ee05a6eb?s=32&&d=blank)\n\nSS![Sebastian Silbermann  (1)](https://gravatar.com/avatar/8909c1e1d9b64fd5db83ca8e0d7e16a5?s=32&&d=blank)\n\n10+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","ogDescription":"TypeScript 3.1 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","description":"TypeScript 3.1 Release Notes","og:title":"Documentation - TypeScript 3.1","ogTitle":"Documentation - TypeScript 3.1","theme-color":"#3178C6","generator":"Gatsby 5.13.5","og:description":"TypeScript 3.1 Release Notes","twitter:site":"typescriptlang","title":"TypeScript: Documentation - TypeScript 3.1","scrapeId":"039ddcbd-6bc1-4397-b358-aedc29653ebe","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.2\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#strictbindcallapply)\n`strictBindCallApply`\n----------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.2 introduces a new [`strictBindCallApply`](https://www.typescriptlang.org/tsconfig#strictBindCallApply)\n compiler option (in the [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n family of options) with which the `bind`, `call`, and `apply` methods on function objects are strongly typed and strictly checked.\n\nts\n\n`   function foo(a: number, b: string): string {    return a + b;  }  let a = foo.apply(undefined, [10]); // error: too few arguments  let b = foo.apply(undefined, [10, 20]); // error: 2nd argument is a number  let c = foo.apply(undefined, [10, \"hello\", 30]); // error: too many arguments  let d = foo.apply(undefined, [10, \"hello\"]); // okay! returns a string   `\n\nThis is achieved by introducing two new types, `CallableFunction` and `NewableFunction`, in `lib.d.ts`. These types contain specialized generic method declarations for `bind`, `call`, and `apply` for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In [`strictBindCallApply`](https://www.typescriptlang.org/tsconfig#strictBindCallApply)\n mode these declarations are used in place of the (very permissive) declarations provided by type `Function`.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#caveats)\nCaveats\n--------------------------------------------------------------------------------------------------\n\nSince the stricter checks may uncover previously unreported errors, this is a breaking change in [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n mode.\n\nAdditionally, [another caveat](https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450)\n of this new functionality is that due to certain limitations, `bind`, `call`, and `apply` can’t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type (`{}`), and when used on a function with overloads, only the last overload will ever be modeled.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#generic-spread-expressions-in-object-literals)\nGeneric spread expressions in object literals\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the `Object.assign` function and JSX literals. For example:\n\nts\n\n`   function taggedObject<T, U extends string>(obj: T, tag: U) {    return { ...obj, tag }; // T & { tag: U }  }  let x = taggedObject({ x: 10, y: 20 }, \"point\"); // { x: number, y: number } & { tag: \"point\" }   `\n\nProperty assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:\n\nts\n\n`   function foo1<T>(t: T, obj1: { a: string }, obj2: { b: string }) {    return { ...obj1, x: 1, ...t, ...obj2, y: 2 }; // { a: string, x: number } & T & { b: string, y: number }  }   `\n\nNon-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:\n\nts\n\n`   function spread<T, U>(t: T, u: U) {    return { ...t, ...u }; // T & U  }  declare let x: { a: string; b: number };  declare let y: { b: string; c: boolean };  let s1 = { ...x, ...y }; // { a: string, b: string, c: boolean }  let s2 = spread(x, y); // { a: string, b: number } & { b: string, c: boolean }  let b1 = s1.b; // string  let b2 = s2.b; // number & string   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#generic-object-rest-variables-and-parameters)\nGeneric object rest variables and parameters\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined `Pick` and `Exclude` helper types from `lib.d.ts`, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.\n\nts\n\n`   function excludeTag<T extends { tag: string }>(obj: T) {    let { tag, ...rest } = obj;    return rest; // Pick<T, Exclude<keyof T, \"tag\">>  }  const taggedPoint = { x: 10, y: 20, tag: \"point\" };  const point = excludeTag(taggedPoint); // { x: number, y: number }   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint)\nBigInt\n------------------------------------------------------------------------------------------------\n\nBigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting `esnext`.\n\nBigInt support in TypeScript introduces a new primitive type called the `bigint` (all lowercase). You can get a `bigint` by calling the `BigInt()` function or by writing out a BigInt literal by adding an `n` to the end of any integer numeric literal:\n\nts\n\n`   let foo: bigint = BigInt(100); // the BigInt function  let bar: bigint = 100n; // a BigInt literal  // *Slaps roof of fibonacci function*  // This bad boy returns ints that can get *so* big!  function fibonacci(n: bigint) {    let result = 1n;    for (let last = 0n, i = 0n; i < n; i++) {      const current = result;      result += last;      last = current;    }    return result;  }  fibonacci(10000n);   `\n\nWhile you might imagine close interaction between `number` and `bigint`, the two are separate domains.\n\nts\n\n`   declare let foo: number;  declare let bar: bigint;  foo = bar; // error: Type 'bigint' is not assignable to type 'number'.  bar = foo; // error: Type 'number' is not assignable to type 'bigint'.   `\n\nAs specified in ECMAScript, mixing `number`s and `bigint`s in arithmetic operations is an error. You’ll have to explicitly convert values to `BigInt`s.\n\nts\n\n`   console.log(3.141592 * 10000n); // error  console.log(3145 * 10n); // error  console.log(BigInt(3145) * 10n); // okay!   `\n\nAlso important to note is that `bigint`s produce a new string when using the `typeof` operator: the string `\"bigint\"`. Thus, TypeScript correctly narrows using `typeof` as you’d expect.\n\nts\n\n`   function whatKindOfNumberIsIt(x: number | bigint) {    if (typeof x === \"bigint\") {      console.log(\"'x' is a bigint!\");    } else {      console.log(\"'x' is a floating-point number\");    }  }   `\n\nWe’d like to extend a huge thanks to [Caleb Sander](https://github.com/calebsander)\n for all the work on this feature. We’re grateful for the contribution, and we’re sure our users are too!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#caveats-1)\nCaveats\n----------------------------------------------------------------------------------------------------\n\nAs we mentioned, BigInt support is only available for the `esnext` target. It may not be obvious, but because BigInts have different behavior for mathematical operators like `+`, `-`, `*`, etc., providing functionality for older targets where the feature doesn’t exist (like `es2017` and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.\n\nFor that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you’ll be able to use BigInts there when targeting `esnext`.\n\nCertain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add `esnext.bigint` to the [`lib`](https://www.typescriptlang.org/tsconfig#lib)\n setting in your compiler options.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#non-unit-types-as-union-discriminants)\nNon-unit types as union discriminants\n--------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property. Common properties of unions are now considered discriminants as long as they contain _some_ singleton type (e.g. a string literal, `null`, or `undefined`), and they contain no generics.\n\nAs a result, TypeScript 3.2 considers the `error` property in the following example to be a discriminant, whereas before it wouldn’t since `Error` isn’t a singleton type. Thanks to this, narrowing works correctly in the body of the `unwrap` function.\n\nts\n\n`   type Result<T> = { error: Error; data: null } | { error: null; data: T };  function unwrap<T>(result: Result<T>) {    if (result.error) {      // Here 'error' is non-null      throw result.error;    }    // Now 'data' is non-null    return result.data;  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#tsconfigjson-inheritance-via-nodejs-packages)\n`tsconfig.json` inheritance via Node.js packages\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.2 now resolves `tsconfig.json`s from `node_modules`. When using a bare path for the `extends` field in `tsconfig.json`, TypeScript will dive into `node_modules` packages for us.\n\n`   {    \"[extends](https://www.typescriptlang.org/tsconfig#extends) \": \"@my-team/tsconfig-base\",    \"[include](https://www.typescriptlang.org/tsconfig#include) \": [\"./**/*\"],    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      // Override certain options on a project-by-project basis.      \"[strictBindCallApply](https://www.typescriptlang.org/tsconfig#strictBindCallApply) \": false    }  }   `\n\nHere, TypeScript will climb up `node_modules` folders looking for a `@my-team/tsconfig-base` package. For each of those packages, TypeScript will first check whether `package.json` contains a `\"tsconfig\"` field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a `tsconfig.json` at the root. This is similar to the lookup process for `.js` files in packages that Node uses, and the `.d.ts` lookup process that TypeScript already uses.\n\nThis feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#the-new---showconfig-flag)\nThe new `--showConfig` flag\n----------------------------------------------------------------------------------------------------------------------------------------\n\n`tsc`, the TypeScript compiler, supports a new flag called `--showConfig`. When running `tsc --showConfig`, TypeScript will calculate the effective `tsconfig.json` (after calculating options inherited from the `extends` field) and print that out. This can be useful for diagnosing configuration issues in general.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#objectdefineproperty-declarations-in-javascript)\n`Object.defineProperty` declarations in JavaScript\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen writing in JavaScript files (using [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)\n), TypeScript now recognizes declarations that use `Object.defineProperty`. This means you’ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs)\n option or adding a `// @ts-check` comment to the top of your file).\n\njs\n\n`   // @ts-check  let obj = {};  Object.defineProperty(obj, \"x\", { value: \"hello\", writable: false });  obj.x.toLowercase();  //    ~~~~~~~~~~~  //    error:  //     Property 'toLowercase' does not exist on type 'string'.  //     Did you mean 'toLowerCase'?  obj.x = \"world\";  //  ~  //  error:  //   Cannot assign to 'x' because it is a read-only property.   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.2.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (52)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)\n\nOT![Orta Therox  (14)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nNS![Nick Schonning  (1)](https://gravatar.com/avatar/a490b76edb21047df004539971c9258a6c3bd8da6bc3ca94c89da3e6398ef08e?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nMU![Masato Urai  (1)](https://gravatar.com/avatar/ed67cd61e7c19e1081270e954cbe4249efd9429305d34b6c43061196ee05a6eb?s=32&&d=blank)\n\n2+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"TypeScript 3.2 Release Notes","theme-color":"#3178C6","description":"TypeScript 3.2 Release Notes","og:title":"Documentation - TypeScript 3.2","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","og:description":"TypeScript 3.2 Release Notes","twitter:site":"typescriptlang","ogTitle":"Documentation - TypeScript 3.2","language":"en","title":"TypeScript: Documentation - TypeScript 3.2","scrapeId":"9d704d0f-2ecd-4900-a51b-9b5b292334f5","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.0\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#project-references)\nProject References\n------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.0 introduces a new concept of project references. Project references allow TypeScript projects to depend on other TypeScript projects - specifically, allowing `tsconfig.json` files to reference other `tsconfig.json` files. Specifying these dependencies makes it easier to split your code into smaller projects, since it gives TypeScript (and tools around it) a way to understand build ordering and output structure.\n\nTypeScript 3.0 also introduces a new mode for tsc, the `--build` flag, that works hand-in-hand with project references to enable faster TypeScript builds.\n\nSee [Project References handbook page](https://www.typescriptlang.org/docs/handbook/project-references.html)\n for more documentation.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#tuples-in-rest-parameters-and-spread-expressions)\nTuples in rest parameters and spread expressions\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.0 adds support to multiple new capabilities to interact with function parameter lists as tuple types. TypeScript 3.0 adds support for:\n\n*   [Expansion of rest parameters with tuple types into discrete parameters.](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#rest-parameters-with-tuple-types)\n    \n*   [Expansion of spread expressions with tuple types into discrete arguments.](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#spread-expressions-with-tuple-types)\n    \n*   [Generic rest parameters and corresponding inference of tuple types.](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#generic-rest-parameters)\n    \n*   [Optional elements in tuple types.](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#optional-elements-in-tuple-types)\n    \n*   [Rest elements in tuple types.](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#rest-elements-in-tuple-types)\n    \n\nWith these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#rest-parameters-with-tuple-types)\nRest parameters with tuple types\n----------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen a rest parameter has a tuple type, the tuple type is expanded into a sequence of discrete parameters. For example the following two declarations are equivalent:\n\nts\n\n`   declare function foo(...args: [number, string, boolean]): void;   `\n\nts\n\n`   declare function foo(args_0: number, args_1: string, args_2: boolean): void;   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#spread-expressions-with-tuple-types)\nSpread expressions with tuple types\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen a function call includes a spread expression of a tuple type as the last argument, the spread expression corresponds to a sequence of discrete arguments of the tuple element types.\n\nThus, the following calls are equivalent:\n\nts\n\n`   const args: [number, string, boolean] = [42, \"hello\", true];  foo(42, \"hello\", true);  foo(args[0], args[1], args[2]);  foo(...args);   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#generic-rest-parameters)\nGeneric rest parameters\n----------------------------------------------------------------------------------------------------------------------------------\n\nA rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:\n\n##### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#example)\nExample\n\nts\n\n`   declare function bind<T, U extends any[], V>(    f: (x: T, ...args: U) => V,    x: T  ): (...args: U) => V;  declare function f3(x: number, y: string, z: boolean): void;  const f2 = bind(f3, 42); // (y: string, z: boolean) => void  const f1 = bind(f2, \"hello\"); // (z: boolean) => void  const f0 = bind(f1, true); // () => void  f3(42, \"hello\", true);  f2(\"hello\", true);  f1(true);  f0();   `\n\nIn the declaration of `f2` above, type inference infers types `number`, `[string, boolean]` and `void` for `T`, `U` and `V` respectively.\n\nNote that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for `U`, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#optional-elements-in-tuple-types)\nOptional elements in tuple types\n----------------------------------------------------------------------------------------------------------------------------------------------------\n\nTuple types now permit a `?` postfix on element types to indicate that the element is optional:\n\n##### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#example-1)\nExample\n\nts\n\n`   let t: [number, string?, boolean?];  t = [42, \"hello\", true];  t = [42, \"hello\"];  t = [42];   `\n\nIn [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n mode, a `?` modifier automatically includes `undefined` in the element type, similar to optional parameters.\n\nA tuple type permits an element to be omitted if it has a postfix `?` modifier on its type and all elements to the right of it also have `?` modifiers.\n\nWhen tuple types are inferred for rest parameters, optional parameters in the source become optional tuple elements in the inferred type.\n\nThe `length` property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the `length` property in the tuple type `[number, string?, boolean?]` is `1 | 2 | 3`.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#rest-elements-in-tuple-types)\nRest elements in tuple types\n\nThe last element of a tuple type can be a rest element of the form `...X`, where `X` is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, `[number, ...string[]]` means tuples with a `number` element followed by any number of `string` elements.\n\n##### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#example-2)\nExample\n\nts\n\n`   function tuple<T extends any[]>(...args: T): T {    return args;  }  const numbers: number[] = getArrayOfNumbers();  const t1 = tuple(\"foo\", 1, true); // [string, number, boolean]  const t2 = tuple(\"bar\", ...numbers); // [string, ...number[]]   `\n\nThe type of the `length` property of a tuple type with a rest element is `number`.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type)\nNew `unknown` top type\n------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.0 introduces a new top type `unknown`. `unknown` is the type-safe counterpart of `any`. Anything is assignable to `unknown`, but `unknown` isn’t assignable to anything but itself and `any` without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an `unknown` without first asserting or narrowing to a more specific type.\n\n##### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#example-3)\nExample\n\nts\n\n`   // In an intersection everything absorbs unknown  type T00 = unknown & null; // null  type T01 = unknown & undefined; // undefined  type T02 = unknown & null & undefined; // null & undefined (which becomes never)  type T03 = unknown & string; // string  type T04 = unknown & string[]; // string[]  type T05 = unknown & unknown; // unknown  type T06 = unknown & any; // any  // In a union an unknown absorbs everything  type T10 = unknown | null; // unknown  type T11 = unknown | undefined; // unknown  type T12 = unknown | null | undefined; // unknown  type T13 = unknown | string; // unknown  type T14 = unknown | string[]; // unknown  type T15 = unknown | unknown; // unknown  type T16 = unknown | any; // any  // Type variable and unknown in union and intersection  type T20<T> = T & {}; // T & {}  type T21<T> = T | {}; // T | {}  type T22<T> = T & unknown; // T  type T23<T> = T | unknown; // unknown  // unknown in conditional types  type T30<T> = unknown extends T ? true : false; // Deferred  type T31<T> = T extends unknown ? true : false; // Deferred (so it distributes)  type T32<T> = never extends T ? true : false; // true  type T33<T> = T extends never ? true : false; // Deferred  // keyof unknown  type T40 = keyof any; // string | number | symbol  type T41 = keyof unknown; // never  // Only equality operators are allowed with unknown  function f10(x: unknown) {    x == 5;    x !== 10;    x >= 0; // Error    x + 1; // Error    x * 2; // Error    -x; // Error    +x; // Error  }  // No property accesses, element accesses, or function calls  function f11(x: unknown) {    x.foo; // Error    x[5]; // Error    x(); // Error    new x(); // Error  }  // typeof, instanceof, and user defined type predicates  declare function isFunction(x: unknown): x is Function;  function f20(x: unknown) {    if (typeof x === \"string\" || typeof x === \"number\") {      x; // string | number    }    if (x instanceof Error) {      x; // Error    }    if (isFunction(x)) {      x; // Function    }  }  // Homomorphic mapped type over unknown  type T50<T> = { [P in keyof T]: number };  type T51 = T50<any>; // { [x: string]: number }  type T52 = T50<unknown>; // {}  // Anything is assignable to unknown  function f21<T>(pAny: any, pNever: never, pT: T) {    let x: unknown;    x = 123;    x = \"hello\";    x = [1, 2, 3];    x = new Error();    x = x;    x = pAny;    x = pNever;    x = pT;  }  // unknown assignable only to itself and any  function f22(x: unknown) {    let v1: any = x;    let v2: unknown = x;    let v3: object = x; // Error    let v4: string = x; // Error    let v5: string[] = x; // Error    let v6: {} = x; // Error    let v7: {} | null | undefined = x; // Error  }  // Type parameter 'T extends unknown' not related to object  function f23<T extends unknown>(x: T) {    let y: object = x; // Error  }  // Anything but primitive assignable to { [x: string]: unknown }  function f24(x: { [x: string]: unknown }) {    x = {};    x = { a: 5 };    x = [1, 2, 3];    x = 123; // Error  }  // Locals of type unknown always considered initialized  function f25() {    let x: unknown;    let y = x;  }  // Spread of unknown causes result to be unknown  function f26(x: {}, y: unknown, z: any) {    let o1 = { a: 42, ...x }; // { a: number }    let o2 = { a: 42, ...x, ...y }; // unknown    let o3 = { a: 42, ...x, ...y, ...z }; // any  }  // Functions with unknown return type don't need return expressions  function f27(): unknown {}  // Rest type cannot be created from unknown  function f28(x: unknown) {    let { ...a } = x; // Error  }  // Class properties of type unknown don't need definite assignment  class C1 {    a: string; // Error    b: unknown;    c: any;  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx)\nSupport for `defaultProps` in JSX\n----------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 2.9 and earlier didn’t leverage [React `defaultProps`](https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values)\n declarations inside JSX components. Users would often have to declare properties optional and use non-null assertions inside of `render`, or they’d use type-assertions to fix up the type of the component before exporting it.\n\nTypeScript 3.0 adds support for a new type alias in the `JSX` namespace called `LibraryManagedAttributes`. This helper type defines a transformation on the component’s `Props` type, before using to check a JSX expression targeting it; thus allowing customization like: how conflicts between provided props and inferred props are handled, how inferences are mapped, how optionality is handled, and how inferences from differing places should be combined.\n\nIn short using this general type, we can model React’s specific behavior for things like `defaultProps` and, to some extent, `propTypes`.\n\ntsx\n\n`   export interface Props {    name: string;  }  export class Greet extends React.Component<Props> {    render() {      const { name } = this.props;      return <div>Hello {name.toUpperCase()}!</div>;    }    static defaultProps = { name: \"world\" };  }  // Type-checks! No type assertions needed!  let el = <Greet />;   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#caveats)\nCaveats\n--------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#explicit-types-on-defaultprops)\nExplicit types on `defaultProps`\n\nThe default-ed properties are inferred from the `defaultProps` property type. If an explicit type annotation is added, e.g. `static defaultProps: Partial<Props>;` the compiler will not be able to identify which properties have defaults (since the type of `defaultProps` include all properties of `Props`).\n\nUse `static defaultProps: Pick<Props, \"name\">;` as an explicit type annotation instead, or do not add a type annotation as done in the example above.\n\nFor function components (formerly known as SFCs) use ES2015 default initializers:\n\ntsx\n\n`   function Greet({ name = \"world\" }: Props) {    return <div>Hello {name.toUpperCase()}!</div>;  }   `\n\n#### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#changes-to-typesreact)\nChanges to `@types/React`\n\nCorresponding changes to add `LibraryManagedAttributes` definition to the `JSX` namespace in `@types/React` are still needed. Keep in mind that there are some limitations.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#-reference-lib--reference-directives)\n`/// <reference lib=\"...\" />` reference directives\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript adds a new triple-slash-reference directive (`/// <reference lib=\"name\" />`), allowing a file to explicitly include an existing built-in _lib_ file.\n\nBuilt-in _lib_ files are referenced in the same fashion as the [`lib`](https://www.typescriptlang.org/tsconfig#lib)\n compiler option in _tsconfig.json_ (e.g. use `lib=\"es2015\"` and not `lib=\"lib.es2015.d.ts\"`, etc.).\n\nFor declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like `Symbol` or `Iterable`, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.\n\n##### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#example-4)\nExample\n\nUsing `/// <reference lib=\"es2017.string\" />` to one of the files in a compilation is equivalent to compiling with `--lib es2017.string`.\n\nts\n\n`   /// <reference lib=\"es2017.string\" />  \"foo\".padStart(4);   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.0.md)\n ❤\n\nContributors to this page:  \n\nMH![Mohamed Hegazy  (53)](https://gravatar.com/avatar/17e2da9785d45119a4c4cfed99e40d9c?s=32&&d=blank)\n\nOT![Orta Therox  (13)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nRC![Ryan Cavanaugh  (2)](https://gravatar.com/avatar/2484d99c8a58bc51ae587e07a05ba6e2?s=32&&d=blank)\n\nRI![Ruslan Iusupov  (2)](https://gravatar.com/avatar/e4eb89fda2c3d3f54efa810a9ba9b0da?s=32&&d=blank)\n\nEI![Eugene Ilyin  (1)](https://gravatar.com/avatar/a65caef54cbaba95975117e96ca2d411668cedaea6e5bbc59287ed673c84751e?s=32&&d=blank)\n\n11+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"theme-color":"#3178C6","og:description":"TypeScript 3.0 Release Notes","ogTitle":"Documentation - TypeScript 3.0","ogDescription":"TypeScript 3.0 Release Notes","og:title":"Documentation - TypeScript 3.0","title":"TypeScript: Documentation - TypeScript 3.0","language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","generator":"Gatsby 5.13.5","description":"TypeScript 3.0 Release Notes","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","scrapeId":"58679723-e2d6-44dd-8c6f-06c6c113068f","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.3\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html#improved-behavior-for-calling-union-types)\nImproved behavior for calling union types\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn prior versions of TypeScript, unions of callable types could _only_ be invoked if they had identical parameter lists.\n\nts\n\n`   type Fruit = \"apple\" | \"orange\";  type Color = \"red\" | \"orange\";  type FruitEater = (fruit: Fruit) => number; // eats and ranks the fruit  type ColorConsumer = (color: Color) => string; // consumes and describes the colors  declare let f: FruitEater | ColorConsumer;  // Cannot invoke an expression whose type lacks a call signature.  //   Type 'FruitEater | ColorConsumer' has no compatible call signatures.ts(2349)  f(\"orange\");   `\n\nHowever, in the above example, both `FruitEater`s and `ColorConsumer`s should be able to take the string `\"orange\"`, and return either a `number` or a `string`.\n\nIn TypeScript 3.3, this is no longer an error.\n\nts\n\n`   type Fruit = \"apple\" | \"orange\";  type Color = \"red\" | \"orange\";  type FruitEater = (fruit: Fruit) => number; // eats and ranks the fruit  type ColorConsumer = (color: Color) => string; // consumes and describes the colors  declare let f: FruitEater | ColorConsumer;  f(\"orange\"); // It works! Returns a 'number | string'.  f(\"apple\"); // error - Argument of type '\"apple\"' is not assignable to parameter of type '\"orange\"'.  f(\"red\"); // error - Argument of type '\"red\"' is not assignable to parameter of type '\"orange\"'.   `\n\nIn TypeScript 3.3, the parameters of these signatures are _intersected_ together to create a new signature.\n\nIn the example above, the parameters `fruit` and `color` are intersected together to a new parameter of type `Fruit & Color`. `Fruit & Color` is really the same as `(\"apple\" | \"orange\") & (\"red\" | \"orange\")` which is equivalent to `(\"apple\" & \"red\") | (\"apple\" & \"orange\") | (\"orange\" & \"red\") | (\"orange\" & \"orange\")`. Each of those impossible intersections reduces to `never`, and we’re left with `\"orange\" & \"orange\"` which is just `\"orange\"`.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html#caveats)\nCaveats\n--------------------------------------------------------------------------------------------------\n\nThis new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on `number[] | string[]` like `map` (which is generic) still won’t be callable.\n\nOn the other hand, methods like `forEach` will now be callable, but under [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n there may be some issues.\n\nts\n\n`   interface Dog {    kind: \"dog\";    dogProp: any;  }  interface Cat {    kind: \"cat\";    catProp: any;  }  const catOrDogArray: Dog[] | Cat[] = [];  catOrDogArray.forEach(animal => {    //                ~~~~~~ error!    // Parameter 'animal' implicitly has an 'any' type.  });   `\n\nThis is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.\n\nts\n\n`   interface Dog {    kind: \"dog\";    dogProp: any;  }  interface Cat {    kind: \"cat\";    catProp: any;  }  const catOrDogArray: Dog[] | Cat[] = [];  catOrDogArray.forEach((animal: Dog | Cat) => {    if (animal.kind === \"dog\") {      animal.dogProp;      // ...    } else if (animal.kind === \"cat\") {      animal.catProp;      // ...    }  });   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html#incremental-file-watching-for-composite-projects-in---build---watch)\nIncremental file watching for composite projects in `--build --watch`\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.0 introduced a new feature for structuring builds called “composite projects”. Part of the goal here was to ensure users could break up large projects into smaller parts that build quickly and preserve project structure, without compromising the existing TypeScript experience. Thanks to composite projects, TypeScript can use `--build` mode to recompile only the set of projects and dependencies. You can think of this as optimizing _inter_\\-project builds.\n\nTypeScript 2.7 also introduced `--watch` mode builds via a new incremental “builder” API. In a similar vein, the entire idea is that this mode only re-checks and re-emits changed files or files whose dependencies might impact type-checking. You can think of this as optimizing _intra_\\-project builds.\n\nPrior to 3.3, building composite projects using `--build --watch` actually didn’t use this incremental file watching infrastructure. An update in one project under `--build --watch` mode would force a full build of that project, rather than determining which files within that project were affected.\n\nIn TypeScript 3.3, `--build` mode’s `--watch` flag _does_ leverage incremental file watching as well. That can mean significantly faster builds under `--build --watch`. In our testing, this functionality has resulted in **a reduction of 50% to 75% in build times** of the original `--build --watch` times. [You can read more on the original pull request for the change](https://github.com/Microsoft/TypeScript/pull/29161)\n to see specific numbers, but we believe most composite project users will see significant wins here.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.3.md)\n ❤\n\nContributors to this page:  \n\nDR![Daniel Rosenwasser  (51)](https://gravatar.com/avatar/96588baac26f6b833dfd1ed0cd084287?s=32&&d=blank)\n\nOT![Orta Therox  (12)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nNS![Nick Schonning  (1)](https://gravatar.com/avatar/a490b76edb21047df004539971c9258a6c3bd8da6bc3ca94c89da3e6398ef08e?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nRA![Riley Avron  (1)](https://gravatar.com/avatar/ed9a8af14efbb5b912454280c1419fc3?s=32&&d=blank)\n\n3+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","generator":"Gatsby 5.13.5","theme-color":"#3178C6","title":"TypeScript: Documentation - TypeScript 3.3","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"TypeScript 3.3 Release Notes","ogTitle":"Documentation - TypeScript 3.3","ogDescription":"TypeScript 3.3 Release Notes","og:title":"Documentation - TypeScript 3.3","og:description":"TypeScript 3.3 Release Notes","scrapeId":"b63bfbd9-537b-473c-a7b0-5af6de355aa4","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 5.3\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#import-attributes)\nImport Attributes\n----------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.3 supports the latest updates to the [import attributes](https://github.com/tc39/proposal-import-attributes)\n proposal.\n\nOne use-case of import attributes is to provide information about the expected format of a module to the runtime.\n\nts\n\n``   // We only want this to be interpreted as JSON,  // not a runnable/malicious JavaScript file with a `.json` extension.  import obj from \"./something.json\" with { type: \"json\" };   ``\n\nThe contents of these attributes are not checked by TypeScript since they’re host-specific, and are simply left alone so that browsers and runtimes can handle them (and possibly error).\n\nts\n\n`   // TypeScript is fine with this.  // But your browser? Probably not.  import * as foo from \"./foo.js\" with { type: \"fluffy bunny\" };   `\n\nDynamic `import()` calls can also use import attributes through a second argument.\n\nts\n\n`   const obj = await import(\"./something.json\", {      with: { type: \"json\" }  });   `\n\nThe expected type of that second argument is defined by a type called `ImportCallOptions`, which by default just expects a property called `with`.\n\nNote that import attributes are an evolution of an earlier proposal called [“import assertions”, which were implemented in TypeScript 4.5](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#import-assertions)\n. The most obvious difference is the use of the `with` keyword over the `assert` keyword. But the less-visible difference is that runtimes are now free to use attributes to guide the resolution and interpretation of import paths, whereas import assertions could only assert some characteristics after loading a module.\n\nOver time, TypeScript will be deprecating the old syntax for import assertions in favor of the proposed syntax for import attributes. Existing code using `assert` should migrate towards the `with` keyword. New code that needs an import attribute should use `with` exclusively.\n\nWe’d like to thank [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n for [implementing this proposal](https://github.com/microsoft/TypeScript/pull/54242)\n! And we’d also like to call out [Wenlu Wang](https://github.com/Kingwl)\n for their implementation of [import assertions](https://github.com/microsoft/TypeScript/pull/40698)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#stable-support-resolution-mode-in-import-types)\nStable Support `resolution-mode` in Import Types\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 4.7, TypeScript added support for a `resolution-mode` attribute in `/// <reference types=\"...\" />` to control whether a specifier should be resolved via `import` or `require` semantics.\n\nts\n\n`   /// <reference types=\"pkg\" resolution-mode=\"require\" />  // or  /// <reference types=\"pkg\" resolution-mode=\"import\" />   `\n\nA corresponding field was added to import assertions on type-only imports as well; however, it was only supported in nightly versions of TypeScript. The rationale was that in spirit, import _assertions_ were not intended to guide module resolution. So this feature was shipped experimentally in a nightly-only mode to get more feedback.\n\nBut given that _[import attributes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#import-attributes)\n_ can guide resolution, and that we’ve seen reasonable use-cases, TypeScript 5.3 now supports the `resolution-mode` attribute for `import type`.\n\nts\n\n``   // Resolve `pkg` as if we were importing with a `require()`  import type { TypeFromRequire } from \"pkg\" with {      \"resolution-mode\": \"require\"  };  // Resolve `pkg` as if we were importing with an `import`  import type { TypeFromImport } from \"pkg\" with {      \"resolution-mode\": \"import\"  };  export interface MergedType extends TypeFromRequire, TypeFromImport {}   ``\n\nThese import attributes can also be used on `import()` types.\n\nts\n\n`   export type TypeFromRequire =      import(\"pkg\", { with: { \"resolution-mode\": \"require\" } }).TypeFromRequire;  export type TypeFromImport =      import(\"pkg\", { with: { \"resolution-mode\": \"import\" } }).TypeFromImport;  export interface MergedType extends TypeFromRequire, TypeFromImport {}   `\n\nFor more information, [check out the change here](https://github.com/microsoft/TypeScript/pull/55725)\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#resolution-mode-supported-in-all-module-modes)\n`resolution-mode` Supported in All Module Modes\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPreviously, using `resolution-mode` was only allowed under the `moduleResolution` options `node16` and `nodenext`. To make it easier to look up modules specifically for type purposes, `resolution-mode` now works appropriately in all other `moduleResolution` options like `bundler`, `node10`, and simply doesn’t error under `classic`.\n\nFor more information, [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/55725)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#switch-true-narrowing)\n`switch (true)` Narrowing\n----------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.3 now can perform narrowing based on conditions in each `case` clause within a `switch (true)`.\n\nts\n\n`   function f(x: unknown) {      switch (true) {          case typeof x === \"string\":              // 'x' is a 'string' here              console.log(x.toUpperCase());              // falls through...          case Array.isArray(x):              // 'x' is a 'string | any[]' here.              console.log(x.length);              // falls through...          default:            // 'x' is 'unknown' here.            // ...      }  }   `\n\n[This feature](https://github.com/microsoft/TypeScript/pull/55991)\n was spearheaded [initial work](https://github.com/microsoft/TypeScript/pull/53681)\n by [Mateusz Burzyński](https://github.com/Andarist)\n We’d like to extend a “thank you!” for this contribution.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#narrowing-on-comparisons-to-booleans)\nNarrowing On Comparisons to Booleans\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nOccasionally you may find yourself performing a direct comparison with `true` or `false` in a condition. Usually these are unnecessary comparisons, but you might prefer it as a point of style, or to avoid certain issues around JavaScript truthiness. Regardless, previously TypeScript just didn’t recognize such forms when performing narrowing.\n\nTypeScript 5.3 now keeps up and understands these expressions when narrowing variables.\n\nts\n\n`   interface A {      a: string;  }  interface B {      b: string;  }  type MyType = A | B;  function isA(x: MyType): x is A {      return \"a\" in x;  }  function someFn(x: MyType) {      if (isA(x) === true) {          console.log(x.a); // works!      }  }   `\n\nWe’d like to thank [Mateusz Burzyński](https://github.com/Andarist)\n for [the pull request](https://github.com/microsoft/TypeScript/pull/53681)\n that implemented this.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#instanceof-narrowing-through-symbolhasinstance)\n`instanceof` Narrowing Through `Symbol.hasInstance`\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nA slightly esoteric feature of JavaScript is that it is possible to override the behavior of the `instanceof` operator. To do so, the value on the right side of the `instanceof` operator needs to have a specific method named by `Symbol.hasInstance`.\n\njs\n\n`   class Weirdo {      static [Symbol.hasInstance](testedValue) {          // wait, what?          return testedValue === undefined;      }  }  // false  console.log(new Thing() instanceof Weirdo);  // true  console.log(undefined instanceof Weirdo);   `\n\nTo better model this behavior in `instanceof`, TypeScript now checks if such a `[Symbol.hasInstance]` method exists and is declared as a type predicate function. If it does, the tested value on the left side of the `instanceof` operator will be narrowed appropriately by that type predicate.\n\nts\n\n`   interface PointLike {      x: number;      y: number;  }  class Point implements PointLike {      x: number;      y: number;      constructor(x: number, y: number) {          this.x = x;          this.y = y;      }      distanceFromOrigin() {          return Math.sqrt(this.x ** 2 + this.y ** 2);      }      static [Symbol.hasInstance](val: unknown): val is PointLike {          return !!val && typeof val === \"object\" &&              \"x\" in val && \"y\" in val &&              typeof val.x === \"number\" &&              typeof val.y === \"number\";      }  }  function f(value: unknown) {      if (value instanceof Point) {          // Can access both of these - correct!          value.x;          value.y;          // Can't access this - we have a 'PointLike',          // but we don't *actually* have a 'Point'.          value.distanceFromOrigin();      }  }   `\n\nAs you can see in this example, `Point` defines its own `[Symbol.hasInstance]` method. It actually acts as a custom type guard over a separate type called `PointLike`. In the function `f`, we were able to narrow `value` down to a `PointLike` with `instanceof`, but _not_ a `Point`. That means that we can access the properties `x` and `y`, but not the method `distanceFromOrigin`.\n\nFor more information, you can [read up on this change here](https://github.com/microsoft/TypeScript/pull/55052)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#checks-for-super-property-accesses-on-instance-fields)\nChecks for `super` Property Accesses on Instance Fields\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript, it’s possible to access a declaration in a base class through the `super` keyword.\n\njs\n\n`   class Base {      someMethod() {          console.log(\"Base method called!\");      }  }  class Derived extends Base {      someMethod() {          console.log(\"Derived method called!\");          super.someMethod();      }  }  new Derived().someMethod();  // Prints:  //   Derived method called!  //   Base method called!   `\n\nThis is different from writing something like `this.someMethod()`, since that could invoke an overridden method. This is a subtle distinction, made more subtle by the fact that often the two can be interchangeable if a declaration is never overridden at all.\n\njs\n\n`   class Base {      someMethod() {          console.log(\"someMethod called!\");      }  }  class Derived extends Base {      someOtherMethod() {          // These act identically.          this.someMethod();          super.someMethod();      }  }  new Derived().someOtherMethod();  // Prints:  //   someMethod called!  //   someMethod called!   `\n\nThe problem is using them interchangeably is that `super` only works on members declared on the prototype — _not_ instance properties. That means that if you wrote `super.someMethod()`, but `someMethod` was defined as a field, you’d get a runtime error!\n\nts\n\n`   class Base {      someMethod = () => {          console.log(\"someMethod called!\");      }  }  class Derived extends Base {      someOtherMethod() {          super.someMethod();      }  }  new Derived().someOtherMethod();  // 💥  // Doesn't work because 'super.someMethod' is 'undefined'.   `\n\nTypeScript 5.3 now more-closely inspects `super` property accesses/method calls to see if they correspond to class fields. If they do, we’ll now get a type-checking error.\n\n[This check](https://github.com/microsoft/TypeScript/pull/54056)\n was contributed thanks to [Jack Works](https://github.com/Jack-Works)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#interactive-inlay-hints-for-types)\nInteractive Inlay Hints for Types\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s inlay hints now support jumping to the definition of types! This makes it easier to casually navigate your code.\n\n![Ctrl-clicking an inlay hint to jump to the definition of a parameter type.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/10/clickable-inlay-hints-for-types-5-3-beta.gif)\n\nSee more at [the implementation here](https://github.com/microsoft/TypeScript/pull/55141)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#settings-to-prefer-type-auto-imports)\nSettings to Prefer `type` Auto-Imports\n--------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPreviously when TypeScript generated auto-imports for something in a type position, it would add a `type` modifier based on your settings. For example, when getting an auto-import on `Person` in the following:\n\nts\n\n`   export let p: Person   `\n\nTypeScript’s editing experience would usually add an import for `Person` as:\n\nts\n\n`   import { Person } from \"./types\";  export let p: Person   `\n\nand under certain settings like `verbatimModuleSyntax`, it would add the `type` modifier:\n\nts\n\n`   import { type Person } from \"./types\";  export let p: Person   `\n\nHowever, maybe your codebase isn’t able to use some of these options; or you just have a preference for explicit `type` imports when possible.\n\n[With a recent change](https://github.com/microsoft/TypeScript/pull/56090)\n, TypeScript now enables this to be an editor-specific option. In Visual Studio Code, you can enable it in the UI under “TypeScript › Preferences: Prefer Type Only Auto Imports”, or as the JSON configuration option `typescript.preferences.preferTypeOnlyAutoImports`\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#optimizations-by-skipping-jsdoc-parsing)\nOptimizations by Skipping JSDoc Parsing\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen running TypeScript via `tsc`, the compiler will now avoid parsing JSDoc. This drops parsing time on its own, but also reduces memory usage to store comments along with time spent in garbage collection. All-in-all, you should see slightly faster compiles and quicker feedback in `--watch` mode.\n\n[The specific changes can be viewed here](https://github.com/microsoft/TypeScript/pull/52921)\n.\n\nBecause not every tool using TypeScript will need to store JSDoc (e.g. typescript-eslint and Prettier), this parsing strategy has been surfaced as part of the API itself. This can enable these tools to gain the same memory and speed improvements we’ve brought to the TypeScript compiler. The new options for comment parsing strategy are described in `JSDocParsingMode`. More information is available [on this pull request](https://github.com/microsoft/TypeScript/pull/55739)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#optimizations-by-comparing-non-normalized-intersections)\nOptimizations by Comparing Non-Normalized Intersections\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript, unions and intersections always follow a specific form, where intersections can’t contain union types. That means that when we create an intersection over a union like `A & (B | C)`, that intersection will be normalized into `(A & B) | (A & C)`. Still, in some cases the type system will maintain the original form for display purposes.\n\nIt turns out that the original form can be used for some clever fast-path comparisons between types.\n\nFor example, let’s say we have `SomeType & (Type1 | Type2 | ... | Type99999NINE)` and we want to see if that’s assignable to `SomeType`. Recall that we don’t really have an intersection as our source type — we have a union that looks like `(SomeType & Type1) | (SomeType & Type2) | ... |(SomeType & Type99999NINE)`. When checking if a union is assignable to some target type, we have to check if _every_ member of the union is assignable to the target type, and that can be very slow.\n\nIn TypeScript 5.3, we peek at the original intersection form that we were able to tuck away. When we compare the types, we do a quick check to see if the target exists in any constituent of the source intersection.\n\nFor more information, [see this pull request](https://github.com/microsoft/TypeScript/pull/55851)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#consolidation-between-tsserverlibraryjs-and-typescriptjs)\nConsolidation Between `tsserverlibrary.js` and `typescript.js`\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript itself ships two library files: `tsserverlibrary.js` and `typescript.js`. There are certain APIs available only in `tsserverlibrary.js` (like the `ProjectService` API), which may be useful to some importers. Still, the two are distinct bundles with a lot of overlap, duplicating code in the package. What’s more, it can be challenging to consistently use one over the other due to auto-imports or muscle memory. Accidentally loading both modules is far too easy, and code may not work properly on a different instance of the API. Even if it does work, loading a second bundle increases resource usage.\n\nGiven this, we’ve decided to consolidate the two. `typescript.js` now contains what `tsserverlibrary.js` used to contain, and `tsserverlibrary.js` now simply re-exports `typescript.js`. Comparing the before/after of this consolidation, we saw the following reduction in package size:\n\n|     | Before | After | Diff | Diff (percent) |\n| --- | --- | --- | --- | --- |\n| Packed | 6.90 MiB | 5.48 MiB | \\-1.42 MiB | \\-20.61% |\n| Unpacked | 38.74 MiB | 30.41 MiB | \\-8.33 MiB | \\-21.50% |\n\n|     | Before | After | Diff | Diff (percent) |\n| --- | --- | --- | --- | --- |\n| `lib/tsserverlibrary.d.ts` | 570.95 KiB | 865.00 B | \\-570.10 KiB | \\-99.85% |\n| `lib/tsserverlibrary.js` | 8.57 MiB | 1012.00 B | \\-8.57 MiB | \\-99.99% |\n| `lib/typescript.d.ts` | 396.27 KiB | 570.95 KiB | +174.68 KiB | +44.08% |\n| `lib/typescript.js` | 7.95 MiB | 8.57 MiB | +637.53 KiB | +7.84% |\n\nIn other words, this is over a 20.5% reduction in package size.\n\nFor more information, you can [see the work involved here](https://github.com/microsoft/TypeScript/pull/55273)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#breaking-changes-and-correctness-improvements)\nBreaking Changes and Correctness Improvements\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#libdts-changes)\n`lib.d.ts` Changes\n\nTypes generated for the DOM may have an impact on your codebase. For more information, [see the DOM updates for TypeScript 5.3](https://github.com/microsoft/TypeScript/pull/55798)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html#checks-for-super-accesses-on-instance-properties)\nChecks for `super` Accesses on Instance Properties\n\nTypeScript 5.3 now detects when the declaration referenced by a `super.` property access is a class field and issues an error. This prevents errors that might occur at runtime.\n\n[See more on this change here](https://github.com/microsoft/TypeScript/pull/54056)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%205.3.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (6)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nEL![Eliran Levi  (1)](https://gravatar.com/avatar/f00fd5d066bb6174a9369ab456ce99bbc444afa281ff050a70a8a6cb0820894a?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"twitter:site":"typescriptlang","og:description":"TypeScript 5.3 Release Notes","ogDescription":"TypeScript 5.3 Release Notes","theme-color":"#3178C6","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","description":"TypeScript 5.3 Release Notes","title":"TypeScript: Documentation - TypeScript 5.3","generator":"Gatsby 5.13.5","ogTitle":"Documentation - TypeScript 5.3","og:title":"Documentation - TypeScript 5.3","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","scrapeId":"d4f7ecd8-f14c-449d-9f1d-4f4c803adf2c","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 5.2\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#using-declarations-and-explicit-resource-management)\n`using` Declarations and Explicit Resource Management\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.2 adds support for the upcoming [Explicit Resource Management](https://github.com/tc39/proposal-explicit-resource-management)\n feature in ECMAScript. Let’s explore some of the motivations and understand what the feature brings us.\n\nIt’s common to need to do some sort of “clean-up” after creating an object. For example, you might need to close network connections, delete temporary files, or just free up some memory.\n\nLet’s imagine a function that creates a temporary file, reads and writes to it for various operations, and then closes and deletes it.\n\nts\n\n`   import * as fs from \"fs\";  export function doSomeWork() {      const path = \".some_temp_file\";      const file = fs.openSync(path, \"w+\");      // use file...      // Close the file and delete it.      fs.closeSync(file);      fs.unlinkSync(path);  }   `\n\nThis is fine, but what happens if we need to perform an early exit?\n\nts\n\n`   export function doSomeWork() {      const path = \".some_temp_file\";      const file = fs.openSync(path, \"w+\");      // use file...      if (someCondition()) {          // do some more work...          // Close the file and delete it.          fs.closeSync(file);          fs.unlinkSync(path);          return;      }      // Close the file and delete it.      fs.closeSync(file);      fs.unlinkSync(path);  }   `\n\nWe’re starting to see some duplication of clean-up which can be easy to forget. We’re also not guaranteed to close and delete the file if an error gets thrown. This could be solved by wrapping this all in a `try`/`finally` block.\n\nts\n\n`   export function doSomeWork() {      const path = \".some_temp_file\";      const file = fs.openSync(path, \"w+\");      try {          // use file...          if (someCondition()) {              // do some more work...              return;          }      }      finally {          // Close the file and delete it.          fs.closeSync(file);          fs.unlinkSync(path);      }  }   `\n\nWhile this is more robust, it’s added quite a bit of “noise” to our code. There are also other foot-guns we can run into if we start adding more clean-up logic to our `finally` block — for example, exceptions preventing other resources from being disposed. This is what the [explicit resource management](https://github.com/tc39/proposal-explicit-resource-management)\n proposal aims to solve. The key idea of the proposal is to support resource disposal — this clean-up work we’re trying to deal with — as a first class idea in JavaScript.\n\nThis starts by adding a new built-in `symbol` called `Symbol.dispose`, and we can create objects with methods named by `Symbol.dispose`. For convenience, TypeScript defines a new global type called `Disposable` which describes these.\n\nts\n\n`   class TempFile implements Disposable {      #path: string;      #handle: number;      constructor(path: string) {          this.#path = path;          this.#handle = fs.openSync(path, \"w+\");      }      // other methods      [Symbol.dispose]() {          // Close the file and delete it.          fs.closeSync(this.#handle);          fs.unlinkSync(this.#path);      }  }   `\n\nLater on we can call those methods.\n\nts\n\n`   export function doSomeWork() {      const file = new TempFile(\".some_temp_file\");      try {          // ...      }      finally {          file[Symbol.dispose]();      }  }   `\n\nMoving the clean-up logic to `TempFile` itself doesn’t buy us much; we’ve basically just moved all the clean-up work from the `finally` block into a method, and that’s always been possible. But having a well-known “name” for this method means that JavaScript can build other features on top of it.\n\nThat brings us to the first star of the feature: `using` declarations! `using` is a new keyword that lets us declare new fixed bindings, kind of like `const`. The key difference is that variables declared with `using` get their `Symbol.dispose` method called at the end of the scope!\n\nSo we could simply have written our code like this:\n\nts\n\n`   export function doSomeWork() {      using file = new TempFile(\".some_temp_file\");      // use file...      if (someCondition()) {          // do some more work...          return;      }  }   `\n\nCheck it out — no `try`/`finally` blocks! At least, none that we see. Functionally, that’s exactly what `using` declarations will do for us, but we don’t have to deal with that.\n\nYou might be familiar with [`using` declarations in C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/using)\n, [`with` statements in Python](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement)\n, or [`try`\\-with-resource declarations in Java](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)\n. These are all similar to JavaScript’s new `using` keyword, and provide a similar explicit way to perform a “tear-down” of an object at the end of a scope.\n\n`using` declarations do this clean-up at the very end of their containing scope or right before an “early return” like a `return` or a `throw`n error. They also dispose in a first-in-last-out order like a stack.\n\nts\n\n``   function loggy(id: string): Disposable {      console.log(`Creating ${id}`);      return {          [Symbol.dispose]() {              console.log(`Disposing ${id}`);          }      }  }  function func() {      using a = loggy(\"a\");      using b = loggy(\"b\");      {          using c = loggy(\"c\");          using d = loggy(\"d\");      }      using e = loggy(\"e\");      return;      // Unreachable.      // Never created, never disposed.      using f = loggy(\"f\");  }  func();  // Creating a  // Creating b  // Creating c  // Creating d  // Disposing d  // Disposing c  // Creating e  // Disposing e  // Disposing b  // Disposing a   ``\n\n`using` declarations are supposed to be resilient to exceptions; if an error is thrown, it’s rethrown after disposal. On the other hand, the body of your function might execute as expected, but the `Symbol.dispose` might throw. In that case, that exception is rethrown as well.\n\nBut what happens if both the logic before and during disposal throws an error? For those cases, `SuppressedError` has been introduced as a new subtype of `Error`. It features a `suppressed` property that holds the last-thrown error, and an `error` property for the most-recently thrown error.\n\nts\n\n``   class ErrorA extends Error {      name = \"ErrorA\";  }  class ErrorB extends Error {      name = \"ErrorB\";  }  function throwy(id: string) {      return {          [Symbol.dispose]() {              throw new ErrorA(`Error from ${id}`);          }      };  }  function func() {      using a = throwy(\"a\");      throw new ErrorB(\"oops!\")  }  try {      func();  }  catch (e: any) {      console.log(e.name); // SuppressedError      console.log(e.message); // An error was suppressed during disposal.      console.log(e.error.name); // ErrorA      console.log(e.error.message); // Error from a      console.log(e.suppressed.name); // ErrorB      console.log(e.suppressed.message); // oops!  }   ``\n\nYou might have noticed that we’re using synchronous methods in these examples. However, lots of resource disposal involves _asynchronous_ operations, and we need to wait for those to complete before we continue running any other code.\n\nThat’s why there is also a new `Symbol.asyncDispose`, and it brings us to the next star of the show — `await using` declarations. These are similar to `using` declarations, but the key is that they look up whose disposal must be `await`ed. They use a different method named by `Symbol.asyncDispose`, though they can operate on anything with a `Symbol.dispose` as well. For convenience, TypeScript also introduces a global type called `AsyncDisposable` that describes any object with an asynchronous dispose method.\n\nts\n\n``   async function doWork() {      // Do fake work for half a second.      await new Promise(resolve => setTimeout(resolve, 500));  }  function loggy(id: string): AsyncDisposable {      console.log(`Constructing ${id}`);      return {          async [Symbol.asyncDispose]() {              console.log(`Disposing (async) ${id}`);              await doWork();          },      }  }  async function func() {      await using a = loggy(\"a\");      await using b = loggy(\"b\");      {          await using c = loggy(\"c\");          await using d = loggy(\"d\");      }      await using e = loggy(\"e\");      return;      // Unreachable.      // Never created, never disposed.      await using f = loggy(\"f\");  }  func();  // Constructing a  // Constructing b  // Constructing c  // Constructing d  // Disposing (async) d  // Disposing (async) c  // Constructing e  // Disposing (async) e  // Disposing (async) b  // Disposing (async) a   ``\n\nDefining types in terms of `Disposable` and `AsyncDisposable` can make your code much easier to work with if you expect others to do tear-down logic consistently. In fact, lots of existing types exist in the wild which have a `dispose()` or `close()` method. For example, the Visual Studio Code APIs even define [their own `Disposable` interface](https://code.visualstudio.com/api/references/vscode-api#Disposable)\n. APIs in the browser and in runtimes like Node.js, Deno, and Bun might also choose to use `Symbol.dispose` and `Symbol.asyncDispose` for objects which already have clean-up methods, like file handles, connections, and more.\n\nNow maybe this all sounds great for libraries, but a little bit heavy-weight for your scenarios. If you’re doing a lot of ad-hoc clean-up, creating a new type might introduce a lot of over-abstraction and questions about best-practices. For example, take our `TempFile` example again.\n\nts\n\n`   class TempFile implements Disposable {      #path: string;      #handle: number;      constructor(path: string) {          this.#path = path;          this.#handle = fs.openSync(path, \"w+\");      }      // other methods      [Symbol.dispose]() {          // Close the file and delete it.          fs.closeSync(this.#handle);          fs.unlinkSync(this.#path);      }  }  export function doSomeWork() {      using file = new TempFile(\".some_temp_file\");      // use file...      if (someCondition()) {          // do some more work...          return;      }  }   `\n\nAll we wanted was to remember to call two functions — but was this the best way to write it? Should we be calling `openSync` in the constructor, create an `open()` method, or pass in the handle ourselves? Should we expose a method for every possible operation we need to perform, or should we just make the properties public?\n\nThat brings us to the final stars of the feature: `DisposableStack` and `AsyncDisposableStack`. These objects are useful for doing both one-off clean-up, along with arbitrary amounts of cleanup. A `DisposableStack` is an object that has several methods for keeping track of `Disposable` objects, and can be given functions for doing arbitrary clean-up work. We can also assign them to `using` variables because — get this — _they’re also `Disposable`_! So here’s how we could’ve written the original example.\n\nts\n\n`   function doSomeWork() {      const path = \".some_temp_file\";      const file = fs.openSync(path, \"w+\");      using cleanup = new DisposableStack();      cleanup.defer(() => {          fs.closeSync(file);          fs.unlinkSync(path);      });      // use file...      if (someCondition()) {          // do some more work...          return;      }      // ...  }   `\n\nHere, the `defer()` method just takes a callback, and that callback will be run once `cleanup` is disposed of. Typically, `defer` (and other `DisposableStack` methods like `use` and `adopt`) should be called immediately after creating a resource. As the name suggests, `DisposableStack` disposes of everything it keeps track of like a stack, in a first-in-last-out order, so `defer`ing immediately after creating a value helps avoid odd dependency issues. `AsyncDisposableStack` works similarly, but can keep track of `async` functions and `AsyncDisposable`s, and is itself an `AsyncDisposable.`\n\nThe `defer` method is similar in many ways to the `defer` keyword in [Go](https://go.dev/tour/flowcontrol/12)\n, [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/statements/#Defer-Statement)\n, [Zig](https://ziglang.org/documentation/master/#defer)\n, [Odin](https://odin-lang.org/docs/overview/#defer-statement)\n, and others, where the conventions should be similar.\n\nBecause this feature is so recent, most runtimes will not support it natively. To use it, you will need runtime polyfills for the following:\n\n*   `Symbol.dispose`\n*   `Symbol.asyncDispose`\n*   `DisposableStack`\n*   `AsyncDisposableStack`\n*   `SuppressedError`\n\nHowever, if all you’re interested in is `using` and `await using`, you should be able to get away with only polyfilling the built-in `symbol`s. Something as simple as the following should work for most cases:\n\nts\n\n`   Symbol.dispose ??= Symbol(\"Symbol.dispose\");  Symbol.asyncDispose ??= Symbol(\"Symbol.asyncDispose\");   `\n\nYou will also need to set your compilation `target` to `es2022` or below, and configure your `lib` setting to either include `\"esnext\"` or `\"esnext.disposable\"`.\n\njson\n\n`   {      \"compilerOptions\": {          \"target\": \"es2022\",          \"lib\": [\"es2022\", \"esnext.disposable\", \"dom\"]      }  }   `\n\nFor more information on this feature, [take a look at the work on GitHub](https://github.com/microsoft/TypeScript/pull/54505)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#decorator-metadata)\nDecorator Metadata\n------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.2 implements [an upcoming ECMAScript feature called decorator metadata](https://github.com/tc39/proposal-decorator-metadata)\n.\n\nThe key idea of this feature is to make it easy for decorators to create and consume metadata on any class they’re used on or within.\n\nWhenever decorator functions are used, they now have access to a new `metadata` property on their context object. The `metadata` property just holds a simple object. Since JavaScript lets us add properties arbitrarily, it can be used as a dictionary that is updated by each decorator. Alternatively, since every `metadata` object will be identical for each decorated portion of a class, it can be used as a key into a `Map`. After all decorators on or in a class get run, that object can be accessed on the class via `Symbol.metadata`.\n\nts\n\n`   interface Context {      name: string;      metadata: Record<PropertyKey, unknown>;  }  function setMetadata(_target: any, context: Context) {      context.metadata[context.name] = true;  }  class SomeClass {      @setMetadata      foo = 123;      @setMetadata      accessor bar = \"hello!\";      @setMetadata      baz() { }  }  const ourMetadata = SomeClass[Symbol.metadata];  console.log(JSON.stringify(ourMetadata));  // { \"bar\": true, \"baz\": true, \"foo\": true }   `\n\nThis can be useful in a number of different scenarios. Metadata could possibly be attached for lots of uses like debugging, serialization, or performing dependency injection with decorators. Since metadata objects are created per decorated class, frameworks can either privately use them as keys into a `Map` or `WeakMap`, or tack properties on as necessary.\n\nFor example, let’s say we wanted to use decorators to keep track of which properties and accessors are serializable when using `JSON.stringify` like so:\n\nts\n\n``   import { serialize, jsonify } from \"./serializer\";  class Person {      firstName: string;      lastName: string;      @serialize      age: number      @serialize      get fullName() {          return `${this.firstName} ${this.lastName}`;      }      toJSON() {          return jsonify(this)      }      constructor(firstName: string, lastName: string, age: number) {          // ...      }  }   ``\n\nHere, the intent is that only `age` and `fullName` should be serialized because they are marked with the `@serialize` decorator. We define a `toJSON` method for this purpose, but it just calls out to `jsonify` which uses the metadata that `@serialize` created.\n\nHere’s an example of how the module `./serialize.ts` might be defined:\n\nts\n\n``   const serializables = Symbol();  type Context =      | ClassAccessorDecoratorContext      | ClassGetterDecoratorContext      | ClassFieldDecoratorContext      ;  export function serialize(_target: any, context: Context): void {      if (context.static || context.private) {          throw new Error(\"Can only serialize public instance members.\")      }      if (typeof context.name === \"symbol\") {          throw new Error(\"Cannot serialize symbol-named properties.\");      }      const propNames =          (context.metadata[serializables] as string[] | undefined) ??= [];      propNames.push(context.name);  }  export function jsonify(instance: object): string {      const metadata = instance.constructor[Symbol.metadata];      const propNames = metadata?.[serializables] as string[] | undefined;      if (!propNames) {          throw new Error(\"No members marked with @serialize.\");      }      const pairStrings = propNames.map(key => {          const strKey = JSON.stringify(key);          const strValue = JSON.stringify((instance as any)[key]);          return `${strKey}: ${strValue}`;      });      return `{ ${pairStrings.join(\", \")} }`;  }   ``\n\nThis module has a local `symbol` called `serializables` to store and retrieve the names of properties marked `@serializable`. It stores a list of these property names on the metadata on each invocation of `@serializable`. When `jsonify` is called, the list of properties is fetched off of the metadata and used to retrieve the actual values from the instance, eventually serializing those names and values.\n\nUsing a `symbol` technically makes this data accessible to others. An alternative might be to use a `WeakMap` using the metadata object as a key. This keeps data private and happens to use fewer type assertions in this case, but is otherwise similar.\n\nts\n\n``   const serializables = new WeakMap<object, string[]>();  type Context =      | ClassAccessorDecoratorContext      | ClassGetterDecoratorContext      | ClassFieldDecoratorContext      ;  export function serialize(_target: any, context: Context): void {      if (context.static || context.private) {          throw new Error(\"Can only serialize public instance members.\")      }      if (typeof context.name !== \"string\") {          throw new Error(\"Can only serialize string properties.\");      }      let propNames = serializables.get(context.metadata);      if (propNames === undefined) {          serializables.set(context.metadata, propNames = []);      }      propNames.push(context.name);  }  export function jsonify(instance: object): string {      const metadata = instance.constructor[Symbol.metadata];      const propNames = metadata && serializables.get(metadata);      if (!propNames) {          throw new Error(\"No members marked with @serialize.\");      }      const pairStrings = propNames.map(key => {          const strKey = JSON.stringify(key);          const strValue = JSON.stringify((instance as any)[key]);          return `${strKey}: ${strValue}`;      });      return `{ ${pairStrings.join(\", \")} }`;  }   ``\n\nAs a note, these implementations don’t handle subclassing and inheritance. That’s left as an exercise to you (and you might find that it is easier in one version of the file than the other!).\n\nBecause this feature is still fresh, most runtimes will not support it natively. To use it, you will need a polyfill for `Symbol.metadata`. Something as simple as the following should work for most cases:\n\nts\n\n`   Symbol.metadata ??= Symbol(\"Symbol.metadata\");   `\n\nYou will also need to set your compilation `target` to `es2022` or below, and configure your `lib` setting to either include `\"esnext\"` or `\"esnext.decorators\"`.\n\njson\n\n`   {      \"compilerOptions\": {          \"target\": \"es2022\",          \"lib\": [\"es2022\", \"esnext.decorators\", \"dom\"]      }  }   `\n\nWe’d like to thank [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n for contributing [the implementation of decorator metadata](https://github.com/microsoft/TypeScript/pull/54657)\n for TypeScript 5.2!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#named-and-anonymous-tuple-elements)\nNamed and Anonymous Tuple Elements\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTuple types have supported optional labels or names for each element.\n\nts\n\n`   type Pair<T> = [first: T, second: T];   `\n\nThese labels don’t change what you’re allowed to do with them — they’re solely to help with readability and tooling.\n\nHowever, TypeScript previously had a rule that tuples could not mix and match between labeled and unlabeled elements. In other words, either no element could have a label in a tuple, or all elements needed one.\n\nts\n\n`   // ✅ fine - no labels  type Pair1<T> = [T, T];  // ✅ fine - all fully labeled  type Pair2<T> = [first: T, second: T];  // ❌ previously an error  type Pair3<T> = [first: T, T];  //                         ~  // Tuple members must all have names  // or all not have names.   `\n\nThis could be annoying for rest elements where we’d be forced to just add a label like `rest` or `tail`.\n\nts\n\n`   // ❌ previously an error  type TwoOrMore_A<T> = [first: T, second: T, ...T[]];  //                                          ~~~~~~  // Tuple members must all have names  // or all not have names.  // ✅  type TwoOrMore_B<T> = [first: T, second: T, rest: ...T[]];   `\n\nIt also meant that this restriction had to be enforced internally in the type system, meaning TypeScript would lose labels.\n\nts\n\n`   type HasLabels = [a: string, b: string];  type HasNoLabels = [number, number];  type Merged = [...HasNoLabels, ...HasLabels];  //   ^ [number, number, string, string]  //  //     'a' and 'b' were lost in 'Merged'   `\n\nIn TypeScript 5.2, the all-or-nothing restriction on tuple labels has been lifted. The language can now also preserve labels when spreading into an unlabeled tuple.\n\nWe’d like to extend our thanks to [Josh Goldberg](https://github.com/JoshuaKGoldberg)\n and [Mateusz Burzyński](https://github.com/Andarist)\n who [collaborated to lift this restriction](https://github.com/microsoft/TypeScript/pull/53356)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#easier-method-usage-for-unions-of-arrays)\nEasier Method Usage for Unions of Arrays\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn previous versions of TypeScript, calling a method on a union of arrays could end in pain.\n\nts\n\n`   declare let array: string[] | number[];  array.filter(x => !!x);  //    ~~~~~~ error!  // This expression is not callable.  //   Each member of the union type '...' has signatures,  //   but none of those signatures are compatible  //   with each other.   `\n\nIn this example, TypeScript would try to see if each version of `filter` is compatible across `string[]` and `number[]`. Without a coherent strategy, TypeScript threw its hands in the air and said “I can’t make it work”.\n\nIn TypeScript 5.2, before giving up in these cases, unions of arrays are treated as a special case. A new array type is constructed out of each member’s element type, and then the method is invoked on that.\n\nTaking the above example, `string[] | number[]` is transformed into `(string | number)[]` (or `Array<string | number>`), and `filter` is invoked on that type. There is a slight caveat which is that `filter` will produce an `Array<string | number>` instead of a `string[] | number[]`; but for a freshly produced value there is less risk of something “going wrong”.\n\nThis means lots of methods like `filter`, `find`, `some`, `every`, and `reduce` should all be invokable on unions of arrays in cases where they were not previously.\n\nYou can [read up more details on the implementing pull request](https://github.com/microsoft/TypeScript/pull/53489)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#type-only-import-paths-with-typescript-implementation-file-extensions)\nType-Only Import Paths with TypeScript Implementation File Extensions\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript now allows both declaration _and_ implementation file extensions to be included in type-only import paths, regardless of whether `allowImportingTsExtensions` is enabled.\n\nThis means that you can now write `import type` statements that use `.ts`, `.mts`, `.cts`, and `.tsx` file extensions.\n\nts\n\n`   import type { JustAType } from \"./justTypes.ts\";  export function f(param: JustAType) {      // ...  }   `\n\nIt also means that `import()` types, which can be used in both TypeScript and JavaScript with JSDoc, can use those file extensions.\n\njs\n\n`   /**   * @param {import(\"./justTypes.ts\").JustAType} param   */  export function f(param) {      // ...  }   `\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/54746)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#comma-completions-for-object-members)\nComma Completions for Object Members\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIt can be easy to forget to add a comma when adding a new property to an object. Previously, if you forgot a comma and requested auto-completion, TypeScript would confusingly give poor unrelated completion results.\n\nTypeScript 5.2 now gracefully provides object member completions when you’re missing a comma. But to just skip past hitting you with a syntax error, it will _also_ auto-insert the missing comma.\n\n![Properties in an object literal are completed despite missing a comma after a prior property. When the property name is completed, the missing comma is automatically inserted.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/06/comma-completions-5-2-beta.gif)\n\nFor more information, [see the implementation here](https://github.com/microsoft/TypeScript/pull/52899)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#inline-variable-refactoring)\nInline Variable Refactoring\n------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.2 now has a refactoring to inline the contents of a variable to all usage sites.\n\n![A variable called 'path' initialized to a string, having both of its usages replaced](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/06/inline-variable-5-2-beta.gif).\n\nUsing the “inline variable” refactoring will eliminate the variable and replace all the variable’s usages with its initializer. Note that this may cause that initializer’s side-effects to run at a different time, and as many times as the variable has been used.\n\nFor more details, [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/54281)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#optimized-checks-for-ongoing-type-compatibility)\nOptimized Checks for Ongoing Type Compatibility\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBecause TypeScript is a structural type system, types occasionally need to be compared in a member-wise fashion; however, recursive types add some issues here. For example:\n\nts\n\n`   interface A {      value: A;      other: string;  }  interface B {      value: B;      other: number;  }   `\n\nWhen checking whether the type `A` is compatible with the type `B`, TypeScript will end up checking whether the types of `value` in `A` and `B` are respectively compatible. At this point, the type system needs to stop checking any further and proceed to check other members. To do this, the type system has to track when any two types are already being related.\n\nPreviously TypeScript already kept a stack of type pairs, and iterated through that to determine whether those types are being related. When this stack is shallow that’s not a problem; but when the stack isn’t shallow, that, uh, [is a problem](https://accidentallyquadratic.tumblr.com/)\n.\n\nIn TypeScript 5.3, a simple `Set` helps track this information. This reduced the time spent on a reported test case that used the [drizzle](https://github.com/drizzle-team/drizzle-orm)\n library by over 33%!\n\n`   Benchmark 1: old    Time (mean ± σ):      3.115 s ±  0.067 s    [User: 4.403 s, System: 0.124 s]    Range (min … max):    3.018 s …  3.196 s    10 runs  Benchmark 2: new    Time (mean ± σ):      2.072 s ±  0.050 s    [User: 3.355 s, System: 0.135 s]    Range (min … max):    1.985 s …  2.150 s    10 runs  Summary    'new' ran      1.50 ± 0.05 times faster than 'old'   `\n\n[Read more on the change here](https://github.com/microsoft/TypeScript/pull/55224)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#breaking-changes-and-correctness-fixes)\nBreaking Changes and Correctness Fixes\n----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript strives not to unnecessarily introduce breaks; however, occasionally we must make corrections and improvements so that code can be better-analyzed.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#libdts-changes)\n`lib.d.ts` Changes\n\nTypes generated for the DOM may have an impact on your codebase. For more information, [see the DOM updates for TypeScript 5.2](https://github.com/microsoft/TypeScript/pull/54725)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#labeledelementdeclarations-may-hold-undefined-elements)\n`labeledElementDeclarations` May Hold `undefined` Elements\n\nIn order [to support a mixture of labeled and unlabeled elements](https://github.com/microsoft/TypeScript/pull/53356)\n, TypeScript’s API has changed slightly. The `labeledElementDeclarations` property of `TupleType` may hold `undefined` for at each position where an element is unlabeled.\n\ndiff\n\n  `interface TupleType {  -     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];  +     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[];    }`\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#module-and-moduleresolution-must-match-under-recent-nodejs-settings)\n`module` and `moduleResolution` Must Match Under Recent Node.js settings\n\nThe `--module` and `--moduleResolution` options each support a `node16` and `nodenext` setting. These are effectively “modern Node.js” settings that should be used on any recent Node.js project. What we’ve found is that when these two options don’t agree on whether they are using Node.js-related settings, projects are effectively misconfigured.\n\nIn TypeScript 5.2, when using `node16` or `nodenext` for either of the `--module` and `--moduleResolution` options, TypeScript now requires the other to have a similar Node.js-related setting. In cases where the settings diverge, you’ll likely get an error message like either\n\n`   Option 'moduleResolution' must be set to 'NodeNext' (or left unspecified) when option 'module' is set to 'NodeNext'.   `\n\nor\n\n`   Option 'module' must be set to 'Node16' when option 'moduleResolution' is set to 'Node16'.   `\n\nSo for example `--module esnext --moduleResolution node16` will be rejected — but you may be better off just using `--module nodenext` alone, or `--module esnext --moduleResolution bundler`.\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/54567)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#consistent-export-checking-for-merged-symbols)\nConsistent Export Checking for Merged Symbols\n\nWhen two declarations merge, they must agree on whether they are both exported. Due to a bug, TypeScript missed specific cases in ambient contexts, like in declaration files or `declare module` blocks. For example, it would not issue an error on a case like the following, where `replaceInFile` is declared once as an exported function, and one as an un-exported namespace.\n\nts\n\n`   declare module 'replace-in-file' {      export function replaceInFile(config: unknown): Promise<unknown[]>;      export {};      namespace replaceInFile {          export function sync(config: unknown): unknown[];    }  }   `\n\nIn an ambient module, adding an `export { ... }` or a similar construct like `export default ...` implicitly changes whether all declarations are automatically exported. TypeScript now recognizes these unfortunately confusing semantics more consistently, and issues an error on the fact that all declarations of `replaceInFile` need to agree in their modifiers, and will issue the following error:\n\n`   Individual declarations in merged declaration 'replaceInFile' must be all exported or all local.   `\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/54659)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%205.2.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (6)](https://gravatar.com/avatar/aa8d4849bebf8520e56d85b1127185b1797030080f3b06c9e3975664c0d926b2?s=32&&d=blank)\n\nEI![Eugene Ilyin  (1)](https://gravatar.com/avatar/a65caef54cbaba95975117e96ca2d411668cedaea6e5bbc59287ed673c84751e?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"TypeScript 5.2 Release Notes","og:description":"TypeScript 5.2 Release Notes","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","description":"TypeScript 5.2 Release Notes","twitter:site":"typescriptlang","language":"en","title":"TypeScript: Documentation - TypeScript 5.2","ogTitle":"Documentation - TypeScript 5.2","theme-color":"#3178C6","og:title":"Documentation - TypeScript 5.2","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","scrapeId":"05ed8c27-edb6-4333-aef5-ddeba057a035","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.7\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining)\nOptional Chaining\n----------------------------------------------------------------------------------------------------------------------\n\n[Playground](https://www.typescriptlang.org/play/#example/optional-chaining)\n\nOptional chaining is [issue #16](https://github.com/microsoft/TypeScript/issues/16)\n on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.\n\nAt its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a `null` or `undefined`. The star of the show in optional chaining is the new `?.` operator for _optional property accesses_. When we write code like\n\nts\n\n`   let x = foo?.bar.baz();   `\n\nthis is a way of saying that when `foo` is defined, `foo.bar.baz()` will be computed; but when `foo` is `null` or `undefined`, stop what we’re doing and just return `undefined`.”\n\nMore plainly, that code snippet is the same as writing the following.\n\nts\n\n`   let x = foo === null || foo === undefined ? undefined : foo.bar.baz();   `\n\nNote that if `bar` is `null` or `undefined`, our code will still hit an error accessing `baz`. Likewise, if `baz` is `null` or `undefined`, we’ll hit an error at the call site. `?.` only checks for whether the value on the _left_ of it is `null` or `undefined` - not any of the subsequent properties.\n\nYou might find yourself using `?.` to replace a lot of code that performs repetitive nullish checks using the `&&` operator.\n\nts\n\n`   // Before  if (foo && foo.bar && foo.bar.baz) {    // ...  }  // After-ish  if (foo?.bar?.baz) {    // ...  }   `\n\nKeep in mind that `?.` acts differently than those `&&` operations since `&&` will act specially on “falsy” values (e.g. the empty string, `0`, `NaN`, and, well, `false`), but this is an intentional feature of the construct. It doesn’t short-circuit on valid data like `0` or empty strings.\n\nOptional chaining also includes two other operations. First there’s the _optional element access_ which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):\n\nts\n\n`   /**   * Get the first element of the array if we have an array.   * Otherwise return undefined.   */  function tryGetFirstElement<T>(arr?: T[]) {    return arr?.[0];    // equivalent to    //   return (arr === null || arr === undefined) ?    //       undefined :    //       arr[0];  }   `\n\nThere’s also _optional call_, which allows us to conditionally call expressions if they’re not `null` or `undefined`.\n\nts\n\n``   async function makeRequest(url: string, log?: (msg: string) => void) {    log?.(`Request started at ${new Date().toISOString()}`);    // roughly equivalent to    //   if (log != null) {    //       log(`Request started at ${new Date().toISOString()}`);    //   }    const result = (await fetch(url)).json();    log?.(`Request finished at ${new Date().toISOString()}`);    return result;  }   ``\n\nThe “short-circuiting” behavior that optional chains have is limited property accesses, calls, element accesses - it doesn’t expand any further out from these expressions. In other words,\n\nts\n\n`   let result = foo?.bar / someComputation();   `\n\ndoesn’t stop the division or `someComputation()` call from occurring. It’s equivalent to\n\nts\n\n`   let temp = foo === null || foo === undefined ? undefined : foo.bar;  let result = temp / someComputation();   `\n\nThat might result in dividing `undefined`, which is why in [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n, the following is an error.\n\nts\n\n`   function barPercentage(foo?: { bar: number }) {    return foo?.bar / 100;    //     ~~~~~~~~    // Error: Object is possibly undefined.  }   `\n\nMore more details, you can [read up on the proposal](https://github.com/tc39/proposal-optional-chaining/)\n and [view the original pull request](https://github.com/microsoft/TypeScript/pull/33294)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing)\nNullish Coalescing\n------------------------------------------------------------------------------------------------------------------------\n\n[Playground](https://www.typescriptlang.org/play/#example/nullish-coalescing)\n\nThe _nullish coalescing operator_ is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.\n\nYou can think of this feature - the `??` operator - as a way to “fall back” to a default value when dealing with `null` or `undefined`. When we write code like\n\nts\n\n`   let x = foo ?? bar();   `\n\nthis is a new way to say that the value `foo` will be used when it’s “present”; but when it’s `null` or `undefined`, calculate `bar()` in its place.\n\nAgain, the above code is equivalent to the following.\n\nts\n\n`   let x = foo !== null && foo !== undefined ? foo : bar();   `\n\nThe `??` operator can replace uses of `||` when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in [`localStorage`](https://developer.mozilla.org/docs/Web/API/Window/localStorage)\n (if it ever was); however, it has a bug because it uses `||`.\n\nts\n\n`   function initializeAudio() {    let volume = localStorage.volume || 0.5;    // ...  }   `\n\nWhen `localStorage.volume` is set to `0`, the page will set the volume to `0.5` which is unintended. `??` avoids some unintended behavior from `0`, `NaN` and `\"\"` being treated as falsy values.\n\nWe owe a large thanks to community members [Wenlu Wang](https://github.com/Kingwl)\n and [Titian Cernicova Dragomir](https://github.com/dragomirtitian)\n for implementing this feature! For more details, [check out their pull request](https://github.com/microsoft/TypeScript/pull/32883)\n and [the nullish coalescing proposal repository](https://github.com/tc39/proposal-nullish-coalescing/)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions)\nAssertion Functions\n--------------------------------------------------------------------------------------------------------------------------\n\n[Playground](https://www.typescriptlang.org/play/#example/assertion-functions)\n\nThere’s a specific set of functions that `throw` an error if something unexpected happened. They’re called “assertion” functions. As an example, Node.js has a dedicated function for this called `assert`.\n\njs\n\n`   assert(someValue === 42);   `\n\nIn this example if `someValue` isn’t equal to `42`, then `assert` will throw an `AssertionError`.\n\nAssertions in JavaScript are often used to guard against improper types being passed in. For example,\n\njs\n\n`   function multiply(x, y) {    assert(typeof x === \"number\");    assert(typeof y === \"number\");    return x * y;  }   `\n\nUnfortunately in TypeScript these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.\n\nts\n\n`   function yell(str) {    assert(typeof str === \"string\");    return str.toUppercase();    // Oops! We misspelled 'toUpperCase'.    // Would be great if TypeScript still caught this!  }   `\n\nThe alternative was to instead rewrite the code so that the language could analyze it, but this isn’t convenient.\n\nts\n\n`   function yell(str) {    if (typeof str !== \"string\") {      throw new TypeError(\"str should have been a string.\");    }    // Error caught!    return str.toUppercase();  }   `\n\nUltimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way. For that reason, TypeScript 3.7 introduces a new concept called “assertion signatures” which model these assertion functions.\n\nThe first type of assertion signature models the way that Node’s `assert` function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.\n\nts\n\n`   function assert(condition: any, msg?: string): asserts condition {    if (!condition) {      throw new AssertionError(msg);    }  }   `\n\n`asserts condition` says that whatever gets passed into the `condition` parameter must be true if the `assert` returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we _do_ catch our original `yell` example.\n\nts\n\n`   function yell(str) {    assert(typeof str === \"string\");    return str.toUppercase();    //         ~~~~~~~~~~~    // error: Property 'toUppercase' does not exist on type 'string'.    //        Did you mean 'toUpperCase'?  }  function assert(condition: any, msg?: string): asserts condition {    if (!condition) {      throw new AssertionError(msg);    }  }   `\n\nThe other type of assertion signature doesn’t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.\n\nts\n\n`   function assertIsString(val: any): asserts val is string {    if (typeof val !== \"string\") {      throw new AssertionError(\"Not a string!\");    }  }   `\n\nHere `asserts val is string` ensures that after any call to `assertIsString`, any variable passed in will be known to be a `string`.\n\nts\n\n`   function yell(str: any) {    assertIsString(str);    // Now TypeScript knows that 'str' is a 'string'.    return str.toUppercase();    //         ~~~~~~~~~~~    // error: Property 'toUppercase' does not exist on type 'string'.    //        Did you mean 'toUpperCase'?  }   `\n\nThese assertion signatures are very similar to writing type predicate signatures:\n\nts\n\n`   function isString(val: any): val is string {    return typeof val === \"string\";  }  function yell(str: any) {    if (isString(str)) {      return str.toUppercase();    }    throw \"Oops!\";  }   `\n\nAnd just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.\n\nts\n\n``   function assertIsDefined<T>(val: T): asserts val is NonNullable<T> {    if (val === undefined || val === null) {      throw new AssertionError(        `Expected 'val' to be defined, but received ${val}`      );    }  }   ``\n\nTo read up more about assertion signatures, [check out the original pull request](https://github.com/microsoft/TypeScript/pull/32695)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#better-support-for-never-returning-functions)\nBetter Support for `never`\\-Returning Functions\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nAs part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return `never`.\n\nThe intent of any function that returns `never` is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, [`process.exit(...)` in `@types/node`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874)\n is specified to return `never`.\n\nIn order to ensure that a function never potentially returned `undefined` or effectively returned from all code paths, TypeScript needed some syntactic signal - either a `return` or `throw` at the end of a function. So users found themselves `return`\\-ing their failure functions.\n\nts\n\n`   function dispatch(x: string | number): SomeType {    if (typeof x === \"string\") {      return doThingWithString(x);    } else if (typeof x === \"number\") {      return doThingWithNumber(x);    }    return process.exit(1);  }   `\n\nNow when these `never`\\-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.\n\nts\n\n`   function dispatch(x: string | number): SomeType {    if (typeof x === \"string\") {      return doThingWithString(x);    } else if (typeof x === \"number\") {      return doThingWithNumber(x);    }    process.exit(1);  }   `\n\nAs with assertion functions, you can [read up more at the same pull request](https://github.com/microsoft/TypeScript/pull/32695)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases)\n(More) Recursive Type Aliases\n--------------------------------------------------------------------------------------------------------------------------------------------\n\n[Playground](https://www.typescriptlang.org/play/#example/recursive-type-references)\n\nType aliases have always had a limitation in how they could be “recursively” referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that’s not possible, so the compiler rejects certain recursive aliases like the following:\n\nts\n\n`   type Foo = Foo;   `\n\nThis is a reasonable restriction because any use of `Foo` would need to be replaced with `Foo` which would need to be replaced with `Foo` which would need to be replaced with `Foo` which… well, hopefully you get the idea! In the end, there isn’t a type that makes sense in place of `Foo`.\n\nThis is fairly [consistent with how other languages treat type aliases](https://wikipedia.org/w/index.php?title=Recursive_data_type&oldid=913091335#in_type_synonyms)\n, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.\n\nts\n\n`   type ValueOrArray<T> = T | Array<ValueOrArray<T>>;  //   ~~~~~~~~~~~~  // error: Type alias 'ValueOrArray' circularly references itself.   `\n\nThis is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.\n\nts\n\n`   type ValueOrArray<T> = T | ArrayOfValueOrArray<T>;  interface ArrayOfValueOrArray<T> extends Array<ValueOrArray<T>> {}   `\n\nBecause interfaces (and other object types) introduce a level of indirection and their full structure doesn’t need to be eagerly built out, TypeScript has no problem working with this structure.\n\nBut workaround of introducing the interface wasn’t intuitive for users. And in principle there really wasn’t anything wrong with the original version of `ValueOrArray` that used `Array` directly. If the compiler was a little bit “lazier” and only calculated the type arguments to `Array` when necessary, then TypeScript could express these correctly.\n\nThat’s exactly what TypeScript 3.7 introduces. At the “top level” of a type alias, TypeScript will defer resolving type arguments to permit these patterns.\n\nThis means that code like the following that was trying to represent JSON…\n\nts\n\n`   type Json = string | number | boolean | null | JsonObject | JsonArray;  interface JsonObject {    [property: string]: Json;  }  interface JsonArray extends Array<Json> {}   `\n\ncan finally be rewritten without helper interfaces.\n\nts\n\n`   type Json =    | string    | number    | boolean    | null    | { [property: string]: Json }    | Json[];   `\n\nThis new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.\n\nts\n\n`   type VirtualNode = string | [string, { [key: string]: any }, ...VirtualNode[]];  const myNode: VirtualNode = [    \"div\",    { id: \"parent\" },    [\"div\", { id: \"first-child\" }, \"I'm the first child\"],    [\"div\", { id: \"second-child\" }, \"I'm the second child\"],  ];   `\n\nFor more information, you can [read up on the original pull request](https://github.com/microsoft/TypeScript/pull/33050)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs)\n`--declaration` and `--allowJs`\n----------------------------------------------------------------------------------------------------------------------------------------------\n\nThe [`declaration`](https://www.typescriptlang.org/tsconfig#declaration)\n flag in TypeScript allows us to generate `.d.ts` files (declaration files) from TypeScript source files (i.e. `.ts` and `.tsx` files). These `.d.ts` files are important for a couple of reasons.\n\nFirst of all, they’re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They’re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren’t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript _and_ JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.\n\nUnfortunately, [`declaration`](https://www.typescriptlang.org/tsconfig#declaration)\n didn’t work with the [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)\n flag which allows mixing TypeScript and JavaScript input files. This was a frustrating limitation because it meant users couldn’t use the [`declaration`](https://www.typescriptlang.org/tsconfig#declaration)\n flag when migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes that, and allows the two options to be used together!\n\nThe most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.\n\nThe way that this works is that when using [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs)\n, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don’t necessarily look like their equivalents in TypeScript. When [`declaration`](https://www.typescriptlang.org/tsconfig#declaration)\n emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output `.d.ts` files.\n\nAs an example, the following code snippet\n\njs\n\n`   const assert = require(\"assert\");  module.exports.blurImage = blurImage;  /**   * Produces a blurred image from an input buffer.   *   * @param input {Uint8Array}   * @param width {number}   * @param height {number}   */  function blurImage(input, width, height) {    const numPixels = width * height * 4;    assert(input.length === numPixels);    const result = new Uint8Array(numPixels);    // TODO    return result;  }   `\n\nWill produce a `.d.ts` file like\n\nts\n\n`   /**   * Produces a blurred image from an input buffer.   *   * @param input {Uint8Array}   * @param width {number}   * @param height {number}   */  export function blurImage(    input: Uint8Array,    width: number,    height: number  ): Uint8Array;   `\n\nThis can go beyond basic functions with `@param` tags too, where the following example:\n\njs\n\n`   /**   * @callback Job   * @returns {void}   */  /** Queues work */  export class Worker {    constructor(maxDepth = 10) {      this.started = false;      this.depthLimit = maxDepth;      /**       * NOTE: queued jobs may add more items to queue       * @type {Job[]}       */      this.queue = [];    }    /**     * Adds a work item to the queue     * @param {Job} work     */    push(work) {      if (this.queue.length + 1 > this.depthLimit) throw new Error(\"Queue full!\");      this.queue.push(work);    }    /**     * Starts the queue if it has not yet started     */    start() {      if (this.started) return false;      this.started = true;      while (this.queue.length) {        /** @type {Job} */ (this.queue.shift())();      }      return true;    }  }   `\n\nwill be transformed into the following `.d.ts` file:\n\nts\n\n`   /**   * @callback Job   * @returns {void}   */  /** Queues work */  export class Worker {    constructor(maxDepth?: number);    started: boolean;    depthLimit: number;    /**     * NOTE: queued jobs may add more items to queue     * @type {Job[]}     */    queue: Job[];    /**     * Adds a work item to the queue     * @param {Job} work     */    push(work: Job): void;    /**     * Starts the queue if it has not yet started     */    start(): boolean;  }  export type Job = () => void;   `\n\nNote that when using these flags together, TypeScript doesn’t necessarily have to downlevel `.js` files. If you simply want TypeScript to create `.d.ts` files, you can use the [`emitDeclarationOnly`](https://www.typescriptlang.org/tsconfig#emitDeclarationOnly)\n compiler option.\n\nFor more details, you can [check out the original pull request](https://github.com/microsoft/TypeScript/pull/32372)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier)\nThe `useDefineForClassFields` Flag and The `declare` Property Modifier\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBack when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code\n\nts\n\n`   class C {    foo = 100;    bar: string;  }   `\n\nwould be equivalent to a similar assignment within a constructor body.\n\nts\n\n`   class C {    constructor() {      this.foo = 100;    }  }   `\n\nUnfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently. Instead, the original code sample might need to de-sugar to something closer to the following:\n\nts\n\n`   class C {    constructor() {      Object.defineProperty(this, \"foo\", {        enumerable: true,        configurable: true,        writable: true,        value: 100,      });      Object.defineProperty(this, \"bar\", {        enumerable: true,        configurable: true,        writable: true,        value: void 0,      });    }  }   `\n\nWhile TypeScript 3.7 isn’t changing any existing emit by default, we’ve been rolling out changes incrementally to help users mitigate potential future breakage. We’ve provided a new flag called [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n to enable this emit mode with some new checking logic.\n\nThe two biggest changes are the following:\n\n*   Declarations are initialized with `Object.defineProperty`.\n*   Declarations are _always_ initialized to `undefined`, even if they have no initializer.\n\nThis can cause quite a bit of fallout for existing code that use inheritance. First of all, `set` accessors from base classes won’t get triggered - they’ll be completely overwritten.\n\nts\n\n`   class Base {    set data(value: string) {      console.log(\"data changed to \" + value);    }  }  class Derived extends Base {    // No longer triggers a 'console.log'    // when using 'useDefineForClassFields'.    data = 10;  }   `\n\nSecondly, using class fields to specialize properties from base classes also won’t work.\n\nts\n\n`   interface Animal {    animalStuff: any;  }  interface Dog extends Animal {    dogStuff: any;  }  class AnimalHouse {    resident: Animal;    constructor(animal: Animal) {      this.resident = animal;    }  }  class DogHouse extends AnimalHouse {    // Initializes 'resident' to 'undefined'    // after the call to 'super()' when    // using 'useDefineForClassFields'!    resident: Dog;    constructor(dog: Dog) {      super(dog);    }  }   `\n\nWhat these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.\n\nTo detect the issue around accessors, TypeScript 3.7 will now emit `get`/`set` accessors in `.d.ts` files so that in TypeScript can check for overridden accessors.\n\nCode that’s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.\n\nts\n\n`   class Base {    set data(value: string) {      console.log(\"data changed to \" + value);    }  }  class Derived extends Base {    constructor() {      this.data = 10;    }  }   `\n\nTo help mitigate the second issue, you can either add an explicit initializer or add a `declare` modifier to indicate that a property should have no emit.\n\nts\n\n`   interface Animal {    animalStuff: any;  }  interface Dog extends Animal {    dogStuff: any;  }  class AnimalHouse {    resident: Animal;    constructor(animal: Animal) {      this.resident = animal;    }  }  class DogHouse extends AnimalHouse {    declare resident: Dog;    //  ^^^^^^^    // 'resident' now has a 'declare' modifier,    // and won't produce any output code.    constructor(dog: Dog) {      super(dog);    }  }   `\n\nCurrently [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n is only available when targeting ES5 and upwards, since `Object.defineProperty` doesn’t exist in ES3. To achieve similar checking for issues, you can create a separate project that targets ES5 and uses [`noEmit`](https://www.typescriptlang.org/tsconfig#noEmit)\n to avoid a full build.\n\nFor more information, you can [take a look at the original pull request for these changes](https://github.com/microsoft/TypeScript/pull/33509)\n.\n\nWe strongly encourage users to try the [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n flag and report back on our issue tracker or in the comments below. This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references)\nBuild-Free Editing with Project References\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s project references provide us with an easy way to break codebases up to give us faster compiles. Unfortunately, editing a project whose dependencies hadn’t been built (or whose output was out of date) meant that the editing experience wouldn’t work well.\n\nIn TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source `.ts`/`.tsx` files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and “just work”. You can disable this behavior with the compiler option [`disableSourceOfProjectReferenceRedirect`](https://www.typescriptlang.org/tsconfig#disableSourceOfProjectReferenceRedirect)\n which may be appropriate when working in very large projects where this change may impact editing performance.\n\nYou can [read up more about this change by reading up on its pull request](https://github.com/microsoft/TypeScript/pull/32028)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#uncalled-function-checks)\nUncalled Function Checks\n------------------------------------------------------------------------------------------------------------------------------------\n\nA common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.\n\nts\n\n`   interface User {    isAdministrator(): boolean;    notify(): void;    doNotDisturb?(): boolean;  }  // later...  // Broken code, do not use!  function doAdminThing(user: User) {    // oops!    if (user.isAdministrator) {      sudo();      editTheConfiguration();    } else {      throw new AccessDeniedError(\"User is not an admin\");    }  }   `\n\nHere, we forgot to call `isAdministrator`, and the code incorrectly allows non-administrator users to edit the configuration!\n\nIn TypeScript 3.7, this is identified as a likely error:\n\nts\n\n`   function doAdminThing(user: User) {      if (user.isAdministrator) {      //  ~~~~~~~~~~~~~~~~~~~~      // error! This condition will always return true since the function is always defined.      //        Did you mean to call it instead?   `\n\nThis check is a breaking change, but for that reason the checks are very conservative. This error is only issued in `if` conditions, and it is not issued on optional properties, if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n is off, or if the function is later called within the body of the `if`:\n\nts\n\n`   interface User {    isAdministrator(): boolean;    notify(): void;    doNotDisturb?(): boolean;  }  function issueNotification(user: User) {    if (user.doNotDisturb) {      // OK, property is optional    }    if (user.notify) {      // OK, called the function      user.notify();    }  }   `\n\nIf you intended to test the function without calling it, you can correct the definition of it to include `undefined`/`null`, or use `!!` to write something like `if (!!user.isAdministrator)` to indicate that the coercion is intentional.\n\nWe owe a big thanks to GitHub user [@jwbay](https://github.com/jwbay)\n who took the initiative to create a [proof-of-concept](https://github.com/microsoft/TypeScript/pull/32802)\n and iterated to provide us with [the current version](https://github.com/microsoft/TypeScript/pull/33178)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#-ts-nocheck-in-typescript-files)\n`// @ts-nocheck` in TypeScript Files\n-------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.7 allows us to add `// @ts-nocheck` comments to the top of TypeScript files to disable semantic checks. Historically this comment was only respected in JavaScript source files in the presence of [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs)\n, but we’ve expanded support to TypeScript files to make migrations easier for all users.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#semicolon-formatter-option)\nSemicolon Formatter Option\n----------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript’s automatic semicolon insertion (ASI) rules. The setting is available now in [Visual Studio Code Insiders](https://code.visualstudio.com/insiders/)\n, and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.\n\n![New semicolon formatter option in VS Code](https://user-images.githubusercontent.com/3277153/65913194-10066e80-e395-11e9-8a3a-4f7305c397d5.png)\n\nChoosing a value of “insert” or “remove” also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of “ignore” makes generated code match the semicolon preference detected in the current file.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#37-breaking-changes)\n3.7 Breaking Changes\n---------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#dom-changes)\nDOM Changes\n\n[Types in `lib.dom.d.ts` have been updated](https://github.com/microsoft/TypeScript/pull/33627)\n. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#class-field-mitigations)\nClass Field Mitigations\n\n[As mentioned above](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier)\n, TypeScript 3.7 emits `get`/`set` accessors in `.d.ts` files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.\n\nWhile not a breakage per se, opting in to the [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n flag can cause breakage when:\n\n*   overriding an accessor in a derived class with a property declaration\n*   re-declaring a property declaration with no initializer\n\nTo understand the full impact, read [the section above on the `useDefineForClassFields` flag](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#function-truthy-checks)\nFunction Truthy Checks\n\nAs mentioned above, TypeScript now errors when functions appear to be uncalled within `if` statement conditions. An error is issued when a function type is checked in `if` conditions unless any of the following apply:\n\n*   the checked value comes from an optional property\n*   [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n     is disabled\n*   the function is later called within the body of the `if`\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#local-and-imported-type-declarations-now-conflict)\nLocal and Imported Type Declarations Now Conflict\n\nDue to a bug, the following construct was previously allowed in TypeScript:\n\nts\n\n`   // ./someOtherModule.ts  interface SomeType {    y: string;  }  // ./myModule.ts  import { SomeType } from \"./someOtherModule\";  export interface SomeType {    x: number;  }  function fn(arg: SomeType) {    console.log(arg.x); // Error! 'x' doesn't exist on 'SomeType'  }   `\n\nHere, `SomeType` appears to originate in both the `import` declaration and the local `interface` declaration. Perhaps surprisingly, inside the module, `SomeType` refers exclusively to the `import`ed definition, and the local declaration `SomeType` is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.\n\nIn TypeScript 3.7, [this is now correctly identified as a duplicate identifier error](https://github.com/microsoft/TypeScript/pull/31231)\n. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#37-api-changes)\n3.7 API Changes\n\nTo enable the recursive type alias patterns described above, the `typeArguments` property has been removed from the `TypeReference` interface. Users should instead use the `getTypeArguments` function on `TypeChecker` instances.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.7.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (67)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nJ![Jake  (3)](https://gravatar.com/avatar/31e55836947e29445f1d7bc9588268c7?s=32&&d=blank)\n\nNS![Nick Schonning  (1)](https://gravatar.com/avatar/a490b76edb21047df004539971c9258a6c3bd8da6bc3ca94c89da3e6398ef08e?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nGL![Giuliano Lauro  (1)](https://gravatar.com/avatar/c79c0cc5024cd6bad263a0e6129ef48d84b71425aec0b6c10b6cd611092c1c05?s=32&&d=blank)\n\n12+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"og:description":"TypeScript 3.7 Release Notes","ogDescription":"TypeScript 3.7 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","generator":"Gatsby 5.13.5","ogTitle":"Documentation - TypeScript 3.7","language":"en","og:title":"Documentation - TypeScript 3.7","twitter:site":"typescriptlang","title":"TypeScript: Documentation - TypeScript 3.7","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","description":"TypeScript 3.7 Release Notes","scrapeId":"202e6153-71e6-403f-8180-2193c799e440","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 5.1\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#easier-implicit-returns-for-undefined-returning-functions)\nEasier Implicit Returns for `undefined`\\-Returning Functions\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript, if a function finishes running without hitting a `return`, it returns the value `undefined`.\n\nts\n\n`   function foo() {      // no return  }  // x = undefined  let x = foo();   `\n\nHowever, in previous versions of TypeScript, the _only_ functions that could have absolutely no return statements were `void`\\- and `any`\\-returning functions. That meant that even if you explicitly said “this function returns `undefined`” you were forced to have at least one return statement.\n\nts\n\n`   // ✅ fine - we inferred that 'f1' returns 'void'  function f1() {      // no returns  }  // ✅ fine - 'void' doesn't need a return statement  function f2(): void {      // no returns  }  // ✅ fine - 'any' doesn't need a return statement  function f3(): any {      // no returns  }  // ❌ error!  // A function whose declared type is neither 'void' nor 'any' must return a value.  function f4(): undefined {      // no returns  }   `\n\nThis could be a pain if some API expected a function returning `undefined` - you would need to have either at least one explicit return of `undefined` or a `return` statement _and_ an explicit annotation.\n\nts\n\n`   declare function takesFunction(f: () => undefined): undefined;  // ❌ error!  // Argument of type '() => void' is not assignable to parameter of type '() => undefined'.  takesFunction(() => {      // no returns  });  // ❌ error!  // A function whose declared type is neither 'void' nor 'any' must return a value.  takesFunction((): undefined => {      // no returns  });  // ❌ error!  // Argument of type '() => void' is not assignable to parameter of type '() => undefined'.  takesFunction(() => {      return;  });  // ✅ works  takesFunction(() => {      return undefined;  });  // ✅ works  takesFunction((): undefined => {      return;  });   `\n\nThis behavior was frustrating and confusing, especially when calling functions outside of one’s control. Understanding the interplay between inferring `void` over `undefined`, whether an `undefined`\\-returning function needs a `return` statement, etc. seems like a distraction.\n\nFirst, TypeScript 5.1 now allows `undefined`\\-returning functions to have no return statement.\n\nts\n\n`   // ✅ Works in TypeScript 5.1!  function f4(): undefined {      // no returns  }  // ✅ Works in TypeScript 5.1!  takesFunction((): undefined => {      // no returns  });   `\n\nSecond, if a function has no return expressions and is being passed to something expecting a function that returns `undefined`, TypeScript infers `undefined` for that function’s return type.\n\nts\n\n`   // ✅ Works in TypeScript 5.1!  takesFunction(function f() {      //                 ^ return type is undefined      // no returns  });  // ✅ Works in TypeScript 5.1!  takesFunction(function f() {      //                 ^ return type is undefined      return;  });   `\n\nTo address another similar pain-point, under TypeScript’s `--noImplicitReturns` option, functions returning _only_ `undefined` now have a similar exception to `void`, in that not every single code path must end in an explicit `return`.\n\nts\n\n`   // ✅ Works in TypeScript 5.1 under '--noImplicitReturns'!  function f(): undefined {      if (Math.random()) {          // do some stuff...          return;      }  }   `\n\nFor more information, you can read up on [the original issue](https://github.com/microsoft/TypeScript/issues/36288)\n and [the implementing pull request](https://github.com/microsoft/TypeScript/pull/53607)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#unrelated-types-for-getters-and-setters)\nUnrelated Types for Getters and Setters\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.3 made it possible to say that a `get` and `set` accessor pair might specify two different types.\n\nts\n\n`   interface Serializer {      set value(v: string | number | boolean);      get value(): string;  }  declare let box: Serializer;  // Allows writing a 'boolean'  box.value = true;  // Comes out as a 'string'  console.log(box.value.toUpperCase());   `\n\nInitially we required that the `get` type had to be a subtype of the `set` type. This meant that writing\n\nts\n\n`   box.value = box.value;   `\n\nwould always be valid.\n\nHowever, there are plenty of existing and proposed APIs that have completely unrelated types between their getters and setters. For example, consider one of the most common examples - the `style` property in the DOM and [`CSSStyleRule`](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleRule)\n API. Every style rule has [a `style` property](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleRule/style)\n that is a [`CSSStyleDeclaration`](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration)\n; however, if you try to write to that property, it will only work correctly with a string!\n\nTypeScript 5.1 now allows completely unrelated types for `get` and `set` accessor properties, provided that they have explicit type annotations. And while this version of TypeScript does not yet change the types for these built-in interfaces, `CSSStyleRule` can now be defined in the following way:\n\nts\n\n``   interface CSSStyleRule {      // ...      /** Always reads as a `CSSStyleDeclaration` */      get style(): CSSStyleDeclaration;      /** Can only write a `string` here. */      set style(newValue: string);      // ...  }   ``\n\nThis also allows other patterns like requiring `set` accessors to accept only “valid” data, but specifying that `get` accessors may return `undefined` if some underlying state hasn’t been initialized yet.\n\nts\n\n`   class SafeBox {      #value: string | undefined;      // Only accepts strings!      set value(newValue: string) {      }      // Must check for 'undefined'!      get value(): string | undefined {          return this.#value;      }  }   `\n\nIn fact, this is similar to how optional properties are checked under `--exactOptionalProperties`.\n\nYou can read up more on [the implementing pull request](https://github.com/microsoft/TypeScript/pull/53417)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#decoupled-type-checking-between-jsx-elements-and-jsx-tag-types)\nDecoupled Type-Checking Between JSX Elements and JSX Tag Types\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nOne pain point TypeScript had with JSX was its requirements on the type of every JSX element’s tag.\n\nFor context, a JSX element is either of the following:\n\ntsx\n\n`   // A self-closing JSX tag  <Foo />  // A regular element with an opening/closing tag  <Bar></Bar>   `\n\nWhen type-checking `<Foo />` or `<Bar></Bar>`, TypeScript always looks up a namespace called `JSX` and fetches a type out of it called `Element` - or more directly, it looks up `JSX.Element`.\n\nBut to check whether `Foo` or `Bar` themselves were valid to use as tag names, TypeScript would roughly just grab the types returned or constructed by `Foo` or `Bar` and check for compatibility with `JSX.Element` (or another type called `JSX.ElementClass` if the type is constructable).\n\nThe limitations here meant that components could not be used if they returned or “rendered” a more broad type than just `JSX.Element`. For example, a JSX library might be fine with a component returning `string`s or `Promise`s.\n\nAs a more concrete example, [React is considering adding limited support for components that return `Promise`s](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md)\n, but existing versions of TypeScript cannot express that without someone drastically loosening the type of `JSX.Element`.\n\ntsx\n\n`   import * as React from \"react\";  async function Foo() {      return <div></div>;  }  let element = <Foo />;  //             ~~~  // 'Foo' cannot be used as a JSX component.  //   Its return type 'Promise<Element>' is not a valid JSX element.   `\n\nTo provide libraries with a way to express this, TypeScript 5.1 now looks up a type called `JSX.ElementType`. `ElementType` specifies precisely what is valid to use as a tag in a JSX element. So it might be typed today as something like\n\ntsx\n\n`   namespace JSX {      export type ElementType =          // All the valid lowercase tags          keyof IntrinsicAttributes          // Function components          (props: any) => Element          // Class components          new (props: any) => ElementClass;      export interface IntrinsicAttributes extends /*...*/ {}      export type Element = /*...*/;      export type ElementClass = /*...*/;  }   `\n\nWe’d like to extend our thanks to [Sebastian Silbermann](https://github.com/eps1lon)\n who contributed [this change](https://github.com/microsoft/TypeScript/pull/51328)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#namespaced-jsx-attributes)\nNamespaced JSX Attributes\n--------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript now supports namespaced attribute names when using JSX.\n\ntsx\n\n`   import * as React from \"react\";  // Both of these are equivalent:  const x = <Foo a:b=\"hello\" />;  const y = <Foo a : b=\"hello\" />;  interface FooProps {      \"a:b\": string;  }  function Foo(props: FooProps) {      return <div>{props[\"a:b\"]}</div>;  }   `\n\nNamespaced tag names are looked up in a similar way on `JSX.IntrinsicAttributes` when the first segment of the name is a lowercase name.\n\ntsx\n\n`   // In some library's code or in an augmentation of that library:  namespace JSX {      interface IntrinsicElements {          [\"a:b\"]: { prop: string };      }  }  // In our code:  let x = <a:b prop=\"hello!\" />;   `\n\n[This contribution](https://github.com/microsoft/TypeScript/pull/53799)\n was provided thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#typeroots-are-consulted-in-module-resolution)\n`typeRoots` Are Consulted In Module Resolution\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen TypeScript’s specified module lookup strategy is unable to resolve a path, it will now resolve packages relative to the specified `typeRoots`.\n\nSee [this pull request](https://github.com/microsoft/TypeScript/pull/51715)\n for more details.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#move-declarations-to-existing-files)\nMove Declarations to Existing Files\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn addition to moving declarations to new files, TypeScript now ships a preview feature for moving declarations to existing files as well. You can try this functionality out in a recent version of Visual Studio Code.\n\n![Moving a function 'getThanks' to an existing file in the workspace.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/05/moveToFile-5.1-preview.gif)\n\nKeep in mind that this feature is currently in preview, and we are seeking further feedback on it.\n\n[https://github.com/microsoft/TypeScript/pull/53542](https://github.com/microsoft/TypeScript/pull/53542)\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#linked-cursors-for-jsx-tags)\nLinked Cursors for JSX Tags\n------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript now supports _linked editing_ for JSX tag names. Linked editing (occasionally called “mirrored cursors”) allows an editor to edit multiple locations at the same time automatically.\n\n![An example of JSX tags with linked editing modifying a JSX fragment and a div element.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/04/linkedEditingJsx-5.1-1.gif)\n\nThis new feature should work in both TypeScript and JavaScript files, and can be enabled in Visual Studio Code Insiders. In Visual Studio Code, you can either edit the `Editor: Linked Editing` option in the Settings UI:\n\n![Visual Studio Code's Editor: Linked Editing` option](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/04/linkedEditing-5.1-vscode-ui-1.png)\n\nor configure `editor.linkedEditing` in your JSON settings file:\n\njsonc\n\n`   {      // ...      \"editor.linkedEditing\": true,  }   `\n\nThis feature will also be supported by Visual Studio 17.7 Preview 1.\n\nYou can take a look at [our implementation of linked editing](https://github.com/microsoft/TypeScript/pull/53284)\n here!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#snippet-completions-for-param-jsdoc-tags)\nSnippet Completions for `@param` JSDoc Tags\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript now provides snippet completions when typing out a `@param` tag in both TypeScript and JavaScript files. This can help cut down on some typing and jumping around text as you document your code or add JSDoc types in JavaScript.\n\n![An example of completing JSDoc param comments on an 'add' function.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/04/paramTagSnippets-5-1-1.gif)\n\nYou can [check out how this new feature was implemented on GitHub](https://github.com/microsoft/TypeScript/pull/53260)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#optimizations)\nOptimizations\n--------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#avoiding-unnecessary-type-instantiation)\nAvoiding Unnecessary Type Instantiation\n\nTypeScript 5.1 now avoids performing type instantiation within object types that are known not to contain references to outer type parameters. This has the potential to cut down on many unnecessary computations, and reduced the type-checking time of [material-ui’s docs directory](https://github.com/mui/material-ui/tree/b0351248fb396001a30330daac86d0e0794a0c1d/docs)\n by over 50%.\n\nYou can [see the changes involved for this change on GitHub](https://github.com/microsoft/TypeScript/pull/53246)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#negative-case-checks-for-union-literals)\nNegative Case Checks for Union Literals\n\nWhen checking if a source type is part of a union type, TypeScript will first do a fast look-up using an internal type identifier for that source. If that look-up fails, then TypeScript checks for compatibility against every type within the union.\n\nWhen relating a literal type to a union of purely literal types, TypeScript can now avoid that full walk against every other type in the union. This assumption is safe because TypeScript always interns/caches literal types - though there are some edge cases to handle relating to “fresh” literal types.\n\n[This optimization](https://github.com/microsoft/TypeScript/pull/53192)\n was able to reduce the type-checking time of [the code in this issue](https://github.com/microsoft/TypeScript/issues/53191)\n from about 45 seconds to about 0.4 seconds.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#reduced-calls-into-scanner-for-jsdoc-parsing)\nReduced Calls into Scanner for JSDoc Parsing\n\nWhen older versions of TypeScript parsed out a JSDoc comment, they would use the scanner/tokenizer to break the comment into fine-grained tokens and piece the contents back together. This could be helpful for normalizing comment text, so that multiple spaces would just collapse into one; but it was extremely “chatty” and meant the parser and scanner would jump back and forth very often, adding overhead to JSDoc parsing.\n\nTypeScript 5.1 has moved more logic around breaking down JSDoc comments into the scanner/tokenizer. The scanner now returns larger chunks of content directly to the parser to do as it needs.\n\n[These changes](https://github.com/microsoft/TypeScript/pull/53081)\n have brought down the parse time of several 10Mb mostly-prose-comment JavaScript files by about half. For a more realistic example, our performance suite’s snapshot of [xstate](https://github.com/statelyai/xstate)\n dropped about 300ms of parse time, making it faster to load and analyze.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#es2020-and-nodejs-1417-as-minimum-runtime-requirements)\nES2020 and Node.js 14.17 as Minimum Runtime Requirements\n\nTypeScript 5.1 now ships JavaScript functionality that was introduced in ECMAScript 2020. As a result, at minimum TypeScript must be run in a reasonably modern runtime. For most users, this means TypeScript now only runs on Node.js 14.17 and later.\n\nIf you try running TypeScript 5.1 under an older version of Node.js such as Node 10 or 12, you may see an error like the following from running either `tsc.js` or `tsserver.js`:\n\n`   node_modules/typescript/lib/tsserver.js:2406    for (let i = startIndex ?? 0; i < array.length; i++) {                             ^  SyntaxError: Unexpected token '?'      at wrapSafe (internal/modules/cjs/loader.js:915:16)      at Module._compile (internal/modules/cjs/loader.js:963:27)      at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10)      at Module.load (internal/modules/cjs/loader.js:863:32)      at Function.Module._load (internal/modules/cjs/loader.js:708:14)      at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)      at internal/main/run_main_module.js:17:47   `\n\nAdditionally, if you try installing TypeScript you’ll get something like the following error messages from npm:\n\n`   npm WARN EBADENGINE Unsupported engine {  npm WARN EBADENGINE   package: 'typescript@5.1.1-rc',  npm WARN EBADENGINE   required: { node: '>=14.17' },  npm WARN EBADENGINE   current: { node: 'v12.22.12', npm: '8.19.2' }  npm WARN EBADENGINE }   `\n\nfrom Yarn:\n\n`   error typescript@5.1.1-rc: The engine \"node\" is incompatible with this module. Expected version \">=14.17\". Got \"12.22.12\"  error Found incompatible module.   `\n\n[See more information around this change here](https://github.com/microsoft/TypeScript/pull/53291)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#explicit-typeroots-disables-upward-walks-for-node_modulestypes)\nExplicit `typeRoots` Disables Upward Walks for `node_modules/@types`\n\nPreviously, when the `typeRoots` option was specified in a `tsconfig.json` but resolution to any `typeRoots` directories had failed, TypeScript would still continue walking up parent directories, trying to resolve packages within each parent’s `node_modules/@types` folder.\n\nThis behavior could prompt excessive look-ups and has been disabled in TypeScript 5.1. As a result, you may begin to see errors like the following based on entries in your `tsconfig.json`’s `types` option or `/// <reference >` directives\n\n`   error TS2688: Cannot find type definition file for 'node'.  error TS2688: Cannot find type definition file for 'mocha'.  error TS2688: Cannot find type definition file for 'jasmine'.  error TS2688: Cannot find type definition file for 'chai-http'.  error TS2688: Cannot find type definition file for 'webpack-env\"'.   `\n\nThe solution is typically to add specific entries for `node_modules/@types` to your `typeRoots`:\n\njsonc\n\n`   {      \"compilerOptions\": {          \"types\": [              \"node\",              \"mocha\"          ],          \"typeRoots\": [              // Keep whatever you had around before.              \"./some-custom-types/\",              // You might need your local 'node_modules/@types'.              \"./node_modules/@types\",              // You might also need to specify a shared 'node_modules/@types'              // if you're using a \"monorepo\" layout.              \"../../node_modules/@types\",          ]      }  }   `\n\nMore information is available [on the original change on our issue tracker](https://github.com/microsoft/TypeScript/pull/51715)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%205.1.md)\n ❤\n\nContributors to this page:  \n\nN![navya9singh  (6)](https://gravatar.com/avatar/e896fd3c90d7bd8d3c276d3ea2dd552ae62d81d4a497cdd589f551c5eb5ccb93?s=32&&d=blank)\n\nBT![Beeno Tung  (1)](https://gravatar.com/avatar/abf3eb978b75f7c318037af0de9f1d7efd5562fa9f63ee1b3838cfc3c49ed36f?s=32&&d=blank)\n\nLL![Lazar Ljubenović  (1)](https://gravatar.com/avatar/699ce6f1dced86e6721758c8eba6afaabf0632aa15f15a379e8a5c7e184cbc51?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogDescription":"TypeScript 5.1 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"TypeScript 5.1 Release Notes","twitter:site":"typescriptlang","generator":"Gatsby 5.13.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:description":"TypeScript 5.1 Release Notes","ogTitle":"Documentation - TypeScript 5.1","theme-color":"#3178C6","og:title":"Documentation - TypeScript 5.1","title":"TypeScript: Documentation - TypeScript 5.1","language":"en","scrapeId":"41a87502-d9bb-400e-b717-1f0b999fec49","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 5.0\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#decorators)\nDecorators\n--------------------------------------------------------------------------------------------------------\n\nDecorators are an upcoming ECMAScript feature that allow us to customize classes and their members in a reusable way.\n\nLet’s consider the following code:\n\nts\n\n``   class Person {      name: string;      constructor(name: string) {          this.name = name;      }      greet() {          console.log(`Hello, my name is ${this.name}.`);      }  }  const p = new Person(\"Ray\");  p.greet();   ``\n\n`greet` is pretty simple here, but let’s imagine it’s something way more complicated - maybe it does some async logic, it’s recursive, it has side effects, etc. Regardless of what kind of ball-of-mud you’re imagining, let’s say you throw in some `console.log` calls to help debug `greet`.\n\nts\n\n``   class Person {      name: string;      constructor(name: string) {          this.name = name;      }      greet() {          console.log(\"LOG: Entering method.\");          console.log(`Hello, my name is ${this.name}.`);          console.log(\"LOG: Exiting method.\")      }  }   ``\n\nThis pattern is fairly common. It sure would be nice if there was a way we could do this for every method!\n\nThis is where decorators come in. We can write a function called `loggedMethod` that looks like the following:\n\nts\n\n`   function loggedMethod(originalMethod: any, _context: any) {      function replacementMethod(this: any, ...args: any[]) {          console.log(\"LOG: Entering method.\")          const result = originalMethod.call(this, ...args);          console.log(\"LOG: Exiting method.\")          return result;      }      return replacementMethod;  }   `\n\n“What’s the deal with all of these `any`s? What is this, `any`Script!?”\n\nJust be patient - we’re keeping things simple for now so that we can focus on what this function is doing. Notice that `loggedMethod` takes the original method (`originalMethod`) and returns a function that\n\n1.  logs an “Entering…” message\n2.  passes along `this` and all of its arguments to the original method\n3.  logs an “Exiting…” message, and\n4.  returns whatever the original method returned.\n\nNow we can use `loggedMethod` to _decorate_ the method `greet`:\n\nts\n\n``   class Person {      name: string;      constructor(name: string) {          this.name = name;      }      @loggedMethod      greet() {          console.log(`Hello, my name is ${this.name}.`);      }  }  const p = new Person(\"Ray\");  p.greet();  // Output:  //  //   LOG: Entering method.  //   Hello, my name is Ray.  //   LOG: Exiting method.   ``\n\nWe just used `loggedMethod` as a decorator above `greet` - and notice that we wrote it as `@loggedMethod`. When we did that, it got called with the method _target_ and a _context object_. Because `loggedMethod` returned a new function, that function replaced the original definition of `greet`.\n\nWe didn’t mention it yet, but `loggedMethod` was defined with a second parameter. It’s called a “context object”, and it has some useful information about how the decorated method was declared - like whether it was a `#private` member, or `static`, or what the name of the method was. Let’s rewrite `loggedMethod` to take advantage of that and print out the name of the method that was decorated.\n\nts\n\n``   function loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) {      const methodName = String(context.name);      function replacementMethod(this: any, ...args: any[]) {          console.log(`LOG: Entering method '${methodName}'.`)          const result = originalMethod.call(this, ...args);          console.log(`LOG: Exiting method '${methodName}'.`)          return result;      }      return replacementMethod;  }   ``\n\nWe’re now using the context parameter - and that it’s the first thing in `loggedMethod` that has a type stricter than `any` and `any[]`. TypeScript provides a type called `ClassMethodDecoratorContext` that models the context object that method decorators take.\n\nApart from metadata, the context object for methods also has a useful function called `addInitializer`. It’s a way to hook into the beginning of the constructor (or the initialization of the class itself if we’re working with `static`s).\n\nAs an example - in JavaScript, it’s common to write something like the following pattern:\n\nts\n\n``   class Person {      name: string;      constructor(name: string) {          this.name = name;          this.greet = this.greet.bind(this);      }      greet() {          console.log(`Hello, my name is ${this.name}.`);      }  }   ``\n\nAlternatively, `greet` might be declared as a property initialized to an arrow function.\n\nts\n\n``   class Person {      name: string;      constructor(name: string) {          this.name = name;      }      greet = () => {          console.log(`Hello, my name is ${this.name}.`);      };  }   ``\n\nThis code is written to ensure that `this` isn’t re-bound if `greet` is called as a stand-alone function or passed as a callback.\n\nts\n\n`   const greet = new Person(\"Ray\").greet;  // We don't want this to fail!  greet();   `\n\nWe can write a decorator that uses `addInitializer` to call `bind` in the constructor for us.\n\nts\n\n``   function bound(originalMethod: any, context: ClassMethodDecoratorContext) {      const methodName = context.name;      if (context.private) {          throw new Error(`'bound' cannot decorate private properties like ${methodName as string}.`);      }      context.addInitializer(function () {          this[methodName] = this[methodName].bind(this);      });  }   ``\n\n`bound` isn’t returning anything - so when it decorates a method, it leaves the original alone. Instead, it will add logic before any other fields are initialized.\n\nts\n\n``   class Person {      name: string;      constructor(name: string) {          this.name = name;      }      @bound      @loggedMethod      greet() {          console.log(`Hello, my name is ${this.name}.`);      }  }  const p = new Person(\"Ray\");  const greet = p.greet;  // Works!  greet();   ``\n\nNotice that we stacked two decorators - `@bound` and `@loggedMethod`. These decorations run in “reverse order”. That is, `@loggedMethod` decorates the original method `greet`, and `@bound` decorates the result of `@loggedMethod`. In this example, it doesn’t matter - but it could if your decorators have side-effects or expect a certain order.\n\nAlso worth noting - if you’d prefer stylistically, you can put these decorators on the same line.\n\nts\n\n    ``@bound @loggedMethod greet() {          console.log(`Hello, my name is ${this.name}.`);      }``\n\nSomething that might not be obvious is that we can even make functions that _return_ decorator functions. That makes it possible to customize the final decorator just a little. If we wanted, we could have made `loggedMethod` return a decorator and customize how it logs its messages.\n\nts\n\n``   function loggedMethod(headMessage = \"LOG:\") {      return function actualDecorator(originalMethod: any, context: ClassMethodDecoratorContext) {          const methodName = String(context.name);          function replacementMethod(this: any, ...args: any[]) {              console.log(`${headMessage} Entering method '${methodName}'.`)              const result = originalMethod.call(this, ...args);              console.log(`${headMessage} Exiting method '${methodName}'.`)              return result;          }          return replacementMethod;      }  }   ``\n\nIf we did that, we’d have to call `loggedMethod` before using it as a decorator. We could then pass in any string as the prefix for messages that get logged to the console.\n\nts\n\n``   class Person {      name: string;      constructor(name: string) {          this.name = name;      }      @loggedMethod(\"⚠️\")      greet() {          console.log(`Hello, my name is ${this.name}.`);      }  }  const p = new Person(\"Ray\");  p.greet();  // Output:  //  //   ⚠️ Entering method 'greet'.  //   Hello, my name is Ray.  //   ⚠️ Exiting method 'greet'.   ``\n\nDecorators can be used on more than just methods! They can be used on properties/fields, getters, setters, and auto-accessors. Even classes themselves can be decorated for things like subclassing and registration.\n\nTo learn more about decorators in-depth, you can read up on [Axel Rauschmayer’s extensive summary](https://2ality.com/2022/10/javascript-decorators.html)\n.\n\nFor more information about the changes involved, you can [view the original pull request](https://github.com/microsoft/TypeScript/pull/50820)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#differences-with-experimental-legacy-decorators)\nDifferences with Experimental Legacy Decorators\n\nIf you’ve been using TypeScript for a while, you might be aware of the fact that it’s had support for “experimental” decorators for years. While these experimental decorators have been incredibly useful, they modeled a much older version of the decorators proposal, and always required an opt-in compiler flag called `--experimentalDecorators`. Any attempt to use decorators in TypeScript without this flag used to prompt an error message.\n\n`--experimentalDecorators` will continue to exist for the foreseeable future; however, without the flag, decorators will now be valid syntax for all new code. Outside of `--experimentalDecorators`, they will be type-checked and emitted differently. The type-checking rules and emit are sufficiently different that while decorators _can_ be written to support both the old and new decorators behavior, any existing decorator functions are not likely to do so.\n\nThis new decorators proposal is not compatible with `--emitDecoratorMetadata`, and it does not allow decorating parameters. Future ECMAScript proposals may be able to help bridge that gap.\n\nOn a final note: in addition to allowing decorators to be placed before the `export` keyword, the proposal for decorators now provides the option of placing decorators after `export` or `export default`. The only exception is that mixing the two styles is not allowed.\n\njs\n\n`   // ✅ allowed  @register export default class Foo {      // ...  }  // ✅ also allowed  export default @register class Bar {      // ...  }  // ❌ error - before *and* after is not allowed  @before export @after class Bar {      // ...  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#writing-well-typed-decorators)\nWriting Well-Typed Decorators\n\nThe `loggedMethod` and `bound` decorator examples above are intentionally simple and omit lots of details about types.\n\nTyping decorators can be fairly complex. For example, a well-typed version of `loggedMethod` from above might look something like this:\n\nts\n\n``   function loggedMethod<This, Args extends any[], Return>(      target: (this: This, ...args: Args) => Return,      context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>  ) {      const methodName = String(context.name);      function replacementMethod(this: This, ...args: Args): Return {          console.log(`LOG: Entering method '${methodName}'.`)          const result = target.call(this, ...args);          console.log(`LOG: Exiting method '${methodName}'.`)          return result;      }      return replacementMethod;  }   ``\n\nWe had to separately model out the type of `this`, the parameters, and the return type of the original method, using the type parameters `This`, `Args`, and `Return`.\n\nExactly how complex your decorators functions are defined depends on what you want to guarantee. Just keep in mind, your decorators will be used more than they’re written, so a well-typed version will usually be preferable - but there’s clearly a trade-off with readability, so try to keep things simple.\n\nMore documentation on writing decorators will be available in the future - but [this post](https://2ality.com/2022/10/javascript-decorators.html)\n should have a good amount of detail for the mechanics of decorators.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#const-type-parameters)\n`const` Type Parameters\n--------------------------------------------------------------------------------------------------------------------------------\n\nWhen inferring the type of an object, TypeScript will usually choose a type that’s meant to be general. For example, in this case, the inferred type of `names` is `string[]`:\n\nts\n\n`   type HasNames = { names: readonly string[] };  function getNamesExactly<T extends HasNames>(arg: T): T[\"names\"] {      return arg.names;  }  // Inferred type: string[]  const names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]});   `\n\nUsually the intent of this is to enable mutation down the line.\n\nHowever, depending on what exactly `getNamesExactly` does and how it’s intended to be used, it can often be the case that a more-specific type is desired.\n\nUp until now, API authors have typically had to recommend adding `as const` in certain places to achieve the desired inference:\n\nts\n\n`   // The type we wanted:  //    readonly [\"Alice\", \"Bob\", \"Eve\"]  // The type we got:  //    string[]  const names1 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]});  // Correctly gets what we wanted:  //    readonly [\"Alice\", \"Bob\", \"Eve\"]  const names2 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]} as const);   `\n\nThis can be cumbersome and easy to forget. In TypeScript 5.0, you can now add a `const` modifier to a type parameter declaration to cause `const`\\-like inference to be the default:\n\nts\n\n`   type HasNames = { names: readonly string[] };  function getNamesExactly<const T extends HasNames>(arg: T): T[\"names\"] {  //                       ^^^^^      return arg.names;  }  // Inferred type: readonly [\"Alice\", \"Bob\", \"Eve\"]  // Note: Didn't need to write 'as const' here  const names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"] });   `\n\nNote that the `const` modifier doesn’t _reject_ mutable values, and doesn’t require immutable constraints. Using a mutable type constraint might give surprising results. For example:\n\nts\n\n`   declare function fnBad<const T extends string[]>(args: T): void;  // 'T' is still 'string[]' since 'readonly [\"a\", \"b\", \"c\"]' is not assignable to 'string[]'  fnBad([\"a\", \"b\" ,\"c\"]);   `\n\nHere, the inferred candidate for `T` is `readonly [\"a\", \"b\", \"c\"]`, and a `readonly` array can’t be used where a mutable one is needed. In this case, inference falls back to the constraint, the array is treated as `string[]`, and the call still proceeds successfully.\n\nA better definition of this function should use `readonly string[]`:\n\nts\n\n`   declare function fnGood<const T extends readonly string[]>(args: T): void;  // T is readonly [\"a\", \"b\", \"c\"]  fnGood([\"a\", \"b\" ,\"c\"]);   `\n\nSimilarly, remember to keep in mind that the `const` modifier only affects inference of object, array and primitive expressions that were written within the call, so arguments which wouldn’t (or couldn’t) be modified with `as const` won’t see any change in behavior:\n\nts\n\n`   declare function fnGood<const T extends readonly string[]>(args: T): void;  const arr = [\"a\", \"b\" ,\"c\"];  // 'T' is still 'string[]'-- the 'const' modifier has no effect here  fnGood(arr);   `\n\n[See the pull request](https://github.com/microsoft/TypeScript/pull/51865)\n and the ([first](https://github.com/microsoft/TypeScript/issues/30680)\n and [second](https://github.com/microsoft/TypeScript/issues/41114)\n) motivating issues for more details.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#supporting-multiple-configuration-files-in-extends)\nSupporting Multiple Configuration Files in `extends`\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen managing multiple projects, it can be helpful to have a “base” configuration file that other `tsconfig.json` files can extend from. That’s why TypeScript supports an `extends` field for copying over fields from `compilerOptions`.\n\njsonc\n\n`   // packages/front-end/src/tsconfig.json  {      \"extends\": \"../../../tsconfig.base.json\",      \"compilerOptions\": {          \"outDir\": \"../lib\",          // ...      }  }   `\n\nHowever, there are scenarios where you might want to extend from multiple configuration files. For example, imagine using [a TypeScript base configuration file shipped to npm](https://github.com/tsconfig/bases)\n. If you want all your projects to also use the options from the `@tsconfig/strictest` package on npm, then there’s a simple solution: have `tsconfig.base.json` extend from `@tsconfig/strictest`:\n\njsonc\n\n`   // tsconfig.base.json  {      \"extends\": \"@tsconfig/strictest/tsconfig.json\",      \"compilerOptions\": {          // ...      }  }   `\n\nThis works to a point. If you have any projects that _don’t_ want to use `@tsconfig/strictest`, they have to either manually disable the options, or create a separate version of `tsconfig.base.json` that _doesn’t_ extend from `@tsconfig/strictest`.\n\nTo give some more flexibility here, Typescript 5.0 now allows the `extends` field to take multiple entries. For example, in this configuration file:\n\njsonc\n\n`   {      \"extends\": [\"a\", \"b\", \"c\"],      \"compilerOptions\": {          // ...      }  }   `\n\nWriting this is kind of like extending `c` directly, where `c` extends `b`, and `b` extends `a`. If any fields “conflict”, the latter entry wins.\n\nSo in the following example, both `strictNullChecks` and `noImplicitAny` are enabled in the final `tsconfig.json`.\n\njsonc\n\n`   // tsconfig1.json  {      \"compilerOptions\": {          \"strictNullChecks\": true      }  }  // tsconfig2.json  {      \"compilerOptions\": {          \"noImplicitAny\": true      }  }  // tsconfig.json  {      \"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"],      \"files\": [\"./index.ts\"]  }   `\n\nAs another example, we can rewrite our original example in the following way.\n\njsonc\n\n`   // packages/front-end/src/tsconfig.json  {      \"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"../../../tsconfig.base.json\"],      \"compilerOptions\": {          \"outDir\": \"../lib\",          // ...      }  }   `\n\nFor more details, [read more on the original pull request](https://github.com/microsoft/TypeScript/pull/50403)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#all-enums-are-union-enums)\nAll `enum`s Are Union `enum`s\n------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen TypeScript originally introduced enums, they were nothing more than a set of numeric constants with the same type.\n\nts\n\n`   enum E {      Foo = 10,      Bar = 20,  }   `\n\nThe only thing special about `E.Foo` and `E.Bar` was that they were assignable to anything expecting the type `E`. Other than that, they were pretty much just `number`s.\n\nts\n\n`   function takeValue(e: E) {}  takeValue(E.Foo); // works  takeValue(123); // error!   `\n\nIt wasn’t until TypeScript 2.0 introduced enum literal types that enums got a bit more special. Enum literal types gave each enum member its own type, and turned the enum itself into a _union_ of each member type. They also allowed us to refer to only a subset of the types of an enum, and to narrow away those types.\n\nts\n\n`   // Color is like a union of Red | Orange | Yellow | Green | Blue | Violet  enum Color {      Red, Orange, Yellow, Green, Blue, /* Indigo, */ Violet  }  // Each enum member has its own type that we can refer to!  type PrimaryColor = Color.Red | Color.Green | Color.Blue;  function isPrimaryColor(c: Color): c is PrimaryColor {      // Narrowing literal types can catch bugs.      // TypeScript will error here because      // we'll end up comparing 'Color.Red' to 'Color.Green'.      // We meant to use ||, but accidentally wrote &&.      return c === Color.Red && c === Color.Green && c === Color.Blue;  }   `\n\nOne issue with giving each enum member its own type was that those types were in some part associated with the actual value of the member. In some cases it’s not possible to compute that value - for instance, an enum member could be initialized by a function call.\n\nts\n\n`   enum E {      Blah = Math.random()  }   `\n\nWhenever TypeScript ran into these issues, it would quietly back out and use the old enum strategy. That meant giving up all the advantages of unions and literal types.\n\nTypeScript 5.0 manages to make all enums into union enums by creating a unique type for each computed member. That means that all enums can now be narrowed and have their members referenced as types as well.\n\nFor more details on this change, you can [read the specifics on GitHub](https://github.com/microsoft/TypeScript/pull/50528)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#--moduleresolution-bundler)\n`--moduleResolution bundler`\n------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.7 introduced the `node16` and `nodenext` options for its `--module` and `--moduleResolution` settings. The intent of these options was to better model the precise lookup rules for ECMAScript modules in Node.js; however, this mode has many restrictions that other tools don’t really enforce.\n\nFor example, in an ECMAScript module in Node.js, any relative import needs to include a file extension.\n\njs\n\n`   // entry.mjs  import * as utils from \"./utils\";     // ❌ wrong - we need to include the file extension.  import * as utils from \"./utils.mjs\"; // ✅ works   `\n\nThere are certain reasons for this in Node.js and the browser - it makes file lookups faster and works better for naive file servers. But for many developers using tools like bundlers, the `node16`/`nodenext` settings were cumbersome because bundlers don’t have most of these restrictions. In some ways, the `node` resolution mode was better for anyone using a bundler.\n\nBut in some ways, the original `node` resolution mode was already out of date. Most modern bundlers use a fusion of the ECMAScript module and CommonJS lookup rules in Node.js. For example, extensionless imports work just fine just like in CommonJS, but when looking through the [`export` conditions](https://nodejs.org/api/packages.html#nested-conditions)\n of a package, they’ll prefer an `import` condition just like in an ECMAScript file.\n\nTo model how bundlers work, TypeScript now introduces a new strategy: `--moduleResolution bundler`.\n\njsonc\n\n`   {      \"compilerOptions\": {          \"target\": \"esnext\",          \"moduleResolution\": \"bundler\"      }  }   `\n\nIf you are using a modern bundler like Vite, esbuild, swc, Webpack, Parcel, and others that implement a hybrid lookup strategy, the new `bundler` option should be a good fit for you.\n\nOn the other hand, if you’re writing a library that’s meant to be published on npm, using the `bundler` option can hide compatibility issues that may arise for your users who _aren’t_ using a bundler. So in these cases, using the `node16` or `nodenext` resolution options is likely to be a better path.\n\nTo read more on `--moduleResolution bundler`, [take a look at the implementing pull request](https://github.com/microsoft/TypeScript/pull/51669)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#resolution-customization-flags)\nResolution Customization Flags\n------------------------------------------------------------------------------------------------------------------------------------------------\n\nJavaScript tooling may now model “hybrid” resolution rules, like in the `bundler` mode we described above. Because tools may differ in their support slightly, TypeScript 5.0 provides ways to enable or disable a few features that may or may not work with your configuration.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#allowimportingtsextensions)\n`allowImportingTsExtensions`\n\n`--allowImportingTsExtensions` allows TypeScript files to import each other with a TypeScript-specific extension like `.ts`, `.mts`, or `.tsx`.\n\nThis flag is only allowed when `--noEmit` or `--emitDeclarationOnly` is enabled, since these import paths would not be resolvable at runtime in JavaScript output files. The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between `.ts` files work.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#resolvepackagejsonexports)\n`resolvePackageJsonExports`\n\n`--resolvePackageJsonExports` forces TypeScript to consult [the `exports` field of `package.json` files](https://nodejs.org/api/packages.html#exports)\n if it ever reads from a package in `node_modules`.\n\nThis option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for `--moduleResolution`.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#resolvepackagejsonimports)\n`resolvePackageJsonImports`\n\n`--resolvePackageJsonImports` forces TypeScript to consult [the `imports` field of `package.json` files](https://nodejs.org/api/packages.html#imports)\n when performing a lookup that starts with `#` from a file whose ancestor directory contains a `package.json`.\n\nThis option defaults to `true` under the `node16`, `nodenext`, and `bundler` options for `--moduleResolution`.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#allowarbitraryextensions)\n`allowArbitraryExtensions`\n\nIn TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of `{file basename}.d.{extension}.ts`. For example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:\n\ncss\n\n`   /* app.css */  .cookie-banner {    display: none;  }   `\n\nts\n\n`   // app.d.css.ts  declare const css: {    cookieBanner: string;  };  export default css;   `\n\nts\n\n`   // App.tsx  import styles from \"./app.css\";  styles.cookieBanner; // string   `\n\nBy default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it. But if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new `--allowArbitraryExtensions` compiler option.\n\nNote that historically, a similar effect has often been achievable by adding a declaration file named `app.css.d.ts` instead of `app.d.css.ts` - however, this just worked through Node’s `require` resolution rules for CommonJS. Strictly speaking, the former is interpreted as a declaration file for a JavaScript file named `app.css.js`. Because relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under `--moduleResolution node16` or `nodenext`.\n\nFor more information, read up [the proposal for this feature](https://github.com/microsoft/TypeScript/issues/50133)\n and [its corresponding pull request](https://github.com/microsoft/TypeScript/pull/51435)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#customconditions)\n`customConditions`\n\n`--customConditions` takes a list of additional [conditions](https://nodejs.org/api/packages.html#nested-conditions)\n that should succeed when TypeScript resolves from an [`exports`](https://nodejs.org/api/packages.html#exports)\n or [`imports`](https://nodejs.org/api/packages.html#imports)\n field of a `package.json`. These conditions are added to whatever existing conditions a resolver will use by default.\n\nFor example, when this field is set in a `tsconfig.json` as so:\n\njsonc\n\n`   {      \"compilerOptions\": {          \"target\": \"es2022\",          \"moduleResolution\": \"bundler\",          \"customConditions\": [\"my-condition\"]      }  }   `\n\nAny time an `exports` or `imports` field is referenced in `package.json`, TypeScript will consider conditions called `my-condition`.\n\nSo when importing from a package with the following `package.json`\n\njsonc\n\n`   {      // ...      \"exports\": {          \".\": {              \"my-condition\": \"./foo.mjs\",              \"node\": \"./bar.mjs\",              \"import\": \"./baz.mjs\",              \"require\": \"./biz.mjs\"          }      }  }   `\n\nTypeScript will try to look for files corresponding to `foo.mjs`.\n\nThis field is only valid under the `node16`, `nodenext`, and `bundler` options for `--moduleResolution`\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#--verbatimmodulesyntax)\n`--verbatimModuleSyntax`\n----------------------------------------------------------------------------------------------------------------------------------\n\nBy default, TypeScript does something called _import elision_. Basically, if you write something like\n\nts\n\n`   import { Car } from \"./car\";  export function drive(car: Car) {      // ...  }   `\n\nTypeScript detects that you’re only using an import for types and drops the import entirely. Your output JavaScript might look something like this:\n\njs\n\n`   export function drive(car) {      // ...  }   `\n\nMost of the time this is good, because if `Car` isn’t a value that’s exported from `./car`, we’ll get a runtime error.\n\nBut it does add a layer of complexity for certain edge cases. For example, notice there’s no statement like `import \"./car\";` - the import was dropped entirely. That actually makes a difference for modules that have side-effects or not.\n\nTypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well. So it’s not always clear whether code like the following\n\nts\n\n`   export { Car } from \"./car\";   `\n\nshould be preserved or dropped. If `Car` is declared with something like a `class`, then it can be preserved in the resulting JavaScript file. But if `Car` is only declared as a `type` alias or `interface`, then the JavaScript file shouldn’t export `Car` at all.\n\nWhile TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.\n\nThe `type` modifier on imports and exports helps with these situations a bit. We can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the `type` modifier.\n\nts\n\n`   // This statement can be dropped entirely in JS output  import type * as car from \"./car\";  // The named import/export 'Car' can be dropped in JS output  import { type Car } from \"./car\";  export { type Car } from \"./car\";   `\n\n`type` modifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between `type` and plain imports and exports. So TypeScript has the flag `--importsNotUsedAsValues` to make sure you use the `type` modifier, `--preserveValueImports` to prevent _some_ module elision behavior, and `--isolatedModules` to make sure that your TypeScript code works across different compilers. Unfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.\n\nTypeScript 5.0 introduces a new option called `--verbatimModuleSyntax` to simplify the situation. The rules are much simpler - any imports or exports without a `type` modifier are left around. Anything that uses the `type` modifier is dropped entirely.\n\nts\n\n`   // Erased away entirely.  import type { A } from \"a\";  // Rewritten to 'import { b } from \"bcd\";'  import { b, type c, type d } from \"bcd\";  // Rewritten to 'import {} from \"xyz\";'  import { type xyz } from \"xyz\";   `\n\nWith this new option, what you see is what you get.\n\nThat does have some implications when it comes to module interop though. Under this flag, ECMAScript `import`s and `export`s won’t be rewritten to `require` calls when your settings or file extension implied a different module system. Instead, you’ll get an error. If you need to emit code that uses `require` and `module.exports`, you’ll have to use TypeScript’s module syntax that predates ES2015:\n\n| Input TypeScript | Output JavaScript |\n| --- | --- |\n| ts<br><br>`   import foo = require(\"foo\");   ` | js<br><br>`   const foo = require(\"foo\");   ` |\n| ts<br><br>`   function foo() {}  function bar() {}  function baz() {}  export = {      foo,      bar,      baz  };   ` | js<br><br>`   function foo() {}  function bar() {}  function baz() {}  module.exports = {      foo,      bar,      baz  };   ` |\n\nWhile this is a limitation, it does help make some issues more obvious. For example, it’s very common to forget to set the [`type` field in `package.json`](https://nodejs.org/api/packages.html#type)\n under `--module node16`. As a result, developers would start writing CommonJS modules instead of ES modules without realizing it, giving surprising lookup rules and JavaScript output. This new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different.\n\nBecause `--verbatimModuleSyntax` provides a more consistent story than `--importsNotUsedAsValues` and `--preserveValueImports`, those two existing flags are being deprecated in its favor.\n\nFor more details, read up on \\[the original pull request\\][https://github.com/microsoft/TypeScript/pull/52203](https://github.com/microsoft/TypeScript/pull/52203)\n and [its proposal issue](https://github.com/microsoft/TypeScript/issues/51479)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#support-for-export-type-)\nSupport for `export type *`\n---------------------------------------------------------------------------------------------------------------------------------------\n\nWhen TypeScript 3.8 introduced type-only imports, the new syntax wasn’t allowed on `export * from \"module\"` or `export * as ns from \"module\"` re-exports. TypeScript 5.0 adds support for both of these forms:\n\nts\n\n``   // models/vehicles.ts  export class Spaceship {    // ...  }  // models/index.ts  export type * as vehicles from \"./vehicles\";  // main.ts  import { vehicles } from \"./models\";  function takeASpaceship(s: vehicles.Spaceship) {    // ✅ ok - `vehicles` only used in a type position  }  function makeASpaceship() {    return new vehicles.Spaceship();    //         ^^^^^^^^    // 'vehicles' cannot be used as a value because it was exported using 'export type'.  }   ``\n\nYou can [read more about the implementation here](https://github.com/microsoft/TypeScript/pull/52217)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#satisfies-support-in-jsdoc)\n`@satisfies` Support in JSDoc\n-------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.9 introduced the `satisfies` operator. It made sure that the type of an expression was compatible, without affecting the type itself. For example, let’s take the following code:\n\nts\n\n`   interface CompilerOptions {      strict?: boolean;      outDir?: string;      // ...  }  interface ConfigSettings {      compilerOptions?: CompilerOptions;      extends?: string | string[];      // ...  }  let myConfigSettings = {      compilerOptions: {          strict: true,          outDir: \"../lib\",          // ...      },      extends: [          \"@tsconfig/strictest/tsconfig.json\",          \"../../../tsconfig.base.json\"      ],  } satisfies ConfigSettings;   `\n\nHere, TypeScript knows that `myConfigSettings.extends` was declared with an array - because while `satisfies` validated the type of our object, it didn’t bluntly change it to `CompilerOptions` and lose information. So if we want to map over `extends`, that’s fine.\n\nts\n\n`   declare function resolveConfig(configPath: string): CompilerOptions;  let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);   `\n\nThis was helpful for TypeScript users, but plenty of people use TypeScript to type-check their JavaScript code using JSDoc annotations. That’s why TypeScript 5.0 is supporting a new JSDoc tag called `@satisfies` that does exactly the same thing.\n\n`/** @satisfies */` can catch type mismatches:\n\njs\n\n`   // @ts-check  /**   * @typedef CompilerOptions   * @prop {boolean} [strict]   * @prop {string} [outDir]   */  /**   * @satisfies {CompilerOptions}   */  let myCompilerOptions = {      outdir: \"../lib\",  //  ~~~~~~ oops! we meant outDir  };   `\n\nBut it will preserve the original type of our expressions, allowing us to use our values more precisely later on in our code.\n\njs\n\n`   // @ts-check  /**   * @typedef CompilerOptions   * @prop {boolean} [strict]   * @prop {string} [outDir]   */  /**   * @typedef ConfigSettings   * @prop {CompilerOptions} [compilerOptions]   * @prop {string | string[]} [extends]   */  /**   * @satisfies {ConfigSettings}   */  let myConfigSettings = {      compilerOptions: {          strict: true,          outDir: \"../lib\",      },      extends: [          \"@tsconfig/strictest/tsconfig.json\",          \"../../../tsconfig.base.json\"      ],  };  let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);   `\n\n`/** @satisfies */` can also be used inline on any parenthesized expression. We could have written `myCompilerOptions` like this:\n\nts\n\n`   let myConfigSettings = /** @satisfies {ConfigSettings} */ ({      compilerOptions: {          strict: true,          outDir: \"../lib\",      },      extends: [          \"@tsconfig/strictest/tsconfig.json\",          \"../../../tsconfig.base.json\"      ],  });   `\n\nWhy? Well, it usually makes more sense when you’re deeper in some other code, like a function call.\n\njs\n\n`   compileCode(/** @satisfies {CompilerOptions} */ ({      // ...  }));   `\n\n[This feature](https://github.com/microsoft/TypeScript/pull/51753)\n was provided thanks to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#overload-support-in-jsdoc)\n`@overload` Support in JSDoc\n-----------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript, you can specify overloads for a function. Overloads give us a way to say that a function can be called with different arguments, and possibly return different results. They can restrict how callers can actually use our functions, and refine what results they’ll get back.\n\nts\n\n`   // Our overloads:  function printValue(str: string): void;  function printValue(num: number, maxFractionDigits?: number): void;  // Our implementation:  function printValue(value: string | number, maximumFractionDigits?: number) {      if (typeof value === \"number\") {          const formatter = Intl.NumberFormat(\"en-US\", {              maximumFractionDigits,          });          value = formatter.format(value);      }      console.log(value);  }   `\n\nHere, we’ve said that `printValue` takes either a `string` or a `number` as its first argument. If it takes a `number`, it can take a second argument to determine how many fractional digits we can print.\n\nTypeScript 5.0 now allows JSDoc to declare overloads with a new `@overload` tag. Each JSDoc comment with an `@overload` tag is treated as a distinct overload for the following function declaration.\n\njs\n\n`   // @ts-check  /**   * @overload   * @param {string} value   * @return {void}   */  /**   * @overload   * @param {number} value   * @param {number} [maximumFractionDigits]   * @return {void}   */  /**   * @param {string | number} value   * @param {number} [maximumFractionDigits]   */  function printValue(value, maximumFractionDigits) {      if (typeof value === \"number\") {          const formatter = Intl.NumberFormat(\"en-US\", {              maximumFractionDigits,          });          value = formatter.format(value);      }      console.log(value);  }   `\n\nNow regardless of whether we’re writing in a TypeScript or JavaScript file, TypeScript can let us know if we’ve called our functions incorrectly.\n\nts\n\n`   // all allowed  printValue(\"hello!\");  printValue(123.45);  printValue(123.45, 2);  printValue(\"hello!\", 123); // error!   `\n\nThis new tag [was implemented](https://github.com/microsoft/TypeScript/pull/51234)\n thanks to [Tomasz Lenarcik](https://github.com/apendua)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#passing-emit-specific-flags-under---build)\nPassing Emit-Specific Flags Under `--build`\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript now allows the following flags to be passed under `--build` mode\n\n*   `--declaration`\n*   `--emitDeclarationOnly`\n*   `--declarationMap`\n*   `--sourceMap`\n*   `--inlineSourceMap`\n\nThis makes it way easier to customize certain parts of a build where you might have different development and production builds.\n\nFor example, a development build of a library might not need to produce declaration files, but a production build would. A project can configure declaration emit to be off by default and simply be built with\n\nsh\n\n`   tsc --build -p ./my-project-dir   `\n\nOnce you’re done iterating in the inner loop, a “production” build can just pass the `--declaration` flag.\n\nsh\n\n`   tsc --build -p ./my-project-dir --declaration   `\n\n[More information on this change is available here](https://github.com/microsoft/TypeScript/pull/51241)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#case-insensitive-import-sorting-in-editors)\nCase-Insensitive Import Sorting in Editors\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn editors like Visual Studio and VS Code, TypeScript powers the experience for organizing and sorting imports and exports. Often though, there can be different interpretations of when a list is “sorted”.\n\nFor example, is the following import list sorted?\n\nts\n\n`   import {      Toggle,      freeze,      toBoolean,  } from \"./utils\";   `\n\nThe answer might surprisingly be “it depends”. If we _don’t_ care about case-sensitivity, then this list is clearly not sorted. The letter `f` comes before both `t` and `T`.\n\nBut in most programming languages, sorting defaults to comparing the byte values of strings. The way JavaScript compares strings means that `\"Toggle\"` always comes before `\"freeze\"` because according to the [ASCII character encoding](https://en.wikipedia.org/wiki/ASCII)\n, uppercase letters come before lowercase. So from that perspective, the import list is sorted.\n\nTypeScript previously considered the import list to be sorted because it was doing a basic case-sensitive sort. This could be a point of frustration for developers who preferred a case-_insensitive_ ordering, or who used tools like ESLint which require case-insensitive ordering by default.\n\nTypeScript now detects case sensitivity by default. This means that TypeScript and tools like ESLint typically won’t “fight” each other over how to best sort imports.\n\nOur team has also been experimenting [with further sorting strategies which you can read about here](https://github.com/microsoft/TypeScript/pull/52115)\n. These options may eventually be configurable by editors. For now, they are still unstable and experimental, and you can opt into them in VS Code today by using the `typescript.unstable` entry in your JSON options. Below are all of the options you can try out (set to their defaults):\n\njsonc\n\n``   {      \"typescript.unstable\": {          // Should sorting be case-sensitive? Can be:          // - true          // - false          // - \"auto\" (auto-detect)          \"organizeImportsIgnoreCase\": \"auto\",          // Should sorting be \"ordinal\" and use code points or consider Unicode rules? Can be:          // - \"ordinal\"          // - \"unicode\"          \"organizeImportsCollation\": \"ordinal\",          // Under `\"organizeImportsCollation\": \"unicode\"`,          // what is the current locale? Can be:          // - [any other locale code]          // - \"auto\" (use the editor's locale)          \"organizeImportsLocale\": \"en\",          // Under `\"organizeImportsCollation\": \"unicode\"`,          // should upper-case letters or lower-case letters come first? Can be:          // - false (locale-specific)          // - \"upper\"          // - \"lower\"          \"organizeImportsCaseFirst\": false,          // Under `\"organizeImportsCollation\": \"unicode\"`,          // do runs of numbers get compared numerically (i.e. \"a1\" < \"a2\" < \"a100\")? Can be:          // - true          // - false          \"organizeImportsNumericCollation\": true,          // Under `\"organizeImportsCollation\": \"unicode\"`,          // do letters with accent marks/diacritics get sorted distinctly          // from their \"base\" letter (i.e. is é different from e)? Can be          // - true          // - false          \"organizeImportsAccentCollation\": true      },      \"javascript.unstable\": {          // same options valid here...      },  }   ``\n\nYou can read more details on [the original work for auto-detecting and specifying case-insensitivity](https://github.com/microsoft/TypeScript/pull/51733)\n, followed by the [the broader set of options](https://github.com/microsoft/TypeScript/pull/52115)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#exhaustive-switchcase-completions)\nExhaustive `switch`/`case` Completions\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen writing a `switch` statement, TypeScript now detects when the value being checked has a literal type. If so, it will offer a completion that scaffolds out each uncovered `case`.\n\n![A set of case statements generated through auto-completion based on literal types.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/01/switchCaseSnippets-5-0_1.gif)\n\nYou can [see specifics of the implementation on GitHub](https://github.com/microsoft/TypeScript/pull/50996)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#speed-memory-and-package-size-optimizations)\nSpeed, Memory, and Package Size Optimizations\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 5.0 contains lots of powerful changes across our code structure, our data structures, and algorithmic implementations. What these all mean is that your entire experience should be faster - not just running TypeScript, but even installing it.\n\nHere are a few interesting wins in speed and size that we’ve been able to capture relative to TypeScript 4.9.\n\n| Scenario | Time or Size Relative to TS 4.9 |\n| --- | --- |\n| material-ui build time | 89% |\n| TypeScript Compiler startup time | 89% |\n| Playwright build time | 88% |\n| TypeScript Compiler self-build time | 87% |\n| Outlook Web build time | 82% |\n| VS Code build time | 80% |\n| typescript npm Package Size | 59% |\n\n![Chart of build/run times and package size of TypeScript 5.0 relative to TypeScript 4.9: material-ui docs build time: 89%; Playwright build time: 88%; tsc startup time: 87%; tsc build time: 87%; Outlook Web build time: 82%; VS Code build time: 80%; typescript Package Size: 59%](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/speed-and-size-5-0-rc.png?1)\n\nHow? There are a few notable improvements we’d like give more details on in the future. But we won’t make you wait for that blog post.\n\nFirst off, we recently migrated TypeScript from namespaces to modules, allowing us to leverage modern build tooling that can perform optimizations like scope hoisting. Using this tooling, revisiting our packaging strategy, and removing some deprecated code has shaved off about 26.4 MB from TypeScript 4.9’s 63.8 MB package size. It also brought us a notable speed-up through direct function calls.\n\nTypeScript also added more uniformity to internal object types within the compiler, and also slimmed the data stored on some of these object types as well. This reduced polymorphic and megamorphic use sites, while offsetting most of the necessary memory consumption that was necessary for uniform shapes.\n\nWe’ve also performed some caching when serializing information to strings. Type display, which can happen as part of error reporting, declaration emit, code completions, and more, can end up being fairly expensive. TypeScript now caches some commonly used machinery to reuse across these operations.\n\nAnother notable change we made that improved our parser was leveraging `var` to occasionally side-step the cost of using `let` and `const` across closures. This improved some of our parsing performance.\n\nOverall, we expect most codebases should see speed improvements from TypeScript 5.0, and have consistently been able to reproduce wins between 10% to 20%. Of course this will depend on hardware and codebase characteristics, but we encourage you to try it out on your codebase today!\n\nFor more information, see some of our notable optimizations:\n\n*   [Migrate to Modules](https://github.com/microsoft/TypeScript/pull/51387)\n    \n*   [`Node` Monomorphization](https://github.com/microsoft/TypeScript/pull/51682)\n    \n*   [`Symbol` Monomorphization](https://github.com/microsoft/TypeScript/pull/51880)\n    \n*   [`Identifier` Size Reduction](https://github.com/microsoft/TypeScript/pull/52170)\n    \n*   [`Printer` Caching](https://github.com/microsoft/TypeScript/pull/52382)\n    \n*   [Limited Usage of `var`](https://github.com/microsoft/TypeScript/issues/52924)\n    \n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#breaking-changes-and-deprecations)\nBreaking Changes and Deprecations\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#runtime-requirements)\nRuntime Requirements\n\nTypeScript now targets ECMAScript 2018. For Node users, that means a minimum version requirement of at least Node.js 10 and later.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#libdts-changes)\n`lib.d.ts` Changes\n\nChanges to how types for the DOM are generated might have an impact on existing code. Notably, certain properties have been converted from `number` to numeric literal types, and properties and methods for cut, copy, and paste event handling have been moved across interfaces.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#api-breaking-changes)\nAPI Breaking Changes\n\nIn TypeScript 5.0, we moved to modules, removed some unnecessary interfaces, and made some correctness improvements. For more details on what’s changed, see our [API Breaking Changes](https://github.com/microsoft/TypeScript/wiki/API-Breaking-Changes)\n page.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#forbidden-implicit-coercions-in-relational-operators)\nForbidden Implicit Coercions in Relational Operators\n\nCertain operations in TypeScript will already warn you if you write code which may cause an implicit string-to-number coercion:\n\nts\n\n`   function func(ns: number | string) {    return ns * 4; // Error, possible implicit coercion  }   `\n\nIn 5.0, this will also be applied to the relational operators `>`, `<`, `<=`, and `>=`:\n\nts\n\n`   function func(ns: number | string) {    return ns > 4; // Now also an error  }   `\n\nTo allow this if desired, you can explicitly coerce the operand to a `number` using `+`:\n\nts\n\n`   function func(ns: number | string) {    return +ns > 4; // OK  }   `\n\nThis [correctness improvement](https://github.com/microsoft/TypeScript/pull/52048)\n was contributed courtesy of [Mateusz Burzyński](https://github.com/Andarist)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#enum-overhaul)\nEnum Overhaul\n\nTypeScript has had some long-standing oddities around `enum`s ever since its first release. In 5.0, we’re cleaning up some of these problems, as well as reducing the concept count needed to understand the various kinds of `enum`s you can declare.\n\nThere are two main new errors you might see as part of this. The first is that assigning an out-of-domain literal to an `enum` type will now error as one might expect:\n\nts\n\n`   enum SomeEvenDigit {      Zero = 0,      Two = 2,      Four = 4  }  // Now correctly an error  let m: SomeEvenDigit = 1;   `\n\nThe other is that declaration of certain kinds of indirected mixed string/number `enum` forms would, incorrectly, create an all-number `enum`:\n\nts\n\n`   enum Letters {      A = \"a\"  }  enum Numbers {      one = 1,      two = Letters.A  }  // Now correctly an error  const t: number = Numbers.two;   `\n\nYou can [see more details in relevant change](https://github.com/microsoft/TypeScript/pull/50528)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#more-accurate-type-checking-for-parameter-decorators-in-constructors-under---experimentaldecorators)\nMore Accurate Type-Checking for Parameter Decorators in Constructors Under `--experimentalDecorators`\n\nTypeScript 5.0 makes type-checking more accurate for decorators under `--experimentalDecorators`. One place where this becomes apparent is when using a decorator on a constructor parameter.\n\nts\n\n`   export declare const inject:    (entity: any) =>      (target: object, key: string | symbol, index?: number) => void;  export class Foo {}  export class C {      constructor(@inject(Foo) private x: any) {      }  }   `\n\nThis call will fail because `key` expects a `string | symbol`, but constructor parameters receive a key of `undefined`. The correct fix is to change the type of `key` within `inject`. A reasonable workaround if you’re using a library that can’t be upgraded is is to wrap `inject` in a more type-safe decorator function, and use a type-assertion on `key`.\n\nFor more details, [see this issue](https://github.com/microsoft/TypeScript/issues/52435)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#deprecations-and-default-changes)\nDeprecations and Default Changes\n\nIn TypeScript 5.0, we’ve deprecated the following settings and setting values:\n\n*   `--target: ES3`\n*   `--out`\n*   `--noImplicitUseStrict`\n*   `--keyofStringsOnly`\n*   `--suppressExcessPropertyErrors`\n*   `--suppressImplicitAnyIndexErrors`\n*   `--noStrictGenericChecks`\n*   `--charset`\n*   `--importsNotUsedAsValues`\n*   `--preserveValueImports`\n*   `prepend` in project references\n\nThese configurations will continue to be allowed until TypeScript 5.5, at which point they will be removed entirely, however, you will receive a warning if you are using these settings. In TypeScript 5.0, as well as future releases 5.1, 5.2, 5.3, and 5.4, you can specify `\"ignoreDeprecations\": \"5.0\"` to silence those warnings. We’ll also shortly be releasing a 4.9 patch to allow specifying `ignoreDeprecations` to allow for smoother upgrades. Aside from deprecations, we’ve changed some settings to better improve cross-platform behavior in TypeScript.\n\n`--newLine`, which controls the line endings emitted in JavaScript files, used to be inferred based on the current operating system if not specified. We think builds should be as deterministic as possible, and Windows Notepad supports line-feed line endings now, so the new default setting is `LF`. The old OS-specific inference behavior is no longer available.\n\n`--forceConsistentCasingInFileNames`, which ensured that all references to the same file name in a project agreed in casing, now defaults to `true`. This can help catch differences issues with code written on case-insensitive file systems.\n\nYou can leave feedback and view more information on the [tracking issue for 5.0 deprecations](https://github.com/microsoft/TypeScript/issues/51909)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%205.0.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (7)](https://gravatar.com/avatar/86ed396e4ffb41b052654b9f8ad4d1caaf732bc42985860b0cac8191a66e33df?s=32&&d=blank)\n\nB![blisse  (1)](https://gravatar.com/avatar/24796bee60c3a5acfd633308f200702e43c3cc4121e6d2e3be05858a028177e5?s=32&&d=blank)\n\nEI![Eugene Ilyin  (1)](https://gravatar.com/avatar/a65caef54cbaba95975117e96ca2d411668cedaea6e5bbc59287ed673c84751e?s=32&&d=blank)\n\nM![marcustyphoon  (1)](https://gravatar.com/avatar/9ebf66173d7989e161e8bf923221ad764844be328f1ddeaf40136b28ecfcc786?s=32&&d=blank)\n\nM![Mohi  (1)](https://gravatar.com/avatar/f465867e32b6ef5414f2746e668a75bb83f241b26d385c466005f5510b8383cf?s=32&&d=blank)\n\n2+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"language":"en","ogTitle":"Documentation - TypeScript 5.0","theme-color":"#3178C6","ogDescription":"TypeScript 5.0 Release Notes","og:title":"Documentation - TypeScript 5.0","generator":"Gatsby 5.13.5","og:description":"TypeScript 5.0 Release Notes","twitter:site":"typescriptlang","title":"TypeScript: Documentation - TypeScript 5.0","description":"TypeScript 5.0 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","scrapeId":"2c1390a7-4303-4cb5-bc73-661311c5e994","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.5\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#supporting-lib-from-node_modules)\nSupporting `lib` from `node_modules`\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTo ensure that TypeScript and JavaScript support works well out of the box, TypeScript bundles a series of declaration files (`.d.ts` files). These declaration files represent the available APIs in the JavaScript language, and the standard browser DOM APIs. While there are some reasonable defaults based on your [`target`](https://www.typescriptlang.org/tsconfig#target)\n, you can pick and choose which declaration files your program uses by configuring the [`lib`](https://www.typescriptlang.org/tsconfig#lib)\n setting in the `tsconfig.json`.\n\nThere are two occasional downsides to including these declaration files with TypeScript though:\n\n*   When you upgrade TypeScript, you’re also forced to handle changes to TypeScript’s built-in declaration files, and this can be a challenge when the DOM APIs change as frequently as they do.\n*   It is hard to customize these files to match your needs with the needs of your project’s dependencies (e.g. if your dependencies declare that they use the DOM APIs, you might also be forced into using the DOM APIs).\n\nTypeScript 4.5 introduces a way to override a specific built-in `lib` in a manner similar to how `@types/` support works. When deciding which `lib` files TypeScript should include, it will first look for a scoped `@typescript/lib-*` package in `node_modules`. For example, when including `dom` as an option in `lib`, TypeScript will use the types in `node_modules/@typescript/lib-dom` if available.\n\nYou can then use your package manager to install a specific package to take over for a given `lib` For example, today TypeScript publishes versions of the DOM APIs on `@types/web`. If you wanted to lock your project to a specific version of the DOM APIs, you could add this to your `package.json`:\n\njson\n\n`   {    \"dependencies\": {      \"@typescript/lib-dom\": \"npm:@types/web\"    }  }   `\n\nThen from 4.5 onwards, you can update TypeScript and your dependency manager’s lockfile will ensure that it uses the exact same version of the DOM types. That means you get to update your types on your own terms.\n\nWe’d like to give a shout-out to [saschanaz](https://github.com/saschanaz)\n who has been extremely helpful and patient as we’ve been building out and experimenting with this feature.\n\nFor more information, you can [see the implementation of this change](https://github.com/microsoft/TypeScript/pull/45771)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#the-awaited-type-and-promise-improvements)\nThe `Awaited` Type and `Promise` Improvements\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.5 introduces a new utility type called the `Awaited` type. This type is meant to model operations like `await` in `async` functions, or the `.then()` method on `Promise`s - specifically, the way that they recursively unwrap `Promise`s.\n\nts\n\n`   // A = string  type A = Awaited<Promise<string>>;  // B = number  type B = Awaited<Promise<Promise<number>>>;  // C = boolean | number  type C = Awaited<boolean | Promise<number>>;   `\n\nThe `Awaited` type can be helpful for modeling existing APIs, including JavaScript built-ins like `Promise.all`, `Promise.race`, etc. In fact, some of the problems around inference with `Promise.all` served as motivations for `Awaited`. Here’s an example that fails in TypeScript 4.4 and earlier.\n\nts\n\n`   declare function MaybePromise<T>(value: T): T | Promise<T> | PromiseLike<T>;  async function doSomething(): Promise<[number, number]> {    const result = await Promise.all([MaybePromise(100), MaybePromise(200)]);    // Error!    //    //    [number | Promise<100>, number | Promise<200>]    //    // is not assignable to type    //    //    [number, number]    return result;  }   `\n\nNow `Promise.all` leverages the combination of certain features with `Awaited` to give much better inference results, and the above example works.\n\nFor more information, you [can read about this change on GitHub](https://github.com/microsoft/TypeScript/pull/45350)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#template-string-types-as-discriminants)\nTemplate String Types as Discriminants\n----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.5 now can narrow values that have template string types, and also recognizes template string types as discriminants.\n\nAs an example, the following used to fail, but now successfully type-checks in TypeScript 4.5.\n\nts\n\n``   export interface Success {      type: `${string}Success`;      body: string;  }  export interface Error {      type: `${string}Error`;      message: string  }  export function handler(r: Success | Error) {      if (r.type === \"HttpSuccess\") {          const token = r.body;                         (parameter) r: Success      }  }   ``[Try](https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBASwHY2FAZgQwMbDgZQFdtcBnUuAbwCg464YBPMYALjgAMASS0mKZAHMAvkRLByHANy16AIwgATRuz4CkgmcOrVQkWIhRosuOAFEoUaFVl0mLdt178hwi1ajTbcALYTSmIJscGpC1Nq64NDw6IRI2DAIEEhwABaYSIoANmgAFFDsYmQUAD7mltAAlDb0iOhw+QB09ngAvO1wAEQAEjAwYEX+ndU0tbXYyXwMEADWwCmtcFCNCsoyY-QA9JsbGwB6APze2sJAA)\n\nFor more information, [see the change that enables this feature](https://github.com/microsoft/TypeScript/pull/46137)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#module-es2022)\n`module es2022`\n----------------------------------------------------------------------------------------------------------------\n\nThanks to [Kagami S. Rosylight](https://github.com/saschanaz)\n, TypeScript now supports a new `module` setting: `es2022`. The main feature in [`module es2022`](https://www.typescriptlang.org/tsconfig#module)\n is top-level `await`, meaning you can use `await` outside of `async` functions. This was already supported in `--module esnext` (and now [`--module nodenext`](https://www.typescriptlang.org/tsconfig#target)\n), but `es2022` is the first stable target for this feature.\n\nYou can [read up more on this change here](https://github.com/microsoft/TypeScript/pull/44656)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#tail-recursion-elimination-on-conditional-types)\nTail-Recursion Elimination on Conditional Types\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript often needs to gracefully fail when it detects possibly infinite recursion, or any type expansions that can take a long time and affect your editor experience. As a result, TypeScript has heuristics to make sure it doesn’t go off the rails when trying to pick apart an infinitely-deep type, or working with types that generate a lot of intermediate results.\n\nts\n\n`   type InfiniteBox<T> = { item: InfiniteBox<T> };  type Unpack<T> = T extends { item: infer U } ? Unpack<U> : T;  // error: Type instantiation is excessively deep and possibly infinite.  type Test = Unpack<InfiniteBox<number>>;   `\n\nThe above example is intentionally simple and useless, but there are plenty of types that are actually useful, and unfortunately trigger our heuristics. As an example, the following `TrimLeft` type removes spaces from the beginning of a string-like type. If given a string type that has a space at the beginning, it immediately feeds the remainder of the string back into `TrimLeft`.\n\nts\n\n``   type TrimLeft<T extends string> =      T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;  // Test = \"hello\" | \"world\"  type Test = TrimLeft<\"   hello\" | \" world\">;   ``\n\nThis type can be useful, but if a string has 50 leading spaces, you’ll get an error.\n\nts\n\n``   type TrimLeft<T extends string> =      T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;  // error: Type instantiation is excessively deep and possibly infinite.  type Test = TrimLeft<\"                                                oops\">;   ``\n\nThat’s unfortunate, because these kinds of types tend to be extremely useful in modeling operations on strings - for example, parsers for URL routers. To make matters worse, a more useful type typically creates more type instantiations, and in turn has even more limitations on input length.\n\nBut there’s a saving grace: `TrimLeft` is written in a way that is _tail-recursive_ in one branch. When it calls itself again, it immediately returns the result and doesn’t do anything with it. Because these types don’t need to create any intermediate results, they can be implemented more quickly and in a way that avoids triggering many of type recursion heuristics that are built into TypeScript.\n\nThat’s why TypeScript 4.5 performs some tail-recursion elimination on conditional types. As long as one branch of a conditional type is simply another conditional type, TypeScript can avoid intermediate instantiations. There are still heuristics to ensure that these types don’t go off the rails, but they are much more generous.\n\nKeep in mind, the following type _won’t_ be optimized, since it uses the result of a conditional type by adding it to a union.\n\nts\n\n``   type GetChars<S> =      S extends `${infer Char}${infer Rest}` ? Char | GetChars<Rest> : never;   ``\n\nIf you would like to make it tail-recursive, you can introduce a helper that takes an “accumulator” type parameter, just like with tail-recursive functions.\n\nts\n\n``   type GetChars<S> = GetCharsHelper<S, never>;  type GetCharsHelper<S, Acc> =      S extends `${infer Char}${infer Rest}` ? GetCharsHelper<Rest, Char | Acc> : Acc;   ``\n\nYou can read up more on the implementation [here](https://github.com/microsoft/TypeScript/pull/45711)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#disabling-import-elision)\nDisabling Import Elision\n------------------------------------------------------------------------------------------------------------------------------------\n\nThere are some cases where TypeScript can’t detect that you’re using an import. For example, take the following code:\n\nts\n\n`   import { Animal } from \"./animal.js\";  eval(\"console.log(new Animal().isDangerous())\");   `\n\nBy default, TypeScript always removes this import because it appears to be unused. In TypeScript 4.5, you can enable a new flag called [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)\n to prevent TypeScript from stripping out any imported values from your JavaScript outputs. Good reasons to use `eval` are few and far between, but something very similar to this happens in Svelte:\n\nhtml\n\n`   <!-- A .svelte File -->  <script>    import { someFunc } from \"./some-module.js\";  </script>  <button on:click=\"{someFunc}\">Click me!</button>   `\n\nalong with in Vue.js, using its `<script setup>` feature:\n\nhtml\n\n`   <!-- A .vue File -->  <script setup>    import { someFunc } from \"./some-module.js\";  </script>  <button @click=\"someFunc\">Click me!</button>   `\n\nThese frameworks generate some code based on markup outside of their `<script>` tags, but TypeScript _only_ sees code within the `<script>` tags. That means TypeScript will automatically drop the import of `someFunc`, and the above code won’t be runnable! With TypeScript 4.5, you can use [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)\n to avoid these situations.\n\nNote that this flag has a special requirement when combined with [—isolatedModules\\`](https://www.typescriptlang.org/tsconfig#isolatedModules)\n: imported types _must_ be marked as type-only because compilers that process single files at a time have no way of knowing whether imports are values that appear unused, or a type that must be removed in order to avoid a runtime crash.\n\nts\n\n``   // Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,  // ts-loader, esbuild, etc. don't, so `isolatedModules` gives an error.  import { someFunc, BaseType } from \"./some-module.js\";  //                 ^^^^^^^^  // Error: 'BaseType' is a type and must be imported using a type-only import  // when 'preserveValueImports' and 'isolatedModules' are both enabled.   ``\n\nThat makes another TypeScript 4.5 feature, [`type` modifiers on import names](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#type-on-import-names)\n, especially important.\n\nFor more information, [see the pull request here](https://github.com/microsoft/TypeScript/pull/44619)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#type-modifiers-on-import-names)\n`type` Modifiers on Import Names\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nAs mentioned above, [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)\n and [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules)\n have special requirements so that there’s no ambiguity for build tools whether it’s safe to drop type imports.\n\nts\n\n``   // Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,  // ts-loader, esbuild, etc. don't, so `isolatedModules` issues an error.  import { someFunc, BaseType } from \"./some-module.js\";  //                 ^^^^^^^^  // Error: 'BaseType' is a type and must be imported using a type-only import  // when 'preserveValueImports' and 'isolatedModules' are both enabled.   ``\n\nWhen these options are combined, we need a way to signal when an import can be legitimately dropped. TypeScript already has something for this with `import type`:\n\nts\n\n`   import type { BaseType } from \"./some-module.js\";  import { someFunc } from \"./some-module.js\";  export class Thing implements BaseType {    // ...  }   `\n\nThis works, but it would be nice to avoid two import statements for the same module. That’s part of why TypeScript 4.5 allows a `type` modifier on individual named imports, so that you can mix and match as needed.\n\nts\n\n`   import { someFunc, type BaseType } from \"./some-module.js\";  export class Thing implements BaseType {      someMethod() {          someFunc();      }  }   `\n\nIn the above example, `BaseType` is always guaranteed to be erased and `someFunc` will be preserved under [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)\n, leaving us with the following code:\n\njs\n\n`   import { someFunc } from \"./some-module.js\";  export class Thing {    someMethod() {      someFunc();    }  }   `\n\nFor more information, see [the changes on GitHub](https://github.com/microsoft/TypeScript/pull/45998)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#private-field-presence-checks)\nPrivate Field Presence Checks\n----------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.5 supports an ECMAScript proposal for checking whether an object has a private field on it. You can now write a class with a `#private` field member and see whether another object has the same field by using the `in` operator.\n\nts\n\n`   class Person {      #name: string;      constructor(name: string) {          this.#name = name;      }      equals(other: unknown) {          return other &&              typeof other === \"object\" &&              #name in other && // <- this is new!              this.#name === other.#name;      }  }   `\n\nOne interesting aspect of this feature is that the check `#name in other` implies that `other` must have been constructed as a `Person`, since there’s no other way that field could be present. This is actually one of the key features of the proposal, and it’s why the proposal is named “ergonomic brand checks” - because private fields often act as a “brand” to guard against objects that aren’t instances of their class. As such, TypeScript is able to appropriately narrow the type of `other` on each check, until it ends up with the type `Person`.\n\nWe’d like to extend a big thanks to our friends at Bloomberg [who contributed this pull request](https://github.com/microsoft/TypeScript/pull/44648)\n: [Ashley Claymore](https://github.com/acutmore)\n, [Titian Cernicova-Dragomir](https://github.com/dragomirtitian)\n, [Kubilay Kahveci](https://github.com/mkubilayk)\n, and [Rob Palmer](https://github.com/robpalme)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#import-assertions)\nImport Assertions\n----------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.5 supports an ECMAScript proposal for _import assertions_. This is a syntax used by runtimes to make sure that an import has an expected format.\n\nts\n\n`   import obj from \"./something.json\" assert { type: \"json\" };   `\n\nThe contents of these assertions are not checked by TypeScript since they’re host-specific, and are simply left alone so that browsers and runtimes can handle them (and possibly error).\n\nts\n\n`   // TypeScript is fine with this.  // But your browser? Probably not.  import obj from \"./something.json\" assert {      type: \"fluffy bunny\"  };   `\n\nDynamic `import()` calls can also use import assertions through a second argument.\n\nts\n\n`   const obj = await import(\"./something.json\", {    assert: { type: \"json\" },  });   `\n\nThe expected type of that second argument is defined by a new type called `ImportCallOptions`, and currently only accepts an `assert` property.\n\nWe’d like to thank [Wenlu Wang](https://github.com/Kingwl/)\n for [implementing this feature](https://github.com/microsoft/TypeScript/pull/40698)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#const-assertions-and-default-type-arguments-in-jsdoc)\nConst Assertions and Default Type Arguments in JSDoc\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.5 brings some extra expressivity to our JSDoc support.\n\nOne example of this is with `const` assertions. In TypeScript, you can get a more precise and immutable type by writing `as const` after a literal.\n\nts\n\n`   // type is { prop: string }  let a = { prop: \"hello\" };  // type is { readonly prop: \"hello\" }  let b = { prop: \"hello\" } as const;   `\n\nIn JavaScript files, you can now use JSDoc type assertions to achieve the same thing.\n\nts\n\n`   // type is { prop: string }  let a = { prop: \"hello\" };  // type is { readonly prop: \"hello\" }  let b = /** @type {const} */ ({ prop: \"hello\" });   `\n\nAs a reminder, JSDoc type assertions comments start with `/** @type {TheTypeWeWant} */` and are followed by a parenthesized expression:\n\njs\n\n``   /** @type {TheTypeWeWant} */` (someExpression)   ``\n\nTypeScript 4.5 also adds default type arguments to JSDoc, which means the following `type` declaration in TypeScript:\n\nts\n\n`   type Foo<T extends string | number = number> = { prop: T };   `\n\ncan be rewritten as the following `@typedef` declaration in JavaScript:\n\njs\n\n`   /**   * @template {string | number} [T=number]   * @typedef Foo   * @property prop {T}   */  // or  /**   * @template {string | number} [T=number]   * @typedef {{ prop: T }} Foo   */   `\n\nFor more information, see [the pull request for const assertions](https://github.com/microsoft/TypeScript/pull/45464)\n along with [the changes for type argument defaults](https://github.com/microsoft/TypeScript/pull/45483)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#faster-load-time-with-realpathsyncnative)\nFaster Load Time with `realPathSync.native`\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript now leverages a system-native implementation of the Node.js `realPathSync` function on all operating systems.\n\nPreviously this function was only used on Linux, but in TypeScript 4.5 it has been adopted to operating systems that are typically case-insensitive, like Windows and MacOS. On certain codebases, this change sped up project loading by 5-13% (depending on the host operating system).\n\nFor more information, see [the original change here](https://github.com/microsoft/TypeScript/pull/44966)\n, along with [the 4.5-specific changes here](https://github.com/microsoft/TypeScript/pull/44966)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#snippet-completions-for-jsx-attributes)\nSnippet Completions for JSX Attributes\n----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.5 brings _snippet completions_ for JSX attributes. When writing out an attribute in a JSX tag, TypeScript will already provide suggestions for those attributes; but with snippet completions, they can remove a little bit of extra typing by adding an initializer and putting your cursor in the right place.\n\n![Snippet completions for JSX attributes. For a string property, quotes are automatically added. For a numeric properties, braces are added.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/jsx-attributes-snippets-4-5.gif)\n\nTypeScript will typically use the type of an attribute to figure out what kind of initializer to insert, but you can customize this behavior in Visual Studio Code.\n\n![Settings in VS Code for JSX attribute completions](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/jsx-snippet-settings-4-5.png)\n\nKeep in mind, this feature will only work in newer versions of Visual Studio Code, so you might have to use an Insiders build to get this working. For more information, [read up on the original pull request](https://github.com/microsoft/TypeScript/pull/45903)\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#better-editor-support-for-unresolved-types)\nBetter Editor Support for Unresolved Types\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn some cases, editors will leverage a lightweight “partial” semantic mode - either while the editor is waiting for the full project to load, or in contexts like [GitHub’s web-based editor](https://docs.github.com/en/codespaces/developing-in-codespaces/web-based-editor)\n.\n\nIn older versions of TypeScript, if the language service couldn’t find a type, it would just print `any`.\n\n![Hovering over a signature where Buffer isn't found, TypeScript replaces it with any.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/quick-info-unresolved-4-4.png)\n\nIn the above example, `Buffer` wasn’t found, so TypeScript replaced it with `any` in _quick info_. In TypeScript 4.5, TypeScript will try its best to preserve what you wrote.\n\n![Hovering over a signature where Buffer isn't found, it continues to use the name Buffer.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/quick-info-unresolved-4-5.png)\n\nHowever, if you hover over `Buffer` itself, you’ll get a hint that TypeScript couldn’t find `Buffer`.\n\n![TypeScript displays type Buffer = /* unresolved */ any;](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/quick-info-unresolved-on-type-4-5.png)\n\nAltogether, this provides a smoother experience when TypeScript doesn’t have the full program available. Keep in mind, you’ll always get an error in regular scenarios to tell you when a type isn’t found.\n\nFor more information, [see the implementation here](https://github.com/microsoft/TypeScript/pull/45976)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#libdts-changes)\n`lib.d.ts` Changes\n\nTypeScript 4.5 contains changes to its built-in declaration files which may affect your compilation; however, [these changes were fairly minimal](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1143)\n, and we expect most code will be unaffected.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#inference-changes-from-awaited)\nInference Changes from `Awaited`\n\nBecause `Awaited` is now used in `lib.d.ts` and as a result of `await`, you may see certain generic types change that might cause incompatibilities; however, given many intentional design decisions around `Awaited` to avoid breakage, we expect most code will be unaffected.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#compiler-options-checking-at-the-root-of-tsconfigjson)\nCompiler Options Checking at the Root of `tsconfig.json`\n\nIt’s an easy mistake to accidentally forget about the `compilerOptions` section in a `tsconfig.json`. To help catch this mistake, in TypeScript 4.5, it is an error to add a top-level field which matches any of the available options in `compilerOptions` _without_ having also defined `compilerOptions` in that `tsconfig.json`.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.5.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (4)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nE![escudero89  (1)](https://gravatar.com/avatar/7355cab5f47300d09c452a83bff6481dd00a1b9c638a44e24f70b1f3b131139c?s=32&&d=blank)\n\nR![Retsam  (1)](https://gravatar.com/avatar/49d2f8cb5cf518953215f7200141ab0f2b84df313e8f90ae69ebeb4e7ddfde80?s=32&&d=blank)\n\nN![navya9singh  (1)](https://gravatar.com/avatar/e896fd3c90d7bd8d3c276d3ea2dd552ae62d81d4a497cdd589f551c5eb5ccb93?s=32&&d=blank)\n\nHG![Holger Grosse-Plankermann  (1)](https://gravatar.com/avatar/27569133ed35633e54d1744e27ead00b5b8221aeef72d66ce617c9b47cc85506?s=32&&d=blank)\n\n4+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"theme-color":"#3178C6","og:title":"Documentation - TypeScript 4.5","title":"TypeScript: Documentation - TypeScript 4.5","ogDescription":"TypeScript 4.5 Release Notes","twitter:site":"typescriptlang","ogTitle":"Documentation - TypeScript 4.5","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","generator":"Gatsby 5.13.5","description":"TypeScript 4.5 Release Notes","og:description":"TypeScript 4.5 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","language":"en","scrapeId":"e0bc4f47-b12a-4675-805d-2b8d853d963c","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.4\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#control-flow-analysis-of-aliased-conditions-and-discriminants)\nControl Flow Analysis of Aliased Conditions and Discriminants\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript, we often have to probe a value in different ways, and do something different once we know more about its type. TypeScript understands these checks and calls them _type guards_. Instead of having to convince TypeScript of a variable’s type whenever we use it, the type-checker leverages something called _control flow analysis_ to see if we’ve used a type guard before a given piece of code.\n\nFor example, we can write something like\n\nts\n\n`   function foo(arg: unknown) {    if (typeof arg === \"string\") {      console.log(arg.toUpperCase());                    (parameter) arg: string    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMOcAUBDATgcwFyLgDWYcA7mAJSIDeAUIojMImlAJ4AOApnC9jkQBeEYgBEAZyhYYYHGOr1GjCAglwANtwB0GuDky5tUOAFVOPLAGEME7mkqUA3A2UB6N8q9eAegH5XAF86QKA)\n\nIn this example, we checked whether `arg` was a `string`. TypeScript recognized the `typeof arg === \"string\"` check, which it considered a type guard, and knew that `arg` was a `string` inside the body of the `if` block. That let us access `string` methods like `toUpperCase()` without getting an error.\n\nHowever, what would happen if we moved the condition out to a constant called `argIsString`?\n\nts\n\n`   // In TS 4.3 and below  function foo(arg: unknown) {    const argIsString = typeof arg === \"string\";    if (argIsString) {      console.log(arg.toUpperCase());      //              ~~~~~~~~~~~      // Error! Property 'toUpperCase' does not exist on type 'unknown'.    }  }   `\n\nIn previous versions of TypeScript, this would be an error - even though `argIsString` was assigned the value of a type guard, TypeScript simply lost that information. That’s unfortunate since we might want to re-use the same check in several places. To get around that, users often have to repeat themselves or use type assertions (a.k.a. casts).\n\nIn TypeScript 4.4, that is no longer the case. The above example works with no errors! When TypeScript sees that we are testing a constant value, it will do a little bit of extra work to see if it contains a type guard. If that type guard operates on a `const`, a `readonly` property, or an un-modified parameter, then TypeScript is able to narrow that value appropriately.\n\nDifferent sorts of type guard conditions are preserved - not just `typeof` checks. For example, checks on discriminated unions work like a charm.\n\nts\n\n`   type Shape =    | { kind: \"circle\"; radius: number }    | { kind: \"square\"; sideLength: number };  function area(shape: Shape): number {    const isCircle = shape.kind === \"circle\";    if (isCircle) {      // We know we have a circle here!      return Math.PI * shape.radius ** 2;    } else {      // We know we're left with a square here!      return shape.sideLength ** 2;    }  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwFEyEADIQSAc2BxhYydJns0aAGZ8StYEQD2JKFogIAFAKIkFTwSBAAlFYSUnjytF4CwFBEAgDCjCzQKFBB4QB0xOSoKDl0mawc8kSOUP6pGUysEXGYmAD07VAA6tAEJB4A7lCD0IgAbtAIUPRNY1IQAITymNrAfAzeALIIFvkACgCSUABUucEQ+dy8gqdnAEz2mDJQEMwC0LgrUJ09fQPDUYAcm0UFYjmSgyIFh8uQ0vigcAWyzaXAg6025wKegMxjMMJODyesjQMiAA)\n\nAnalysis on discriminants in 4.4 also goes a little bit deeper - we can now extract out discriminants and TypeScript can narrow the original object.\n\nts\n\n`   type Shape =    | { kind: \"circle\"; radius: number }    | { kind: \"square\"; sideLength: number };  function area(shape: Shape): number {    // Extract out the 'kind' field first.    const { kind } = shape;    if (kind === \"circle\") {      // We know we have a circle here!      return Math.PI * shape.radius ** 2;    } else {      // We know we're left with a square here!      return shape.sideLength ** 2;    }  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwFEyEADIQSAc2BxhYydJns0aAGZ8StYEQD2JKFogIAFAKIkFTwSBAAlFYSUnjyAPTxUACiAB7A3G5QHnzAUBbQAOTE5IVQjkQQzGTljALAAHTytF71iiU1MqhQQeH28kSOUP4dqCgoNPRMrNQRcZiYiVAA6tAEJB4A7lCb0IgAbtAIUFMse1IQAITymNrAfAzeALIIFg0ACgCSUABUPcEQBrcXiCX5-ABM9kwXSqAmguBuUCWq0IG22u0K2igrEceU2RAsPh6Gl8UDgF2uCy4EHuj3+4QaegMxjMhJ+EKhsjQMiAA)\n\nAs another example, here’s a function that checks whether two of its inputs have contents.\n\nts\n\n`   function doSomeChecks(    inputA: string | undefined,    inputB: string | undefined,    shouldDoExtraWork: boolean  ) {    const mustDoWork = inputA && inputB && shouldDoExtraWork;    if (mustDoWork) {      // We can access 'string' properties on both 'inputA' and 'inputB'!      const upperA = inputA.toUpperCase();      const upperB = inputB.toUpperCase();      // ...    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKYGEAW2EA1gM4AUAUIojGAA4hQCCAXIqVAE50DmiAH0Thk2YHWzIANNVoMmAIXaceYfkJFiJ02aXxwQAG2QAROAFEAHtwCGAdThdi7AEZw4h7DbCUAlIgBvWQgETkRMEE4zBydEAF45RhZEADIUxMVU9L0DYzMrWxjiAG5ZGGBEcgiouCL-IJoaAHomxDtsRAhvRBsICGxSUkQAchU+YcR6Ljh6bC5YAcQERDcofBG6JOYJ72QN+SgFYYBCWRoQsDCQelmuZniMlgA6KDgAVRu53BtSbHJfUqNTqhKDCT5cBQPTaKF7vcHfX7-QGNFqIJ7o2QAX0omKAA)\n\nTypeScript can understand that both `inputA` and `inputB` are both present if `mustDoWork` is `true`. That means we don’t have to write a non-null assertion like `inputA!` to convince TypeScript that `inputA` isn’t `undefined`.\n\nOne neat feature here is that this analysis works transitively. TypeScript will hop through constants to understand what sorts of checks you’ve already performed.\n\nts\n\n`   function f(x: string | number | boolean) {    const isString = typeof x === \"string\";    const isNumber = typeof x === \"number\";    const isStringOrNumber = isString || isNumber;    if (isStringOrNumber) {      x;       (parameter) x: string | number    } else {      x;       (parameter) x: boolean    }  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwFyIM5QE4xgDmiAPomCALYBGApnmYjXHADZ0CGYAlIgN4AoRIggJciGNgDK+QiQC8iKAE8ADnTjBEaRAv2IARLgLFDAbmGjxUSdgBy1eoyWqNWnXoOHKtBhasxMAkpWVMiAHk8Rz8XOzD5MnIpGOdLERhtFFC5YijUhj4hERE0SwB6cpEAPQB+KwBfRDo2bDoBK1KKqsQ6xsEGoA)\n\nNote that there’s a cutoff - TypeScript doesn’t go arbitrarily deep when checking these conditions, but its analysis is deep enough for most checks.\n\nThis feature should make a lot of intuitive JavaScript code “just work” in TypeScript without it getting in your way. For more details, [check out the implementation on GitHub](https://github.com/microsoft/TypeScript/pull/44730)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#symbol-and-template-string-pattern-index-signatures)\nSymbol and Template String Pattern Index Signatures\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript lets us describe objects where every property has to have a certain type using _index signatures_. This allows us to use these objects as dictionary-like types, where we can use string keys to index into them with square brackets.\n\nFor example, we can write a type with an index signature that takes `string` keys and maps to `boolean` values. If we try to assign anything other than a `boolean` value, we’ll get an error.\n\nts\n\n`  interface BooleanDictionary {    [key: string]: boolean;  }  declare let myDict: BooleanDictionary;  // Valid to assign boolean values  myDict[\"foo\"] = true;  myDict[\"bar\"] = false;  // Error, \"oops\" isn't a boolean  myDict[\"baz\"] = \"oops\";  Type 'string' is not assignable to type 'boolean'.2322Type 'string' is not assignable to type 'boolean'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vRg7AKwBQAlgHYAuMAZgIYDGkoAQnHADaS1kAiJ9FEnDK1oAT1ABvIqFABtANaQxqRBWjkA5gF1UAIzaduAbiIBfIkQAmkeu1FNOFUAFsxfAalYcuvfoOFRMVMiEFAANVp2EitQCjhQWkREEk0yUAMfblAANyiAV0hEIjcPCjkAImo2Cu1QAF446ELTUv9KvVFahtA6dkRIELCAUVgEABpQCrYAB0QK0BJEMgByZ1oMw18S93aKzoAvbsbpuDmK4yA)\n\nWhile [a `Map` might be a better data structure here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n (specifically, a `Map<string, boolean>`), JavaScript objects are often more convenient to use or just happen to be what we’re given to work with.\n\nSimilarly, `Array<T>` already defines a `number` index signature that lets us insert/retrieve values of type `T`.\n\nts\n\n`   // @errors: 2322 2375  // This is part of TypeScript's definition of the built-in Array type.  interface Array<T> {    [index: number]: T;    // ...  }  let arr = new Array<string>();  // Valid  arr[0] = \"hello!\";  // Error, expecting a 'string' value here  arr[1] = 123;   `\n\nIndex signatures are very useful to express lots of code out in the wild; however, until now they’ve been limited to `string` and `number` keys (and `string` index signatures have an intentional quirk where they can accept `number` keys since they’ll be coerced to strings anyway). That means that TypeScript didn’t allow indexing objects with `symbol` keys. TypeScript also couldn’t model an index signature of some _subset_ of `string` keys - for example, an index signature which describes just properties whose names start with the text `data-`.\n\nTypeScript 4.4 addresses these limitations, and allows index signatures for `symbol`s and template string patterns.\n\nFor example, TypeScript now allows us to declare a type that can be keyed on arbitrary `symbol`s.\n\nts\n\n`  interface Colors {    [sym: symbol]: number;  }  const red = Symbol(\"red\");  const green = Symbol(\"green\");  const blue = Symbol(\"blue\");  let colors: Colors = {};  // Assignment of a number is allowed  colors[red] = 255;  let redVal = colors[red];          let redVal: number  colors[blue] = \"da ba dee\";  Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1vRg7AKwBQAlgHYAuMAZgIYDGkoAwnADYKKgDeRooAbUQBPALaoRogEbsAuqjIBXaTADcRAL5Ei9OGUQVQ0SABNQAXlABlMTLYAKAETGTjgJTrd+wwHNjkMgtrW3YnP0gA9089A1ApNkUmSxtpUMd4xKjtNkhDXQ4kVFYCrktuDXUiEFAAQUREEh8yUQDDOGpQWlAlFWhQEi5aNg4Ad1Mddk4BF1kgtAICdRzDFwA1IaD8qZn1atAAPQB+bS2kAQzIWctHEy6pLpMIx1UgA)\n\nSimilarly, we can write an index signature with template string pattern type. One use of this might be to exempt properties starting with `data-` from TypeScript’s excess property checking. When we pass an object literal to something with an expected type, TypeScript will look for excess properties that weren’t declared in the expected type.\n\nts\n\n``   // @errors: 2322 2375  interface Options {      width?: number;      height?: number;  }  let a: Options = {      width: 100,      height: 100,      \"data-blah\": true,  };  interface OptionsWithDataProps extends Options {      // Permit any property starting with 'data-'.      [optName: `data-${string}`]: unknown;  }  let b: OptionsWithDataProps = {      width: 100,      height: 100,      \"data-blah\": true,      // Fails for a property which is not known, nor      // starts with 'data-'      \"unknown-property\": true,  };   ``\n\nA final note on index signatures is that they now permit union types, as long as they’re a union of infinite-domain primitive types - specifically:\n\n*   `string`\n*   `number`\n*   `symbol`\n*   template string patterns (e.g. `` `hello-${string}` ``)\n\nAn index signature whose argument is a union of these types will de-sugar into several different index signatures.\n\nts\n\n`   interface Data {    [optName: string | symbol]: any;  }  // Equivalent to  interface Data {    [optName: string]: any;    [optName: symbol]: any;  }   `\n\nFor more details, [read up on the pull request](https://github.com/microsoft/TypeScript/pull/44512)\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#defaulting-to-the-unknown-type-in-catch-variables---useunknownincatchvariables)\nDefaulting to the `unknown` Type in Catch Variables (`--useUnknownInCatchVariables`)\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript, any type of value can be thrown with `throw` and caught in a `catch` clause. Because of this, TypeScript historically typed catch clause variables as `any`, and would not allow any other type annotation:\n\nts\n\n`   try {    // Who knows what this might throw...    executeSomeThirdPartyCode();  } catch (err) {    // err: any    console.error(err.message); // Allowed, because 'any'    err.thisWillProbablyFail(); // Allowed, because 'any' :(  }   `\n\nOnce TypeScript added the `unknown` type, it became clear that `unknown` was a better choice than `any` in `catch` clause variables for users who want the highest degree of correctness and type-safety, since it narrows better and forces us to test against arbitrary values. Eventually TypeScript 4.0 allowed users to specify an explicit type annotation of `unknown` (or `any`) on each `catch` clause variable so that we could opt into stricter types on a case-by-case basis; however, for some, manually specifying `: unknown` on every `catch` clause was a chore.\n\nThat’s why TypeScript 4.4 introduces a new flag called [`useUnknownInCatchVariables`](https://www.typescriptlang.org/tsconfig#useUnknownInCatchVariables)\n. This flag changes the default type of `catch` clause variables from `any` to `unknown`.\n\nts\n\n`   try {    executeSomeThirdPartyCode();  } catch (err) {    // err: unknown    // Error! Property 'message' does not exist on type 'unknown'.    console.error(err.message);  'err' is of type 'unknown'.18046'err' is of type 'unknown'.    // Works! We can narrow 'err' from 'unknown' to 'Error'.    if (err instanceof Error) {      console.error(err.message);    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AKABNIBjAGwENpJQAzAVwDtaAXASzhdQkAB50OvSAGU4AW0gAVABb9oVAArNeATwDCcGgAoAlKgBucflQDcFEKAC0z2pOeOKvaDtABvCqAi4q5Ssgoqapra+oaQpnYAvqC0jLy0yqBGMNAmfgGgDtmo3ADWXHAA7lwU+Q4AorAIAISgGvAADjC6oADkCoiIjADmkD2gVHCQiKDlvEH8iHNCoLqdvaXlVT0AdPm0Qohw9JDb2QhZsNv9gyMmdrVgAOoIJYgtj6wpwlzM8BW92TGbHgcnWXDKlS4Y14cF6DXg0B2+X4bEy2VA-C4i0YPEgcFR8IQuX8gUC+yxRxOZ2gF2gVymN0gd3yCQoCSAA)\n\nThis flag is enabled under the [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n family of options. That means that if you check your code using [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n, this option will automatically be turned on. You may end up with errors in TypeScript 4.4 such as\n\n`   Property 'message' does not exist on type 'unknown'.  Property 'name' does not exist on type 'unknown'.  Property 'stack' does not exist on type 'unknown'.   `\n\nIn cases where we don’t want to deal with an `unknown` variable in a `catch` clause, we can always add an explicit `: any` annotation so that we can opt _out_ of stricter types.\n\nts\n\n`   try {    executeSomeThirdPartyCode();  } catch (err: any) {    console.error(err.message); // Works again!  }   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXxAA9xkMQBlHAWxABUALLGYABVgwE8BhHUACgCUALngA3HFmABuAFAB6OfAC0KsKRVKZGGB3gBvGfALE1ZSjQZNW7brxCDZAX3hgoGMPXh8QMGCKioHAL6hi54AM44ECAAdD4wODDevjE04eFQAOYgAlLwCvAA6okA1uHwWVBYqACEMo5AA)\n\nFor more information, take a look at [the implementing pull request](https://github.com/microsoft/TypeScript/pull/41013)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#exact-optional-property-types---exactoptionalpropertytypes)\nExact Optional Property Types (`--exactOptionalPropertyTypes`)\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript, reading a _missing_ property on an object produces the value `undefined`. It’s also possible to _have_ an actual property with the value `undefined`. A lot of code in JavaScript tends to treat these situations the same way, and so initially TypeScript just interpreted every optional property as if a user had written `undefined` in the type. For example,\n\nts\n\n`   interface Person {    name: string;    age?: number;  }   `\n\nwas considered equivalent to\n\nts\n\n`   interface Person {    name: string;    age?: number | undefined;  }   `\n\nWhat this meant is that a user could explicitly write `undefined` in place of `age`.\n\nts\n\n`   const p: Person = {    name: \"Daniel\",    age: undefined, // This is okay by default.  };   `\n\nSo by default, TypeScript doesn’t distinguish between a present property with the value `undefined` and a missing property. While this works most of the time, not all code in JavaScript makes the same assumptions. Functions and operators like `Object.assign`, `Object.keys`, object spread (`{ ...obj }`), and `for`\\-`in` loops behave differently depending on whether or not a property actually exists on an object. In the case of our `Person` example, this could potentially lead to runtime errors if the `age` property was observed in a context where its presence was important.\n\nIn TypeScript 4.4, the new flag [`exactOptionalPropertyTypes`](https://www.typescriptlang.org/tsconfig#exactOptionalPropertyTypes)\n specifies that optional property types should be interpreted exactly as written, meaning that `| undefined` is not added to the type:\n\nts\n\n`   // With 'exactOptionalPropertyTypes' on:  const p: Person = {  Type '{ name: string; age: undefined; }' is not assignable to type 'Person' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.   Types of property 'age' are incompatible.     Type 'undefined' is not assignable to type 'number'.2375Type '{ name: string; age: undefined; }' is not assignable to type 'Person' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.   Types of property 'age' are incompatible.     Type 'undefined' is not assignable to type 'number'.    name: \"Daniel\",    age: undefined, // Error! undefined isn't a number  };   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMA8EMGMAuB5ADoglgewHawDYAKATlqpMYgJ4AqV5AzgFAgQWnEMBcoATAMy9effgHYArEww5EFAGYJIoQhQa5QAbyahQeALaQeDRMWkBzANzbQsM5AD8PHAFc9AIwpWAvizABaAPhnRAC-X1AAdQxEAAtQAHIYBBR0bDwiUnJKWnpIBnjQXC4meFxjUFQeFU51AF5Na31DUAAiABFYHAxIfBaAGmtbZuccABNIOWlIUb7QVgBRYg4AQlAR8cmcadAMBhx4xBtdVw9iJi8LIA)\n\nThis flag is **not** part of the [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n family and needs to be turned on explicitly if you’d like this behavior. It also requires [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n to be enabled as well. We’ve been making updates to DefinitelyTyped and other definitions to try to make the transition as straightforward as possible, but you may encounter some friction with this depending on how your code is structured.\n\nFor more information, you can [take a look at the implementing pull request here](https://github.com/microsoft/TypeScript/pull/43947)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#static-blocks-in-classes)\n`static` Blocks in Classes\n--------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.4 brings support for [`static` blocks in classes](https://github.com/tc39/proposal-class-static-block#ecmascript-class-static-initialization-blocks)\n, an upcoming ECMAScript feature that can help you write more-complex initialization code for static members.\n\nts\n\n`   class Foo {      static count = 0;      // This is a static block:      static {          if (someCondition()) {              Foo.count++;          }      }  }   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwGccBbEAYT2C2zwAoBKALngCMccIQpUAoAej7wAtCLDIMIoT0hQCBeADF28AN494GwhijYw8MDjQZ4AXngAGANw91mgfAAqACyzzX8KFp1Y9LCDjAAa0ZbDQJtXVVQzQ0sRHhaIlIKVCoaVAZ6KJiczSUcADoDIwBqEutcjQBfaJqqoA)\n\nThese static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. That means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.\n\nts\n\n`   class Foo {      static #count = 0;      get count() {          return Foo.#count;      }      static {          try {              const lastInstances = loadLastInstances();              Foo.#count += lastInstances.length;          }          catch {}      }  }   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwhymABkoBnDASVUqnRHIAoBKALnnoE8BtAXQBQAeiHwAtBLDIMEsQMgVy8AGI4c8AN4D4O+HWxh4AYjA40GeAF54ABgDcA7boDmIC6fOtNT3brgZkGHxVHAA6EzNUDAdfAF9HX30sQy1fXwwYLm80nPhTWgtoSho6BiVrQmIyYoL6MEZWGNzfEPCPKPgAagqKalqy0IgQVGcMAAsmnPjmsCgMMDHNad142KA)\n\nWithout `static` blocks, writing the code above was possible, but often involved several different types of hacks that had to compromise in some way.\n\nNote that a class can have multiple `static` blocks, and they’re run in the same order in which they’re written.\n\nts\n\n`   // Prints:  //    1  //    2  //    3  class Foo {      static prop = 1      static {          console.log(Foo.prop++);      }      static {          console.log(Foo.prop++);      }      static {          console.log(Foo.prop++);      }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAUCcEsDsBcDOAuAUCUnQEZ1iwEx5agDMqAxgDYCGiioAYgPbOgDeqJi8N80FUAAdIzIaAC8OLlh58BHGSUwVmsRMyoBTAHRVmAcwAULZjpFiA1JYCUAbiWgAvo7n9BnZVlXrNu-cam5qJC1vaOLty87opeKmoa2nqGJqzBVrYOJC5OQA)\n\nWe’d like to extend our thanks to [Wenlu Wang](https://github.com/Kingwl)\n for TypeScript’s implementation of this feature. For more details, you can [see that pull request here](https://github.com/microsoft/TypeScript/pull/43370)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#tsc---help-updates-and-improvements)\n`tsc --help` Updates and Improvements\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript’s `--help` option has gotten a refresh! Thanks to work in part by [Song Gao](https://github.com/ShuiRuTian)\n, we’ve brought in changes to [update the descriptions of our compiler options](https://github.com/microsoft/TypeScript/pull/44409)\n and [restyle the `--help` menu](https://github.com/microsoft/TypeScript/pull/44157)\n with colors and other visual separation.\n\n![The new TypeScript --help menu where the output is bucketed into several different areas](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/tsc-help-ps-wt-4-4.png)\n\nYou can read more on [the original proposal thread](https://github.com/microsoft/TypeScript/issues/44074)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#performance-improvements)\nPerformance Improvements\n------------------------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#faster-declaration-emit)\nFaster Declaration Emit\n\nTypeScript now caches whether internal symbols are accessible in different contexts, along with how specific types should be printed. These changes can improve TypeScript’s general performance in code with fairly complex types, and is especially observed when emitting `.d.ts` files under the [`declaration`](https://www.typescriptlang.org/tsconfig#declaration)\n flag.\n\n[See more details here](https://github.com/microsoft/TypeScript/pull/43973)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#faster-path-normalization)\nFaster Path Normalization\n\nTypeScript often has to do several types of “normalization” on file paths to get them into a consistent format that the compiler can use everywhere. This involves things like replacing backslashes with slashes, or removing intermediate `/./` and `/../` segments of paths. When TypeScript has to operate over millions of these paths, these operations end up being a bit slow. In TypeScript 4.4, paths first undergo quick checks to see whether they need any normalization in the first place. These improvements together reduce project load time by 5-10% on bigger projects, and significantly more in massive projects that we’ve tested internally.\n\nFor more details, you can [view the PR for path segment normalization](https://github.com/microsoft/TypeScript/pull/44173)\n along with [the PR for slash normalization](https://github.com/microsoft/TypeScript/pull/44100)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#faster-path-mapping)\nFaster Path Mapping\n\nTypeScript now caches the way it constructs path-mappings (using the [`paths`](https://www.typescriptlang.org/tsconfig#paths)\n option in `tsconfig.json`). For projects with several hundred mappings, the reduction is significant. You can see more [on the change itself](https://github.com/microsoft/TypeScript/pull/44078)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#faster-incremental-builds-with---strict)\nFaster Incremental Builds with `--strict`\n\nIn what was effectively a bug, TypeScript would end up redoing type-checking work under [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n compilations if [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n was on. This led to many builds being just as slow as if [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n was turned off. TypeScript 4.4 fixes this, though the change has also been back-ported to TypeScript 4.3.\n\nSee more [here](https://github.com/microsoft/TypeScript/pull/44394)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#faster-source-map-generation-for-big-outputs)\nFaster Source Map Generation for Big Outputs\n\nTypeScript 4.4 adds an optimization for source map generation on extremely large output files. When building an older version of the TypeScript compiler, this results in around an 8% reduction in emit time.\n\nWe’d like to extend our thanks to [David Michon](https://github.com/dmichon-msft)\n who provided a [simple and clean change](https://github.com/microsoft/TypeScript/pull/44031)\n to enable this performance win.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#faster---force-builds)\nFaster `--force` Builds\n\nWhen using `--build` mode on project references, TypeScript has to perform up-to-date checks to determine which files need to be rebuilt. When performing a [`--force`](https://www.typescriptlang.org/tsconfig#force)\n build, however, that information is irrelevant since every project dependency will be rebuilt from scratch. In TypeScript 4.4, [`--force`](https://www.typescriptlang.org/tsconfig#force)\n builds avoid those unnecessary steps and start a full build. See more about the change [here](https://github.com/microsoft/TypeScript/pull/43666)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#spelling-suggestions-for-javascript)\nSpelling Suggestions for JavaScript\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript powers the JavaScript editing experience in editors like Visual Studio and Visual Studio Code. Most of the time, TypeScript tries to stay out of the way in JavaScript files; however, TypeScript often has a lot of information to make confident suggestions, and ways of surfacing suggestions that aren’t _too_ invasive.\n\nThat’s why TypeScript now issues spelling suggestions in plain JavaScript files - ones without `// @ts-check` or in a project with [`checkJs`](https://www.typescriptlang.org/tsconfig#checkJs)\n turned off. These are the same _“Did you mean…?”_ suggestions that TypeScript files already have, and now they’re available in _all_ JavaScript files in some form.\n\nThese spelling suggestions can provide a subtle clue that your code is wrong. We managed to find a few bugs in existing code while testing this feature!\n\nFor more details on this new feature, [take a look at the pull request](https://github.com/microsoft/TypeScript/pull/44271)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#inlay-hints)\nInlay Hints\n----------------------------------------------------------------------------------------------------------\n\nTypeScript 4.4 provides support for _inlay hints_ which can help display useful information like parameter names and return types in your code. You can think of it as a sort of friendly “ghost text”.\n\n![A preview of inlay hints in Visual Studio Code](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/inlayHints-4.4-rc-ghd.png)\n\nThis feature was built by [Wenlu Wang](https://github.com/Kingwl)\n whose [pull request](https://github.com/microsoft/TypeScript/pull/42089)\n has more details.\n\nWenlu also contributed [the integration for inlay hints in Visual Studio Code](https://github.com/microsoft/vscode/pull/113412)\n which has shipped as [part of the July 2021 (1.59) release](https://code.visualstudio.com/updates/v1_59#_typescript-44)\n. If you’d like to try inlay hints out, make sure you’re using a recent [stable](https://code.visualstudio.com/updates/v1_59)\n or [insiders](https://code.visualstudio.com/insiders/)\n version of the editor. You can also modify when and where inlay hints get displayed in Visual Studio Code’s settings.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#auto-imports-show-true-paths-in-completion-lists)\nAuto-Imports Show True Paths in Completion Lists\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen editors like Visual Studio Code show a completion list, completions which include auto-imports are displayed with a path to the given module; however, this path usually isn’t what TypeScript ends up placing in a module specifier. The path is usually something relative to the _workspace_, meaning that if you’re importing from a package like `moment`, you’ll often see a path like `node_modules/moment`.\n\n![A completion list containing unwieldy paths containing 'node_modules'. For example, the label for 'calendarFormat' is 'node_modules/moment/moment' instead of 'moment'.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/completion-import-labels-pre-4-4.png)\n\nThese paths end up being unwieldy and often misleading, especially given that the path that actually gets inserted into your file needs to consider Node’s `node_modules` resolution, path mappings, symlinks, and re-exports.\n\nThat’s why with TypeScript 4.4, the completion item label now shows the _actual_ module path that will be used for the import!\n\n![A completion list containing clean paths with no intermediate 'node_modules'. For example, the label for 'calendarFormat' is 'moment' instead of 'node_modules/moment/moment'.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/completion-import-labels-4-4.png)\n\nSince this calculation can be expensive, completion lists containing many auto-imports may fill in the final module specifiers in batches as you type more characters. It’s possible that you’ll still sometimes see the old workspace-relative path labels; however, as your editing experience “warms up”, they should get replaced with the actual path after another keystroke or two.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#libdts-changes-for-typescript-44)\n`lib.d.ts` Changes for TypeScript 4.4\n\nAs with every TypeScript version, declarations for `lib.d.ts` (especially the declarations generated for web contexts), have changed. You can consult [our list of known `lib.dom.d.ts` changes](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1029#issuecomment-869224737)\n to understand what is impacted.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#more-compliant-indirect-calls-for-imported-functions)\nMore-Compliant Indirect Calls for Imported Functions\n\nIn earlier versions of TypeScript, calling an import from CommonJS, AMD, and other non-ES module systems would set the `this` value of the called function. Specifically, in the following example, when calling `fooModule.foo()`, the `foo()` method will have `fooModule` set as the value of `this`.\n\nts\n\n`   // Imagine this is our imported module, and it has an export named 'foo'.  let fooModule = {    foo() {      console.log(this);    },  };  fooModule.foo();   `\n\nThis is not the way exported functions in ECMAScript are supposed to work when we call them. That’s why TypeScript 4.4 intentionally discards the `this` value when calling imported functions, by using the following emit.\n\nts\n\n`   // Imagine this is our imported module, and it has an export named 'foo'.  let fooModule = {    foo() {      console.log(this);    },  };  // Notice we're actually calling '(0, fooModule.foo)' now, which is subtly different.  (0, fooModule.foo)();   `\n\nYou can [read up more about the changes here](https://github.com/microsoft/TypeScript/pull/44624)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#using-unknown-in-catch-variables)\nUsing `unknown` in Catch Variables\n\nUsers running with the [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n flag may see new errors around `catch` variables being `unknown`, especially if the existing code assumes only `Error` values have been caught. This often results in error messages such as:\n\n`   Property 'message' does not exist on type 'unknown'.  Property 'name' does not exist on type 'unknown'.  Property 'stack' does not exist on type 'unknown'.   `\n\nTo get around this, you can specifically add runtime checks to ensure that the thrown type matches your expected type. Otherwise, you can just use a type assertion, add an explicit `: any` to your catch variable, or turn off [`useUnknownInCatchVariables`](https://www.typescriptlang.org/tsconfig#useUnknownInCatchVariables)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#broader-always-truthy-promise-checks)\nBroader Always-Truthy Promise Checks\n\nIn prior versions, TypeScript introduced “Always Truthy Promise checks” to catch code where an `await` may have been forgotten; however, the checks only applied to named declarations. That meant that while this code would correctly receive an error…\n\nts\n\n`   async function foo(): Promise<boolean> {    return false;  }  async function bar(): Promise<string> {    const fooResult = foo();    if (fooResult) {      // <- error! :D      return \"true\";    }    return \"false\";  }   `\n\n…the following code would not.\n\nts\n\n`   async function foo(): Promise<boolean> {    return false;  }  async function bar(): Promise<string> {    if (foo()) {      // <- no error :(      return \"true\";    }    return \"false\";  }   `\n\nTypeScript 4.4 now flags both. For more information, [read up on the original change](https://github.com/microsoft/TypeScript/pull/44491)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#abstract-properties-do-not-allow-initializers)\nAbstract Properties Do Not Allow Initializers\n\nThe following code is now an error because abstract properties may not have initializers:\n\nts\n\n`   abstract class C {    abstract prop = 1;    //       ~~~~    // Property 'prop' cannot have an initializer because it is marked abstract.  }   `\n\nInstead, you may only specify a type for the property:\n\nts\n\n`   abstract class C {    abstract prop: number;  }   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.4.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (2)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nEL![Eliran Levi  (1)](https://gravatar.com/avatar/f00fd5d066bb6174a9369ab456ce99bbc444afa281ff050a70a8a6cb0820894a?s=32&&d=blank)\n\nAB![Andrew Branch  (1)](https://gravatar.com/avatar/86ed396e4ffb41b052654b9f8ad4d1caaf732bc42985860b0cac8191a66e33df?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"title":"TypeScript: Documentation - TypeScript 4.4","description":"TypeScript 4.4 Release Notes","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","generator":"Gatsby 5.13.5","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","language":"en","og:description":"TypeScript 4.4 Release Notes","ogDescription":"TypeScript 4.4 Release Notes","ogTitle":"Documentation - TypeScript 4.4","og:title":"Documentation - TypeScript 4.4","scrapeId":"81f66439-9394-4284-807b-dfaabff7b053","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.3\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#separate-write-types-on-properties)\nSeparate Write Types on Properties\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript, it’s pretty common for APIs to convert values that are passed in before storing them. This often happens with getters and setters too. For example, let’s imagine we’ve got a class with a setter that always converts a value into a `number` before saving it in a private field.\n\njs\n\n`   class Thing {    #size = 0;    get size() {      return this.#size;    }    set size(value) {      let num = Number(value);      // Don't allow NaN and stuff.      if (!Number.isFinite(num)) {        this.#size = 0;        return;      }      this.#size = num;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwFDWgYgkQC8BTaAXmgAYBuLHaVEgF2kNIAoBKTB3AJxYBXfsmjMkEAHQFiJOrgC+DCCzZyOANzAghJHtly4Qa5EIC2FaADkLAIxL8tOvVzp9oAek-QAIgHtkAHJWHRB-AHcbMGtoMGQAEzZmIQAzVKkPRFToDgBCW3MHfilECAAxFERmEg4zcy4DD1wJMpl2MkpaZuhBFNEFI2UPVulZUit6weVFIA)\n\nHow would we type this JavaScript code in TypeScript? Well, technically we don’t have to do anything special here - TypeScript can look at this with no explicit types and can figure out that `size` is a number.\n\nThe problem is that `size` allows you to assign more than just `number`s to it. We could get around this by saying that `size` has the type `unknown` or `any` like in this snippet:\n\nts\n\n`   class Thing {    // ...    get size(): unknown {      return this.#size;    }  }   `\n\nBut that’s no good - `unknown` forces people reading `size` to do a type assertion, and `any` won’t catch any mistakes. If we really want to model APIs that convert values, previous versions of TypeScript forced us to pick between being precise (which makes reading values easier, and writing harder) and being permissive (which makes writing values easier, and reading harder).\n\nThat’s why TypeScript 4.3 allows you to specify types for reading and writing to properties.\n\nts\n\n`   class Thing {    #size = 0;    get size(): number {      return this.#size;    }    set size(value: string | number | boolean) {      let num = Number(value);      // Don't allow NaN and stuff.      if (!Number.isFinite(num)) {        this.#size = 0;        return;      }      this.#size = num;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwFDWgYgkQC8BTaAXmgAYBuLHaVEgF2kNIAoBKALmmQCuAWwBGJAE6YGucSwHjk0ZkggA6AsRJ1cAX3q4ILNpo4A3MCAEk+EZuJToAPv2FjJzkQHtPIEmGRcUri4vqyCQhTQAHKuEmYWVlx00tAA9KnQACKeyADkrBYgngDu0WBR0P4AJmzMAgBm9aopiPXQHACEMaISqogQAGIoiMwkHOFcgdjBwcr96uxklLQpMnIK2sF6KXNqGqSR4Zt6OkA)\n\nIn the above example, our `set` accessor takes a broader set of types (`string`s, `boolean`s, and `number`s), but our `get` accessor always guarantees it will be a `number`. Now we can finally assign other types to these properties with no errors!\n\nts\n\n``   let thing = new Thing();  // Assigning other types to `thing.size` works!  thing.size = \"hello\";  thing.size = true;  thing.size = 42;  // Reading `thing.size` always produces a number!  let mySize: number = thing.size;   ``[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwFDWgYgkQC8BTaAXmgAYBuLHaVEgF2kNIAoBKALmmQCuAWwBGJAE6YGucSwHjk0ZkggA6AsRJ1cAX3q4ILNpo4A3MCAEk+EZuJToAPv2FjJzkQHtPIEmGRcUri4vqyCQhTQAHKuEmYWVlx00tAA9KnQACKeyADkrBYgngDu0WBR0P4AJmzMAgBm9aopiPXQHACEMaISqogQAGIoiMwkHOFcgdjBwcr96uxklLQpMnIK2sF6KXNqGqSR4Zt6eunQALSXwALMl+dYoUpIaIckpQgO3MlnAIJQiKhkA5oJ5lBIlABPAAOJBgzE80AABnM0KpFojoMVPOIANYQDpYFGoNGaSIAIngJBARTJdCJJIOlDsVjpz2Ji0iABYAEzfDIAJT8VWByLZDJIGIsxTAEJgUPEniqAmAsMqLh64gJjyEEIAypo+OE3JF6YsaEA)\n\nWhen considering how two properties with the same name relate to each other, TypeScript will only use the “reading” type (e.g. the type on the `get` accessor above). “Writing” types are only considered when directly writing to a property.\n\nKeep in mind, this isn’t a pattern that’s limited to classes. You can write getters and setters with different types in object literals.\n\nts\n\n`   function makeThing(): Thing {    let size = 0;    return {      get size(): number {        return size;      },      set size(value: string | number | boolean) {        let num = Number(value);        // Don't allow NaN and stuff.        if (!Number.isFinite(num)) {          size = 0;          return;        }        size = num;      },    };  }   `\n\nIn fact, we’ve added syntax to interfaces/object types to support different reading/writing types on properties.\n\nts\n\n`   // Now valid!  interface Thing {      get size(): number      set size(value: number | string | boolean);  }   `\n\nOne limitation of using different types for reading and writing properties is that the type for reading a property has to be assignable to the type that you’re writing. In other words, the getter type has to be assignable to the setter. This ensures some level of consistency, so that a property is always assignable to itself.\n\nFor more information on this feature, take a look at [the implementing pull request](https://github.com/microsoft/TypeScript/pull/42425)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#override-and-the---noimplicitoverride-flag)\n`override` and the `--noImplicitOverride` Flag\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nWhen extending classes in JavaScript, the language makes it super easy (pun intended) to override methods - but unfortunately, there are some mistakes that you can run into.\n\nOne big one is missing renames. For example, take the following classes:\n\nts\n\n`   class SomeComponent {    show() {      // ...    }    hide() {      // ...    }  }  class SpecializedComponent extends SomeComponent {    show() {      // ...    }    hide() {      // ...    }  }   `\n\n`SpecializedComponent` subclasses `SomeComponent`, and overrides the `show` and `hide` methods. What happens if someone decides to rip out `show` and `hide` and replace them with a single method?\n\ndiff\n\n `class SomeComponent {  -    show() {  -        // ...  -    }  -    hide() {  -        // ...  -    }  +    setVisible(value: boolean) {  +        // ...  +    }   }   class SpecializedComponent extends SomeComponent {       show() {           // ...       }       hide() {           // ...       }   }`\n\n_Oh no!_ Our `SpecializedComponent` didn’t get updated. Now it’s just adding these two useless `show` and `hide` methods that probably won’t get called.\n\nPart of the issue here is that a user can’t make it clear whether they meant to add a new method, or to override an existing one. That’s why TypeScript 4.3 adds the `override` keyword.\n\nts\n\n`   class SpecializedComponent extends SomeComponent {      override show() {          // ...      }      override hide() {          // ...      }  }   `\n\nWhen a method is marked with `override`, TypeScript will always make sure that a method with the same name exists in a the base class.\n\nts\n\n`   class SomeComponent {      setVisible(value: boolean) {          // ...      }  }  class SpecializedComponent extends SomeComponent {      override show() {  This member cannot have an 'override' modifier because it is not declared in the base class 'SomeComponent'.4113This member cannot have an 'override' modifier because it is not declared in the base class 'SomeComponent'.      }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwPIDcBTAJyNQBMCAoECYo6IgZwC5QAWARg4GZL1kAho0agAytHgEAwhMTRIBSFlABvSqA2hGBLADVUjVACNkBABR4ByAK4FWR6NFMDIASlXrNXmgDo-njQBfSmD+IRFRRAJMK1QALwIyGSR5RWUCAA8sRTIIiWlZVKUPL2hCEnICLQALaAB3M3c1ANBgwKA)\n\nThis is a big improvement, but it doesn’t help if you _forget_ to write `override` on a method - and that’s a big mistake users can run into also.\n\nFor example, you might accidentally “trample over” a method that exists in a base class without realizing it.\n\nts\n\n`   class Base {    someHelperMethod() {      // ...    }  }  class Derived extends Base {    // Oops! We weren't trying to override here,    // we just needed to write a local helper method.    someHelperMethod() {      // ...    }  }   `\n\nThat’s why TypeScript 4.3 _also_ provides a new [`noImplicitOverride`](https://www.typescriptlang.org/tsconfig#noImplicitOverride)\n flag. When this option is turned on, it becomes an error to override any method from a superclass unless you explicitly use an `override` keyword. In that last example, TypeScript would error under [`noImplicitOverride`](https://www.typescriptlang.org/tsconfig#noImplicitOverride)\n, and give us a clue that we probably need to rename our method inside of `Derived`.\n\nWe’d like to extend our thanks to our community for the implementation here. The work for these items was implemented in [a pull request](https://github.com/microsoft/TypeScript/pull/39669)\n by [Wenlu Wang](https://github.com/Kingwl)\n, though an earlier pull request implementing only the `override` keyword by [Paul Cody Johnston](https://github.com/pcj)\n served as a basis for direction and discussion. We extend our gratitude for putting in the time for these features.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#template-string-type-improvements)\nTemplate String Type Improvements\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn recent versions, TypeScript introduced a new type construct: template string types. These are types that either construct new string-like types by concatenating…\n\nts\n\n``   type Color = \"red\" | \"blue\";  type Quantity = \"one\" | \"two\";  type SeussFish = `${Quantity | Color} fish`;  // same as  //   type SeussFish = \"one fish\" | \"two fish\"  //                  | \"red fish\" | \"blue fish\";   ``\n\n…or match patterns of other string-like types.\n\nts\n\n``   declare let s1: `${number}-${number}-${number}`;  declare let s2: `1-2-3`;  // Works!  s1 = s2;   ``\n\nThe first change we made is just in when TypeScript will infer a template string type. When a template string is _contextually typed_ by a string-literal-like type (i.e. when TypeScript sees we’re passing a template string to something that takes a literal type) it will try to give that expression a template type.\n\nts\n\n``   function bar(s: string): `hello ${string}` {      // Previously an error, now works!      return `hello ${s}`;  }   ``\n\nThis also kicks in when inferring types, and the type parameter `extends string`\n\nts\n\n``   declare let s: string;  declare function f<T extends string>(x: T): T;  // Previously: string  // Now       : `hello ${string}`  let x2 = f(`hello ${s}`);   ``\n\nThe second major change here is that TypeScript can now better-relate, and _infer between_, different template string types.\n\nTo see this, take the following example code:\n\nts\n\n``   declare let s1: `${number}-${number}-${number}`;  declare let s2: `1-2-3`;  declare let s3: `${number}-2-3`;  s1 = s2;  s1 = s3;   ``\n\nWhen checking against a string literal type like on `s2`, TypeScript could match against the string contents and figure out that `s2` was compatible with `s1` in the first assignment; however, as soon as it saw another template string, it just gave up. As a result, assignments like `s3` to `s1` just didn’t work.\n\nTypeScript now actually does the work to prove whether or not each part of a template string can successfully match. You can now mix and match template strings with different substitutions and TypeScript will do a good job to figure out whether they’re really compatible.\n\nts\n\n``   declare let s1: `${number}-${number}-${number}`;  declare let s2: `1-2-3`;  declare let s3: `${number}-2-3`;  declare let s4: `1-${number}-3`;  declare let s5: `1-2-${number}`;  declare let s6: `${number}-2-${number}`;  // Now *all of these* work!  s1 = s2;  s1 = s3;  s1 = s4;  s1 = s5;  s1 = s6;   ``\n\nIn doing this work, we were also sure to add better inference capabilities. You can see an example of these in action:\n\nts\n\n``   declare function foo<V extends string>(arg: `*${V}*`): V;  function test<T extends string>(s: string, n: number, b: boolean, t: T) {      let x1 = foo(\"*hello*\");            // \"hello\"      let x2 = foo(\"**hello**\");          // \"*hello*\"      let x3 = foo(`*${s}*` as const);    // string      let x4 = foo(`*${n}*` as const);    // `${number}`      let x5 = foo(`*${b}*` as const);    // \"true\" | \"false\"      let x6 = foo(`*${t}*` as const);    // `${T}`      let x7 = foo(`**${s}**` as const);  // `*${string}*`  }   ``\n\nFor more information, see [the original pull request on leveraging contextual types](https://github.com/microsoft/TypeScript/pull/43376)\n, along with [the pull request that improved inference and checking between template types](https://github.com/microsoft/TypeScript/pull/43361)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#ecmascript-private-class-elements)\nECMAScript `#private` Class Elements\n---------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.3 expands which elements in a class can be given `#private` `#names` to make them truly private at run-time. In addition to properties, methods and accessors can also be given private names.\n\nts\n\n`   class Foo {    #someMethod() {      //...    }    get #someValue() {      return 100;    }    publicMethod() {      // These work.      // We can access private-named members inside this class.      this.#someMethod();      return this.#someValue;    }  }  new Foo().#someMethod();  //        ~~~~~~~~~~~  // error!  // Property '#someMethod' is not accessible  // outside class 'Foo' because it has a private identifier.  new Foo().#someValue;  //        ~~~~~~~~~~  // error!  // Property '#someValue' is not accessible  // outside class 'Foo' because it has a private identifier.   `\n\nEven more broadly, static members can now also have private names.\n\nts\n\n`   class Foo {    static #someMethod() {      // ...    }  }  Foo.#someMethod();  //  ~~~~~~~~~~~  // error!  // Property '#someMethod' is not accessible  // outside class 'Foo' because it has a private identifier.   `\n\nThis feature was authored [in a pull request](https://github.com/microsoft/TypeScript/pull/42458)\n from our friends at Bloomberg - written by [Titian Cernicova-Dragomir](https://github.com/dragomirtitian)\nand [Kubilay Kahveci](https://github.com/mkubilayk)\n, with support and expertise from [Joey Watts](https://github.com/joeywatts)\n, [Rob Palmer](https://github.com/robpalme)\n, and [Tim McClure](https://github.com/tim-mc)\n. We’d like to extend our thanks to all of them!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#constructorparameters-works-on-abstract-classes)\n`ConstructorParameters` Works on Abstract Classes\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 4.3, the `ConstructorParameters` type helper now works on `abstract` classes.\n\nts\n\n`   abstract class C {    constructor(a: string, b: number) {      // ...    }  }  // Has the type '[a: string, b: number]'.  type CParams = ConstructorParameters<typeof C>;   `\n\nThis is thanks to work done in TypeScript 4.2, where construct signatures can be marked as abstract:\n\nts\n\n`   type MyConstructorOf<T> = {      abstract new(...args: any[]): T;  }  // or using the shorthand syntax:  type MyConstructorOf<T> = abstract new (...args: any[]) => T;   `\n\nYou can [see the change in more detail on GitHub](https://github.com/microsoft/TypeScript/pull/43380)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#contextual-narrowing-for-generics)\nContextual Narrowing for Generics\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.3 now includes some slightly smarter type-narrowing logic on generic values. This allows TypeScript to accept more patterns, and sometimes even catch mistakes.\n\nFor some motivation, let’s say we’re trying to write a function called `makeUnique`. It’ll take a `Set` or an `Array` of elements, and if it’s given an `Array`, it’ll sort that `Array` remove duplicates according to some comparison function. After all that, it will return the original collection.\n\nts\n\n`   function makeUnique<T>(    collection: Set<T> | T[],    comparer: (x: T, y: T) => number  ): Set<T> | T[] {    // Early bail-out if we have a Set.    // We assume the elements are already unique.    if (collection instanceof Set) {      return collection;    }    // Sort the array, then remove consecutive duplicates.    collection.sort(comparer);    for (let i = 0; i < collection.length; i++) {      let j = i;      while (        j < collection.length &&        comparer(collection[i], collection[j + 1]) === 0      ) {        j++;      }      collection.splice(i + 1, j - i);    }    return collection;  }   `\n\nLet’s leave questions about this function’s implementation aside, and assume it arose from the requirements of a broader application. Something that you might notice is that the signature doesn’t capture the original type of `collection`. We can do that by adding a type parameter called `C` in place of where we’ve written `Set<T> | T[]`.\n\ndiff\n\n`   - function makeUnique<T>(collection: Set<T> | T[], comparer: (x: T, y: T) => number): Set<T> | T[]  + function makeUnique<T, C extends Set<T> | T[]>(collection: C, comparer: (x: T, y: T) => number): C   `\n\nIn TypeScript 4.2 and earlier, you’d end up with a bunch of errors as soon as you tried this.\n\nts\n\n`   function makeUnique<T, C extends Set<T> | T[]>(    collection: C,    comparer: (x: T, y: T) => number  ): C {    // Early bail-out if we have a Set.    // We assume the elements are already unique.    if (collection instanceof Set) {      return collection;    }    // Sort the array, then remove consecutive duplicates.    collection.sort(comparer);    //         ~~~~    // error: Property 'sort' does not exist on type 'C'.    for (let i = 0; i < collection.length; i++) {      //                             ~~~~~~      // error: Property 'length' does not exist on type 'C'.      let j = i;      while (        j < collection.length &&        comparer(collection[i], collection[j + 1]) === 0      ) {        //                    ~~~~~~        // error: Property 'length' does not exist on type 'C'.        //                                       ~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~        // error: Element implicitly has an 'any' type because expression of type 'number'        //        can't be used to index type 'Set<T> | T[]'.        j++;      }      collection.splice(i + 1, j - i);      //         ~~~~~~      // error: Property 'splice' does not exist on type 'C'.    }    return collection;  }   `\n\nEw, errors! Why is TypeScript being so mean to us?\n\nThe issue is that when we perform our `collection instanceof Set` check, we’re expecting that to act as a type guard that narrows the type from `Set<T> | T[]` to `Set<T>` and `T[]` depending on the branch we’re in; however, we’re not dealing with a `Set<T> | T[]`, we’re trying to narrow the generic value `collection`, whose type is `C`.\n\nIt’s a very subtle distinction, but it makes a difference. TypeScript can’t just grab the constraint of `C` (which is `Set<T> | T[]`) and narrow that. If TypeScript _did_ try to narrow from `Set<T> | T[]`, it would forget that `collection` is also a `C` in each branch because there’s no easy way to preserve that information. If hypothetically TypeScript tried that approach, it would break the above example in a different way. At the return positions, where the function expects values with the type `C`, we would instead get a `Set<T>` and a `T[]` in each branch, which TypeScript would reject.\n\nts\n\n`   function makeUnique<T>(    collection: Set<T> | T[],    comparer: (x: T, y: T) => number  ): Set<T> | T[] {    // Early bail-out if we have a Set.    // We assume the elements are already unique.    if (collection instanceof Set) {      return collection;      //     ~~~~~~~~~~      // error: Type 'Set<T>' is not assignable to type 'C'.      //          'Set<T>' is assignable to the constraint of type 'C', but      //          'C' could be instantiated with a different subtype of constraint 'Set<T> | T[]'.    }    // ...    return collection;    //     ~~~~~~~~~~    // error: Type 'T[]' is not assignable to type 'C'.    //          'T[]' is assignable to the constraint of type 'C', but    //          'C' could be instantiated with a different subtype of constraint 'Set<T> | T[]'.  }   `\n\nSo how does TypeScript 4.3 change things? Well, basically in a few key places when writing code, all the type system really cares about is the constraint of a type. For example, when we write `collection.length`, TypeScript doesn’t care about the fact that `collection` has the type `C`, it only cares about the properties available, which are determined by the constraint `T[] | Set<T>`.\n\nIn cases like this, TypeScript will grab the narrowed type of the constraint because that will give you the data you care about; however, in any other case, we’ll just try to narrow the original generic type (and often end up with the original generic type).\n\nIn other words, based on how you use a generic value, TypeScript will narrow it a little differently. The end result is that the entire above example compiles with no type-checking errors.\n\nFor more details, you can [look at the original pull request on GitHub](https://github.com/microsoft/TypeScript/pull/43183)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#always-truthy-promise-checks)\nAlways-Truthy Promise Checks\n--------------------------------------------------------------------------------------------------------------------------------------------\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n, checking whether a `Promise` is “truthy” in a conditional will trigger an error.\n\nts\n\n`   async function foo(): Promise<boolean> {    return false;  }  async function bar(): Promise<string> {    if (foo()) {      //  ~~~~~      // Error!      // This condition will always return true since      // this 'Promise<boolean>' appears to always be defined.      // Did you forget to use 'await'?      return \"true\";    }    return \"false\";  }   `\n\n[This change](https://github.com/microsoft/TypeScript/pull/39175)\n was contributed by [Jack Works](https://github.com/Jack-Works)\n, and we extend our thanks to them!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#static-index-signatures)\n`static` Index Signatures\n------------------------------------------------------------------------------------------------------------------------------------\n\nIndex signatures allow us to set more properties on a value than a type explicitly declares.\n\nts\n\n`   class Foo {    hello = \"hello\";    world = 1234;    // This is an index signature:    [propName: string]: string | number | undefined;  }  let instance = new Foo();  // Valid assignment  instance[\"whatever\"] = 42;  // Has type 'string | number | undefined'.  let x = instance[\"something\"];   `\n\nUp until now, an index signature could only be declared on the instance side of a class. Thanks to [a pull request](https://github.com/microsoft/TypeScript/pull/37797)\n from [Wenlu Wang](https://github.com/microsoft/TypeScript/pull/37797)\n, index signatures can now be declared as `static`.\n\nts\n\n`   class Foo {    static hello = \"hello\";    static world = 1234;    static [propName: string]: string | number | undefined;  }  // Valid.  Foo[\"whatever\"] = 42;  // Has type 'string | number | undefined'  let x = Foo[\"something\"];   `\n\nThe same sorts of rules apply for index signatures on the static side of a class as they do for the instance side - namely, that every other static property has to be compatible with the index signature.\n\nts\n\n`   class Foo {    static prop = true;    //     ~~~~    // Error! Property 'prop' of type 'boolean'    // is not assignable to string index type    // 'string | number | undefined'.    static [propName: string]: string | number | undefined;  }   `\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#tsbuildinfo-size-improvements)\n`.tsbuildinfo` Size Improvements\n-------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 4.3, `.tsbuildinfo` files that are generated as part of [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n builds should be significantly smaller. This is thanks to several optimizations in the internal format, creating tables with numeric identifiers to be used throughout the file instead of repeating full paths and similar information. This work was spear-headed by [Tobias Koppers](https://github.com/sokra)\n in [their pull request](https://github.com/microsoft/TypeScript/pull/43079)\n, serving as inspiration for [the ensuing pull request](https://github.com/microsoft/TypeScript/pull/43155)\n and [further optimizations](https://github.com/microsoft/TypeScript/pull/43695)\n.\n\nWe have seen significant reductions of `.tsbuildinfo` file sizes including\n\n*   1MB to 411 KB\n*   14.9MB to 1MB\n*   1345MB to 467MB\n\nNeedless to say, these sorts of savings in size translate to slightly faster build times as well.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#lazier-calculations-in---incremental-and---watch-compilations)\nLazier Calculations in `--incremental` and `--watch` Compilations\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nOne of the issues with [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n and `--watch` modes are that while they make later compilations go faster, the initial compilation can be a bit slower - in some cases, significantly slower. This is because these modes have to perform a bunch of book-keeping, computing information about the current project, and sometimes saving that data in a `.tsbuildinfo` file for later builds.\n\nThat’s why on top of `.tsbuildinfo` size improvements, TypeScript 4.3 also ships some changes to [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n and `--watch` modes that make the first build of a project with these flags just as fast as an ordinary build! To do this, much of the information that would ordinarily be computed up-front is instead done on an on-demand basis for later builds. While this can add some overhead to a subsequent build, TypeScript’s [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n and `--watch` functionality will still typically operate on a much smaller set of files, and any needed information will be saved afterwards. In a sense, [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n and `--watch` builds will “warm up” and get faster at compiling files once you’ve updated them a few times.\n\nIn a repository with 3000 files, **this reduced initial build times to almost a third**!\n\n[This work was started](https://github.com/microsoft/TypeScript/pull/42960)\n by [Tobias Koppers](https://github.com/sokra)\n, whose work ensued in [the resulting final change](https://github.com/microsoft/TypeScript/pull/43314)\n for this functionality. We’d like to extend a great thanks to Tobias for helping us find these opportunities for improvements!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#import-statement-completions)\nImport Statement Completions\n--------------------------------------------------------------------------------------------------------------------------------------------\n\nOne of the biggest pain-points users run into with import and export statements in JavaScript is the order - specifically that imports are written as\n\nts\n\n`   import { func } from \"./module.js\";   `\n\ninstead of\n\nts\n\n`   from \"./module.js\" import { func };   `\n\nThis causes some pain when writing out a full import statement from scratch because auto-complete wasn’t able to work correctly. For example, if you start writing something like `import {`, TypeScript has no idea what module you’re planning on importing from, so it couldn’t provide any scoped-down completions.\n\nTo alleviate this, we’ve leveraged the power of auto-imports! Auto-imports already deal with the issue of not being able to narrow down completions from a specific module - their whole point is to provide every possible export and automatically insert an import statement at the top of your file.\n\nSo when you now start writing an `import` statement that doesn’t have a path, we’ll provide you with a list of possible imports. When you commit a completion, we’ll complete the full import statement, including the path that you were going to write.\n\n![Import statement completions](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/05/auto-import-statement-4-3.gif)\n\nThis work requires editors that specifically support the feature. You’ll be able to try this out by using the latest [Insiders versions of Visual Studio Code](https://code.visualstudio.com/insiders/)\n.\n\nFor more information, take a look at [the implementing pull request](https://github.com/microsoft/TypeScript/pull/43149)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#editor-support-for-link-tags)\nEditor Support for `@link` Tags\n-----------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript can now understand `@link` tags, and will try to resolve declarations that they link to. What this means is that you’ll be able to hover over names within `@link` tags and get quick information, or use commands like go-to-definition or find-all-references.\n\nFor example, you’ll be able to go-to-definition on `plantCarrot` in `@link plantCarrot` in the example below and a TypeScript-supported editor will jump to `plantCarrot`’s function declaration.\n\nts\n\n`   /**   * To be called 70 to 80 days after {@link plantCarrot}.   */  function harvestCarrot(carrot: Carrot) {}  /**   * Call early in spring for best results. Added in v2.1.0.   * @param seed Make sure it's a carrot seed!   */  function plantCarrot(seed: Seed) {    // TODO: some gardening  }   `\n\n![Jumping to definition and requesting quick info on a @link tag for ](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/05/link-tag-4-3.gif)\n\nFor more information, see [the pull request on GitHub](https://github.com/microsoft/TypeScript/pull/41877)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#go-to-definition-on-non-javascript-file-paths)\nGo-to-Definition on Non-JavaScript File Paths\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nMany loaders allow users to include assets in their applications using JavaScript imports. They’ll typically be written as something like `import \"./styles.css\"` or the like.\n\nUp until now, TypeScript’s editor functionality wouldn’t even attempt to read this file, so go-to-definition would typically fail. At best, go-to-definition would jump to a declaration like `declare module \"*.css\"` if it could find something along those lines.\n\nTypeScript’s language service now tries to jump to the correct file when you perform a go-to-definition on relative file paths, even if they’re not JavaScript or TypeScript files! Try it out with imports to CSS, SVGs, PNGs, font files, Vue files, and more.\n\nFor more information, you can check out [the implementing pull request](https://github.com/microsoft/TypeScript/pull/42539)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#libdts-changes)\n`lib.d.ts` Changes\n\nAs with every TypeScript version, declarations for `lib.d.ts` (especially the declarations generated for web contexts), have changed. In this release, we leveraged [Mozilla’s browser-compat-data](https://github.com/mdn/browser-compat-data)\n to remove APIs that no browser implements. While it is unlike that you are using them, APIs such as `Account`, `AssertionOptions`, `RTCStatsEventInit`, `MSGestureEvent`, `DeviceLightEvent`, `MSPointerEvent`, `ServiceWorkerMessageEvent`, and `WebAuthentication` have all been removed from `lib.d.ts`. This is discussed [in some detail here](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991)\n.\n\n[https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991)\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#usedefineforclassfields-now-defaults-to-true-on-esnext-and-eventually-on-es2022)\n`useDefineForClassFields` now defaults to true on `esnext` and eventually on `es2022`\n\nIn 2021 the class fields feature was added into the JavaScript specification with behavior which differed from how TypeScript had implemented it. In preparation for this, in TypeScript 3.7, a flag was added ([`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n) to migrate to emitted JavaScript to match the JavaScript standard behavior.\n\nNow that the feature is in JavaScript we are changing the default to `true` for ES2022 and above, including ESNext.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#errors-on-always-truthy-promise-checks)\nErrors on Always-Truthy Promise Checks\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n, using a `Promise` that always appears to be defined within a condition check is now considered an error.\n\nts\n\n`   declare var p: Promise<number>;  if (p) {    //  ~    // Error!    // This condition will always return true since    // this 'Promise<number>' appears to always be defined.    //    // Did you forget to use 'await'?  }   `\n\nFor more details, [see the original change](https://github.com/microsoft/TypeScript/pull/39175)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#union-enums-cannot-be-compared-to-arbitrary-numbers)\nUnion Enums Cannot Be Compared to Arbitrary Numbers\n\nCertain `enum`s are considered _union `enum`s_ when their members are either automatically filled in, or trivially written. In those cases, an enum can recall each value that it potentially represents.\n\nIn TypeScript 4.3, if a value with a union `enum` type is compared with a numeric literal that it could never be equal to, then the type-checker will issue an error.\n\nts\n\n`   enum E {    A = 0,    B = 1,  }  function doSomething(x: E) {    // Error! This condition will always return 'false' since the types 'E' and '-1' have no overlap.    if (x === -1) {      // ...    }  }   `\n\nAs a workaround, you can re-write an annotation to include the appropriate literal type.\n\nts\n\n`   enum E {    A = 0,    B = 1,  }  // Include -1 in the type, if we're really certain that -1 can come through.  function doSomething(x: E | -1) {    if (x === -1) {      // ...    }  }   `\n\nYou can also use a type-assertion on the value.\n\nts\n\n`   enum E {    A = 0,    B = 1,  }  function doSomething(x: E) {    // Use a type assertion on 'x' because we know we're not actually just dealing with values from 'E'.    if ((x as number) === -1) {      // ...    }  }   `\n\nAlternatively, you can re-declare your enum to have a non-trivial initializer so that any number is both assignable and comparable to that enum. This may be useful if the intent is for the enum to specify a few well-known values.\n\nts\n\n`   enum E {    // the leading + on 0 opts TypeScript out of inferring a union enum.    A = +0,    B = 1,  }   `\n\nFor more details, [see the original change](https://github.com/microsoft/TypeScript/pull/42472)\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.3.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (3)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nEL![Eliran Levi  (1)](https://gravatar.com/avatar/f00fd5d066bb6174a9369ab456ce99bbc444afa281ff050a70a8a6cb0820894a?s=32&&d=blank)\n\nNT![Németh Tamás  (1)](https://gravatar.com/avatar/fbb19ef18f56cb0703bb690128773015cd13893c79c9bda9e7c1430e7c1439f0?s=32&&d=blank)\n\nMS![Max Strübing  (1)](https://gravatar.com/avatar/b5d096f3354104f5ab8594fd849ae6d398acc0e042b3ac94d665cf4489664851?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","language":"en","ogTitle":"Documentation - TypeScript 4.3","ogDescription":"TypeScript 4.3 Release Notes","og:title":"Documentation - TypeScript 4.3","title":"TypeScript: Documentation - TypeScript 4.3","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","description":"TypeScript 4.3 Release Notes","og:description":"TypeScript 4.3 Release Notes","twitter:site":"typescriptlang","generator":"Gatsby 5.13.5","theme-color":"#3178C6","scrapeId":"6d95189a-30c0-412d-9c48-303d6e98112f","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.7\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#ecmascript-module-support-in-nodejs)\nECMAScript Module Support in Node.js\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nFor the last few years, Node.js has been working to support ECMAScript modules (ESM). This has been a very difficult feature, since the Node.js ecosystem is built on a different module system called CommonJS (CJS). Interoperating between the two brings large challenges, with many new features to juggle; however, support for ESM in Node.js was largely implemented in Node.js 12 and later. Around TypeScript 4.5 we rolled out nightly-only support for ESM in Node.js to get some feedback from users and let library authors ready themselves for broader support.\n\nTypeScript 4.7 adds this functionality with two new `module` settings: `node16` and `nodenext`.\n\njsonc\n\n`   {      \"compilerOptions\": {          \"module\": \"node16\",      }  }   `\n\nThese new modes bring a few high-level features which we’ll explore here.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#type-in-packagejson-and-new-extensions)\n`type` in `package.json` and New Extensions\n\nNode.js supports [a new setting in `package.json`](https://nodejs.org/api/packages.html#packages_package_json_and_file_extensions)\n called `type`. `\"type\"` can be set to either `\"module\"` or `\"commonjs\"`.\n\njsonc\n\n`   {      \"name\": \"my-package\",      \"type\": \"module\",      \"//\": \"...\",      \"dependencies\": {      }  }   `\n\nThis setting controls whether `.js` and `.d.ts` files are interpreted as ES modules or CommonJS modules, and defaults to CommonJS when not set. When a file is considered an ES module, a few different rules come into play compared to CommonJS:\n\n*   `import`/`export` statements can be used.\n*   Top-level `await` can be used\n*   Relative import paths need full extensions (we have to write `import \"./foo.js\"` instead of `import \"./foo\"`).\n*   Imports might resolve differently from dependencies in `node_modules`.\n*   Certain global-like values like `require` and `module` cannot be used directly.\n*   CommonJS modules get imported under certain special rules.\n\nWe’ll come back to some of these.\n\nTo overlay the way TypeScript works in this system, `.ts` and `.tsx` files now work the same way. When TypeScript finds a `.ts`, `.tsx`, `.js`, or `.jsx` file, it will walk up looking for a `package.json` to see whether that file is an ES module, and use that to determine:\n\n*   how to find other modules which that file imports\n*   and how to transform that file if producing outputs\n\nWhen a `.ts` file is compiled as an ES module, ECMAScript `import`/`export` statements are left alone in the `.js` output; when it’s compiled as a CommonJS module, it will produce the same output you get today under `--module commonjs`.\n\nThis also means paths resolve differently between `.ts` files that are ES modules and ones that are CJS modules. For example, let’s say you have the following code today:\n\nts\n\n`   // ./foo.ts  export function helper() {      // ...  }  // ./bar.ts  import { helper } from \"./foo\"; // only works in CJS  helper();   `\n\nThis code works in CommonJS modules, but will fail in ES modules because relative import paths need to use extensions. As a result, it will have to be rewritten to use the extension of the _output_ of `foo.ts` - so `bar.ts` will instead have to import from `./foo.js`.\n\nts\n\n`   // ./bar.ts  import { helper } from \"./foo.js\"; // works in ESM & CJS  helper();   `\n\nThis might feel a bit cumbersome at first, but TypeScript tooling like auto-imports and path completion will typically just do this for you.\n\nOne other thing to mention is the fact that this applies to `.d.ts` files too. When TypeScript finds a `.d.ts` file in a package, it is interpreted based on the containing package.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#new-file-extensions)\nNew File Extensions\n\nThe `type` field in `package.json` is nice because it allows us to continue using the `.ts` and `.js` file extensions which can be convenient; however, you will occasionally need to write a file that differs from what `type` specifies. You might also just prefer to always be explicit.\n\nNode.js supports two extensions to help with this: `.mjs` and `.cjs`. `.mjs` files are always ES modules, and `.cjs` files are always CommonJS modules, and there’s no way to override these.\n\nIn turn, TypeScript supports two new source file extensions: `.mts` and `.cts`. When TypeScript emits these to JavaScript files, it will emit them to `.mjs` and `.cjs` respectively.\n\nFurthermore, TypeScript also supports two new declaration file extensions: `.d.mts` and `.d.cts`. When TypeScript generates declaration files for `.mts` and `.cts`, their corresponding extensions will be `.d.mts` and `.d.cts`.\n\nUsing these extensions is entirely optional, but will often be useful even if you choose not to use them as part of your primary workflow.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#commonjs-interoperability)\nCommonJS Interoperability\n\nNode.js allows ES modules to import CommonJS modules as if they were ES modules with a default export.\n\nts\n\n`   // ./foo.cts  export function helper() {      console.log(\"hello world!\");  }  // ./bar.mts  import foo from \"./foo.cjs\";  // prints \"hello world!\"  foo.helper();   `\n\nIn some cases, Node.js also synthesizes named exports from CommonJS modules, which can be more convenient. In these cases, ES modules can use a “namespace-style” import (i.e. `import * as foo from \"...\"`), or named imports (i.e. `import { helper } from \"...\"`).\n\nts\n\n`   // ./foo.cts  export function helper() {      console.log(\"hello world!\");  }  // ./bar.mts  import { helper } from \"./foo.cjs\";  // prints \"hello world!\"  helper();   `\n\nThere isn’t always a way for TypeScript to know whether these named imports will be synthesized, but TypeScript will err on being permissive and use some heuristics when importing from a file that is definitely a CommonJS module.\n\nOne TypeScript-specific note about interop is the following syntax:\n\nts\n\n`   import foo = require(\"foo\");   `\n\nIn a CommonJS module, this just boils down to a `require()` call, and in an ES module, this imports [`createRequire`](https://nodejs.org/api/module.html#module_module_createrequire_filename)\n to achieve the same thing. This will make code less portable on runtimes like the browser (which don’t support `require()`), but will often be useful for interoperability. In turn, you can write the above example using this syntax as follows:\n\nts\n\n`   // ./foo.cts  export function helper() {      console.log(\"hello world!\");  }  // ./bar.mts  import foo = require(\"./foo.cjs\");  foo.helper()   `\n\nFinally, it’s worth noting that the only way to import ESM files from a CJS module is using dynamic `import()` calls. This can present challenges, but is the behavior in Node.js today.\n\nYou can [read more about ESM/CommonJS interop in Node.js here](https://nodejs.org/api/esm.html#esm_interoperability_with_commonjs)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#packagejson-exports-imports-and-self-referencing)\n`package.json` Exports, Imports, and Self-Referencing\n\nNode.js supports [a new field for defining entry points in `package.json` called `\"exports\"`](https://nodejs.org/api/packages.html#packages_exports)\n. This field is a more powerful alternative to defining `\"main\"` in `package.json`, and can control what parts of your package are exposed to consumers.\n\nHere’s a `package.json` that supports separate entry-points for CommonJS and ESM:\n\njsonc\n\n``   // package.json  {      \"name\": \"my-package\",      \"type\": \"module\",      \"exports\": {          \".\": {              // Entry-point for `import \"my-package\"` in ESM              \"import\": \"./esm/index.js\",              // Entry-point for `require(\"my-package\") in CJS              \"require\": \"./commonjs/index.cjs\",          },      },      // CJS fall-back for older versions of Node.js      \"main\": \"./commonjs/index.cjs\",  }   ``\n\nThere’s a lot to this feature, [which you can read more about on the Node.js documentation](https://nodejs.org/api/packages.html)\n. Here we’ll try to focus on how TypeScript supports it.\n\nWith TypeScript’s original Node support, it would look for a `\"main\"` field, and then look for declaration files that corresponded to that entry. For example, if `\"main\"` pointed to `./lib/index.js`, TypeScript would look for a file called `./lib/index.d.ts`. A package author could override this by specifying a separate field called `\"types\"` (e.g. `\"types\": \"./types/index.d.ts\"`).\n\nThe new support works similarly with [import conditions](https://nodejs.org/api/packages.html)\n. By default, TypeScript overlays the same rules with import conditions - if you write an `import` from an ES module, it will look up the `import` field, and from a CommonJS module, it will look at the `require` field. If it finds them, it will look for a corresponding declaration file. If you need to point to a different location for your type declarations, you can add a `\"types\"` import condition.\n\njsonc\n\n``   // package.json  {      \"name\": \"my-package\",      \"type\": \"module\",      \"exports\": {          \".\": {              // Entry-point for `import \"my-package\"` in ESM              \"import\": {                  // Where TypeScript will look.                  \"types\": \"./types/esm/index.d.ts\",                  // Where Node.js will look.                  \"default\": \"./esm/index.js\"              },              // Entry-point for `require(\"my-package\") in CJS              \"require\": {                  // Where TypeScript will look.                  \"types\": \"./types/commonjs/index.d.cts\",                  // Where Node.js will look.                  \"default\": \"./commonjs/index.cjs\"              },          }      },      // Fall-back for older versions of TypeScript      \"types\": \"./types/index.d.ts\",      // CJS fall-back for older versions of Node.js      \"main\": \"./commonjs/index.cjs\"  }   ``\n\n> The `\"types\"` condition should always come first in `\"exports\"`.\n\nIt’s important to note that the CommonJS entrypoint and the ES module entrypoint each needs its own declaration file, even if the contents are the same between them. Every declaration file is interpreted either as a CommonJS module or as an ES module, based on its file extension and the `\"type\"` field of the `package.json`, and this detected module kind must match the module kind that Node will detect for the corresponding JavaScript file for type checking to be correct. Attempting to use a single `.d.ts` file to type both an ES module entrypoint and a CommonJS entrypoint will cause TypeScript to think only one of those entrypoints exists, causing compiler errors for users of the package.\n\nTypeScript also supports [the `\"imports\"` field of `package.json`](https://nodejs.org/api/packages.html#packages_imports)\n in a similar manner by looking for declaration files alongside corresponding files, and supports [packages self-referencing themselves](https://nodejs.org/api/packages.html#packages_self_referencing_a_package_using_its_name)\n. These features are generally not as involved to set up, but are supported.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#your-feedback-wanted)\nYour Feedback Wanted!\n\nAs we continue working on TypeScript 4.7, we expect to see more documentation and polish go into this functionality. Supporting these new features has been an ambitious under-taking, and that’s why we’re looking for early feedback on it! Please try it out and let us know how it works for you.\n\nFor more information, [you can see the implementing PR here](https://github.com/microsoft/TypeScript/pull/44501)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#control-over-module-detection)\nControl over Module Detection\n----------------------------------------------------------------------------------------------------------------------------------------------\n\nOne issue with the introduction of modules to JavaScript was the ambiguity between existing “script” code and the new module code. JavaScript code in a module runs slightly differently, and has different scoping rules, so tools have to make decisions as to how each file runs. For example, Node.js requires module entry-points to be written in a `.mjs`, or have a nearby `package.json` with `\"type\": \"module\"`. TypeScript treats a file as a module whenever it finds any `import` or `export` statement in a file, but otherwise, will assume a `.ts` or `.js` file is a script file acting on the global scope.\n\nThis doesn’t quite match up with the behavior of Node.js where the `package.json` can change the format of a file, or the `--jsx` setting `react-jsx`, where any JSX file contains an implicit import to a JSX factory. It also doesn’t match modern expectations where most new TypeScript code is written with modules in mind.\n\nThat’s why TypeScript 4.7 introduces a new option called `moduleDetection`. `moduleDetection` can take on 3 values: `\"auto\"` (the default), `\"legacy\"` (the same behavior as 4.6 and prior), and `\"force\"`.\n\nUnder the mode `\"auto\"`, TypeScript will not only look for `import` and `export` statements, but it will also check whether\n\n*   the `\"type\"` field in `package.json` is set to `\"module\"` when running under `--module nodenext`/`--module node16`, and\n*   check whether the current file is a JSX file when running under `--jsx react-jsx`\n\nIn cases where you want every file to be treated as a module, the `\"force\"` setting ensures that every non-declaration file is treated as a module. This will be true regardless of how `module`, `moduleResolution`, and `jsx` are configured.\n\nMeanwhile, the `\"legacy\"` option simply goes back to the old behavior of only seeking out `import` and `export` statements to determine whether a file is a module.\n\nYou can [read up more about this change on the pull request](https://github.com/microsoft/TypeScript/pull/47495)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#control-flow-analysis-for-bracketed-element-access)\nControl-Flow Analysis for Bracketed Element Access\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.7 now narrows the types of element accesses when the indexed keys are literal types and unique symbols. For example, take the following code:\n\nts\n\n`   const key = Symbol();  const numberOrString = Math.random() < 0.5 ? 42 : \"hello\";  const obj = {      [key]: numberOrString,  };  if (typeof obj[key] === \"string\") {      let str = obj[key].toUpperCase();  }   `\n\nPreviously, TypeScript would not consider any type guards on `obj[key]`, and would have no idea that `obj[key]` was really a `string`. Instead, it would think that `obj[key]` was still a `string | number` and accessing `toUpperCase()` would trigger an error.\n\nTypeScript 4.7 now knows that `obj[key]` is a string.\n\nThis also means that under `--strictPropertyInitialization`, TypeScript can correctly check that computed properties are initialized by the end of a constructor body.\n\nts\n\n`   // 'key' has type 'unique symbol'  const key = Symbol();  class C {      [key]: string;      constructor(str: string) {          // oops, forgot to set 'this[key]'      }      screamString() {          return this[key].toUpperCase();      }  }   `\n\nUnder TypeScript 4.7, `--strictPropertyInitialization` reports an error telling us that the `[key]` property wasn’t definitely assigned by the end of the constructor.\n\nWe’d like to extend our gratitude to [Oleksandr Tarasiuk](https://github.com/a-tarasyuk)\n who provided [this change](https://github.com/microsoft/TypeScript/pull/45974)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#improved-function-inference-in-objects-and-methods)\nImproved Function Inference in Objects and Methods\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.7 can now perform more granular inferences from functions within objects and arrays. This allows the types of these functions to consistently flow in a left-to-right manner just like for plain arguments.\n\nts\n\n`   declare function f<T>(arg: {      produce: (n: string) => T,      consume: (x: T) => void }  ): void;  // Works  f({      produce: () => \"hello\",      consume: x => x.toLowerCase()  });  // Works  f({      produce: (n: string) => n,      consume: x => x.toLowerCase(),  });  // Was an error, now works.  f({      produce: n => n,      consume: x => x.toLowerCase(),  });  // Was an error, now works.  f({      produce: function () { return \"hello\"; },      consume: x => x.toLowerCase(),  });  // Was an error, now works.  f({      produce() { return \"hello\" },      consume: x => x.toLowerCase(),  });   `\n\nInference failed in some of these examples because knowing the type of their `produce` functions would indirectly request the type of `arg` before finding a good type for `T`. TypeScript now gathers functions that could contribute to the inferred type of `T` and infers from them lazily.\n\nFor more information, you can [take a look at the specific modifications to our inference process](https://github.com/microsoft/TypeScript/pull/48538)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#instantiation-expressions)\nInstantiation Expressions\n--------------------------------------------------------------------------------------------------------------------------------------\n\nOccasionally functions can be a bit more general than we want. For example, let’s say we had a `makeBox` function.\n\nts\n\n`   interface Box<T> {      value: T;  }  function makeBox<T>(value: T) {      return { value };  }   `\n\nMaybe we want to create a more specialized set of functions for making `Box`es of `Wrench`es and `Hammer`s. To do that today, we’d have to wrap `makeBox` in other functions, or use an explicit type for an alias of `makeBox`.\n\nts\n\n`   function makeHammerBox(hammer: Hammer) {      return makeBox(hammer);  }  // or...  const makeWrenchBox: (wrench: Wrench) => Box<Wrench> = makeBox;   `\n\nThese work, but wrapping a call to `makeBox` is a bit wasteful, and writing the full signature of `makeWrenchBox` could get unwieldy. Ideally, we would be able to say that we just want to alias `makeBox` while replacing all of the generics in its signature.\n\nTypeScript 4.7 allows exactly that! We can now take functions and constructors and feed them type arguments directly.\n\nts\n\n`   const makeHammerBox = makeBox<Hammer>;  const makeWrenchBox = makeBox<Wrench>;   `\n\nSo with this, we can specialize `makeBox` to accept more specific types and reject anything else.\n\nts\n\n`   const makeStringBox = makeBox<string>;  // TypeScript correctly rejects this.  makeStringBox(42);   `\n\nThis logic also works for constructor functions such as `Array`, `Map`, and `Set`.\n\nts\n\n``   // Has type `new () => Map<string, Error>`  const ErrorMap = Map<string, Error>;  // Has type `// Map<string, Error>`  const errorMap = new ErrorMap();   ``\n\nWhen a function or constructor is given type arguments, it will produce a new type that keeps all signatures with compatible type parameter lists, and replaces the corresponding type parameters with the given type arguments. Any other signatures are dropped, as TypeScript will assume that they aren’t meant to be used.\n\nFor more information on this feature, [check out the pull request](https://github.com/microsoft/TypeScript/pull/47607)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#extends-constraints-on-infer-type-variables)\n`extends` Constraints on `infer` Type Variables\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nConditional types are a bit of a power-user feature. They allow us to match and infer against the shape of types, and make decisions based on them. For example, we can write a conditional type that returns the first element of a tuple type if it’s a `string`\\-like type.\n\nts\n\n`   type FirstIfString<T> =      T extends [infer S, ...unknown[]]          ? S extends string ? S : never          : never;   // string  type A = FirstIfString<[string, number, number]>;  // \"hello\"  type B = FirstIfString<[\"hello\", number, number]>;  // \"hello\" | \"world\"  type C = FirstIfString<[\"hello\" | \"world\", boolean]>;  // never  type D = FirstIfString<[boolean, number, string]>;   `\n\n`FirstIfString` matches against any tuple with at least one element and grabs the type of the first element as `S`. Then it checks if `S` is compatible with `string` and returns that type if it is.\n\nNote that we had to use two conditional types to write this. We could have written `FirstIfString` as follows:\n\nts\n\n``   type FirstIfString<T> =      T extends [string, ...unknown[]]          // Grab the first type out of `T`          ? T[0]          : never;   ``\n\nThis works, but it’s slightly more “manual” and less declarative. Instead of just pattern-matching on the type and giving the first element a name, we have to fetch out the `0`th element of `T` with `T[0]`. If we were dealing with types more complex than tuples, this could get a lot trickier, so `infer` can simplify things.\n\nUsing nested conditionals to infer a type and then match against that inferred type is pretty common. To avoid that second level of nesting, TypeScript 4.7 now allows you to place a constraint on any `infer` type.\n\nts\n\n`   type FirstIfString<T> =      T extends [infer S extends string, ...unknown[]]          ? S          : never;   `\n\nThis way, when TypeScript matches against `S`, it also ensures that `S` has to be a `string`. If `S` isn’t a `string`, it takes the false path, which in these cases is `never`.\n\nFor more details, you can [read up on the change on GitHub](https://github.com/microsoft/TypeScript/pull/48112)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#optional-variance-annotations-for-type-parameters)\nOptional Variance Annotations for Type Parameters\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nLet’s take the following types.\n\nts\n\n`   interface Animal {      animalStuff: any;  }  interface Dog extends Animal {      dogStuff: any;  }  // ...  type Getter<T> = () => T;  type Setter<T> = (value: T) => void;   `\n\nImagine we had two different instances of `Getter`s. Figuring out whether any two different `Getter`s are substitutable for one another depends entirely on `T`. In the case of whether an assignment of `Getter<Dog>` → `Getter<Animal>` is valid, we have to check whether `Dog` → `Animal` is valid. Because each type for `T` just gets related in the same “direction”, we say that the `Getter` type is _covariant_ on `T`. On the other hand, checking whether `Setter<Dog>` → `Setter<Animal>` is valid involves checking whether `Animal` → `Dog` is valid. That “flip” in direction is kind of like how in math, checking whether −_x_ < _−y_ is the same as checking whether _y_ < _x_. When we have to flip directions like this to compare `T`, we say that `Setter` is _contravariant_ on `T`.\n\nWith TypeScript 4.7, we’re now able to _explicitly_ specify variance on type parameters.\n\nSo now, if we want to make it explicit that `Getter` is covariant on `T`, we can now give it an `out` modifier.\n\nts\n\n`   type Getter<out T> = () => T;   `\n\nAnd similarly, if we also want to make it explicit that `Setter` is contravariant on `T`, we can give it an `in` modifier.\n\nts\n\n`   type Setter<in T> = (value: T) => void;   `\n\n`out` and `in` are used here because a type parameter’s variance depends on whether it’s used in an _output_ or an _input_. Instead of thinking about variance, you can just think about if `T` is used in output and input positions.\n\nThere are also cases for using both `in` and `out`.\n\nts\n\n`   interface State<in out T> {      get: () => T;      set: (value: T) => void;  }   `\n\nWhen a `T` is used in both an output and input position, it becomes _invariant_. Two different `State<T>`s can’t be interchanged unless their `T`s are the same. In other words, `State<Dog>` and `State<Animal>` aren’t substitutable for the other.\n\nNow technically speaking, in a purely structural type system, type parameters and their variance don’t really matter - you can just plug in types in place of each type parameter and check whether each matching member is structurally compatible. So if TypeScript uses a structural type system, why are we interested in the variance of type parameters? And why might we ever want to annotate them?\n\nOne reason is that it can be useful for a reader to explicitly see how a type parameter is used at a glance. For much more complex types, it can be difficult to tell whether a type is meant to be read, written, or both. TypeScript will also help us out if we forget to mention how that type parameter is used. As an example, if we forgot to specify both `in` and `out` on `State`, we’d get an error.\n\nts\n\n`   interface State<out T> {      //          ~~~~~      // error!      // Type 'State<sub-T>' is not assignable to type 'State<super-T>' as implied by variance annotation.      //   Types of property 'set' are incompatible.      //     Type '(value: sub-T) => void' is not assignable to type '(value: super-T) => void'.      //       Types of parameters 'value' and 'value' are incompatible.      //         Type 'super-T' is not assignable to type 'sub-T'.      get: () => T;      set: (value: T) => void;  }   `\n\nAnother reason is precision and speed! TypeScript already tries to infer the variance of type parameters as an optimization. By doing this, it can type-check larger structural types in a reasonable amount of time. Calculating variance ahead of time allows the type-checker to skip deeper comparisons and just compare type arguments which can be _much_ faster than comparing the full structure of a type over and over again. But often there are cases where this calculation is still fairly expensive, and the calculation may find circularities that can’t be accurately resolved, meaning there’s no clear answer for the variance of a type.\n\nts\n\n`   type Foo<T> = {      x: T;      f: Bar<T>;  }  type Bar<U> = (x: Baz<U[]>) => void;  type Baz<V> = {      value: Foo<V[]>;  }  declare let foo1: Foo<unknown>;  declare let foo2: Foo<string>;  foo1 = foo2;  // Should be an error but isn't ❌  foo2 = foo1;  // Error - correct ✅   `\n\nProviding an explicit annotation can speed up type-checking at these circularities and provide better accuracy. For instance, marking `T` as invariant in the above example can help stop the problematic assignment.\n\ndiff\n\n`   - type Foo<T> = {  + type Foo<in out T> = {        x: T;        f: Bar<T>;    }   `\n\nWe don’t necessarily recommend annotating every type parameter with its variance; For example, it’s possible (but not recommended) to make variance a little stricter than is necessary, so TypeScript won’t stop you from marking something as invariant if it’s really just covariant, contravariant, or even independent. So if you do choose to add explicit variance markers, we would encourage thoughtful and precise use of them.\n\nBut if you’re working with deeply recursive types, especially if you’re a library author, you may be interested in using these annotations to the benefit of your users. Those annotations can provide wins in both accuracy and type-checking speed, which can even affect their code editing experience. Determining when variance calculation is a bottleneck on type-checking time can be done experimentally, and determined using tooling like our [analyze-trace](https://github.com/microsoft/typescript-analyze-trace)\n utility.\n\nFor more details on this feature, you can [read up on the pull request](https://github.com/microsoft/TypeScript/pull/48240)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#resolution-customization-with-modulesuffixes)\nResolution Customization with `moduleSuffixes`\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.7 now supports a `moduleSuffixes` option to customize how module specifiers are looked up.\n\njsonc\n\n`   {      \"compilerOptions\": {          \"moduleSuffixes\": [\".ios\", \".native\", \"\"]      }  }   `\n\nGiven the above configuration, an import like the following…\n\nts\n\n`   import * as foo from \"./foo\";   `\n\nwill try to look at the relative files `./foo.ios.ts`, `./foo.native.ts`, and finally `./foo.ts`.\n\nThis feature can be useful for React Native projects where each target platform can use a separate `tsconfig.json` with differing `moduleSuffixes`.\n\n[The `moduleSuffixes` option](https://github.com/microsoft/TypeScript/pull/48189)\n was contributed thanks to [Adam Foxman](https://github.com/afoxman)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#resolution-mode)\nresolution-mode\n------------------------------------------------------------------------------------------------------------------\n\nWith Node’s ECMAScript resolution, the mode of the containing file and the syntax you use determines how imports are resolved; however it would be useful to reference the types of a CommonJS module from an ECMAScript module, or vice-versa.\n\nTypeScript now allows `/// <reference types=\"...\" />` directives.\n\nts\n\n`   /// <reference types=\"pkg\" resolution-mode=\"require\" />  // or  /// <reference types=\"pkg\" resolution-mode=\"import\" />   `\n\nAdditionally, in nightly versions of TypeScript, `import type` can specify an import assertion to achieve something similar.\n\nts\n\n``   // Resolve `pkg` as if we were importing with a `require()`  import type { TypeFromRequire } from \"pkg\" assert {      \"resolution-mode\": \"require\"  };  // Resolve `pkg` as if we were importing with an `import`  import type { TypeFromImport } from \"pkg\" assert {      \"resolution-mode\": \"import\"  };  export interface MergedType extends TypeFromRequire, TypeFromImport {}   ``\n\nThese import assertions can also be used on `import()` types.\n\nts\n\n`   export type TypeFromRequire =      import(\"pkg\", { assert: { \"resolution-mode\": \"require\" } }).TypeFromRequire;  export type TypeFromImport =      import(\"pkg\", { assert: { \"resolution-mode\": \"import\" } }).TypeFromImport;  export interface MergedType extends TypeFromRequire, TypeFromImport {}   `\n\nThe `import type` and `import()` syntaxes only support `resolution-mode` in [nightly builds of TypeScript](https://www.typescriptlang.org/docs/handbook/nightly-builds.html)\n. You’ll likely get an error like\n\n`   Resolution mode assertions are unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'.   `\n\nIf you do find yourself using this feature in nightly versions of TypeScript, [consider providing feedback on this issue](https://github.com/microsoft/TypeScript/issues/49055)\n.\n\nYou can see the respective changes [for reference directives](https://github.com/microsoft/TypeScript/pull/47732)\n and [for type import assertions](https://github.com/microsoft/TypeScript/pull/47807)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#go-to-source-definition)\nGo to Source Definition\n----------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.7 contains support for a new experimental editor command called _Go To Source Definition_. It’s similar to _Go To Definition_, but it never returns results inside declaration files. Instead, it tries to find corresponding _implementation_ files (like `.js` or `.ts` files), and find definitions there — even if those files are normally shadowed by `.d.ts` files.\n\nThis comes in handy most often when you need to peek at the implementation of a function you’re importing from a library instead of its type declaration in a `.d.ts` file.\n\n![The \"Go to Source Definition\" command on a use of the yargs package jumps the editor to an index.cjs file in yargs.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/05/go-to-source-definition-4-7-v1.gif)\n\nYou can try this new command in the latest versions of Visual Studio Code. Note, though, that this functionality is still in preview, and there are some known limitations. In some cases TypeScript uses heuristics to guess which `.js` file corresponds to the given result of a definition, so these results might be inaccurate. Visual Studio Code also doesn’t yet indicate whether a result was a guess, but it’s something we’re collaborating on.\n\nYou can leave feedback about the feature, read about known limitations, or learn more at [our dedicated feedback issue](https://github.com/microsoft/TypeScript/issues/49003)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#group-aware-organize-imports)\nGroup-Aware Organize Imports\n--------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript has an _Organize Imports_ editor feature for both JavaScript and TypeScript. Unfortunately, it could be a bit of a blunt instrument, and would often naively sort your import statements.\n\nFor instance, if you ran Organize Imports on the following file…\n\nts\n\n`   // local code  import * as bbb from \"./bbb\";  import * as ccc from \"./ccc\";  import * as aaa from \"./aaa\";  // built-ins  import * as path from \"path\";  import * as child_process from \"child_process\"  import * as fs from \"fs\";  // some code...   `\n\nYou would get something like the following\n\nts\n\n`   // local code  import * as child_process from \"child_process\";  import * as fs from \"fs\";  // built-ins  import * as path from \"path\";  import * as aaa from \"./aaa\";  import * as bbb from \"./bbb\";  import * as ccc from \"./ccc\";  // some code...   `\n\nThis is… not ideal. Sure, our imports are sorted by their paths, and our comments and newlines are preserved, but not in a way we expected. Much of the time, if we have our imports grouped in a specific way, then we want to keep them that way.\n\nTypeScript 4.7 performs Organize Imports in a group-aware manner. Running it on the above code looks a little bit more like what you’d expect:\n\nts\n\n`   // local code  import * as aaa from \"./aaa\";  import * as bbb from \"./bbb\";  import * as ccc from \"./ccc\";  // built-ins  import * as child_process from \"child_process\";  import * as fs from \"fs\";  import * as path from \"path\";  // some code...   `\n\nWe’d like to extend our thanks to [Minh Quy](https://github.com/MQuy)\n who provided [this feature](https://github.com/microsoft/TypeScript/pull/48330)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#object-method-snippet-completions)\nObject Method Snippet Completions\n------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript now provides snippet completions for object literal methods. When completing members in an object, TypeScript will provide a typical completion entry for just the name of a method, along with a separate completion entry for the full method definition!\n\n![Completion a full method signature from an object](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/05/object-method-completions-4-7-v2.gif)\n\nFor more details, [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/48168)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#libdts-updates)\n`lib.d.ts` Updates\n\nWhile TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don’t expect major breaks as a result of DOM and `lib.d.ts` updates, but there may be some small ones.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#stricter-spread-checks-in-jsx)\nStricter Spread Checks in JSX\n\nWhen writing a `...spread` in JSX, TypeScript now enforces stricter checks that the given type is actually an object. As a result, values with the types `unknown` and `never` (and more rarely, just bare `null` and `undefined`) can no longer be spread into JSX elements.\n\nSo for the following example:\n\ntsx\n\n`   import * as React from \"react\";  interface Props {      stuff?: string;  }  function MyComponent(props: unknown) {      return <div {...props} />;  }   `\n\nyou’ll now receive an error like the following:\n\n`   Spread types may only be created from object types.   `\n\nThis makes this behavior more consistent with spreads in object literals.\n\nFor more details, [see the change on GitHub](https://github.com/microsoft/TypeScript/pull/48570)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#stricter-checks-with-template-string-expressions)\nStricter Checks with Template String Expressions\n\nWhen a `symbol` value is used in a template string, it will trigger a runtime error in JavaScript.\n\njs\n\n``   let str = `hello ${Symbol()}`;  // TypeError: Cannot convert a Symbol value to a string   ``\n\nAs a result, TypeScript will issue an error as well; however, TypeScript now also checks if a generic value that is constrained to a symbol in some way is used in a template string.\n\nts\n\n``   function logKey<S extends string | symbol>(key: S): S {      // Now an error.      console.log(`${key} is the key`);      return key;  }  function get<T, K extends keyof T>(obj: T, key: K) {      // Now an error.      console.log(`Grabbing property '${key}'.`);      return obj[key];  }   ``\n\nTypeScript will now issue the following error:\n\n`   Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'.   `\n\nIn some cases, you can get around this by wrapping the expression in a call to `String`, just like the error message suggests.\n\nts\n\n``   function logKey<S extends string | symbol>(key: S): S {      // No longer an error.      console.log(`${String(key)} is the key`);      return key;  }   ``\n\nIn others, this error is too pedantic, and you might not ever care to even allow `symbol` keys when using `keyof`. In such cases, you can switch to `string & keyof ...`:\n\nts\n\n``   function get<T, K extends string & keyof T>(obj: T, key: K) {      // No longer an error.      console.log(`Grabbing property '${key}'.`);      return obj[key];  }   ``\n\nFor more information, you can [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/44578)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#readfile-method-is-no-longer-optional-on-languageservicehost)\n`readFile` Method is No Longer Optional on `LanguageServiceHost`\n\nIf you’re creating `LanguageService` instances, then provided `LanguageServiceHost`s will need to provide a `readFile` method. This change was necessary to support the new `moduleDetection` compiler option.\n\nYou can [read more on the change here](https://github.com/microsoft/TypeScript/pull/47495)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#readonly-tuples-have-a-readonly-length-property)\n`readonly` Tuples Have a `readonly` `length` Property\n\nA `readonly` tuple will now treat its `length` property as `readonly`. This was almost never witnessable for fixed-length tuples, but was an oversight which could be observed for tuples with trailing optional and rest element types.\n\nAs a result, the following code will now fail:\n\nts\n\n`   function overwriteLength(tuple: readonly [string, string, string]) {      // Now errors.      tuple.length = 7;  }   `\n\nYou can [read more on this change here](https://github.com/microsoft/TypeScript/pull/47717)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.7.md)\n ❤\n\nContributors to this page:  \n\nAB![Andrew Branch  (9)](https://gravatar.com/avatar/86ed396e4ffb41b052654b9f8ad4d1caaf732bc42985860b0cac8191a66e33df?s=32&&d=blank)\n\nNT![Németh Tamás  (1)](https://gravatar.com/avatar/fbb19ef18f56cb0703bb690128773015cd13893c79c9bda9e7c1430e7c1439f0?s=32&&d=blank)\n\nPADPB![Pedro Augusto de Paula Barbosa  (1)](https://gravatar.com/avatar/790eda60de64b0ecd6abcb01795c4b618a33f73dfe8922010d0076919bdf518f?s=32&&d=blank)\n\nHC![Hyunyoung Cho  (1)](https://gravatar.com/avatar/cb18dd5cc127bc0a4f24d70555a3a527df1a1c150ec6d36f22273dc702739842?s=32&&d=blank)\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","title":"TypeScript: Documentation - TypeScript 4.7","description":"TypeScript 4.7 Release Notes","generator":"Gatsby 5.13.5","ogDescription":"TypeScript 4.7 Release Notes","language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","theme-color":"#3178C6","og:title":"Documentation - TypeScript 4.7","ogTitle":"Documentation - TypeScript 4.7","twitter:site":"typescriptlang","og:description":"TypeScript 4.7 Release Notes","scrapeId":"99986cca-f305-4dde-b46f-3f724da7fa91","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.2\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#smarter-type-alias-preservation)\nSmarter Type Alias Preservation\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript has a way to declare new names for types called type aliases. If you’re writing a set of functions that all work on `string | number | boolean`, you can write a type alias to avoid repeating yourself over and over again.\n\nts\n\n`   type BasicPrimitive = number | string | boolean;   `\n\nTypeScript has always used a set of rules and guesses for when to reuse type aliases when printing out types. For example, take the following code snippet.\n\nts\n\n`   export type BasicPrimitive = number | string | boolean;  export function doStuff(value: BasicPrimitive) {    let x = value;    return x;  }   `\n\nIf we hover our mouse over `x` in an editor like Visual Studio, Visual Studio Code, or [the TypeScript Playground](https://www.typescriptlang.org/play?ts=4.1.3#code/KYDwDg9gTgLgBDAnmYcBCBDAzgSwMYAKUOAtjjDgG6oC8cAdgK4kBGwUcAPnFjMfQHMucFhAgAbYBnoBuAFBzQkWHABmjengoR6cACYQAyjEarVACkoZxjYAC502fEVLkqwAJRwA3nLj+4SXgQODorG2B5ALgoYBMoXRB5AF8gA)\n, we’ll get a quick info panel that shows the type `BasicPrimitive`. Likewise, if we get the declaration file output (`.d.ts` output) for this file, TypeScript will say that `doStuff` returns `BasicPrimitive`.\n\nHowever, what happens if we return a `BasicPrimitive` or `undefined`?\n\nts\n\n`   export type BasicPrimitive = number | string | boolean;  export function doStuff(value: BasicPrimitive) {    if (Math.random() < 0.5) {      return undefined;    }    return value;  }   `\n\nWe can see what happens [in the TypeScript 4.1 playground](https://www.typescriptlang.org/play?ts=4.1.3#code/KYDwDg9gTgLgBDAnmYcBCBDAzgSwMYAKUOAtjjDgG6oC8cAdgK4kBGwUcAPnFjMfQHMucFhAgAbYBnoBuALAAoRQHplcABIRqHCPTgByACYQAyjEYAzC-pHBxEAO4IIPYKgcALDPAAqyYCZ4xGDwhjhYYOIYiFhwFtAIHqhQwOZQekgoAHQqagDqqGQCHvBe1HCgKHgwwIZw5M5wYPzw2Lm5cJ2YuITEZBTl3Iz0hsAWOPS1HR0sjPBs9k5+KIHB8AAsWQBMADT18BO8UnVhEVExcG0Kqh2dTKzswrz8QtyiElJ6QyNjE1PXykUlWg8Asw2qOF0cGMZksFgAFJQMOJGMAAFzobD4IikchUYAASjgAG9FJ1yTgLHB4QBZbweLJQaTGEjwokAHjgAAYsgBWImkhTk4WdFJpPTDUbjSaGeRC4UAX0UZOFYsY6TgSJRwDlcAVQA)\n. While we might want TypeScript to display the return type of `doStuff` as `BasicPrimitive | undefined`, it instead displays `string | number | boolean | undefined`! What gives?\n\nWell this has to do with how TypeScript represents types internally. When creating a union type out of one or more union types, it will always _normalize_ those types into a new flattened union type - but doing that loses information. The type-checker would have to find every combination of types from `string | number | boolean | undefined` to see what type aliases could have been used, and even then, there might be multiple type aliases to `string | number | boolean`.\n\nIn TypeScript 4.2, our internals are a little smarter. We keep track of how types were constructed by keeping around parts of how they were originally written and constructed over time. We also keep track of, and differentiate, type aliases to instances of other aliases!\n\nBeing able to print back the types based on how you used them in your code means that as a TypeScript user, you can avoid some unfortunately humongous types getting displayed, and that often translates to getting better `.d.ts` file output, error messages, and in-editor type displays in quick info and signature help. This can help TypeScript feel a little bit more approachable for newcomers.\n\nFor more information, check out [the first pull request that improves various cases around preserving union type aliases](https://github.com/microsoft/TypeScript/pull/42149)\n, along with [a second pull request that preserves indirect aliases](https://github.com/microsoft/TypeScript/pull/42284)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#leadingmiddle-rest-elements-in-tuple-types)\nLeading/Middle Rest Elements in Tuple Types\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript, tuple types are meant to model arrays with specific lengths and element types.\n\nts\n\n`   // A tuple that stores a pair of numbers  let a: [number, number] = [1, 2];  // A tuple that stores a string, a number, and a boolean  let b: [string, number, boolean] = [\"hello\", 42, true];   `\n\nOver time, TypeScript’s tuple types have become more and more sophisticated, since they’re also used to model things like parameter lists in JavaScript. As a result, they can have optional elements and rest elements, and can even have labels for tooling and readability.\n\nts\n\n`   // A tuple that has either one or two strings.  let c: [string, string?] = [\"hello\"];  c = [\"hello\", \"world\"];  // A labeled tuple that has either one or two strings.  let d: [first: string, second?: string] = [\"hello\"];  d = [\"hello\", \"world\"];  // A tuple with a *rest element* - holds at least 2 strings at the front,  // and any number of booleans at the back.  let e: [string, string, ...boolean[]];  e = [\"hello\", \"world\"];  e = [\"hello\", \"world\", false];  e = [\"hello\", \"world\", true, false, true];   `[Try](https://www.typescriptlang.org/play/#code/PTAEEFQFwVwBwDYFNoAsCGVQYM6iQJZSpIBOoA9gHYoXlQDuFoOUpBVA5jgHQBQyLAGMAXKADardlwA0LNh04B+ALqgAvBIBEJBAgpaVAbj5CN23fq1ytTUggAmhk3xARQCdACMkyB9HhkNExsdDxCYjJKGkp6Jnlpbn5BUAcxcQAzAlJWMSlFORwkIWoHJTyFLjVNcR1fK2M+fxq6vQMbO0dnPlcwSFhEFAYiVFB0UAAqUiRWfGQAWyQqKAnQAFpsCkc8EOQwrAAmBMUdrEjQDNJqKBlesap-dCoAT1AqGHmfcgoM0C8KLZIJ6nNAoLzoIQAa2SSCwSHS+VkxyRPFR-0BT3EKkafBQLUs7VAtjoXUaeIs9UJxPsTjkGXQCCKZPMtQJ1iJnVp0FIMCQdIZRTkbF5xiAA)\n\nIn TypeScript 4.2, rest elements specifically been expanded in how they can be used. In prior versions, TypeScript only allowed `...rest` elements at the very last position of a tuple type.\n\nHowever, now rest elements can occur _anywhere_ within a tuple - with only a few restrictions.\n\nts\n\n`   let foo: [...string[], number];  foo = [123];  foo = [\"hello\", 123];  foo = [\"hello!\", \"hello!\", \"hello!\", 123];  let bar: [boolean, ...string[], boolean];  bar = [true, false];  bar = [true, \"some text\", false];  bar = [true, \"some\", \"separated\", \"text\", false];   `[Try](https://www.typescriptlang.org/play/#code/DYUwLgBAZg9jBcEDaA6NBnMAnAlgOwHMkBdAGgjwFcBbAIxC2IG4AoF2GCAXmQEYAmAMzN2cbsgBEACxDBgMCeQHDWHcUmmz5AQkURNcmLvIGde5SJahItAIZZESWnFC285NCky5CJcs5hXPEs7LHVsShByKFtgdBARUPCsSJN0GGoQCDAQAA8wPRi4hNYkniQIqP10zL0JeIAHe1scgBM6nPzC2PjmIA)\n\nThe only restriction is that a rest element can be placed anywhere in a tuple, so long as it’s not followed by another optional element or rest element. In other words, only one rest element per tuple, and no optional elements after rest elements.\n\nts\n\n`  interface Clown {    /*...*/  }  interface Joker {    /*...*/  }  let StealersWheel: [...Clown[], \"me\", ...Joker[]];  A rest element cannot follow another rest element.1265A rest element cannot follow another rest element.  let StringsAndMaybeBoolean: [...string[], boolean?];  An optional element cannot follow a rest element.1266An optional element cannot follow a rest element.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwCYBsBWd2sAoASwDsAXGAMwEMBjSUAYQBs4B3U0Ab0NFGAAqAHSjBwQgF8SFavUYApOAGsYPPgJFiJ0wi0jlQAZUo19SAOoALSJBaoA2qOGsOpBwF0ANKABEAW0hfH2clVWhPDwBuQj0DY3JoMgBzRABBUgATAFkaAE8AI0gAITg4fRpSR2dERJTPHwKyitIAfmigA)\n\nThese non-trailing rest elements can be used to model functions that take any number of leading arguments, followed by a few fixed ones.\n\nts\n\n`   declare function doStuff(...args: [...names: string[], shouldCapitalize: boolean]): void;  doStuff(/*shouldCapitalize:*/ false)  doStuff(\"fee\", \"fi\", \"fo\", \"fum\", /*shouldCapitalize:*/ true);   `[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtX2BwGUNlFEAKAOhtgHMBnALngG0arUoBbEZ+BhhhZUdVgF0ANAIAWOZBGABhKAAcsGKBCwAvECwBGOHBBBRU4gJQsAbjizAA3AChnhEmUoB6AFQM5CspqGlq6+j5eSFoMIJZuxKTkFABEiCAgydKpWJnwqTi5qcjcub7+8ooq6praekwR8ELIsY5AA)\n\nEven though JavaScript doesn’t have any syntax to model leading rest parameters, we were still able to declare `doStuff` as a function that takes leading arguments by declaring the `...args` rest parameter with _a tuple type that uses a leading rest element_. This can help model lots of existing JavaScript out there!\n\nFor more details, [see the original pull request](https://github.com/microsoft/TypeScript/pull/41544)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#stricter-checks-for-the-in-operator)\nStricter Checks For The `in` Operator\n------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn JavaScript, it is a runtime error to use a non-object type on the right side of the `in` operator. TypeScript 4.2 ensures this can be caught at design-time.\n\nts\n\n`  \"foo\" in 42;  Type 'number' is not assignable to type 'object'.2322Type 'number' is not assignable to type 'object'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsBGdG00AoAIgDM44TQBLAO1ABY0BuIA)\n\nThis check is fairly conservative for the most part, so if you have received an error about this, it is likely an issue in the code.\n\nA big thanks to our external contributor [Jonas Hübotter](https://github.com/jonhue)\n for [their pull request](https://github.com/microsoft/TypeScript/pull/41928)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#--nopropertyaccessfromindexsignature)\n`--noPropertyAccessFromIndexSignature`\n--------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBack when TypeScript first introduced index signatures, you could only get properties declared by them with “bracketed” element access syntax like `person[\"name\"]`.\n\nts\n\n`   interface SomeType {    /** This is an index signature. */    [propName: string]: any;  }  function doStuff(value: SomeType) {    let x = value[\"someProperty\"];  }   `[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoHsC2EAqBPABxQG8AoZZAegCprkcALYAZ2ReThDZABMIAPZM2ABzEHDABXKBAB0yapXLIA2gSjoCAOTjYAXELBRQIgLoHOeANykAvqVIxJIBGGDouPdKikwYACgA3OAAbSQgDDGx8IgBKZDIKEIgwZEEAXmRgsIgVACJmLAgABQ0iKDA8PNMbWyA)\n\nThis ended up being cumbersome in situations where we need to work with objects that have arbitrary properties. For example, imagine an API where it’s common to misspell a property name by adding an extra `s` character at the end.\n\nts\n\n``   interface Options {    /** File patterns to be excluded. */    exclude?: string[];    /**     * It handles any extra properties that we haven't declared as type 'any'.     */    [x: string]: any;  }  function processOptions(opts: Options) {    // Notice we're *intentionally* accessing `excludes`, not `exclude`    if (opts.excludes) {      console.error(        \"The option `excludes` is not valid. Did you mean `exclude`?\"      );    }  }   ``[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM7IDeAUMsgPQBUlyAYsADYrpxiRT7JjbIBGKEAB4IGAVwAmEcQDpklcqWRCREiAH4AXMjxgooAOYBtALoBuYoqqVFc5AEkwyABZwQ4pgVcBPJYN1xkdChsdGgsCAIwF0cAdxQXADcIEAByR0kROCgpZDhIr1DkFO8U6Rt5RUNBLR09EH1jLW9zAF8LGFEQBCxcQOCkPDwMHvwAChCwPC1hnHwASiJLcmQAOWwsJGQ4lOy5UEhwWbgGBi8aRAG8A2QAA2UxSTwbgBpkEHXb+9UbxWAYZHGmDw0i+jwWJDIZAQuDw2CYIKgwSgoxskIARAAVJwoCazT7CB4RG7IYAEd6OBLHYAyZAAEWpyC82FEyAAthBXPiVJIbmo0ai5uYyG0WkA)\n\nTo make these types of situations easier, a while back, TypeScript made it possible to use “dotted” property access syntax like `person.name` when a type had a string index signature. This also made it easier to transition existing JavaScript code over to TypeScript.\n\nHowever, loosening the restriction also meant that misspelling an explicitly declared property became much easier.\n\nts\n\n``   function processOptions(opts: Options) {    // ...    // Notice we're *accidentally* accessing `excludes` this time.    // Oops! Totally valid.    for (const excludePattern of opts.excludes) {      // ...    }  }   ``[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM7IDeAUMsgPQBUlyAYsADYrpxiRT7JjbIBGKEAB4IGAVwAmEcQDpklcqWRCREiAH4AXMjxgooAOYBtALoBuYoqqVFc5AEkwyABZwQ4pgVcBPJYN1xkdChsdGgsCAIwF0cAdxQXADcIEAByR0kROCgpZDhIr1DkFO8U6Rt5RUNBLR09EH1jLW9zAF9icnJkAFoehFEwHq7iGFEQBCxcQOCkPDwMCfwAChCwPC15nHwASiJLTukDizIO5AA5bCwkZDiU7LlEBGBJcDgGBi8aB4i8A2QAA2UYkkeD+XCcwEiwAAthAysdOqgQngAITIAAqF1e72QCVeTzhyBg2CgyEWCFwOl8KkkAAVWOwQMhsDAmZg8NJAao8DsSGR4cgDgS2i0gA)\n\nIn some cases, users would prefer to explicitly opt into the index signature - they would prefer to get an error message when a dotted property access doesn’t correspond to a specific property declaration.\n\nThat’s why TypeScript introduces a new flag called [`noPropertyAccessFromIndexSignature`](https://www.typescriptlang.org/tsconfig#noPropertyAccessFromIndexSignature)\n. Under this mode, you’ll be opted in to TypeScript’s older behavior that issues an error. This new setting is not under the [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n family of flags, since we believe users will find it more useful on certain codebases than others.\n\nYou can understand this feature in more detail by reading up on the corresponding [pull request](https://github.com/microsoft/TypeScript/pull/40171/)\n. We’d also like to extend a big thanks to [Wenlu Wang](https://github.com/Kingwl)\n who sent us this pull request!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#abstract-construct-signatures)\n`abstract` Construct Signatures\n------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript allows us to mark a class as _abstract_. This tells TypeScript that the class is only meant to be extended from, and that certain members need to be filled in by any subclass to actually create an instance.\n\nts\n\n`   abstract class Shape {    abstract getArea(): number;  }  new Shape();  Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.  class Square extends Shape {    #sideLength: number;    constructor(sideLength: number) {      super();      this.#sideLength = sideLength;    }    getArea() {      return this.#sideLength ** 2;    }  }  // Works fine.  new Square(42);   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWBQBDAI0QBdp8BjE0CgG30UVAGUALfAB0lAG9dRQRUuSqgA5pBIBBaJHwAKAJSoAdgFcAtoRgBuXAF9cuFZADuLdlyV7cdBk2YBHNflmhIADxKQVAEweW3HwCAMSIAJa+kAAyPmIkrKqa2tA2AhRwKsJqVAjyEVGxKvGJoOpaMIq8-AKgiGpc0NY1AgnhiAB0YZExcQmgALx1PUUlegKGNRLSsgpVwbWyJGrQKqBtnd2FfaygAFR76OOghpMgoADqCADWTABm4SYdxmYszq6Q8gAsaIo6QA)\n\nTo make sure this restriction in `new`\\-ing up `abstract` classes is consistently applied, you can’t assign an `abstract` class to anything that expects a construct signature.\n\nts\n\n`  interface HasArea {    getArea(): number;  }  let Ctor: new () => HasArea = Shape;  Type 'typeof Shape' is not assignable to type 'new () => HasArea'.   Cannot assign an abstract constructor type to a non-abstract constructor type.2322Type 'typeof Shape' is not assignable to type 'new () => HasArea'.   Cannot assign an abstract constructor type to a non-abstract constructor type.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEMAjRAF2jwGNjRyAbPRRUAZQAs8AHSUAbx1FEIkylUAHNIxAILRIeABQBKVADsArgFsCMANw4AvjhCgAtKfKrip4zgCWy4jABmFLgAl602Tz5iJn+Uqgapo6+jg4NBKgAMLECCqQAO6giqAAvAB8oO6I-unMbJzaQA)\n\nThis does the right thing in case we intend to run code like `new Ctor`, but it’s overly-restrictive in case we want to write a subclass of `Ctor`.\n\nts\n\n`  abstract class Shape {    abstract getArea(): number;  }  interface HasArea {    getArea(): number;  }  function makeSubclassWithArea(Ctor: new () => HasArea) {    return class extends Ctor {      getArea() {        return 42      }    };  }  let MyShape = makeSubclassWithArea(Shape);  Argument of type 'typeof Shape' is not assignable to parameter of type 'new () => HasArea'.   Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Shape' is not assignable to parameter of type 'new () => HasArea'.   Cannot assign an abstract constructor type to a non-abstract constructor type.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAIYBGiALtAQMamiUA2BiioAygBYEAOkoA3nqFDEyFaqADmkUgEFokAgAoAlKgB2AVwC2RGAG48AXzx4AlqtIwAZlR4AJRrPl8BEqY8UrQG7XsPHL6qrUJnCqoJoEANaQLOpE9IyIAOompGzuCgDCpAhqkADuoMqgALwAfKD2iO5KzoJypOrQYQlMoJAAHhaqACbM2Qh1gq4ych5Dw6ANTWFYaC6CRov6Rnh0UqAAsgCe7Fw8JeFRMXGtyanpYwp73Eq6QA)\n\nIt also doesn’t work well with built-in helper types like `InstanceType`.\n\nts\n\n`   type MyInstance = InstanceType<typeof Shape>;   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQBDAI0QBdp8BjE0CgG30UVAGUALfAB0lAG9dRQRUuSqgA5pBIBBaJHwAKAJSoAdgFcAtoRgBuXAF9cIUAFozFNSTMncJAJ5dQAWTsBJFaXwqK3ALyh3T29IABUHSAAeey44ADMWdi4APh0gA)\n\nThat’s why TypeScript 4.2 allows you to specify an `abstract` modifier on constructor signatures.\n\nts\n\n`   interface HasArea {      getArea(): number;  }  // Works!  let Ctor: abstract new () => HasArea = Shape;   `[Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgygC2ABwFMEBvAKAQVEhngQHMCIBBKA4ACgEoAuBAOwCuAWxAEoAblIBfUgHpZCALTLYAiMsWkAlnwhiAZnCIAJNCzYlyFeo3Mce-YaInTSchQHUA9lADWYAEJSZEYEAGEIH14qaDhEPgIAdwQuBABeAD4EUzA7dKxcQnEgA)\n\nAdding the `abstract` modifier to a construct signature signals that you can pass in `abstract` constructors. It doesn’t stop you from passing in other classes/constructor functions that are “concrete” - it really just signals that there’s no intent to run the constructor directly, so it’s safe to pass in either class type.\n\nThis feature allows us to write _mixin factories_ in a way that supports abstract classes. For example, in the following code snippet, we’re able to use the mixin function `withStyles` with the `abstract` class `SuperClass`.\n\nts\n\n`   abstract class SuperClass {      abstract someMethod(): void;      badda() {}  }  type AbstractConstructor<T> = abstract new (...args: any[]) => T  function withStyles<T extends AbstractConstructor<object>>(Ctor: T) {      abstract class StyledClass extends Ctor {          getStyles() {              // ...          }      }      return StyledClass;  }  class SubClass extends withStyles(SuperClass) {      someMethod() {          this.someMethod()      }  }   `[Try](https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgygVwA4FMoBhVdBAbwCgEaFRIZ4EwB7AW3wFl8IALFgCYAKAJQAuBADcWASwEBuarRDABA4KIoBfSjsoQAngQQBBcNDgQiLAHYNs8FlAA8AFQB8CALx1zjRDb4AO4IQgB0EcBQAOZgEsA2BgDaALoi3p6ulJQAZtg28DK2CEEyfJiGyPhgbgj4AB4Q+DYCGGYMltZ20A4QTs4sIABW+PDu7kJEfVASrulUtL4dTChoGBUGVQIka3WNza0IU04USos00TwbVWCaC+cPAPSPCBFhZ+c6i1+0UDzYUBsWEq+G2pDAij0qzIOBAOzIDSaLQwpXKINuOAIxHB8w+rA43D4gjuH0WfBkYDC+K4PH4whEHx0WiAA)\n\nNote that `withStyles` is demonstrating a specific rule, where a class (like `StyledClass`) that extends a value that’s generic and bounded by an abstract constructor (like `Ctor`) has to also be declared `abstract`. This is because there’s no way to know if a class with _more_ abstract members was passed in, and so it’s impossible to know whether the subclass implements all the abstract members.\n\nYou can read up more on abstract construct signatures [on its pull request](https://github.com/microsoft/TypeScript/pull/36392)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#understanding-your-project-structure-with---explainfiles)\nUnderstanding Your Project Structure With `--explainFiles`\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nA surprisingly common scenario for TypeScript users is to ask “why is TypeScript including this file?“. Inferring the files of your program turns out to be a complicated process, and so there are lots of reasons why a specific combination of `lib.d.ts` got used, why certain files in `node_modules` are getting included, and why certain files are being included even though we thought specifying [`exclude`](https://www.typescriptlang.org/tsconfig#exclude)\n would keep them out.\n\nThat’s why TypeScript now provides an [`explainFiles`](https://www.typescriptlang.org/tsconfig#explainFiles)\n flag.\n\nsh\n\n`   tsc --explainFiles   `\n\nWhen using this option, the TypeScript compiler will give some very verbose output about why a file ended up in your program. To read it more easily, you can forward the output to a file, or pipe it to a program that can easily view it.\n\nsh\n\n``   # Forward output to a text file  tsc --explainFiles > explanation.txt  # Pipe output to a utility program like `less`, or an editor like VS Code  tsc --explainFiles | less  tsc --explainFiles | code -   ``\n\nTypically, the output will start out by listing out reasons for including `lib.d.ts` files, then for local files, and then `node_modules` files.\n\n`   TS_Compiler_Directory/4.2.2/lib/lib.es5.d.ts    Library referenced via 'es5' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts'  TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts    Library referenced via 'es2015' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts'  TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts    Library referenced via 'es2016' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts'  TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts    Library referenced via 'es2017' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts'  TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts    Library referenced via 'es2018' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts'  TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts    Library referenced via 'es2019' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts'  TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts    Library referenced via 'es2020' from file 'TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts'  TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts    Library 'lib.esnext.d.ts' specified in compilerOptions  ... More Library References...  foo.ts    Matched by include pattern '**/*' in 'tsconfig.json'   `\n\nRight now, we make no guarantees about the output format - it might change over time. On that note, we’re interested in improving this format if you have any suggestions!\n\nFor more information, [check out the original pull request](https://github.com/microsoft/TypeScript/pull/40011)\n!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#improved-uncalled-function-checks-in-logical-expressions)\nImproved Uncalled Function Checks in Logical Expressions\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThanks to further improvements from [Alex Tarasyuk](https://github.com/a-tarasyuk)\n, TypeScript’s uncalled function checks now apply within `&&` and `||` expressions.\n\nUnder [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n, the following code will now error.\n\nts\n\n`   function shouldDisplayElement(element: Element) {    // ...    return true;  }  function getVisibleItems(elements: Element[]) {    return elements.filter((e) => shouldDisplayElement && e.children.length);    //                          ~~~~~~~~~~~~~~~~~~~~    // This condition will always return true since the function is always defined.    // Did you mean to call it instead.  }   `\n\nFor more details, [check out the pull request here](https://github.com/microsoft/TypeScript/issues/40197)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#destructured-variables-can-be-explicitly-marked-as-unused)\nDestructured Variables Can Be Explicitly Marked as Unused\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nThanks to another pull request from [Alex Tarasyuk](https://github.com/a-tarasyuk)\n, you can now mark destructured variables as unused by prefixing them with an underscore (the `_` character).\n\nts\n\n`   let [_first, second] = getValues();   `\n\nPreviously, if `_first` was never used later on, TypeScript would issue an error under [`noUnusedLocals`](https://www.typescriptlang.org/tsconfig#noUnusedLocals)\n. Now, TypeScript will recognize that `_first` was intentionally named with an underscore because there was no intent to use it.\n\nFor more details, take a look at [the full change](https://github.com/microsoft/TypeScript/pull/41378)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#relaxed-rules-between-optional-properties-and-string-index-signatures)\nRelaxed Rules Between Optional Properties and String Index Signatures\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nString index signatures are a way of typing dictionary-like objects, where you want to allow access with arbitrary keys:\n\nts\n\n`   const movieWatchCount: { [key: string]: number } = {};  function watchMovie(title: string) {    movieWatchCount[title] = (movieWatchCount[title] ?? 0) + 1;  }   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAtiAbgSwKYHUCGVgAsDCIArmFAFwwDeMA2gNaoCeF0ATsmAOYC6FYRcAEapWMAL4wAvFTEBuAFDyAZiWBRk4GAHdseALJI0ACnVQANqhZR2XAJRV5MeIYy6CxUjVMXuUmEYQUVxx3EigvZHNUXwB+GJgABnsAahgARgUxIA)\n\nOf course, for any movie title not yet in the dictionary, `movieWatchCount[title]` will be `undefined` (TypeScript 4.1 added the option [`noUncheckedIndexedAccess`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#checked-indexed-accesses---nouncheckedindexedaccess)\n to include `undefined` when reading from an index signature like this). Even though it’s clear that there must be some strings not present in `movieWatchCount`, previous versions of TypeScript treated optional object properties as unassignable to otherwise compatible index signatures, due to the presence of `undefined`.\n\nts\n\n`   type WesAndersonWatchCount = {    \"Fantastic Mr. Fox\"?: number;    \"The Royal Tenenbaums\"?: number;    \"Moonrise Kingdom\"?: number;    \"The Grand Budapest Hotel\"?: number;  };  declare const wesAndersonWatchCount: WesAndersonWatchCount;  const movieWatchCount: { [key: string]: number } = wesAndersonWatchCount;  //    ~~~~~~~~~~~~~~~ error!  // Type 'WesAndersonWatchCount' is not assignable to type '{ [key: string]: number; }'.  //    Property '\"Fantastic Mr. Fox\"' is incompatible with index signature.  //      Type 'number | undefined' is not assignable to type 'number'.  //        Type 'undefined' is not assignable to type 'number'. (2322)   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6hDOBBAdgEwgJ3ge2TAhsAMYAWAwtgK7LBQC8UA3gFBRQBEAYvjfvMAEsiUALIYAdFE7YAHuwD8ALijJKAWwBGmANysOAFRLQASthD4ANlH0RktjfnXwFy1Zp172I7LgwD40ADSAsgA5qjYai4q6loYumzshtAA4hg8qFAAQpSo+JD8UAAS2MAQFtFucboAvrrM6EQW+BjQRLiFAO4IKOhYuATE5FQ0ynBIaJg4eISkFNTAuu3IhWrYAG4CEINzI8DKjFAA2gDWECDK-H5hALqusZhQNfRQ3RN90zvDC7oA9L9sNgAPxBoLB4KgmAw2AwAEJmP9rOBoAByca9KYDWbfGgoqD+FSlKB8eACULIfAaCzQYDYKCgSBQFGHU7nS7Aa6hO4xdzxJ4o8QIgGAgAK0MgGFATK4PGAfEEwjEkmkcjxBJC7TUYEIAip0E6AmAJHxkxkUFJ5MIlFagsRgLY+mRTKqjwAPlBqOgAGYhCCoNXwQm0Elkil6+l0hmol0YAVC+32x2MlGeiA+uz+-GB5BEkOW8O0+lOlExgVQAAUACYAMyVysASiAA)\n\nTypeScript 4.2 allows this assignment. However, it does _not_ allow the assignment of non-optional properties with `undefined` in their types, nor does it allow writing `undefined` to a specific key:\n\nts\n\n``  type BatmanWatchCount = {    \"Batman Begins\": number | undefined;    \"The Dark Knight\": number | undefined;    \"The Dark Knight Rises\": number | undefined;  };  declare const batmanWatchCount: BatmanWatchCount;  // Still an error in TypeScript 4.2.  const movieWatchCount: { [key: string]: number } = batmanWatchCount;  Type 'BatmanWatchCount' is not assignable to type '{ [key: string]: number; }'.   Property '\"Batman Begins\"' is incompatible with index signature.     Type 'number | undefined' is not assignable to type 'number'.       Type 'undefined' is not assignable to type 'number'.2322Type 'BatmanWatchCount' is not assignable to type '{ [key: string]: number; }'.   Property '\"Batman Begins\"' is incompatible with index signature.     Type 'number | undefined' is not assignable to type 'number'.       Type 'undefined' is not assignable to type 'number'.  // Still an error in TypeScript 4.2.  // Index signatures don't implicitly allow explicit `undefined`.  movieWatchCount[\"It's the Great Pumpkin, Charlie Brown\"] = undefined;  Type 'undefined' is not assignable to type 'number'.2322Type 'undefined' is not assignable to type 'number'.``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lACEBDPAWwoDsB1KgYwAsBhOAVzr1AF5QAbxyhQAIko165SAHMAlnUTjUdLtQBGMUAB9QPACaQAZksiGA3KIkAVVqQAiFaAGtQAaToK5rPKtB1LR19I1NzKxtxeycXdy8fP1AAJQVESBU1DW1oPQM6YzM6C2sAX2scY2YAGxdSZjhlPk0qWkYWDm5eVCk2pjw2Th48CpBQAGU8BWrq0BkYeFylUFtiSHHmaAUiPgAWADo0fZwGptBqOAA3BUh+wa68VCFQAG1XSAJURDwtujkAXSywVypQEoBa0naA06w1GYEm01m81gCFAy1WJA2Wx2oAORxwYwAkgVIAAPUCIHx0KhcaAZUCGRoAcj4CmoRGqCmYCjw1QIcxmcAA7qAyRyuTzQAADMJFCxS44Xa63DpDXgvcSEvBMxCgPAOUAAcTpVFAAAUNERXEoADSgdisFyc0hkeBCujif5g2URSxAA)\n\nThe new rule also does not apply to number index signatures, since they are assumed to be array-like and dense:\n\nts\n\n`  declare let sortOfArrayish: { [key: number]: string };  declare let numberKeys: { 42?: string };  sortOfArrayish = numberKeys;  Type '{ 42?: string | undefined; }' is not assignable to type '{ [key: number]: string; }'.   Property '42' is incompatible with index signature.     Type 'string | undefined' is not assignable to type 'string'.       Type 'undefined' is not assignable to type 'string'.2322Type '{ 42?: string | undefined; }' is not assignable to type '{ [key: number]: string; }'.   Property '42' is incompatible with index signature.     Type 'string | undefined' is not assignable to type 'string'.       Type 'undefined' is not assignable to type 'string'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABNIBjAGwENpJRjIAXURBGgeQDMBBWUgTwEtEALVAG9QAbQDWkLqgB2AVwC2AIxgBdVIhrQeMgOagAvgG58RMhSq1Q85TADSUlKBEAWNAH4NWnfuM4cDNDM7Jy8AqAAvNaKKtAOXIhGQA)\n\nYou can get a better sense of this change [by reading up on the original PR](https://github.com/microsoft/TypeScript/pull/41921)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#declare-missing-helper-function)\nDeclare Missing Helper Function\n--------------------------------------------------------------------------------------------------------------------------------------------------\n\nThanks to [a community pull request](https://github.com/microsoft/TypeScript/pull/41215)\n from [Alexander Tarasyuk](https://github.com/a-tarasyuk)\n, we now have a quick fix for declaring new functions and methods based on the call-site!\n\n![An un-declared function foo being called, with a quick fix scaffolding out the new contents of the file](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/01/addMissingFunction-4.2.gif)\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\nWe always strive to minimize breaking changes in a release. TypeScript 4.2 contains some breaking changes, but we believe they should be manageable in an upgrade.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#libdts-updates)\n`lib.d.ts` Updates\n\nAs with every TypeScript version, declarations for `lib.d.ts` (especially the declarations generated for web contexts), have changed. There are various changes, though `Intl` and `ResizeObserver`’s may end up being the most disruptive.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#noimplicitany-errors-apply-to-loose-yield-expressions)\n`noImplicitAny` Errors Apply to Loose `yield` Expressions\n\nWhen the value of a `yield` expression is captured, but TypeScript can’t immediately figure out what type you intend for it to receive (i.e. the `yield` expression isn’t contextually typed), TypeScript will now issue an implicit `any` error.\n\nts\n\n``   function* g1() {    const value = yield 1;  'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.7057'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.  }  function* g2() {    // No error.    // The result of `yield 1` is unused.    yield 1;  }  function* g3() {    // No error.    // `yield 1` is contextually typed by 'string'.    const value: string = yield 1;  }  function* g4(): Generator<number, void, string> {    // No error.    // TypeScript can figure out the type of `yield 1`    // from the explicit return type of `g4`.    const value = yield 1;  }   ``[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYCsaBQAzAVwDsBjAFwEs5iAqUAcwEYAKASlAG9dRRSbE5UADcAhgBtCkUAF5QAT0qRxAE1BMA3LgC+uAiQrU6jAEzsuPUCFAA5OKBjxoAOkvWAKgAtp0SIkLiQnD4oAAGispqTKGglIigJISIkCquvBGq6lq6+mRUNPQMAMzm3LzWdg6wCGlWYOFKmdGx8fzE5JAAHuSEEuLyoOTyAA4poABGAwDkgtCUxAxTtW2CIhJSqLPzDLIKjVHZekR5RoUALOyoAOKQxDCi5AgAPMSEALbjMAA0InCUKj8tgsAHwWcpgSqOGpuMDuEaQADKpDmwyEpFExFA+EoDEIvlAcEIQnI3kG8IJIQakXUoRhWPgb0GpK6w3ElFIlCEvh60ExQ1GFLCDDOoWWAiEYkk0jkGQOOiAA)\n\nSee more details in [the corresponding changes](https://github.com/microsoft/TypeScript/pull/41348)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#expanded-uncalled-function-checks)\nExpanded Uncalled Function Checks\n\nAs described above, uncalled function checks will now operate consistently within `&&` and `||` expressions when using [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n. This can be a source of new breaks, but is typically an indication of a logic error in existing code.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#type-arguments-in-javascript-are-not-parsed-as-type-arguments)\nType Arguments in JavaScript Are Not Parsed as Type Arguments\n\nType arguments were already not allowed in JavaScript, but in TypeScript 4.2, the parser will parse them in a more spec-compliant way. So when writing the following code in a JavaScript file:\n\nts\n\n`   f<T>(100);   `\n\nTypeScript will parse it as the following JavaScript:\n\njs\n\n`   f < T > 100;   `\n\nThis may impact you if you were leveraging TypeScript’s API to parse type constructs in JavaScript files, which may have occurred when trying to parse Flow files.\n\nSee [the pull request](https://github.com/microsoft/TypeScript/pull/41928)\n for more details on what’s checked.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#tuple-size-limits-for-spreads)\nTuple size limits for spreads\n\nTuple types can be made by using any sort of spread syntax (`...`) in TypeScript.\n\nts\n\n`   // Tuple types with spread elements  type NumStr = [number, string];  type NumStrNumStr = [...NumStr, ...NumStr];  // Array spread expressions  const numStr = [123, \"hello\"] as const;  const numStrNumStr = [...numStr, ...numStr] as const;   `\n\nSometimes these tuple types can accidentally grow to be huge, and that can make type-checking take a long time. Instead of letting the type-checking process hang (which is especially bad in editor scenarios), TypeScript has a limiter in place to avoid doing all that work.\n\nYou can [see this pull request](https://github.com/microsoft/TypeScript/pull/42448)\n for more details.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#dts-extensions-cannot-be-used-in-import-paths)\n`.d.ts` Extensions Cannot Be Used In Import Paths\n\nIn TypeScript 4.2, it is now an error for your import paths to contain `.d.ts` in the extension.\n\nts\n\n`   // must be changed to something like  //   - \"./foo\"  //   - \"./foo.js\"  import { Foo } from \"./foo.d.ts\";   `\n\nInstead, your import paths should reflect whatever your loader will do at runtime. Any of the following imports might be usable instead.\n\nts\n\n`   import { Foo } from \"./foo\";  import { Foo } from \"./foo.js\";  import { Foo } from \"./foo/index.js\";   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#reverting-template-literal-inference)\nReverting Template Literal Inference\n\nThis change removed a feature from TypeScript 4.2 beta. If you haven’t yet upgraded past our last stable release, you won’t be affected, but you may still be interested in the change.\n\nThe beta version of TypeScript 4.2 included a change in inference to template strings. In this change, template string literals would either be given template string types or simplify to multiple string literal types. These types would then _widen_ to `string` when assigning to mutable variables.\n\nts\n\n``   declare const yourName: string;  // 'bar' is constant.  // It has type '`hello ${string}`'.  const bar = `hello ${yourName}`;  // 'baz' is mutable.  // It has type 'string'.  let baz = `hello ${yourName}`;   ``\n\nThis is similar to how string literal inference works.\n\nts\n\n`   // 'bar' has type '\"hello\"'.  const bar = \"hello\";  // 'baz' has type 'string'.  let baz = \"hello\";   `\n\nFor that reason, we believed that making template string expressions have template string types would be “consistent”; however, from what we’ve seen and heard, that isn’t always desirable.\n\nIn response, we’ve reverted this feature (and potential breaking change). If you _do_ want a template string expression to be given a literal-like type, you can always add `as const` to the end of it.\n\nts\n\n``   declare const yourName: string;  // 'bar' has type '`hello ${string}`'.  const bar = `hello ${yourName}` as const;  //                              ^^^^^^^^  // 'baz' has type 'string'.  const baz = `hello ${yourName}`;   ``\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#typescripts-lift-callback-in-visitnode-uses-a-different-type)\nTypeScript’s `lift` Callback in `visitNode` Uses a Different Type\n\nTypeScript has a `visitNode` function that takes a `lift` function. `lift` now expects a `readonly Node[]` instead of a `NodeArray<Node>`. This is technically an API breaking change which you can read more on [here](https://github.com/microsoft/TypeScript/pull/42000)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.2.md)\n ❤\n\nContributors to this page:  \n\nEL![Eliran Levi  (1)](https://gravatar.com/avatar/f00fd5d066bb6174a9369ab456ce99bbc444afa281ff050a70a8a6cb0820894a?s=32&&d=blank)\n\nAG![Anton Gilgur  (1)](https://gravatar.com/avatar/14cf8bfc7e9486a5c6c0acc08682cfef8de31d40c2634eb4099fe3fc008a3492?s=32&&d=blank)\n\nAB![Andrew Branch  (1)](https://gravatar.com/avatar/86ed396e4ffb41b052654b9f8ad4d1caaf732bc42985860b0cac8191a66e33df?s=32&&d=blank)\n\nJB![Jack Bates  (1)](https://gravatar.com/avatar/98326ec560d25aebd787245a6c457afd24ed35b0ba578c2a5e38da41ff657152?s=32&&d=blank)\n\nGG![Gabriel Goller  (1)](https://gravatar.com/avatar/d181093cddf3e126722ed209e92f75a58db26cf4ad74295f5a3e1830dbb137fc?s=32&&d=blank)\n\n3+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - TypeScript 4.2","generator":"Gatsby 5.13.5","theme-color":"#3178C6","twitter:site":"typescriptlang","description":"TypeScript 4.2 Release Notes","ogDescription":"TypeScript 4.2 Release Notes","og:description":"TypeScript 4.2 Release Notes","language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","title":"TypeScript: Documentation - TypeScript 4.2","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","og:title":"Documentation - TypeScript 4.2","scrapeId":"7b75f119-3767-4db0-838e-9097ecd2eb38","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 3.9\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#improvements-in-inference-and-promiseall)\nImprovements in Inference and `Promise.all`\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nRecent versions of TypeScript (around 3.7) have had updates to the declarations of functions like `Promise.all` and `Promise.race`. Unfortunately, that introduced a few regressions, especially when mixing in values with `null` or `undefined`.\n\nts\n\n`   interface Lion {    roar(): void;  }  interface Seal {    singKissFromARose(): void;  }  async function visitZoo(    lionExhibit: Promise<Lion>,    sealExhibit: Promise<Seal | undefined>  ) {    let [lion, seal] = await Promise.all([lionExhibit, sealExhibit]);    lion.roar(); // uh oh    //  ~~~~    // Object is possibly 'undefined'.  }   `\n\nThis is strange behavior! The fact that `sealExhibit` contained an `undefined` somehow poisoned type of `lion` to include `undefined`.\n\nThanks to [a pull request](https://github.com/microsoft/TypeScript/pull/34501)\n from [Jack Bates](https://github.com/jablko)\n, this has been fixed with improvements in our inference process in TypeScript 3.9. The above no longer errors. If you’ve been stuck on older versions of TypeScript due to issues around `Promise`s, we encourage you to give 3.9 a shot!\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#what-about-the-awaited-type)\nWhat About the `awaited` Type?\n\nIf you’ve been following our issue tracker and design meeting notes, you might be aware of some work around [a new type operator called `awaited`](https://github.com/microsoft/TypeScript/pull/35998)\n. This goal of this type operator is to accurately model the way that `Promise` unwrapping works in JavaScript.\n\nWe initially anticipated shipping `awaited` in TypeScript 3.9, but as we’ve run early TypeScript builds with existing codebases, we’ve realized that the feature needs more design work before we can roll it out to everyone smoothly. As a result, we’ve decided to pull the feature out of our main branch until we feel more confident. We’ll be experimenting more with the feature, but we won’t be shipping it as part of this release.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#speed-improvements)\nSpeed Improvements\n------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 3.9 ships with many new speed improvements. Our team has been focusing on performance after observing extremely poor editing/compilation speed with packages like material-ui and styled-components. We’ve dived deep here, with a series of different pull requests that optimize certain pathological cases involving large unions, intersections, conditional types, and mapped types.\n\n*   [https://github.com/microsoft/TypeScript/pull/36576](https://github.com/microsoft/TypeScript/pull/36576)\n    \n*   [https://github.com/microsoft/TypeScript/pull/36590](https://github.com/microsoft/TypeScript/pull/36590)\n    \n*   [https://github.com/microsoft/TypeScript/pull/36607](https://github.com/microsoft/TypeScript/pull/36607)\n    \n*   [https://github.com/microsoft/TypeScript/pull/36622](https://github.com/microsoft/TypeScript/pull/36622)\n    \n*   [https://github.com/microsoft/TypeScript/pull/36754](https://github.com/microsoft/TypeScript/pull/36754)\n    \n*   [https://github.com/microsoft/TypeScript/pull/36696](https://github.com/microsoft/TypeScript/pull/36696)\n    \n\nEach of these pull requests gains about a 5-10% reduction in compile times on certain codebases. In total, we believe we’ve achieved around a 40% reduction in material-ui’s compile time!\n\nWe also have some changes to file renaming functionality in editor scenarios. We heard from the Visual Studio Code team that when renaming a file, just figuring out which import statements needed to be updated could take between 5 to 10 seconds. TypeScript 3.9 addresses this issue by [changing the internals of how the compiler and language service caches file lookups](https://github.com/microsoft/TypeScript/pull/37055)\n.\n\nWhile there’s still room for improvement, we hope this work translates to a snappier experience for everyone!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#-ts-expect-error-comments)\n`// @ts-expect-error` Comments\n-------------------------------------------------------------------------------------------------------------------------------------------\n\nImagine that we’re writing a library in TypeScript and we’re exporting some function called `doStuff` as part of our public API. The function’s types declare that it takes two `string`s so that other TypeScript users can get type-checking errors, but it also does a runtime check (maybe only in development builds) to give JavaScript users a helpful error.\n\nts\n\n`   function doStuff(abc: string, xyz: string) {    assert(typeof abc === \"string\");    assert(typeof xyz === \"string\");    // do some stuff  }   `\n\nSo TypeScript users will get a helpful red squiggle and an error message when they misuse this function, and JavaScript users will get an assertion error. We’d like to test this behavior, so we’ll write a unit test.\n\nts\n\n`   expect(() => {    doStuff(123, 456);  }).toThrow();   `\n\nUnfortunately if our tests are written in TypeScript, TypeScript will give us an error!\n\nts\n\n`   doStuff(123, 456);  //          ~~~  // error: Type 'number' is not assignable to type 'string'.   `\n\nThat’s why TypeScript 3.9 brings a new feature: `// @ts-expect-error` comments. When a line is preceded by a `// @ts-expect-error` comment, TypeScript will suppress that error from being reported; but if there’s no error, TypeScript will report that `// @ts-expect-error` wasn’t necessary.\n\nAs a quick example, the following code is okay\n\nts\n\n`   // @ts-expect-error  console.log(47 * \"octopus\");   `\n\nwhile the following code\n\nts\n\n`   // @ts-expect-error  console.log(1 + 1);   `\n\nresults in the error\n\n`   Unused '@ts-expect-error' directive.   `\n\nWe’d like to extend a big thanks to [Josh Goldberg](https://github.com/JoshuaKGoldberg)\n, the contributor who implemented this feature. For more information, you can take a look at [the `ts-expect-error` pull request](https://github.com/microsoft/TypeScript/pull/36014)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#ts-ignore-or-ts-expect-error)\n`ts-ignore` or `ts-expect-error`?\n\nIn some ways `// @ts-expect-error` can act as a suppression comment, similar to `// @ts-ignore`. The difference is that `// @ts-ignore` will do nothing if the following line is error-free.\n\nYou might be tempted to switch existing `// @ts-ignore` comments over to `// @ts-expect-error`, and you might be wondering which is appropriate for future code. While it’s entirely up to you and your team, we have some ideas of which to pick in certain situations.\n\nPick `ts-expect-error` if:\n\n*   you’re writing test code where you actually want the type system to error on an operation\n*   you expect a fix to be coming in fairly quickly and you just need a quick workaround\n*   you’re in a reasonably-sized project with a proactive team that wants to remove suppression comments as soon as affected code is valid again\n\nPick `ts-ignore` if:\n\n*   you have a larger project and new errors have appeared in code with no clear owner\n*   you are in the middle of an upgrade between two different versions of TypeScript, and a line of code errors in one version but not another.\n*   you honestly don’t have the time to decide which of these options is better.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#uncalled-function-checks-in-conditional-expressions)\nUncalled Function Checks in Conditional Expressions\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn TypeScript 3.7 we introduced _uncalled function checks_ to report an error when you’ve forgotten to call a function.\n\nts\n\n`   function hasImportantPermissions(): boolean {    // ...  }  // Oops!  if (hasImportantPermissions) {    //  ~~~~~~~~~~~~~~~~~~~~~~~    // This condition will always return true since the function is always defined.    // Did you mean to call it instead?    deleteAllTheImportantFiles();  }   `\n\nHowever, this error only applied to conditions in `if` statements. Thanks to [a pull request](https://github.com/microsoft/TypeScript/pull/36402)\n from [Alexander Tarasyuk](https://github.com/a-tarasyuk)\n, this feature is also now supported in ternary conditionals (i.e. the `cond ? trueExpr : falseExpr` syntax).\n\nts\n\n`   declare function listFilesOfDirectory(dirPath: string): string[];  declare function isDirectory(): boolean;  function getAllFiles(startFileName: string) {    const result: string[] = [];    traverse(startFileName);    return result;    function traverse(currentPath: string) {      return isDirectory        ? //     ~~~~~~~~~~~          // This condition will always return true          // since the function is always defined.          // Did you mean to call it instead?          listFilesOfDirectory(currentPath).forEach(traverse)        : result.push(currentPath);    }  }   `\n\n[https://github.com/microsoft/TypeScript/issues/36048](https://github.com/microsoft/TypeScript/issues/36048)\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#editor-improvements)\nEditor Improvements\n--------------------------------------------------------------------------------------------------------------------------\n\nThe TypeScript compiler not only powers the TypeScript editing experience in most major editors, it also powers the JavaScript experience in the Visual Studio family of editors and more. Using new TypeScript/JavaScript functionality in your editor will differ depending on your editor, but\n\n*   Visual Studio Code supports [selecting different versions of TypeScript](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript)\n    . Alternatively, there’s the [JavaScript/TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next)\n     to stay on the bleeding edge (which is typically very stable).\n*   Visual Studio 2017/2019 have \\[the SDK installers above\\] and [MSBuild installs](https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild)\n    .\n*   Sublime Text 3 supports [selecting different versions of TypeScript](https://github.com/microsoft/TypeScript-Sublime-Plugin#note-using-different-versions-of-typescript)\n    \n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#commonjs-auto-imports-in-javascript)\nCommonJS Auto-Imports in JavaScript\n\nOne great new improvement is in auto-imports in JavaScript files using CommonJS modules.\n\nIn older versions, TypeScript always assumed that regardless of your file, you wanted an ECMAScript-style import like\n\njs\n\n`   import * as fs from \"fs\";   `\n\nHowever, not everyone is targeting ECMAScript-style modules when writing JavaScript files. Plenty of users still use CommonJS-style `require(...)` imports like so\n\njs\n\n`   const fs = require(\"fs\");   `\n\nTypeScript now automatically detects the types of imports you’re using to keep your file’s style clean and consistent.\n\nFor more details on the change, see [the corresponding pull request](https://github.com/microsoft/TypeScript/pull/37027)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#code-actions-preserve-newlines)\nCode Actions Preserve Newlines\n\nTypeScript’s refactorings and quick fixes often didn’t do a great job of preserving newlines. As a really basic example, take the following code.\n\nts\n\n`   const maxValue = 100;  /*start*/  for (let i = 0; i <= maxValue; i++) {    // First get the squared value.    let square = i ** 2;    // Now print the squared value.    console.log(square);  }  /*end*/   `\n\nIf we highlighted the range from `/*start*/` to `/*end*/` in our editor to extract to a new function, we’d end up with code like the following.\n\nts\n\n`   const maxValue = 100;  printSquares();  function printSquares() {    for (let i = 0; i <= maxValue; i++) {      // First get the squared value.      let square = i ** 2;      // Now print the squared value.      console.log(square);    }  }   `\n\n![Extracting the for loop to a function in older versions of TypeScript. A newline is not preserved.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/03/printSquaresWithoutNewlines-3.9.gif.gif)\n\nThat’s not ideal - we had a blank line between each statement in our `for` loop, but the refactoring got rid of it! TypeScript 3.9 does a little more work to preserve what we write.\n\nts\n\n`   const maxValue = 100;  printSquares();  function printSquares() {    for (let i = 0; i <= maxValue; i++) {      // First get the squared value.      let square = i ** 2;      // Now print the squared value.      console.log(square);    }  }   `\n\n![Extracting the for loop to a function in TypeScript 3.9. A newline is preserved.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/03/printSquaresWithNewlines-3.9.gif.gif)\n\nYou can see more about the implementation [in this pull request](https://github.com/microsoft/TypeScript/pull/36688)\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#quick-fixes-for-missing-return-expressions)\nQuick Fixes for Missing Return Expressions\n\nThere are occasions where we might forget to return the value of the last statement in a function, especially when adding curly braces to arrow functions.\n\nts\n\n`   // before  let f1 = () => 42;  // oops - not the same!  let f2 = () => {    42;  };   `\n\nThanks to [a pull request](https://github.com/microsoft/TypeScript/pull/26434)\n from community member [Wenlu Wang](https://github.com/Kingwl)\n, TypeScript can provide a quick-fix to add missing `return` statements, remove curly braces, or add parentheses to arrow function bodies that look suspiciously like object literals.\n\n![TypeScript fixing an error where no expression is returned by adding a return statement or removing curly braces.](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/04/missingReturnValue-3-9.gif)\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#support-for-solution-style-tsconfigjson-files)\nSupport for “Solution Style” `tsconfig.json` Files\n\nEditors need to figure out which configuration file a file belongs to so that it can apply the appropriate options and figure out which other files are included in the current “project”. By default, editors powered by TypeScript’s language server do this by walking up each parent directory to find a `tsconfig.json`.\n\nOne case where this slightly fell over is when a `tsconfig.json` simply existed to reference other `tsconfig.json` files.\n\n`   // tsconfig.json  {    \"[files](https://www.typescriptlang.org/tsconfig#files) \": [],    \"[references](https://www.typescriptlang.org/tsconfig#references) \": [      { \"path\": \"./tsconfig.shared.json\" },      { \"path\": \"./tsconfig.frontend.json\" },      { \"path\": \"./tsconfig.backend.json\" }    ]  }   `\n\nThis file that really does nothing but manage other project files is often called a “solution” in some environments. Here, none of these `tsconfig.*.json` files get picked up by the server, but we’d really like the language server to understand that the current `.ts` file probably belongs to one of the mentioned projects in this root `tsconfig.json`.\n\nTypeScript 3.9 adds support to editing scenarios for this configuration. For more details, take a look at [the pull request that added this functionality](https://github.com/microsoft/TypeScript/pull/37239)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#parsing-differences-in-optional-chaining-and-non-null-assertions)\nParsing Differences in Optional Chaining and Non-Null Assertions\n\nTypeScript recently implemented the optional chaining operator, but we’ve received user feedback that the behavior of optional chaining (`?.`) with the non-null assertion operator (`!`) is extremely counter-intuitive.\n\nSpecifically, in previous versions, the code\n\nts\n\n`   foo?.bar!.baz;   `\n\nwas interpreted to be equivalent to the following JavaScript.\n\njs\n\n`   (foo?.bar).baz;   `\n\nIn the above code the parentheses stop the “short-circuiting” behavior of optional chaining, so if `foo` is `undefined`, accessing `baz` will cause a runtime error.\n\nThe Babel team who pointed this behavior out, and most users who provided feedback to us, believe that this behavior is wrong. We do too! The thing we heard the most was that the `!` operator should just “disappear” since the intent was to remove `null` and `undefined` from the type of `bar`.\n\nIn other words, most people felt that the original snippet should be interpreted as\n\njs\n\n`   foo?.bar.baz;   `\n\nwhich just evaluates to `undefined` when `foo` is `undefined`.\n\nThis is a breaking change, but we believe most code was written with the new interpretation in mind. Users who want to revert to the old behavior can add explicit parentheses around the left side of the `!` operator.\n\nts\n\n`   foo?.bar!.baz;   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#-and--are-now-invalid-jsx-text-characters)\n`}` and `>` are Now Invalid JSX Text Characters\n\nThe JSX Specification forbids the use of the `}` and `>` characters in text positions. TypeScript and Babel have both decided to enforce this rule to be more conformant. The new way to insert these characters is to use an HTML escape code (e.g. `<span> 2 &gt 1 </span>`) or insert an expression with a string literal (e.g. `<span> 2 {\">\"} 1 </span>`).\n\nLuckily, thanks to the [pull request](https://github.com/microsoft/TypeScript/pull/36636)\n enforcing this from [Brad Zacher](https://github.com/bradzacher)\n, you’ll get an error message along the lines of\n\n``   Unexpected token. Did you mean `{'>'}` or `>`?  Unexpected token. Did you mean `{'}'}` or `}`?   ``\n\nFor example:\n\ntsx\n\n``   let directions = <span>Navigate to: Menu Bar > Tools > Options</span>;  //                                           ~       ~  // Unexpected token. Did you mean `{'>'}` or `>`?   ``\n\nThat error message came with a handy quick fix, and thanks to [Alexander Tarasyuk](https://github.com/a-tarasyuk)\n, [you can apply these changes in bulk](https://github.com/microsoft/TypeScript/pull/37436)\n if you have a lot of errors.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#stricter-checks-on-intersections-and-optional-properties)\nStricter Checks on Intersections and Optional Properties\n\nGenerally, an intersection type like `A & B` is assignable to `C` if either `A` or `B` is assignable to `C`; however, sometimes that has problems with optional properties. For example, take the following:\n\nts\n\n`   interface A {    a: number; // notice this is 'number'  }  interface B {    b: string;  }  interface C {    a?: boolean; // notice this is 'boolean'    b: string;  }  declare let x: A & B;  declare let y: C;  y = x;   `\n\nIn previous versions of TypeScript, this was allowed because while `A` was totally incompatible with `C`, `B` _was_ compatible with `C`.\n\nIn TypeScript 3.9, so long as every type in an intersection is a concrete object type, the type system will consider all of the properties at once. As a result, TypeScript will see that the `a` property of `A & B` is incompatible with that of `C`:\n\n`   Type 'A & B' is not assignable to type 'C'.    Types of property 'a' are incompatible.      Type 'number' is not assignable to type 'boolean | undefined'.   `\n\nFor more information on this change, [see the corresponding pull request](https://github.com/microsoft/TypeScript/pull/37195)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#intersections-reduced-by-discriminant-properties)\nIntersections Reduced By Discriminant Properties\n\nThere are a few cases where you might end up with types that describe values that just don’t exist. For example\n\nts\n\n`   declare function smushObjects<T, U>(x: T, y: U): T & U;  interface Circle {    kind: \"circle\";    radius: number;  }  interface Square {    kind: \"square\";    sideLength: number;  }  declare let x: Circle;  declare let y: Square;  let z = smushObjects(x, y);  console.log(z.kind);   `\n\nThis code is slightly weird because there’s really no way to create an intersection of a `Circle` and a `Square` - they have two incompatible `kind` fields. In previous versions of TypeScript, this code was allowed and the type of `kind` itself was `never` because `\"circle\" & \"square\"` described a set of values that could `never` exist.\n\nIn TypeScript 3.9, the type system is more aggressive here - it notices that it’s impossible to intersect `Circle` and `Square` because of their `kind` properties. So instead of collapsing the type of `z.kind` to `never`, it collapses the type of `z` itself (`Circle & Square`) to `never`. That means the above code now errors with:\n\n`   Property 'kind' does not exist on type 'never'.   `\n\nMost of the breaks we observed seem to correspond with slightly incorrect type declarations. For more details, [see the original pull request](https://github.com/microsoft/TypeScript/pull/36696)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#getterssetters-are-no-longer-enumerable)\nGetters/Setters are No Longer Enumerable\n\nIn older versions of TypeScript, `get` and `set` accessors in classes were emitted in a way that made them enumerable; however, this wasn’t compliant with the ECMAScript specification which states that they must be non-enumerable. As a result, TypeScript code that targeted ES5 and ES2015 could differ in behavior.\n\nThanks to [a pull request](https://github.com/microsoft/TypeScript/pull/32264)\n from GitHub user [pathurs](https://github.com/pathurs)\n, TypeScript 3.9 now conforms more closely with ECMAScript in this regard.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#type-parameters-that-extend-any-no-longer-act-as-any)\nType Parameters That Extend `any` No Longer Act as `any`\n\nIn previous versions of TypeScript, a type parameter constrained to `any` could be treated as `any`.\n\nts\n\n`   function foo<T extends any>(arg: T) {    arg.spfjgerijghoied; // no error!  }   `\n\nThis was an oversight, so TypeScript 3.9 takes a more conservative approach and issues an error on these questionable operations.\n\nts\n\n`   function foo<T extends any>(arg: T) {    arg.spfjgerijghoied;    //  ~~~~~~~~~~~~~~~    // Property 'spfjgerijghoied' does not exist on type 'T'.  }   `\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#export--is-always-retained)\n`export *` is Always Retained\n\nIn previous TypeScript versions, declarations like `export * from \"foo\"` would be dropped in our JavaScript output if `foo` didn’t export any values. This sort of emit is problematic because it’s type-directed and can’t be emulated by Babel. TypeScript 3.9 will always emit these `export *` declarations. In practice, we don’t expect this to break much existing code.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#more-libdomdts-refinements)\nMore libdom.d.ts refinements\n\nWe are continuing to move more of TypeScript’s built-in .d.ts library (lib.d.ts and family) to be generated from Web IDL files directly from the DOM specification. As a result some vendor-specific types related to media access have been removed.\n\nAdding this file to an ambient `*.d.ts` to your project will bring them back:\n\nts\n\n`   interface AudioTrackList {       [Symbol.iterator](): IterableIterator<AudioTrack>;   }  interface HTMLVideoElement {    readonly audioTracks: AudioTrackList    msFrameStep(forward: boolean): void;    msInsertVideoEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;    msSetVideoRectangle(left: number, top: number, right: number, bottom: number): void;    webkitEnterFullScreen(): void;    webkitEnterFullscreen(): void;    webkitExitFullScreen(): void;    webkitExitFullscreen(): void;    msHorizontalMirror: boolean;    readonly msIsLayoutOptimalForPlayback: boolean;    readonly msIsStereo3D: boolean;    msStereo3DPackingMode: string;    msStereo3DRenderMode: string;    msZoom: boolean;    onMSVideoFormatChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;    onMSVideoFrameStepCompleted: ((this: HTMLVideoElement, ev: Event) => any) | null;    onMSVideoOptimalLayoutChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;    webkitDisplayingFullscreen: boolean;    webkitSupportsFullscreen: boolean;  }  interface MediaError {    readonly msExtendedCode: number;    readonly MS_MEDIA_ERR_ENCRYPTED: number;  }   `\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%203.9.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (12)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nSL![Shammel Lee  (1)](https://gravatar.com/avatar/38e9cfee5d8d7e5bc125b30703ff146382d0995511059d3a62af013d2c6d6585?s=32&&d=blank)\n\nNS![Nick Schonning  (1)](https://gravatar.com/avatar/a490b76edb21047df004539971c9258a6c3bd8da6bc3ca94c89da3e6398ef08e?s=32&&d=blank)\n\nMU![Masato Urai  (1)](https://gravatar.com/avatar/ed67cd61e7c19e1081270e954cbe4249efd9429305d34b6c43061196ee05a6eb?s=32&&d=blank)\n\nHK![Homyee King  (1)](https://gravatar.com/avatar/e7d363bbf3babf109136ec715a4a7ed30449175b180b0a4e48957d564cb03aec?s=32&&d=blank)\n\n2+\n\nLast updated: Mar 04, 2025  \n  \n \n\nMSG","metadata":{"ogTitle":"Documentation - TypeScript 3.9","language":"en","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","twitter:site":"typescriptlang","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","generator":"Gatsby 5.13.5","theme-color":"#3178C6","ogDescription":"TypeScript 3.9 Release Notes","description":"TypeScript 3.9 Release Notes","og:description":"TypeScript 3.9 Release Notes","title":"TypeScript: Documentation - TypeScript 3.9","og:title":"Documentation - TypeScript 3.9","scrapeId":"491b2bd4-b65c-4e10-ac2e-f3f33af51dd5","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html","statusCode":200}},{"markdown":"Was this page helpful?\n\nTypeScript 4.0\n==============\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)\nVariadic Tuple Types\n----------------------------------------------------------------------------------------------------------------------------\n\nConsider a function in JavaScript called `concat` that takes two array or tuple types and concatenates them together to make a new array.\n\njs\n\n`   function concat(arr1, arr2) {    return [...arr1, ...arr2];  }   `\n\nAlso consider `tail`, that takes an array or tuple, and returns all elements but the first.\n\njs\n\n`   function tail(arg) {    const [_, ...result] = arg;    return result;  }   `\n\nHow would we type either of these in TypeScript?\n\nFor `concat`, the only valid thing we could do in older versions of the language was to try and write some overloads.\n\nts\n\n`   function concat(arr1: [], arr2: []): [];  function concat<A>(arr1: [A], arr2: []): [A];  function concat<A, B>(arr1: [A, B], arr2: []): [A, B];  function concat<A, B, C>(arr1: [A, B, C], arr2: []): [A, B, C];  function concat<A, B, C, D>(arr1: [A, B, C, D], arr2: []): [A, B, C, D];  function concat<A, B, C, D, E>(arr1: [A, B, C, D, E], arr2: []): [A, B, C, D, E];  function concat<A, B, C, D, E, F>(arr1: [A, B, C, D, E, F], arr2: []): [A, B, C, D, E, F];   `\n\nUh…okay, that’s…seven overloads for when the second array is always empty. Let’s add some for when `arr2` has one argument.\n\nts\n\n`   function concat<A2>(arr1: [], arr2: [A2]): [A2];  function concat<A1, A2>(arr1: [A1], arr2: [A2]): [A1, A2];  function concat<A1, B1, A2>(arr1: [A1, B1], arr2: [A2]): [A1, B1, A2];  function concat<A1, B1, C1, A2>(arr1: [A1, B1, C1], arr2: [A2]): [A1, B1, C1, A2];  function concat<A1, B1, C1, D1, A2>(arr1: [A1, B1, C1, D1], arr2: [A2]): [A1, B1, C1, D1, A2];  function concat<A1, B1, C1, D1, E1, A2>(arr1: [A1, B1, C1, D1, E1], arr2: [A2]): [A1, B1, C1, D1, E1, A2];  function concat<A1, B1, C1, D1, E1, F1, A2>(arr1: [A1, B1, C1, D1, E1, F1], arr2: [A2]): [A1, B1, C1, D1, E1, F1, A2];   `\n\nWe hope it’s clear that this is getting unreasonable. Unfortunately, you’d also end up with the same sorts of issues typing a function like `tail`.\n\nThis is another case of what we like to call “death by a thousand overloads”, and it doesn’t even solve the problem generally. It only gives correct types for as many overloads as we care to write. If we wanted to make a catch-all case, we’d need an overload like the following:\n\nts\n\n`   function concat<T, U>(arr1: T[], arr2: U[]): Array<T | U>;   `\n\nBut that signature doesn’t encode anything about the lengths of the input, or the order of the elements, when using tuples.\n\nTypeScript 4.0 brings two fundamental changes, along with inference improvements, to make typing these possible.\n\nThe first change is that spreads in tuple type syntax can now be generic. This means that we can represent higher-order operations on tuples and arrays even when we don’t know the actual types we’re operating over. When generic spreads are instantiated (or, replaced with a real type) in these tuple types, they can produce other sets of array and tuple types.\n\nFor example, that means we can type function like `tail`, without our “death by a thousand overloads” issue.\n\nts\n\n`   function tail<T extends any[]>(arr: readonly [any, ...T]) {    const [_ignored, ...rest] = arr;    return rest;  }  const myTuple = [1, 2, 3, 4] as const;  const myArray = [\"hello\", \"world\"];  const r1 = tail(myTuple);          const r1: [2, 3, 4]  const r2 = tail([...myTuple, ...myArray] as const);          const r2: [2, 3, 4, ...string[]]   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFAhjANgHgCqIKYAeUeYAJgM6IpgCeA2gLoB8AFCgE7sBci7eKpBOhqI61GgBpEAOlnYGASkQBvAFCJEEBOSiiA+jADmYOH1JTZ0vjoaIAvFU4BudbzxQQ7JNaguAvqqqWmA6iAC2NNggAA7oePaiAIxSAExSAMxSACy2KJTBOi4FuhEAgpwoIg50AEQAFnjo6HA1UjUA7qbopDUMLkHauuyJCagYLBFRsXgKLgD0cxoaAHoA-IHFvCmjaOgsdJaTMXEWsmUVNLn5g7OqC0uIa0A)\n\nThe second change is that rest elements can occur anywhere in a tuple - not just at the end!\n\nts\n\n`   type Strings = [string, string];  type Numbers = [number, number];  type StrStrNumNumBool = [...Strings, ...Numbers, boolean];   `\n\nPreviously, TypeScript would issue an error like the following:\n\n`   A rest element must be last in a tuple type.   `\n\nBut with TypeScript 4.0, this restriction is relaxed.\n\nNote that in cases when we spread in a type without a known length, the resulting type becomes unbounded as well, and all the following elements factor into the resulting rest element type.\n\nts\n\n`   type Strings = [string, string];  type Numbers = number[];  type Unbounded = [...Strings, ...Numbers, boolean];   `\n\nBy combining both of these behaviors together, we can write a single well-typed signature for `concat`:\n\nts\n\n`   type Arr = readonly any[];  function concat<T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U] {    return [...arr1, ...arr2];  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnKBeKcIEMAmB7AdgGxCnVxAG0BdAbgCgaAzAV1wGNgBLPKFvF9YADwAVKBAAewCLkwBnWAgA0UAKqiJU2fLgA+ABToEARgBcUIUoNwATKeUBKU2QB0L81BdPlFKAG8aUVAhgRjhcKGcXS0MlD0srahoAXyA)\n\nWhile that one signature is still a bit lengthy, it’s just one signature that doesn’t have to be repeated, and it gives predictable behavior on all arrays and tuples.\n\nThis functionality on its own is great, but it shines in more sophisticated scenarios too. For example, consider a function to [partially apply arguments](https://en.wikipedia.org/wiki/Partial_application)\n called `partialCall`. `partialCall` takes a function - let’s call it `f` - along with the initial few arguments that `f` expects. It then returns a new function that takes any other arguments that `f` still needs, and calls `f` when it receives them.\n\njs\n\n`   function partialCall(f, ...headArgs) {    return (...tailArgs) => f(...headArgs, ...tailArgs);  }   `\n\nTypeScript 4.0 improves the inference process for rest parameters and rest tuple elements so that we can type this and have it “just work”.\n\nts\n\n`   type Arr = readonly unknown[];  function partialCall<T extends Arr, U extends Arr, R>(    f: (...args: [...T, ...U]) => R,    ...headArgs: T  ) {    return (...tailArgs: U) => f(...headArgs, ...tailArgs);  }   `[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnKBeKcIEMAmB7AdgGxCgFdcBrXbAd1wG0BdAbgChmAzUgY2AEs8ow6OL3T4AwqPwAeACpQIAD2ARcmAM6wEAGigBVeUpXrNcHQCUAfAApmUKGwBcUKwDo3QgOZqntNy5k6frr0AJTIFlBmWrZQfgAWGJjwXk4yzGEA3jFowMRwuM5+wOg8+MneemFIEWyubglY5YFuxaXlISwAvkA)\n\nIn this case, `partialCall` understands which parameters it can and can’t initially take, and returns functions that appropriately accept and reject anything left over.\n\nts\n\n`  const foo = (x: string, y: number, z: boolean) => {};  const f1 = partialCall(foo, 100);  Argument of type 'number' is not assignable to parameter of type 'string'.2345Argument of type 'number' is not assignable to parameter of type 'string'.  const f2 = partialCall(foo, \"hello\", 100, true, \"oops\");  Expected 4 arguments, but got 5.2554Expected 4 arguments, but got 5.  // This works!  const f3 = partialCall(foo, \"hello\");          const f3: (y: number, z: boolean) => void  // What can we do with f3 now?  // Works!  f3(123, true);  f3();  Expected 2 arguments, but got 0.2554Expected 2 arguments, but got 0.  f3(123, \"hello\");  Argument of type 'string' is not assignable to parameter of type 'boolean'.2345Argument of type 'string' is not assignable to parameter of type 'boolean'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdOct9D1scAoAFwE8AHSUAQVlAF5RpIBDAEzgDsANtVABXfgGt+cAO78A2gF0A3OXIAzcQGNKASwGhaXaHq6CAwmcEAeACqhIAD0qR+PRE1gAaUAFUHzq7untA+AEoAfAAU5KCg6qhRAHQpxgDmKKDyKUm2Pjm+igCUbBGgYV6xoDkAFtw8zBmotuQlAN5VnJSi0PygySmUXLqCjZm+Jaxl6gNJdbxj+YPDo9AZRaoAvuQgoAC0B1qilAd75FoCiJTxcHBs-Y6oV9C6-Gk+1Kj8ogC2AEYwHwAL1Qf1ugm4-EmZTam1U50u13UAEZ7kYTLozJZBIIoupbj5kQAGIkbNQXfhXeJoNHGUwWKx4gmgABEdRxcBZhJJPko0FEkB8LNutEQLLJOzAthqug8MgQEkQAEIEZSkRhaRisYz8XAhezBJyybs4qAAHoAfjUuwA6jUuNctFw+jIGHxQDJdJQavENdIZFbJaAbQrlRoMFFkZhefzIBL1BH4xGoxh9ZAOeLlEA)\n\nVariadic tuple types enable a lot of new exciting patterns, especially around function composition. We expect we may be able to leverage it to do a better job type-checking JavaScript’s built-in `bind` method. A handful of other inference improvements and patterns also went into this, and if you’re interested in learning more, you can take a look at [the pull request](https://github.com/microsoft/TypeScript/pull/39094)\n for variadic tuples.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#labeled-tuple-elements)\nLabeled Tuple Elements\n--------------------------------------------------------------------------------------------------------------------------------\n\nImproving the experience around tuple types and parameter lists is important because it allows us to get strongly typed validation around common JavaScript idioms - really just slicing and dicing argument lists and passing them to other functions. The idea that we can use tuple types for rest parameters is one place where this is crucial.\n\nFor example, the following function that uses a tuple type as a rest parameter…\n\nts\n\n`   function foo(...args: [string, number]): void {    // ...  }   `\n\n…should appear no different from the following function…\n\nts\n\n`   function foo(arg0: string, arg1: number): void {    // ...  }   `\n\n…for any caller of `foo`.\n\nts\n\n`  foo(\"hello\", 42);  foo(\"hello\", 42, true);  Expected 2 arguments, but got 3.2554Expected 2 arguments, but got 3.  foo(\"hello\");  Expected 2 arguments, but got 1.2554Expected 2 arguments, but got 1.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jR844AKAQ2gHMAGVRc6S4tgBpQrNgEZUxQgFsARjACUqAG5xKAE1ABvXKFAhQAOmO4AvrgMBaa6ULlrlgg0YAiABaQANp7gvh2NAUAblwnJncvHz9QAOFeQkhgsNcPb19goA)\n\nThere is one place where the differences begin to become observable though: readability. In the first example, we have no parameter names for the first and second elements. While these have no impact on type-checking, the lack of labels on tuple positions can make them harder to use - harder to communicate our intent.\n\nThat’s why in TypeScript 4.0, tuples types can now provide labels.\n\nts\n\n`   type Range = [start: number, end: number];   `\n\nTo deepen the connection between parameter lists and tuple types, the syntax for rest elements and optional elements mirrors the syntax for parameter lists.\n\nts\n\n`   type Foo = [first: number, second?: string, ...rest: any[]];   `\n\nThere are a few rules when using labeled tuples. For one, when labeling a tuple element, all other elements in the tuple must also be labeled.\n\nts\n\n`   type Bar = [first: string, number];   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygKwAYAcAWAUAC4CeADpKAEICG0oAvKANoBmAlkgaogdKwHYBzADSg+AVwC2AIxgBdANxA)\n\nIt’s worth noting - labels don’t require us to name our variables differently when destructuring. They’re purely there for documentation and tooling.\n\nts\n\n`   function foo(x: [first: string, second: number]) {      // ...      // note: we didn't need to name these 'first' and 'second'      const [a, b] = x;      a       const a: string      b       const b: number  }   `[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMOcAUAPAXIg2sGAJwGcodTCYwBzAGkWIFMIEATHMEAWwCNHCAugEpEAbwBQiKYgD0MxADol4ydLmIwcKIxwB3RolYxWYAORQNjRq0RQ4GgIZcDUABaMmiUwRJRTiBzAbUyYWINNVKTDSPAd6HgFEAF5EDABuSIDxdUQAPQB+TJ5s+TzCgF8gA)\n\nOverall, labeled tuples are handy when taking advantage of patterns around tuples and argument lists, along with implementing overloads in a type-safe way. In fact, TypeScript’s editor support will try to display them as overloads when possible.\n\n![Signature help displaying a union of labeled tuples as in a parameter list as two signatures](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/signatureHelpLabeledTuples.gif)\n\nTo learn more, check out [the pull request](https://github.com/microsoft/TypeScript/pull/38234)\n for labeled tuple elements.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#class-property-inference-from-constructors)\nClass Property Inference from Constructors\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.0 can now use control flow analysis to determine the types of properties in classes when [`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)\n is enabled.\n\nts\n\n`   class Square {    // Previously both of these were any    area;       (property) Square.area: number    sideLength;          (property) Square.sideLength: number    constructor(sideLength: number) {      this.sideLength = sideLength;      this.area = sideLength ** 2;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKCOBXMAnAptA3gKGtA9PtAAroBuAlgPaIQgCe0ARlQC4AW0VAZtB2hAwB3NOmhgAdvVzj0YANzZC0AHoB+GRAoATNABk0EgOYdFy9TOBUJEVikTBWVFAAotug8Y4AuaBMQAtkyiAJRYMngcFBAAdO76hiacALzQ8Z5JiniR7NExqGhg0KnpiRzQAFQV0ABMWdAAvtgNQA)\n\nIn cases where not all paths of a constructor assign to an instance member, the property is considered to potentially be `undefined`.\n\nts\n\n`   class Square {    sideLength;          (property) Square.sideLength: number | undefined    constructor(sideLength: number) {      if (Math.random()) {        this.sideLength = sideLength;      }    }    get area() {      return this.sideLength ** 2;  Object is possibly 'undefined'.2532Object is possibly 'undefined'.    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCAoAYwBsBDRRUAZQEcBXW6SUAb3NFCIAlgBNIAGUgA7AOYAXABYBuciFAA9APzl+oSnCmI50NpTkIAFMLGTZi1FLYBbAEYwAlL10ChAM1AWALK0igB00LRSInBOFu6efAJJoIpCiKHWEtLyCqAAvIKiWXbK3qAAvrqVujKQcqCckLRxXslccmzQUikKaRlFtjmgAFTD6CoCleVAA)\n\nIn cases where you know better (e.g. you have an `initialize` method of some sort), you’ll still need an explicit type annotation along with a definite assignment assertion (`!`) if you’re in [`strictPropertyInitialization`](https://www.typescriptlang.org/tsconfig#strictPropertyInitialization)\n.\n\nts\n\n`   class Square {    // definite assignment assertion    //        v    sideLength!: number;    // type annotation    constructor(sideLength: number) {      this.initialize(sideLength);    }    initialize(sideLength: number) {      this.sideLength = sideLength;    }    get area() {      return this.sideLength ** 2;    }  }   `[Try](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKCOBXMAnAptA3gKGtA9PtACZoBmAlgHYUAuGkEFA5lQLZpW3SNoq0UA9lVwEieCXgBuopqQAynZrQAWAQgBc0KojYAjPgG5RhSWYB6lq5ZNFaATwAODKlUG0wA4dlHBhEWhREYFpBFAAKOTRFKmUVLR19PgBKLFE8VQoIADpqOgowEAoALzRIigUlVWTjPABfHzw8gUKSsqiYuITdAxRUnElMnI6qlWgAXmgR2NVa6AbRZjRuVDQwcP706HRaRBQqaCHs6bjoACoz6AAmOYa6oA)\n\nFor more details, [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/37920)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#short-circuiting-assignment-operators)\nShort-Circuiting Assignment Operators\n--------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nJavaScript, and a lot of other languages, support a set of operators called _compound assignment_ operators. Compound assignment operators apply an operator to two arguments, and then assign the result to the left side. You may have seen these before:\n\nts\n\n`   // Addition  // a = a + b  a += b;  // Subtraction  // a = a - b  a -= b;  // Multiplication  // a = a * b  a *= b;  // Division  // a = a / b  a /= b;  // Exponentiation  // a = a ** b  a **= b;  // Left Bit Shift  // a = a << b  a <<= b;   `\n\nSo many operators in JavaScript have a corresponding assignment operator! Up until recently, however, there were three notable exceptions: logical _and_ (`&&`), logical _or_ (`||`), and nullish coalescing (`??`).\n\nThat’s why TypeScript 4.0 supports a new ECMAScript feature to add three new assignment operators: `&&=`, `||=`, and `??=`.\n\nThese operators are great for substituting any example where a user might write code like the following:\n\nts\n\n`   a = a && b;  a = a || b;  a = a ?? b;   `\n\nOr a similar `if` block like\n\nts\n\n`   // could be 'a ||= b'  if (!a) {    a = b;  }   `\n\nThere are even some patterns we’ve seen (or, uh, written ourselves) to lazily initialize values, only if they’ll be needed.\n\nts\n\n`   let values: string[];  (values ?? (values = [])).push(\"hello\");  // After  (values ??= []).push(\"hello\");   `\n\n(look, we’re not proud of _all_ the code we write…)\n\nOn the rare case that you use getters or setters with side-effects, it’s worth noting that these operators only perform assignments if necessary. In that sense, not only is the right side of the operator “short-circuited” - the assignment itself is too.\n\nts\n\n`   obj.prop ||= foo();  // roughly equivalent to either of the following  obj.prop || (obj.prop = foo());  if (!obj.prop) {      obj.prop = foo();  }   `\n\n[Try running the following example](https://www.typescriptlang.org/play?ts=next#code/MYewdgzgLgBCBGArGBeGBvAsAKBnmA5gKawAOATiKQBQCUGO+TMokIANkQHTsgHUAiYlChFyMABYBDCDHIBXMANoBuHI2Z4A9FpgAlIqXZTgRGAFsiAQg2byJeeTAwAslKgSu5KWAAmIczoYAB4YAAYuAFY1XHwAXwAaWxgIEhgKKmoAfQA3KXYALhh4EA4iH3osWM1WCDKePkFUkTFJGTlFZRimOJw4mJwAM0VgKABLcBhB0qCqplr63n4BcjGCCVgIMd8zIjz2eXciXy7k+yhHZygFIhje7BwFzgblgBUJMdlwM3yAdykAJ6yBSQGAeMzNUTkU7YBCILgZUioOBIBGUJEAHwxUxmqnU2Ce3CWgnenzgYDMACo6pZxpYIJSOqDwSkSFCYXC0VQYFi0NMQHQVEA)\n to see how that differs from _always_ performing the assignment.\n\nts\n\n`   const obj = {      get prop() {          console.log(\"getter has run\");          // Replace me!          return Math.random() < 0.5;      },      set prop(_val: boolean) {          console.log(\"setter has run\");      }  };  function foo() {      console.log(\"right side evaluated\");      return true;  }  console.log(\"This one always runs the setter\");  obj.prop = obj.prop || foo();  console.log(\"This one *sometimes* runs the setter\");  obj.prop ||= foo();   `[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBCBGArGBeGBvAUDHMDmAprAA4BOIxAFAJQba4OiQgA2BAdCyHpQESFQoBUjAAWAQwgxSAVzC9qAbkz0GOAPTqYAJQLEW44ARgBbAgEJVa0kRmkwMALLioo9qXFgAJiBM0YADwwAAzsAKzKDAC+ADRWEEQwZBSUAPoAbuIsAFww8CCsBJ60WGq4TBCFnNx8CYLCYpLScgqRuFGYUcqYAGZywFAAluAwPQX+peXglWzVPLykg3iisBCDXsYEmSwyLgRerVY2UHYOULIEyh2YFVVc8wAqooNS4MZZAO7iAJ5SspAwVzGOpCUiHBCIdjJYioOBIKHkGEAHyRo3GShUt1m9z4TxecDAxgAVJUzEMzBAic0AUCYCDhOD4dCYCi0GMQDRFEA)\n\nWe’d like to extend a big thanks to community member [Wenlu Wang](https://github.com/Kingwl)\n for this contribution!\n\nFor more details, you can [take a look at the pull request here](https://github.com/microsoft/TypeScript/pull/37727)\n. You can also [check out TC39’s proposal repository for this feature](https://github.com/tc39/proposal-logical-assignment/)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#unknown-on-catch-clause-bindings)\n`unknown` on `catch` Clause Bindings\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\nSince the beginning days of TypeScript, `catch` clause variables have always been typed as `any`. This meant that TypeScript allowed you to do anything you wanted with them.\n\nts\n\n`   try {    // Do some work  } catch (x) {    // x has type 'any' - have fun!    console.log(x.message);    console.log(x.toUpperCase());    x++;    x.yadda.yadda.yadda();  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFcGcFMFUB2BrRB7A7ogkogwgIYAuAxgBYBqBATgJYEBGANrNAFygBmBTcAUEWoBPUAG8+oUCFAARNKGhoAtrFAY01ZHwC+oEsXKgAFAA8AlGIlSwJ0GQLRQRIQAdVAcgKIh70AFo7AgA3VU5IRABCKxI0REUWADomNABzUwSVaGgCFNgzAG5o2PjYJNT0ojR4FzdqQjgjMwKrEwBqVsLJEwShAgATPoIe-sHhgYJGwu0gA)\n\nThe above has some undesirable behavior if we’re trying to prevent _more_ errors from happening in our error-handling code! Because these variables have the type `any` by default, they lack any type-safety which could have errored on invalid operations.\n\nThat’s why TypeScript 4.0 now lets you specify the type of `catch` clause variables as `unknown` instead. `unknown` is safer than `any` because it reminds us that we need to perform some sorts of type-checks before operating on our values.\n\nts\n\n`   try {    // ...  } catch (e: unknown) {    // Can't access values on unknowns    console.log(e.toUpperCase());  'e' is of type 'unknown'.18046'e' is of type 'unknown'.    if (typeof e === \"string\") {      // We've narrowed 'e' down to the type 'string'.      console.log(e.toUpperCase());    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AKABdoBPUAbwtFBFADpOKBfUAYwCGVPgAtQACkioArgDsA1rLgB3WQEpGzVmADCA2QHIqoAXz6REiUADcBAG2kXQcWaDmKVsxFr4vEcO0h2OzgAc0l2KjgAVQAHWJg9REhxNTUAbgotAEsAMwkqWgS4fMhQAF5K0AAiRBps2VDqjSYWFjYAdUgDazLZAVgVSAATUANu0GHPUCiZkTLChLG66AbQg3YtFl8vAKCQ8KCouIToJJS0zJZuHiA)\n\nWhile the types of `catch` variables won’t change by default, we might consider a new [`strict`](https://www.typescriptlang.org/tsconfig#strict)\n mode flag in the future so that users can opt in to this behavior. In the meantime, it should be possible to write a lint rule to force `catch` variables to have an explicit annotation of either `: any` or `: unknown`.\n\nFor more details you can [peek at the changes for this feature](https://github.com/microsoft/TypeScript/pull/39015)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#custom-jsx-factories)\nCustom JSX Factories\n----------------------------------------------------------------------------------------------------------------------------\n\nWhen using JSX, a [_fragment_](https://reactjs.org/docs/fragments.html)\n is a type of JSX element that allows us to return multiple child elements. When we first implemented fragments in TypeScript, we didn’t have a great idea about how other libraries would utilize them. Nowadays most other libraries that encourage using JSX and support fragments have a similar API shape.\n\nIn TypeScript 4.0, users can customize the fragment factory through the new [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n option.\n\nAs an example, the following `tsconfig.json` file tells TypeScript to transform JSX in a way compatible with React, but switches each factory invocation to `h` instead of `React.createElement`, and uses `Fragment` instead of `React.Fragment`.\n\n`   {    \"[compilerOptions](https://www.typescriptlang.org/tsconfig#compilerOptions) \": {      \"[target](https://www.typescriptlang.org/tsconfig#target) \": \"esnext\",      \"[module](https://www.typescriptlang.org/tsconfig#module) \": \"commonjs\",      \"[jsx](https://www.typescriptlang.org/tsconfig#jsx) \": \"react\",      \"[jsxFactory](https://www.typescriptlang.org/tsconfig#jsxFactory) \": \"h\",      \"[jsxFragmentFactory](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory) \": \"Fragment\"    }  }   `\n\nIn cases where you need to have a different JSX factory on a per-file basis, you can take advantage of the new `/** @jsxFrag */` pragma comment. For example, the following…\n\ntsx\n\n`   // Note: these pragma comments need to be written  // with a JSDoc-style multiline syntax to take effect.  /** @jsx h */  /** @jsxFrag Fragment */  import { h, Fragment } from \"preact\";  export const Header = (    <>      <h1>Welcome</h1>    </>  );   `[Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAOwgFEocoAzqzgA5CDCQAuODAAWSAUjhgoKAOYgUcNLhBIOMAXA5IkAExkQ4AIyUB3KMBgSOwu09lwtAKQDKAEQg0agEYAE8AGyUQegiYYAjgEzgBMIMUAA9LGRQAayUkTEwkDAA6UgoAKkq4NgArASzPSvIqmvrGgDFVNThu9T0DOBaK0EhYOABvOFkAGj6ewfgAXzhsXDgAIhViGE2AbgqkDPH4HQ5QuAAJVDMkKDgAXjgAClI4OAAeAD53j6-ZABGb4AdSQER0ek+5CBvw+0N+AEp9kA)\n\n…will get transformed to this output JavaScript…\n\ntsx\n\n`import React from 'react';  export const Header = (React.createElement(React.Fragment, null,      React.createElement(\"h1\", null, \"Welcome\")));` [Try](https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wCgB6cuAWlrQFcZbqKqABAOwgFEocoAzqzhsBACwgB3biGAxhAOQgwkALjgwxSAUjhgoKAOYgUcNLhBIOMAXA5IkAEw0Q4AI12SoclR2GS5MThTACkAZQARCDRqARgATwAbXRB6RJhgROB7OAF46xQADxcNFABrXSRMTCQMADpSCgAqJpEAKwFioKbyZta2DsKAMQNDOBGjS2s4HsbQSFg4AG84MQAacdGp+ABfOGxcOAAifWIYI4BuRqRChfhzDji4AAlURyQoOABeOAAKUjgcAAPAA+AGA4FiACMIIA6khEuZLEDyNCwYCUWCAJQXIA)\n\nWe’d like to extend a big thanks to community member [Noj Vek](https://github.com/nojvek)\n for sending this pull request and patiently working with our team on it.\n\nYou can see that [the pull request](https://github.com/microsoft/TypeScript/pull/38720)\n for more details!\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#speed-improvements-in-build-mode-with---noemitonerror)\nSpeed Improvements in `build` mode with `--noEmitOnError`\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPreviously, compiling a program after a previous compile with errors under [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n would be extremely slow when using the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)\n flag. This is because none of the information from the last compilation would be cached in a `.tsbuildinfo` file based on the [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)\n flag.\n\nTypeScript 4.0 changes this which gives a great speed boost in these scenarios, and in turn improves `--build` mode scenarios (which imply both [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n and [`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)\n).\n\nFor details, [read up more on the pull request](https://github.com/microsoft/TypeScript/pull/38853)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#--incremental-with---noemit)\n`--incremental` with `--noEmit`\n----------------------------------------------------------------------------------------------------------------------------------------------\n\nTypeScript 4.0 allows us to use the [`noEmit`](https://www.typescriptlang.org/tsconfig#noEmit)\n flag while still leveraging [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n compiles. This was previously not allowed, as [`incremental`](https://www.typescriptlang.org/tsconfig#incremental)\n needs to emit a `.tsbuildinfo` files; however, the use-case to enable faster incremental builds is important enough to enable for all users.\n\nFor more details, you can [see the implementing pull request](https://github.com/microsoft/TypeScript/pull/39122)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#editor-improvements)\nEditor Improvements\n--------------------------------------------------------------------------------------------------------------------------\n\nThe TypeScript compiler doesn’t only power the editing experience for TypeScript itself in most major editors - it also powers the JavaScript experience in the Visual Studio family of editors and more. For that reason, much of our work focuses on improving editor scenarios - the place you spend most of your time as a developer.\n\nUsing new TypeScript/JavaScript functionality in your editor will differ depending on your editor, but\n\n*   Visual Studio Code supports [selecting different versions of TypeScript](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript)\n    . Alternatively, there’s the [JavaScript/TypeScript Nightly Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next)\n     to stay on the bleeding edge (which is typically very stable).\n*   Visual Studio 2017/2019 have \\[the SDK installers above\\] and [MSBuild installs](https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild)\n    .\n*   Sublime Text 3 supports [selecting different versions of TypeScript](https://github.com/microsoft/TypeScript-Sublime-Plugin#note-using-different-versions-of-typescript)\n    \n\nYou can check out a partial [list of editors that have support for TypeScript](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)\n to learn more about whether your favorite editor has support to use new versions.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#convert-to-optional-chaining)\nConvert to Optional Chaining\n\nOptional chaining is a recent feature that’s received a lot of love. That’s why TypeScript 4.0 brings a new refactoring to convert common patterns to take advantage of [optional chaining](https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#optional-chaining)\n and [nullish coalescing](https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing)\n!\n\n![Converting a && a.b.c && a.b.c.d.e.f() to a?.b.c?.d.e.f.()](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/convertToOptionalChain-4-0.gif)\n\nKeep in mind that while this refactoring doesn’t _perfectly_ capture the same behavior due to subtleties with truthiness/falsiness in JavaScript, we believe it should capture the intent for most use-cases, especially when TypeScript has more precise knowledge of your types.\n\nFor more details, [check out the pull request for this feature](https://github.com/microsoft/TypeScript/pull/39135)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#-deprecated--support)\n`/** @deprecated */` Support\n\nTypeScript’s editing support now recognizes when a declaration has been marked with a `/** @deprecated */` JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed in a strike-though style ~like this~.\n\n![Some examples of deprecated declarations with strikethrough text in the editor](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/06/deprecated_4-0.png)\n\nThis new functionality is available thanks to [Wenlu Wang](https://github.com/Kingwl)\n. See [the pull request](https://github.com/microsoft/TypeScript/pull/38523)\n for more details.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#partial-semantic-mode-at-startup)\nPartial Semantic Mode at Startup\n\nWe’ve heard a lot from users suffering from long startup times, especially on bigger projects. The culprit is usually a process called _program construction_. This is the process of starting with an initial set of root files, parsing them, finding their dependencies, parsing those dependencies, finding those dependencies’ dependencies, and so on. The bigger your project is, the longer you’ll have to wait before you can get basic editor operations like go-to-definition or quick info.\n\nThat’s why we’ve been working on a new mode for editors to provide a _partial_ experience until the full language service experience has loaded up. The core idea is that editors can run a lightweight partial server that only looks at the current files that the editor has open.\n\nIt’s hard to say precisely what sorts of improvements you’ll see, but anecdotally, it used to take anywhere between _20 seconds to a minute_ before TypeScript would become fully responsive on the Visual Studio Code codebase. In contrast, **our new partial semantic mode seems to bring that delay down to just a few seconds**. As an example, in the following video, you can see two side-by-side editors with TypeScript 3.9 running on the left and TypeScript 4.0 running on the right.\n\nWhen restarting both editors on a particularly large codebase, the one with TypeScript 3.9 can’t provide completions or quick info at all. On the other hand, the editor with TypeScript 4.0 can _immediately_ give us a rich experience in the current file we’re editing, despite loading the full project in the background.\n\nCurrently the only editor that supports this mode is [Visual Studio Code](http://code.visualstudio.com/)\n which has some UX improvements coming up in [Visual Studio Code Insiders](http://code.visualstudio.com/insiders)\n. We recognize that this experience may still have room for polish in UX and functionality, and we have [a list of improvements](https://github.com/microsoft/TypeScript/issues/39035)\n in mind. We’re looking for more feedback on what you think might be useful.\n\nFor more information, you can [see the original proposal](https://github.com/microsoft/TypeScript/issues/37713)\n, [the implementing pull request](https://github.com/microsoft/TypeScript/pull/38561)\n, along with [the follow-up meta issue](https://github.com/microsoft/TypeScript/issues/39035)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#smarter-auto-imports)\nSmarter Auto-Imports\n\nAuto-import is a fantastic feature that makes coding a lot easier; however, every time auto-import doesn’t seem to work, it can throw users off a lot. One specific issue that we heard from users was that auto-imports didn’t work on dependencies that were written in TypeScript - that is, until they wrote at least one explicit import somewhere else in their project.\n\nWhy would auto-imports work for `@types` packages, but not for packages that ship their own types? It turns out that auto-imports only work on packages your project _already_ includes. Because TypeScript has some quirky defaults that automatically add packages in `node_modules/@types` to your project, _those_ packages would be auto-imported. On the other hand, other packages were excluded because crawling through all your `node_modules` packages can be _really_ expensive.\n\nAll of this leads to a pretty lousy getting started experience for when you’re trying to auto-import something that you’ve just installed but haven’t used yet.\n\nTypeScript 4.0 now does a little extra work in editor scenarios to include the packages you’ve listed in your `package.json`’s `dependencies` (and `peerDependencies`) fields. The information from these packages is only used to improve auto-imports, and doesn’t change anything else like type-checking. This allows us to provide auto-imports for all of your dependencies that have types, without incurring the cost of a complete `node_modules` search.\n\nIn the rare cases when your `package.json` lists more than ten typed dependencies that haven’t been imported yet, this feature automatically disables itself to prevent slow project loading. To force the feature to work, or to disable it entirely, you should be able to configure your editor. For Visual Studio Code, this is the “Include Package JSON Auto Imports” (or `typescript.preferences.includePackageJsonAutoImports`) setting.\n\n![Configuring 'include package JSON auto imports'](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/configurePackageJsonAutoImports4-0.png) For more details, you can see the [proposal issue](https://github.com/microsoft/TypeScript/issues/37812)\n along with [the implementing pull request](https://github.com/microsoft/TypeScript/pull/38923)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#our-new-website)\nOur New Website!\n-------------------------------------------------------------------------------------------------------------------\n\n[The TypeScript website](https://www.typescriptlang.org/)\n has recently been rewritten from the ground up and rolled out!\n\n![A screenshot of the new TypeScript website](https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/ts-web.png)\n\n[We already wrote a bit about our new site](https://devblogs.microsoft.com/typescript/announcing-the-new-typescript-website/)\n, so you can read up more there; but it’s worth mentioning that we’re still looking to hear what you think! If you have questions, comments, or suggestions, you can [file them over on the website’s issue tracker](https://github.com/microsoft/TypeScript-Website)\n.\n\n[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#breaking-changes)\nBreaking Changes\n--------------------------------------------------------------------------------------------------------------------\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#libdts-changes)\n`lib.d.ts` Changes\n\nOur `lib.d.ts` declarations have changed - most specifically, types for the DOM have changed. The most notable change may be the removal of [`document.origin`](https://developer.mozilla.org/en-US/docs/Web/API/Document/origin)\n which only worked in old versions of IE and Safari MDN recommends moving to [`self.origin`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/origin)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#properties-overriding-accessors-and-vice-versa-is-an-error)\nProperties Overriding Accessors (and vice versa) is an Error\n\nPreviously, it was only an error for properties to override accessors, or accessors to override properties, when using [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n; however, TypeScript now always issues an error when declaring a property in a derived class that would override a getter or setter in the base class.\n\nts\n\n`   class Base {    get foo() {      return 100;    }    set foo(value) {      // ...    }  }  class Derived extends Base {    foo = 10;  'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.2610'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYAsBOUAmANkwCgBjAGwENFFQAhGyUAbxNFAHNIAXUAMzhwAFAEpW7DqGi8ArtAB26DBgDckgL6TEvAUOEA3KhVmRxbKaBCgAdHc0kt5arVAARGAEsDkACahIAA8eSAVfOkYdCQ5BOFAAXmV1DSA)\n\nts\n\n`   class Base {    prop = 10;  }  class Derived extends Base {    get prop() {  'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.2611'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.      return 100;    }  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCMWBQBjAGwENFFQAhUyUAb11FAAd4nQBeULABgG5cAvrgIkyoACIwAlgDdIAE1CQAHgBdIAO3nkqiGvUYBzSKuasAFAEo6DRqGgmArtA1dufW0IFA)\n\nSee more details on [the implementing pull request](https://github.com/microsoft/TypeScript/pull/37894)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#operands-for-delete-must-be-optional)\nOperands for `delete` must be optional.\n\nWhen using the `delete` operator in [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\n, the operand must now be `any`, `unknown`, `never`, or be optional (in that it contains `undefined` in the type). Otherwise, use of the `delete` operator is an error.\n\nts\n\n`   interface Thing {    prop: string;  }  function f(x: Thing) {    delete x.prop;  The operand of a 'delete' operator must be optional.2790The operand of a 'delete' operator must be optional.  }   `[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYCcAGAUAJYB2ALjAGYCGAxpKACoAWxA5qAN56igAO8PqRCWisA3HgC+ePOQCuRaiQJwiocgAoAHqiasAlBy6gAJpAA2kMqE0A6PnB7iJQA)\n\nSee more details on [the implementing pull request](https://github.com/microsoft/TypeScript/pull/37921)\n.\n\n### [](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#usage-of-typescripts-node-factory-is-deprecated)\nUsage of TypeScript’s Node Factory is Deprecated\n\nToday TypeScript provides a set of “factory” functions for producing AST Nodes; however, TypeScript 4.0 provides a new node factory API. As a result, for TypeScript 4.0 we’ve made the decision to deprecate these older functions in favor of the new ones.\n\nFor more details, [read up on the relevant pull request for this change](https://github.com/microsoft/TypeScript/pull/35282)\n.\n\nThe TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/release-notes/TypeScript%204.0.md)\n ❤\n\nContributors to this page:  \n\nOT![Orta Therox  (6)](https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4)\n\nAB![Andrew Branch  (2)](https://gravatar.com/avatar/86ed396e4ffb41b052654b9f8ad4d1caaf732bc42985860b0cac8191a66e33df?s=32&&d=blank)\n\nEI![Eugene Ilyin  (1)](https://gravatar.com/avatar/a65caef54cbaba95975117e96ca2d411668cedaea6e5bbc59287ed673c84751e?s=32&&d=blank)\n\nDR![Dan Rose  (1)](https://gravatar.com/avatar/817768956c9b0bb4b029a8ac0d3d4edeb599a858acd5a78168c21f479568aacf?s=32&&d=blank)\n\nA![any86  (1)](https://gravatar.com/avatar/9b118187b2cdc8aa0b94b40bdcdd1560a6f58ca6c9015c0f3e4c53d1bc32b397?s=32&&d=blank)\n\n4+\n\nLast updated: Mar 04, 2025  \n  \nThis page loaded in 3.986 seconds.\n\nMSG","metadata":{"og:description":"TypeScript 4.0 Release Notes","twitter:site":"typescriptlang","language":"en","generator":"Gatsby 5.13.5","og:title":"Documentation - TypeScript 4.0","ogTitle":"Documentation - TypeScript 4.0","ogDescription":"TypeScript 4.0 Release Notes","viewport":"width=device-width, initial-scale=1, shrink-to-fit=no","title":"TypeScript: Documentation - TypeScript 4.0","favicon":"https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae","theme-color":"#3178C6","description":"TypeScript 4.0 Release Notes","scrapeId":"539a2b98-4ef6-48b9-985a-93ba49c775f5","sourceURL":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html","url":"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html","statusCode":200}}]}