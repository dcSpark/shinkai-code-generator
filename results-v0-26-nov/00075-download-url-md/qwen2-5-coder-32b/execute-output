{
  "markdowns": [
    "The Nightmare of Apple's OTA Update: Bypassing the Signature Verification and Pwning the Kernel – Mickey's Blogs – Exploring the world with my sword of debugger :)             \n\n[![](https://avatars.githubusercontent.com/u/10210124?s=460&u=220a7d6d07a020cbe6096a7f63d0e6dcfae69d52&v=4)](/)\n\n[Mickey's Blogs](/)\n===================\n\nExploring the world with my sword of debugger :)\n\n[CVE List](/cvelist) [More Blogs](/blogs) [Conferences](/conferences) [About](/about)\n\nThe Nightmare of Apple's OTA Update: Bypassing the Signature Verification and Pwning the Kernel\n===============================================================================================\n\nThis blog post is written for my talk at [OBTS v6.0](https://objectivebythesea.org/v6/talks.html).\n\nIn this session, I talked about what Apple’s OTA update is and how it works.\n\nI also shared the vulnerabilities during the update process and how I exploited them.\n\nIn addition, I discussed how to execute arbitrary kernel code after bypassing the SIP.\n\nApple’s OTA Update\n==================\n\nIn most cases, macOS updates are done through the OTA update process.\n\n**OTA** is short for **over-the-air**.\n\nFrom the **System Settings**, we can update the system directly by clicking on the **Update Now** button.\n\n![image-20231014220736328](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014220736328.png)\n\nAn OTA update is an **incremental update** and is therefore faster and smaller than a **full OS upgrade**.\n\nIt is used for minor version updates, usually every two months. But it is possible to be available in a few weeks if Apple considers there’s an urgent vulnerability in kernel, that’s already being actively exploited, and could not be patched through the **RSR (Rapid Security Response)**.\n\nThe OTA update packages are downloaded from the Apple CDN server.\n\n![image-20231014221848127](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014221848127.png)\n\nAs you can see from [the table](https://www.theiphonewiki.com/wiki/OTA_Updates/Mac/12.6), the OTA packages are customized for the current OS versions.\n\ne.g., in order to update to 12.6, the packages for 12.5 and 12.4 are different. The update process is to apply the patch codes. So different OS versions have different patch codes. In most scenarios, the older the system, the larger the package size.\n\n### OTA Package Contents\n\nAfter downloading and unzipping the OTA package, we can see the package contents as follows:\n\n![image-20231014222259372](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014222259372.png)\n\nThe `boot` directory contains something related to the boot process. The real patch code for the incremental update is located in a directory named `payloadv2`. There is a critical file named `payload.bom` that **lists all the items in the OTA package and their check sum values**. The file `payload.bom.signature` is used to verify the integrity of the `payload.bom` file. The files `pre.bom` and `post.bom` list all the items and their check sum values on the system **before and after the update**. The `Info.plist` file provides some basic information about the current OTA package, such as the pre-version, the target version, etc.\n\nIn the `payloadv2` folder, there are some important files to be aware of. The new data files in the new system are compressed into a file named `data_payload`. The `ecc_data` folder contains some files related to file permissions. The `links.txt` file lists all hard links for the new system. The `removed.txt` file lists all items that need to be removed from the current system.\n\nThe Update Stages\n=================\n\nThe general update process could be abstracted into 3 phases.\n\n![image-20231014222945651](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014222945651.png)\n\nThe first stage is to download and extract the **UpdateBrainService** bundle package.\n\nThe second stage is to download and extract the OTA package.\n\nThe third stage is to spawn the **UpdateBrainService** with the OTA package.\n\n### Stage 1\n\nSo, where does the system download the **UpdateBrainService** from?\n\nAfter some research, I found the download URL located in the XML file `/System/Library/AssetsV2/com_apple_MobileAsset_MobileSoftwareUpdate_MacUpdateBrain/com_apple_MobileAsset_MobileSoftwareUpdate_MacUpdateBrain.xml`:\n\n![image-20231014223222420](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014223222420.png)\n\nFrom this file, we can see the base URL and the relative path to build a complete URL. It also contains the version, the release date, the package size, the SHA1 value, and other useful information.\n\nThe first stage is as follows:\n\n![image-20231014223358455](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014223358455.png)\n\nAfter fetching the download URL, the process **nsurlsessiond** is responsible for downloading the **UpdateBrainService** to a temporary directory. At the same time, the **com.apple.StreamingUnzipService** decompresses it to the same temporary location. Next, the **mobileassetd** process moves the decompressed contents to the trusted location, `/System/Library/AssetsV2/com_apple_MobileAsset_MobileSoftwareUpdate_MacUpdateBrain/`. Finally, before the **launchd** process spawns the **UpdateBrainService**, the xpc service bundle will be copied to its staging path.\n\n### Stage 2\n\nThe second stage is similar to the first stage:\n\n![image-20231014223958413](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014223958413.png)\n\nThe differences are the xml path (`/System/Library/AssetsV2/com_apple_MobileAsset_MacSoftwareUpdate/com_apple_MobileAsset_MacSoftwareUpdate.xml`), the download url and the target location (`/System/Library/AssetsV2/com_apple_MobileAsset_MacSoftwareUpdate/`).\n\n### Stage 3\n\nThe third stage is the **UpdateBrainService** itself.\n\nThe particular xpc service has a number of juicy entitlements:\n\n![image-20231014224440771](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014224440771.png)\n\ne.g., the entitlement “**com.apple.rootless.install.heritable**” grants itself and all its child processes permission to modify the SIP-protected locations. Moreover, The entitlements “**com.apple.apfs.revert-to-snapshot**” and “**com.apple.private.apfs.create-sealed-snapshot**” may allow the service to update the SSV-protected contents after a reboot.\n\nOne more thing we should note is that it is signed with the flag **library validation**. So we cannot enjoy these entitlements directly by injecting dynamic library into this service.\n\nReversing the UpdateBrainService\n================================\n\n### com.apple.MobileSoftwareUpdate.UpdateBrainService2\n\nThrough simple reverse engineering, I found that it provides a mach service called **com.apple.MobileSoftwareUpdate.UpdateBrainService2** with a protocol called **MSUBrainPrivateNSXPCInterface**.\n\n![image-20231014224736459](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014224736459.png)\n\nIt accepts all xpc connections from any client directly by returning YES in its delegate method:\n\n    @protocol MSUBrainPrivateNSXPCInterface\n    - (void) getListenerEndpoint:(void (^)(NSXPCListenerEndpoint *, NSError *))reply;\n    - (void) ping:(void (^)(NSDictionary *, NSError *))reply;\n    - (void) start:(void (^)(NSError *))reply;\n    @end\n    \n    BOOL -[MSUBrainServerImpl listener:shouldAcceptNewConnection:](id self, SEL selector, id listener, id connection) {\n        //...\n        [connection setExportedInterface:[NSXPCInterface interfaceWithProtocol:@protocol(MSUBrainPrivateNSXPCInterface)]];\n        [connection setExportedObject:self];\n        [connection resume];\n        return YES;\n    }\n    \n\nHowever, during my research, I realized that the protocol methods in the service are not implemented, so maybe I’ll check again in a future release.\n\n### com.apple.MobileSoftwareUpdate.UpdateBrainService\n\nThere is another service named **com.apple.MobileSoftwareUpdate.UpdateBrainService**. It is implemented through a low-level XPC API in the C language:\n\n![image-20231014225232542](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014225232542.png)\n\n![image-20231014225238231](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014225238231.png)\n\nIn the xpc handler method, we can see that it dispatches xpc requests through a global array:\n\n![image-20231014225403260](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014225403260.png)\n\nIf the xpc client has the required entitlement for the corresponding request, the service will call the processing routine function accordingly.\n\nThe global dispatch table has 7 elements, each with 3 members: the name of the operation, the required entitlement string, and the address of the actual processing routine function.\n\n![image-20231014225546924](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014225546924.png)\n\nBypass the Signature Verification (CVE-2022-42791)\n==================================================\n\n### Modifying the package\n\nSo can I modify the OTA package before applying the patches?\n\nLet’s recall the second stage of the update that we talked about earlier. We can confirm that the final path of the OTA package (**/System/Library/AssetsV2/com\\_apple\\_MobileAsset\\_MacSoftwareUpdate/**) is protected by SIP.\n\nHowever, we will notice that the extracted content is first placed in a temporary location (**/var/folders/zz/zyxvpxvq6csfxvn\\_n00000y800007k/T/**\n\n**com.apple.nsurlsessiond/CFNetworkDownload\\_XXXXXX.tmp/\\[hash\\].asset**), which is not restricted at all. It is owned by **nsurlsessiond** and can be modified directly by the root user.\n\nTherefore, there is a time window to modify the contents before the **mobileassetd** process moves to the final trusted location. As a result, the content of the OTA package in the trusted location is **not trustworthy and needs to be verified**.\n\nWhen I try to replace the `payload.bom` file directly, the **mobileassetd** process fails to call a file API due to a permission issue and therefore refuses to move to the final path:\n\n![image-20231014230610880](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014230610880.png)\n\nBut the truth is that once it passes the check here, it will call the API `rename` to move the package content. So I replaced the target file too early.\n\nBut what does a successful log look like?\n\n![image-20231014230852188](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014230852188.png)\n\nFortunately, there is a keyword string (“**Moving file in …**”) that indicates a time window of passing the check. So once that keyword is monitored from the log, I can replace the target file.\n\nSo next, here is my second attempt:\n\n*   Monitor the logs, replace the target file from the OTA package as soon as the keyword “Moving file” is detected.\n*   The tampered content was then successfully transferred to the final trusted location!\n*   However, the **UpdateBrainService** stops preparing the OS update.\n\n### The OTA Package Validation\n\n**It is the duty of this service to verify the contents of untrustworthy OTA package from a trusted location.** So, how does it validate the OTA Package?\n\nAs mentioned earlier, the `payload.bom` file lists all the items and their checksum values in the OTA package:\n\n![image-20231014231629302](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014231629302.png)\n\nHere is the function that verifies the package contents:\n\n![image-20231014231815936](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014231815936.png)\n\nIt opens the file `payload.bom` and reads its contents. Next, the function compares the file digest value specified from the `payload.bom` file with the true digest value on the final path:\n\n![image-20231014231926741](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014231926741.png)\n\nIf one of the digest values is not equal to the expected value, the function returns false and the verification fails.\n\nBut how does it verify the `payload.bom` file itself?\n\nAnother function named **verify\\_package\\_signature** is responsible for the verification:\n\n![image-20231014232054299](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014232054299.png)\n\nFirst, it opens the `payload.bom` file and calculates its SHA1 value. Then it opens the `payload.bom.signature` file and reads the signature file content.\n\nNext, it fetches the public key from the system certificate file (`/System/Library/SoftwareUpdateCertificates/iPhoneSoftwareUpdate.pem`), which is protected by SIP and SSV:\n\n![image-20231014232206900](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014232206900.png)\n\nFinally, it verifies the signature with the public key, the calculated SHA1 value, and the signature file content, by calling the API **SecKeyVerifySignature** from the **Security.framework**:\n\n![image-20231014232447011](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014232447011.png)\n\n### The TOCTOU Issue\n\nSo, there is a classic **TOCTOU (Time-Of-Check-Time-Of-Use)** issue inside the validation:\n\n![image-20231014233131773](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014233131773.png)\n\nThe `payload.bom` file located in the trusted location cannot be modified directly, but we can replace it with a symbolic link before the **mobileassetd** process moves the OTA package. Therefore, the `payload.bom` file can be modified at any time by using the symbolic link.\n\nNext, in the function `verify_package_signature`, it reads the BOM file from a controlled location according to the symbolic link, so we use the original `payload.bom` to pass the check.\n\nThen in the function `verify_package_contents`, it also follows the symbolic link and uses the controlled BOM file to verify all the other items in the OTA package. So at this time, we can fake the `payload.bom` file to fake all the other items in the OTA package.\n\nThis was my third attempt, and it worked:\n\n*   Copy the original `payload.bom` to a controlled location `/tmp/payload.bom`.\n*   Monitor the logs, replace the `payload.bom` with a symlink to `/tmp/payload.bom`, as soon as the keyword “**Moving file**” is detected.\n*   The symlink (`/tmp/payload.bom`) is successfully moved to the final trusted location!\n*   Fake the BOM file (`/tmp/payload.bom`) after passing the function `verify_package_signature`.\n*   Now all items in the OTA package can be tampered with!\n\n### Exploit 1 - SIP Bypass\n\nNext, what can we do after bypassing the signature verification?\n\nThe first exploit is to bypass the SIP. It is very easy to do that.\n\nThe function **ParallelPatchRemoveFiles** reads the `removed.txt` file in the OTA package and removes all items specified in the txt file:\n\n![image-20231014233921125](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231014233921125.png)\n\nAs a result, I could get a primitive to remove arbitrary SIP-protected paths by modifying the txt file.\n\nThis exploit **works on all Mac platforms**, including the Intel Macs and Apple Silicon Macs.\n\n### Exploit 2 - Infect the kernel\n\nBut I want to get more! So, can I hijack the new OS kernel?\n\n#### The Challenge - SSV\n\nThe challenge to hijacking the OS kernel directly after bypassing the SIP is the SSV protection.\n\n**SSV** is short for **Signed System Volume**. It’s a new feature introduced in macOS Big Sur. In case the SIP is bypassed, it still uses an isolated read-only system volume to protect system files.\n\n[Quoted from Apple](https://support.apple.com/en-gb/guide/security/secd698747c9/web):\n\n    Each SSV hash value is stored in the main file system metadata tree, which is itself hashed. Since each node of the tree recursively verifies the integrity of its children's hashes, the root node's hash value, called a seal, covers every byte of data in the SSV, which means that the cryptographic signature covers the entire system volume.\n    \n    This advanced system volume technology provides a high level of security against malware and tampering with the operating system.\n    \n\nThe basic fact is that Apple needs to update the OS kernel file via the OTA update. Therefore, the OTA update process must have the ability to break the SSV protection.\n\nBut how is this process accomplished?\n\nmacOS system has a hidden update volume (**/System/Volumes/Update/mnt1**), that is a **snapshot** of the current OS. All patches are then applied to that snapshot. If the update process is successful, it will update the seal value and boot the new OS. If the update fails, it will revert to the previous snapshot.\n\nAfter digging deeper into the **UpdateBrainService**, I have summarized the following key workflows in the OTA update process.\n\n**Function Name**\n\n**Action**\n\nverify\\_package\\_\\[signature|contents\\]\n\nVerify the integrity of the OTA package\n\nprepare\\_snapshot\n\nPrepare a mirror/**snapshot** of the current OS at the volume **/System/Volumes/Update/mnt1**\n\ncopy\\_patched\\_files\n\nApply the patches from **payloadv2/patches/XXX** (**BXDIFF5** format) to the snapshot\n\ncopy\\_archived\\_files\n\nExtract the payloads from **payload.\\[000-999\\]** (**AppleArchive** format) to the snapshot. And repair file permissions according to the files **payload.XXX.ecc** (**AppleArchive** format)\n\ncopy\\_archived\\_data\\_files\n\nSimilar to the above, extract the **data\\_payload** to the snapshot\n\nverify\\_postbom\n\nVerify the checksum values of the new system files in the snapshot against **post.bom**\n\n#### 1st Attempt\n\nMy first attempt was to drop a crafted kernel file **via the payload extraction functions**.\n\nThe steps to make a crafted **data\\_payload** are as follows:\n\n    mkdir -p /tmp/payload/System/Library/Kernels\n    mkdir -p /tmp/payload/System/Library/KernelCollections\n    cp /System/Volumes/Update/mnt1/System/Library/Kernels/kernel /tmp/payload/System/Library/Kernels\n    cp /System/Volumes/Update/mnt1/System/Library/KernelCollections/BootKernelExtensions.kc /tmp/payload/System/Library/KernelCollections\n    perl -pi -e 's/Darwin Kernel Version/Hacked By Mickey Jin /g' /tmp/payload/System/Library/Kernels/kernel\n    perl -pi -e 's/Darwin Kernel Version/Hacked By Mickey Jin /g' /tmp/payload/System/Library/KernelCollections/BootKernelExtensions.kc\n    aa archive -d /tmp/payload -o /tmp/data_payload\n    \n\nDuring the OTA update process, the crafted **data\\_payload** is extracted into the snapshot as expected.\n\nHowever, it didn’t work after a reboot. I’m not sure what the reason is.\n\n#### 2nd Attempt\n\nMy second approach was to **abuse the function `copy_patched_files` that applies the patches**. This is the same way the OTA update process updates the kernel.\n\nThe difficulty, however, is that I have to create the patch file by myself, which is in **BXDIFF 5** format and undocumented. So, I must explore the file format first.\n\n##### BXDIFF 5 File Format\n\nI started with a Google search for this file format and then found two GitHub repositories [\\[1\\]](https://github.com/ezhes/bxdiff50) [\\[2\\]](https://github.com/npupyshev/bxdiff). Both of them are used to apply a patch file to an old file and then generate a new file. However, I need to generate a patch file based on two different files.\n\nBut they did help me understand the file format. From reading the code, I know that the **BXDIFF 5** file consists of 4 sections: **Header**, **Control**, **Diff** and **Extra**.\n\nThe **Header** section is 88 bytes in size, with the first 8 bytes being hard-coded magic numbers:\n\n![image-20231015000532247](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015000532247.png)\n\nThe red part is unknown and seems useless. The green parts are the hash values **before and after the patch**, which are used to verify that the patch was successful. The blue part is the size of the following sections.\n\nThe **Control** section is compressed using the **LZMA** algorithm. After decompression, the **Control** section data is 24 bytes and consists of 3 types of control commands:\n\n![image-20231015000717457](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015000717457.png)\n\nThe first is the **mix** length, which specifies how many bytes to mix from the **Diff** section. The second is the **copy** length, and the third is the **seek** length.\n\nThe **Diff** section and the **Extra** section are also **LZMA** compressed. After decompression, the data is a raw bytes array, that is used by the **Control** section before.\n\n#### Make a crafted patch file\n\nMy goal is to replace the output string of the system command `uname` in the kernel. So I should modify the **Diff** Section.\n\nFirst, use the following script to calculate the new bytes in the **Diff** Section.\n\n![image-20231015002215981](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015002215981.png)\n\nThen figure out the `diffSeekPosition` when it reaches the `inputSeekPosition`.\n\n![image-20231015001917341](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015001917341.png)\n\nI found my target string “**Darwin Kernel Version**” was located at the offset `0x95058d`. Therefore, I used this value as the `inputSeekPosition` and then got the corresponding `diffSeekPosition`.\n\nNext, rewrite the new bytes at the `diffSeekPosition` and compress the newly created **Diff** Section by using the **LZMA** algorithm. We can reuse the **Control** section and the **Extra** section directly. Finally, update the hash value and size in the new **Header** Section.\n\nAfter I made a patch file for the kernel, it worked as expected! The PoC is uploaded [here](https://github.com/jhftss/POC/tree/main/CVE-2022-42791).\n\nAlthough it **only works on the Intel Macs without the T2 chip**, I was able to inject malicious shell code into the kernel and execute arbitrary code at ring 0!\n\n#### Hareware Mitigation - Secure Boot\n\nThe challenge for other Mac platforms (**Intel Macs with the T2 Chip** & **Apple Silicon Macs**) is the hardware mitigation called [Secure Boot](https://support.apple.com/en-gb/guide/security/sec5d0fab7c6/web). The default setting is [Full Security](https://support.apple.com/en-gb/HT208198#secureboot), which offers the highest level of security.\n\nDuring startup, your Mac verifies the integrity of the operating system on your startup disk to make sure it’s legitimate. If the OS is unknown or can’t be verified as legitimate, your Mac **connects to Apple to download the updated integrity information** it needs to verify the OS. This information is unique to your Mac, and it ensures that your Mac starts up from an OS that is trusted by Apple.\n\n### Apple’s Patch\n\nHere is how Apple patched this vulnerability:\n\n![image-20231015003228614](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015003228614.png)\n\nAt line 180, it calls the function `digest_file_nofollow` to calculate the SHA1 value. Internally, it opens the `payload.bom` file with the flag **NO\\_FOLLOW** to block the symbolic link attack.\n\nA Stupid SIP Bypass Issue (CVE-2022-46722)\n==========================================\n\nAs we can see from the screenshot below:\n\n![image-20231015003359265](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015003359265.png)\n\n**The extracted folder itself is restricted, but the files and folders inside are not restricted.**\n\nAn example is the folder named `AssetData`. Therefore, we can directly modify the contents of OTA packages, even after they are moved to the final trusted location!\n\nSo it is useless to verify the integrity of the OTA package. We can get a SIP-bypass primitive directly by modifying the OTA package contents after it passes the package verification.\n\n### Root Cause\n\nThrough my research, I realized that the root cause of the issue lies in the function named `moveTargetToDirectory` in the process **mobileassetd**:\n\n![image-20231015003757058](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015003757058.png)\n\nIt moves the OTA package contents by calling the API **moveItemAtURL:toURL:**, which itself **preserves the source file flags and extended attributes**.\n\nThe contents on the final path are **unrestricted** because the source files are **unrestricted**.\n\n### Apple’s Patch\n\nNow, Apple has addressed the issue as follows:\n\n![image-20231015004018950](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015004018950.png)\n\nIt first uses the API **copyItemAtURL:toURL:** to copy the OTA package contents to an intermediate path, and then uses the API **moveItemAtURL:toURL:** after copying.\n\nNow, the contents on the final path will be restricted because the files written by the process **mobileassted** are restricted.\n\nHow to attack the kernel directly after bypassing the SIP?\n==========================================================\n\nAs mentioned earlier, we could execute arbitrary kernel code by **replacing the kernel patch files** via a SIP-bypass primitive, as done in exploit 2 before.\n\nBut this is a bit complicated. Can I replace the restricted kernel file itself **directly from the snapshot**?\n\nDuring my research, I realized that if I replace it too late, it won’t work after a reboot. However, if I replace it too early, the new kernel will be overwritten by the patch. So what is the right time to replace the kernel file from the snapshot? How can I catch this timing?\n\nBy monitoring `/System/Volumes/Update/restore.log`, I found that it outputs some useful information during the patching process. When all the patches have been applied, it goes to the next phase and outputs the log “**Unarchiving files in parallel…**”:\n\n![image-20231015004659942](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015004659942.png)\n\nSo I wrote a function named `spin_for_log` to wait for the right moment when all the patches are up:\n\n![image-20231015004804192](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015004804192.png)\n\nNext, I can replace the original kernel with a maliciously infected one **directly from the snapshot**.\n\nAs before, it **only works on the Intel Macs without the T2 chip**, which don’t have the Secure Boot Mitigation.\n\nOne more issue (No CVE, Additional Recognition)\n===============================================\n\n### The issue\n\nNow we know that it is the duty of the **UpdateBrainService** to verify the contents of the untrusted OTA package. The verification depends on the file `payload.bom`.\n\nHowever, I found that **not all files** in the OTA package are listed in the BOM file:\n\n![image-20231015005401974](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015005401974.png)\n\ne.g., `usr/standalone/update/ramdisk/`_, `Restore/`_, `boot/*`, …\n\n### The exploits\n\nThis leaves many critical files unprotected:\n\n![image-20231015005638342](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015005638342.png)\n\nSo there are many ways to exploit this issue.\n\nFirst, removing and touching the file `AssetData/usr/standalone/update/ramdisk/x86_64SURamDisk.dmg` will lead to a DoS issue.\n\nSecond, hijacking the firmwares by modifying the contents of the folder `Firmware/*`.\n\nThird, modifying the file `AssetData/boot/Firmware/System/Library/CoreServices/bootbase.efi` to hijack the boot process from the first instruction, and **inject the earliest shell code** to the system.\n\nThe `bootbase.efi` file is in **Windows PE** format. I did not develop my own EFI program to change the OS boot process. For a quick proof of concept, I just patched the entry point code to “**0xEB 0xFE**”, which is a short jump instruction for a dead loop:\n\n![image-20231015010120321](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015010120321.png)\n\nAfter replacing the `bootbase.efi` file and rebooting, the system hangs into a dead loop. To verify this, I set up a remote GDB stub and connected to it remotely in IDA Pro. As a result, you can see that my shellcode did execute in the EFI shell as expected!\n\n![image-20231015010302369](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015010302369.png)\n\n### Apple’s Fix\n\nIn order to effectively verify the integrity of the OTA package, it is necessary to list **all the items** in the OTA package from the `payload.bom` file.\n\nNow, Apple did do it after this report:\n\n![image-20231015010418846](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015010418846.png)\n\nDowngrade attack (CVE-2023-35983)\n=================================\n\n### The issue\n\nThe main executable of the **UpdateBrainService** is an empty caller:\n\n![image-20231015010542468](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015010542468.png)\n\nAll functions are implemented in the **UpdateBrainLibrary.dylib**. Of course, the new patch code is also included in the dylib.\n\n![image-20231015010644500](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015010644500.png)\n\nTherefore, an attacker can perform the downgrade attack by replacing with the **old version** of dylib, which is **signed by apple** and okay with the **Library Validation**.\n\nSimilar to the OTA update package, the **UpdateBrainService** bundle package can be modified by the root user. As a result, an attacker could replace the **UpdateBrainService** with an older version before moving it to the trusted location, and then exploit the old issues again.\n\n### Apple’s Fix\n\nNow, Apple has refactored the whole process. It **ensures that the entire process is trusted** and that the package contents are not tampered with:\n\n![image-20231015011058606](../res/2023-10-15-The-Nightmare-of-Apple-OTA-Update/image-20231015011058606.png)\n\nFirst, the process **nsurlsessiond** creates a restricted directory called `downloadDir`, and then downloads the **UpdateBrainService** bundle package to the trusted location. Next, the newly introduced service **com.apple.StreamingUnzipService.privileged.xpc** performs the decompression in parallel at the trusted location.\n\nOnce the download and unzip operations are complete, the processes later are similar.\n\nNote that the process **nsurlsessiond** and **com.apple.StreamingUnzipService.privileged.xpc** now have the new special entitlement **com.apple.rootless.storage.MobileAssetDownload** to modify the restricted directory.\n\nBy the way, the download of the OTA package also follows this new process.\n\nTake Away\n=========\n\n*   Slides: https://github.com/jhftss/jhftss.github.io/blob/main/res/slides/OBTS\\_v6\\_The%20Nightmare%20of%20Apple%20OTA%20Update\\_Mickey%20Jin.pdf\n*   PoC: https://github.com/jhftss/POC/tree/main/CVE-2022-46722\n*   Demo: https://www.youtube.com/watch?v=m\\_gGHVWLQ0Y\n\nWritten on October 15, 2023\n\n[](mailto:jhftss@foxmail.com)[](https://github.com/jhftss)[](https://www.twitter.com/patch1t)"
  ]
}
